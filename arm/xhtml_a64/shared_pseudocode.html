<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>A64 Instruction Summary -- Shared Pseudocode</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">Shared Pseudocode Functions</h2><p>This page displays common pseudocode functions shared by many pages</p><h2 class="pseudocode">Pseudocodes</h2>
    <div class="ps"><a id="aarch32.at.AArch32.AT"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.AT</h3>
      <p class="pseudocode">// AArch32.AT()
// ============
// Perform address translation as per AT instructions.

<a id="AArch32.AT.4"/>AArch32.AT(bits(32) vaddress, <a href="shared_pseudocode.html#TranslationStage" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</a> stage, bits(2) el, <a href="shared_pseudocode.html#ATAccess" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess</a> ataccess)
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss;

    // ATS1Hx instructions
    if el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        regime = <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
        eae = TRUE;
        ss = <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    // ATS1Cxx instructions
    elsif stage == <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> || (stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>)) then
        stage = <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a>;
        ss = SecurityStateAtEL(PSTATE.EL);
        regime = if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> else <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
        eae = TTBCR.EAE == '1';

    // ATS12NSOxx instructions
    else
        regime = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
        eae = if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then TTBCR_NS.EAE == '1' else TTBCR.EAE == '1';
        ss = <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc;
    aligned = TRUE;
    ispriv = el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    supersection = '0';
    iswrite = ataccess IN {<a href="shared_pseudocode.html#ATAccess_WritePAN" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_WritePAN</a>, <a href="shared_pseudocode.html#ATAccess_Write" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</a>};
    acctype = if ataccess IN {<a href="shared_pseudocode.html#ATAccess_Read" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Read</a>, <a href="shared_pseudocode.html#ATAccess_Write" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</a>} then <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a> else <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>;

    // Prepare fault fields in case a fault is detected
    fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
    fault.acctype = acctype;
    fault.write = iswrite;

    if eae then
        (fault, addrdesc) = <a href="shared_pseudocode.html#AArch32.S1TranslateLD.8" title="function: (FaultRecord, AddressDescriptor) AArch32.S1TranslateLD(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateLD</a>(fault, regime, ss, vaddress, acctype, aligned,
                                                  iswrite, ispriv);
    else
        (fault, addrdesc, sdftype) = <a href="shared_pseudocode.html#AArch32.S1TranslateSD.8" title="function: (FaultRecord, AddressDescriptor, SDFType) AArch32.S1TranslateSD(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateSD</a>(fault, regime, ss, vaddress, acctype,
                                                           aligned, iswrite, ispriv);
        supersection = if sdftype == <a href="shared_pseudocode.html#SDFType_Supersection" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a> then '1' else '0';

    // ATS12NSOxx instructions
    if stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        s2fs1walk = FALSE;
        (fault, addrdesc) = <a href="shared_pseudocode.html#AArch32.S2Translate.8" title="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</a>(fault, addrdesc, ss, s2fs1walk, acctype, aligned,
                                                iswrite, ispriv);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        // Take exception when External abort occurs on translation table walk
        if (<a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) || (stage == <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> &amp;&amp; el != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
                                       &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; fault.s2fs1walk)) then
            PAR = bits(64) UNKNOWN;
            <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(vaddress, fault);

    addrdesc.fault = fault;

    if (eae || (stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; (HCR.VM == '1' || HCR.DC == '1'))
            || (stage == <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> &amp;&amp; el != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>)) then
        <a href="shared_pseudocode.html#AArch32.EncodePARLD.2" title="function: AArch32.EncodePARLD(AddressDescriptor addrdesc, SecurityState ss)">AArch32.EncodePARLD</a>(addrdesc, ss);
    else
        <a href="shared_pseudocode.html#AArch32.EncodePARSD.3" title="function: AArch32.EncodePARSD(AddressDescriptor addrdesc, bit supersection, SecurityState ss)">AArch32.EncodePARSD</a>(addrdesc, supersection, ss);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.EncodePARLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.EncodePARLD</h3>
      <p class="pseudocode">// AArch32.EncodePARLD()
// =====================
// Returns 64-bit format PAR on address translation instruction.

<a id="AArch32.EncodePARLD.2"/>AArch32.EncodePARLD(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)

    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(addrdesc) then
        bit ns;
        if ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
            ns = bit UNKNOWN;
        elsif addrdesc.paddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
            ns = '0';
        else
            ns = '1';
        PAR.F      = '0';
        PAR.SH     = ReportedPARShareability(<a href="shared_pseudocode.html#impl-shared.PAREncodeShareability.1" title="function: bits(2) PAREncodeShareability(MemoryAttributes memattrs)">PAREncodeShareability</a>(addrdesc.memattrs));
        PAR.NS     = ns;
        PAR&lt;10&gt;    = bit IMPLEMENTATION_DEFINED "Non-Faulting PAR";               // IMPDEF
        PAR.LPAE   = '1';
        PAR.PA     = addrdesc.paddress.address&lt;39:12&gt;;
        PAR.ATTR   = ReportedPARAttrs(<a href="shared_pseudocode.html#impl-shared.EncodePARAttrs.1" title="function: bits(8) EncodePARAttrs(MemoryAttributes memattrs)">EncodePARAttrs</a>(addrdesc.memattrs));
    else
        PAR.F      = '1';
        PAR.FST    = <a href="shared_pseudocode.html#AArch32.PARFaultStatusLD.1" title="function: bits(6) AArch32.PARFaultStatusLD(FaultRecord fault)">AArch32.PARFaultStatusLD</a>(addrdesc.fault);
        PAR.S2WLK  = if addrdesc.fault.s2fs1walk then '1' else '0';
        PAR.FSTAGE = if addrdesc.fault.secondstage then '1' else '0';
        PAR.LPAE   = '1';
        PAR&lt;63:48&gt; = bits(16) IMPLEMENTATION_DEFINED "Faulting PAR";              // IMPDEF
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.EncodePARSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.EncodePARSD</h3>
      <p class="pseudocode">// AArch32.EncodePARSD()
// =====================
// Returns 32-bit format PAR on address translation instruction.

<a id="AArch32.EncodePARSD.3"/>AArch32.EncodePARSD(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc, bit supersection, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(addrdesc) then
        if (addrdesc.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> ||
                (addrdesc.memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp;
                 addrdesc.memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>)) then
            addrdesc.memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        bit ns;
        if ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
            ns = bit UNKNOWN;
        elsif addrdesc.paddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
            ns = '0';
        else
            ns = '1';
        bits(2) sh = if addrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then '01' else '00';
        PAR.F      = '0';
        PAR.SS     = supersection;
        PAR.Outer  = AArch32.ReportedOuterAttrs(<a href="shared_pseudocode.html#AArch32.PAROuterAttrs.1" title="function: bits(2) AArch32.PAROuterAttrs(MemoryAttributes memattrs)">AArch32.PAROuterAttrs</a>(addrdesc.memattrs));
        PAR.Inner  = AArch32.ReportedInnerAttrs(<a href="shared_pseudocode.html#AArch32.PARInnerAttrs.1" title="function: bits(3) AArch32.PARInnerAttrs(MemoryAttributes memattrs)">AArch32.PARInnerAttrs</a>(addrdesc.memattrs));
        PAR.SH     = ReportedPARShareability(sh);
        PAR&lt;8&gt;     = bit IMPLEMENTATION_DEFINED "Non-Faulting PAR";               // IMPDEF
        PAR.NS     = ns;
        PAR.NOS    = if addrdesc.memattrs.shareability == <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> then '0' else '1';
        PAR.LPAE   = '0';
        PAR.PA     = addrdesc.paddress.address&lt;39:12&gt;;
    else
        PAR.F      = '1';
        PAR.FST    = <a href="shared_pseudocode.html#AArch32.PARFaultStatusSD.1" title="function: bits(6) AArch32.PARFaultStatusSD(FaultRecord fault)">AArch32.PARFaultStatusSD</a>(addrdesc.fault);
        PAR.LPAE   = '0';
        PAR&lt;31:16&gt; = bits(16) IMPLEMENTATION_DEFINED "Faulting PAR";              // IMPDEF
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.PARFaultStatusLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.PARFaultStatusLD</h3>
      <p class="pseudocode">// AArch32.PARFaultStatusLD()
// ==========================
// Fault status field decoding of 64-bit PAR

bits(6) <a id="AArch32.PARFaultStatusLD.1"/>AArch32.PARFaultStatusLD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    bits(32) syndrome;

    if fault.statuscode == <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a> then
        // Report Domain fault
        assert fault.level IN {1,2};
        syndrome&lt;1:0&gt; = if fault.level == 1 then '01' else '10';
        syndrome&lt;5:2&gt; = '1111';
    else
        syndrome = <a href="shared_pseudocode.html#AArch32.FaultStatusLD.2" title="function: bits(32) AArch32.FaultStatusLD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusLD</a>(TRUE, fault);
    return syndrome&lt;5:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.PARFaultStatusSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.PARFaultStatusSD</h3>
      <p class="pseudocode">// AArch32.PARFaultStatusSD()
// ==========================
// Fault status field decoding of 32-bit PAR.

bits(6) <a id="AArch32.PARFaultStatusSD.1"/>AArch32.PARFaultStatusSD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    bits(32) syndrome;

    syndrome = <a href="shared_pseudocode.html#AArch32.FaultStatusSD.2" title="function: bits(32) AArch32.FaultStatusSD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusSD</a>(TRUE, fault);
    return syndrome&lt;12,10,3:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.PARInnerAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.PARInnerAttrs</h3>
      <p class="pseudocode">// AArch32.PARInnerAttrs()
// =======================
// Convert orthogonal attributes and hints to 32-bit PAR Inner field.

bits(3) <a id="AArch32.PARInnerAttrs.1"/>AArch32.PARInnerAttrs(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    bits(3) result;

    if memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        if memattrs.device == <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> then
            result = '001'; // Non-cacheable
        elsif memattrs.device == <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> then
            result = '011'; // Non-cacheable
    else
        <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> inner = memattrs.inner;
        if inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            result = '000'; // Non-cacheable
        elsif inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; inner.hints&lt;0&gt; == '1' then
            result = '101'; // Write-Back, Write-Allocate
        elsif inner.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
            result = '110'; // Write-Through
        elsif inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; inner.hints&lt;0&gt; == '0' then
            result = '111'; // Write-Back, no Write-Allocate
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.at.AArch32.PAROuterAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch32/at/AArch32.PAROuterAttrs</h3>
      <p class="pseudocode">// AArch32.PAROuterAttrs()
// =======================
// Convert orthogonal attributes and hints to 32-bit PAR Outer field.

bits(2) <a id="AArch32.PAROuterAttrs.1"/>AArch32.PAROuterAttrs(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    bits(2) result;

    if memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        result = bits(2) UNKNOWN;
    else
        <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> outer = memattrs.outer;
        if outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            result = '00'; // Non-cacheable
        elsif outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; outer.hints&lt;0&gt; == '1' then
            result = '01'; // Write-Back, Write-Allocate
        elsif outer.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> &amp;&amp; outer.hints&lt;0&gt; == '0' then
            result = '10'; // Write-Through, no Write-Allocate
        elsif outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; outer.hints&lt;0&gt; == '0' then
            result = '11'; // Write-Back, no Write-Allocate
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.dc.AArch32.DC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/dc/AArch32.DC</h3>
      <p class="pseudocode">// AArch32.DC()
// ============
// Perform Data Cache Operation.

<a id="AArch32.DC.3"/>AArch32.DC(bits(32) regval, <a href="shared_pseudocode.html#CacheOp" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</a> cacheop, <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>;
    <a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;

    cache.acctype = acctype;
    cache.cacheop = cacheop;
    cache.opscope = opscope;
    cache.cachetype = <a href="shared_pseudocode.html#CacheType_Data" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</a>;
    cache.security = SecurityStateAtEL(PSTATE.EL);

    if opscope == <a href="shared_pseudocode.html#CacheOpScope_SetWay" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_SetWay</a> then
        cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        (cache.set, cache.way, cache.level) = <a href="shared_pseudocode.html#impl-shared.DecodeSW.2" title="function: (integer, integer, integer) DecodeSW(bits(64) regval, CacheType cachetype)">DecodeSW</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(regval), <a href="shared_pseudocode.html#CacheType_Data" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</a>);

        if (cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
          ((!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.SWIO == '1') || (<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR.SWIO == '1') ||
          (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.&lt;DC,VM&gt; != '00') || (<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR.&lt;DC,VM&gt; != '00'))) then
            cache.cacheop = <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;
        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
        return;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            cache.is_vmid_valid = TRUE;
            cache.vmid          = VMID[];
        else
            cache.is_vmid_valid = FALSE;
    else
        cache.is_vmid_valid = FALSE;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        cache.is_asid_valid = TRUE;
        cache.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];
    else
        cache.is_asid_valid = FALSE;

    need_translate = <a href="shared_pseudocode.html#impl-shared.DCInstNeedsTranslation.1" title="function: boolean DCInstNeedsTranslation(CacheOpScope opscope)">DCInstNeedsTranslation</a>(opscope);
    iswrite = cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a>;
    vaddress = regval;

    size = 0;        // by default no watchpoint address
    if iswrite then
        size = integer IMPLEMENTATION_DEFINED "Data Cache Invalidate Watchpoint Size";
        assert size &gt;= 4*(2^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(CTR_EL0.DminLine))) &amp;&amp; size &lt;= 2048;
        assert (size&lt;32:0&gt; AND (size-1)&lt;32:0&gt;) == 0; // size is power of 2
        vaddress = <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(regval, size);

    cache.translated = need_translate;
    cache.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress);

    if need_translate then
        wasaligned = TRUE;
        memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(vaddress, acctype, iswrite, wasaligned, size);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(regval, memaddrdesc.fault);

        memattrs = memaddrdesc.memattrs;
        cache.paddress = memaddrdesc.paddress;
        if opscope == <a href="shared_pseudocode.html#CacheOpScope_PoC" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a> then
            cache.shareability = memattrs.shareability;
        else
            cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
    else
        cache.shareability = <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> UNKNOWN;
        cache.paddress = <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> UNKNOWN;

    if (cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>()
      &amp;&amp; ((!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.&lt;DC,VM&gt; != '00') || (<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR.&lt;DC,VM&gt; != '00'))) then
        cache.cacheop = <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;

    <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.VCRMatch.AArch32.VCRMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/VCRMatch/AArch32.VCRMatch</h3>
      <p class="pseudocode">// AArch32.VCRMatch()
// ==================

boolean <a id="AArch32.VCRMatch.1"/>AArch32.VCRMatch(bits(32) vaddress)

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        // Each bit position in this string corresponds to a bit in DBGVCR and an exception vector.
        match_word = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);

        if vaddress&lt;31:5&gt; == <a href="shared_pseudocode.html#impl-aarch32.ExcVectorBase.0" title="function: bits(32) ExcVectorBase()">ExcVectorBase</a>()&lt;31:5&gt; then
            if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
                match_word&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2&gt;) + 24&gt; = '1';     // Non-secure vectors
            else
                match_word&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2&gt;) + 0&gt; = '1';      // Secure vectors (or no EL3)

        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; vaddress&lt;31:5&gt; == MVBAR&lt;31:5&gt; then
            match_word&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;4:2&gt;) + 8&gt; = '1';          // Monitor vectors

        // Mask out bits not corresponding to vectors.
        if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            mask = '00000000':'00000000':'00000000':'11011110'; // DBGVCR[31:8] are RES0
        elsif !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            mask = '11011110':'00000000':'00000000':'11011110'; // DBGVCR[15:8] are RES0
        else
            mask = '11011110':'00000000':'11011100':'11011110';

        match_word = match_word AND DBGVCR AND mask;
        match = !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(match_word);

        // Check for UNPREDICTABLE case - match on Prefetch Abort and Data Abort vectors
        if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(match_word&lt;28:27,12:11,4:3&gt;) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()">DebugTarget</a>() == PSTATE.EL then
            match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_VCMATCHDAPA" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_VCMATCHDAPA</a>);

        if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(vaddress&lt;1:0&gt;) &amp;&amp; match then
            match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_VCMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_VCMATCHHALF</a>);
    else
        match = FALSE;

    return match;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.authentication.AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/authentication/AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled</h3>
      <p class="pseudocode">// AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()
// ========================================================

boolean <a id="AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled.0"/>AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()
    // The definition of this function is IMPLEMENTATION DEFINED.
    // In the recommended interface, AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled returns
    // the state of the (DBGEN AND SPIDEN) signal.
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then return FALSE;
    return DBGEN == HIGH &amp;&amp; SPIDEN == HIGH;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.breakpoint.AArch32.BreakpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32.BreakpointMatch</h3>
      <p class="pseudocode">// AArch32.BreakpointMatch()
// =========================
// Breakpoint matching in an AArch32 translation regime.

(boolean,boolean) <a id="AArch32.BreakpointMatch.3"/>AArch32.BreakpointMatch(integer n, bits(32) vaddress,
                                               integer size)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>();

    enabled = DBGBCR[n].E == '1';
    ispriv = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    linked = DBGBCR[n].BT == '0x01';
    isbreakpnt = TRUE;
    linked_to = FALSE;

    state_match = <a href="shared_pseudocode.html#AArch32.StateMatch.7" title="function: boolean AArch32.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN,&#13; boolean isbreakpnt,  boolean ispriv)">AArch32.StateMatch</a>(DBGBCR[n].SSC, DBGBCR[n].HMC, DBGBCR[n].PMC,
                                     linked, DBGBCR[n].LBN, isbreakpnt, ispriv);
    (value_match, value_mismatch) = <a href="shared_pseudocode.html#AArch32.BreakpointValueMatch.3" title="function: (boolean,boolean) AArch32.BreakpointValueMatch(integer n, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(n, vaddress, linked_to);

    if size == 4 then                    // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        (match_i, mismatch_i) = <a href="shared_pseudocode.html#AArch32.BreakpointValueMatch.3" title="function: (boolean,boolean) AArch32.BreakpointValueMatch(integer n, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(n, vaddress + 2, linked_to);
        if !value_match &amp;&amp; match_i then
            value_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPMATCHHALF</a>);
        if value_mismatch &amp;&amp; !mismatch_i then
            value_mismatch = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMISMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPMISMATCHHALF</a>);
    if vaddress&lt;1&gt; == '1' &amp;&amp; DBGBCR[n].BAS == '1111' then
        // The above notwithstanding, if DBGBCR[n].BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR[n]+2.
        if value_match then value_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPMATCHHALF</a>);
        if !value_mismatch then value_mismatch = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMISMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPMISMATCHHALF</a>);

    match = value_match &amp;&amp; state_match &amp;&amp; enabled;
    mismatch = value_mismatch &amp;&amp; state_match &amp;&amp; enabled;

    return (match, mismatch);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.breakpoint.AArch32.BreakpointValueMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32.BreakpointValueMatch</h3>
      <p class="pseudocode">// AArch32.BreakpointValueMatch()
// ==============================
// The first result is whether an Address Match or Context breakpoint is programmed on the
// instruction at "address". The second result is whether an Address Mismatch breakpoint is
// programmed on the instruction, that is, whether the instruction should be stepped.

(boolean,boolean) <a id="AArch32.BreakpointValueMatch.3"/>AArch32.BreakpointValueMatch(integer n, bits(32) vaddress, boolean linked_to)

    // "n" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n &gt;= <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() then
        (c, n) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(0, <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1, <a href="shared_pseudocode.html#Unpredictable_BPNOTIMPL" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPNOTIMPL</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return (FALSE,FALSE);

    // If this breakpoint is not enabled, it cannot generate a match. (This could also happen on a
    // call from StateMatch for linking).
    if DBGBCR[n].E == '0' then return (FALSE,FALSE);

    context_aware = (n &gt;= (<a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - <a href="shared_pseudocode.html#impl-shared.NumContextAwareBreakpointsImplemented.0" title="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>()));

    // If BT is set to a reserved type, behaves either as disabled or as a not-reserved type.
    dbgtype = DBGBCR[n].BT;

    if ((dbgtype IN {'011x','11xx'} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveV82Debug.0" title="function: boolean HaveV82Debug()">HaveV82Debug</a>()) ||    // Context matching
          (dbgtype == '010x' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>()) ||                  // Address mismatch
          (dbgtype != '0x0x' &amp;&amp; !context_aware) ||                                  // Context matching
          (dbgtype == '1xxx' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>))) then                                 // EL2 extension
        (c, dbgtype) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESBPTYPE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESBPTYPE</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return (FALSE,FALSE);
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    // Determine what to compare against.
    match_addr = (dbgtype == '0x0x');
    mismatch   = (dbgtype == '010x');
    match_vmid = (dbgtype == '10xx');
    match_cid1 = (dbgtype == 'xx1x');
    match_cid2 = (dbgtype == '11xx');
    linked     = (dbgtype == 'xxx1');

    // If this is a call from StateMatch, return FALSE if the breakpoint is not programmed for a
    // VMID and/or context ID match, of if not context-aware. The above assertions mean that the
    // code can just test for match_addr == TRUE to confirm all these things.
    if linked_to &amp;&amp; (!linked || match_addr) then return (FALSE,FALSE);

    // If called from BreakpointMatch return FALSE for Linked context ID and/or VMID matches.
    if !linked_to &amp;&amp; linked &amp;&amp; !match_addr then return (FALSE,FALSE);

    // Do the comparison.
    if match_addr then
        byte = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;1:0&gt;);
        assert byte IN {0,2};                     // "vaddress" is halfword aligned
        byte_select_match = (DBGBCR[n].BAS&lt;byte&gt; == '1');
        integer top = 31;
        BVR_match = (vaddress&lt;top:2&gt; == DBGBVR[n]&lt;top:2&gt;) &amp;&amp; byte_select_match;

    elsif match_cid1 then
        BVR_match = (PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; CONTEXTIDR == DBGBVR[n]&lt;31:0&gt;);
    if match_vmid then
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
            bvr_vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBXVR[n]&lt;7:0&gt;, 16);
        elsif !<a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()">Have16bitVMID</a>() || VTCR_EL2.VS == '0' then
            vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
            bvr_vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBXVR[n]&lt;7:0&gt;, 16);
        else
            vmid = VTTBR_EL2.VMID;
            bvr_vmid = DBGBXVR[n]&lt;15:0&gt;;
        BXVR_match = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      vmid == bvr_vmid);
    elsif match_cid2 then
        BXVR_match = (PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a href="shared_pseudocode.html#impl-shared.HaveV82Debug.0" title="function: boolean HaveV82Debug()">HaveV82Debug</a>()) &amp;&amp;
                      <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
                      DBGBXVR[n]&lt;31:0&gt; == CONTEXTIDR_EL2&lt;31:0&gt;);

    bvr_match_valid = (match_addr || match_cid1);
    bxvr_match_valid = (match_vmid || match_cid2);

    match = (!bxvr_match_valid || BXVR_match) &amp;&amp; (!bvr_match_valid || BVR_match);

    return (match &amp;&amp; !mismatch, !match &amp;&amp; mismatch);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.breakpoint.AArch32.StateMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/breakpoint/AArch32.StateMatch</h3>
      <p class="pseudocode">// AArch32.StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.

boolean <a id="AArch32.StateMatch.7"/>AArch32.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN,
                           boolean isbreakpnt,  boolean ispriv)
    // "SSC", "HMC", "PxC" are the control fields from the DBGBCR[n] or DBGWCR[n] register.
    // "linked" is TRUE if this is a linked breakpoint/watchpoint type.
    // "LBN" is the linked breakpoint number from the DBGBCR[n] or DBGWCR[n] register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "ispriv" is valid for watchpoints, and selects between privileged and unprivileged accesses.

    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    (c, SSC, HMC, PxC) = <a href="shared_pseudocode.html#impl-shared.CheckValidStateMatch.4" title="function: (Constraint, bits(2), bit, bits(2)) CheckValidStateMatch(bits(2) SSC, bit HMC, bits(2) PxC,&#13; boolean isbreakpnt)">CheckValidStateMatch</a>(SSC, HMC, PxC, isbreakpnt);
    if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;
    // Otherwise the HMC,SSC,PxC values are either valid or the values returned by
    // CheckValidStateMatch are valid.

    PL2_match = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; ((HMC == '1' &amp;&amp; (SSC:PxC != '1000')) || SSC == '11');
    PL1_match = PxC&lt;0&gt; == '1';
    PL0_match = PxC&lt;1&gt; == '1';
    SSU_match = isbreakpnt &amp;&amp; HMC == '0' &amp;&amp; PxC == '00' &amp;&amp; SSC != '11';

    if !ispriv &amp;&amp; !isbreakpnt then
        priv_match = PL0_match;
    elsif SSU_match then
        priv_match = PSTATE.M IN {<a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>,<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>,<a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>};
    else
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  priv_match = PL1_match;           // EL3 and EL1 are both PL1
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  priv_match = PL2_match;
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  priv_match = PL1_match;
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  priv_match = PL0_match;

    case SSC of
        when '00'  security_state_match = TRUE;                        // Both
        when '01'  security_state_match = !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();                 // Non-secure only
        when '10'  security_state_match = <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();                  // Secure only
        when '11'  security_state_match = (HMC == '1' || <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>());  // HMC=1 -&gt; Both, 0 -&gt; Secure only

    if linked then
        // "LBN" must be an enabled context-aware breakpoint unit. If it is not context-aware then
        // it is CONSTRAINED UNPREDICTABLE whether this gives no match, or LBN is mapped to some
        // UNKNOWN breakpoint that is context-aware.
        lbn = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(LBN);
        first_ctx_cmp = <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - <a href="shared_pseudocode.html#impl-shared.NumContextAwareBreakpointsImplemented.0" title="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>();
        last_ctx_cmp = <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1;
        if (lbn &lt; first_ctx_cmp || lbn &gt; last_ctx_cmp) then
            (c, lbn) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(first_ctx_cmp, last_ctx_cmp, <a href="shared_pseudocode.html#Unpredictable_BPNOTCTXCMP" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPNOTCTXCMP</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
            case c of
                when <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;      // Disabled
                when <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      linked = FALSE;    // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint

    if linked then
        vaddress = bits(32) UNKNOWN;
        linked_to = TRUE;
        (linked_match,-) = <a href="shared_pseudocode.html#AArch32.BreakpointValueMatch.3" title="function: (boolean,boolean) AArch32.BreakpointValueMatch(integer n, bits(32) vaddress, boolean linked_to)">AArch32.BreakpointValueMatch</a>(lbn, vaddress, linked_to);

    return priv_match &amp;&amp; security_state_match &amp;&amp; (!linked || linked_match);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.enables.AArch32.GenerateDebugExceptions"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/enables/AArch32.GenerateDebugExceptions</h3>
      <p class="pseudocode">// AArch32.GenerateDebugExceptions()
// =================================

boolean <a id="AArch32.GenerateDebugExceptions.0"/>AArch32.GenerateDebugExceptions()
    return <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptionsFrom.2" title="function: boolean AArch32.GenerateDebugExceptionsFrom(bits(2) from, boolean secure)">AArch32.GenerateDebugExceptionsFrom</a>(PSTATE.EL, <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>());</p>
    </div>
    <div class="ps"><a id="aarch32.debug.enables.AArch32.GenerateDebugExceptionsFrom"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/enables/AArch32.GenerateDebugExceptionsFrom</h3>
      <p class="pseudocode">// AArch32.GenerateDebugExceptionsFrom()
// =====================================

boolean <a id="AArch32.GenerateDebugExceptionsFrom.2"/>AArch32.GenerateDebugExceptionsFrom(bits(2) from, boolean secure)

    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.DebugTargetFrom.1" title="function: bits(2) DebugTargetFrom(boolean secure)">DebugTargetFrom</a>(secure)) then
        mask = '0';    // No PSTATE.D in AArch32 state
        return <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(from, secure, mask);

    if DBGOSLSR.OSLK == '1' || <a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()">DoubleLockStatus</a>() || <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then
        return FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; secure then
        assert from != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;    // Secure EL2 always uses AArch64
        if <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() then
            // Implies that EL3 and EL2 both using AArch64
            enabled = MDCR_EL3.SDD == '0';
        else
            spd = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SPD else MDCR_EL3.SPD32;
            if spd&lt;1&gt; == '1' then
                enabled = spd&lt;0&gt; == '1';
            else
                // SPD == 0b01 is reserved, but behaves the same as 0b00.
                enabled = <a href="shared_pseudocode.html#AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled.0" title="function: boolean AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled()">AArch32.SelfHostedSecurePrivilegedInvasiveDebugEnabled</a>();
        if from == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then enabled = enabled || SDER.SUIDEN == '1';
    else
        enabled = from != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    return enabled;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.CheckForPMUOverflow"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.CheckForPMUOverflow</h3>
      <p class="pseudocode">// AArch32.CheckForPMUOverflow()
// =============================
// Signal Performance Monitors overflow IRQ and CTI overflow events

<a id="AArch32.CheckForPMUOverflow.0"/>AArch32.CheckForPMUOverflow()
    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.CheckForPMUOverflow.0" title="function: AArch64.CheckForPMUOverflow()">AArch64.CheckForPMUOverflow</a>();
        return;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        hpme = if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPME else HDCR.HPME;
    pmuirq = PMCR.E == '1' &amp;&amp; PMINTENSET.C == '1' &amp;&amp; PMOVSSET.C == '1';
    for idx = 0 to <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() - 1
        E = if <a href="shared_pseudocode.html#AArch32.PMUCounterIsHyp.1" title="function: boolean AArch32.PMUCounterIsHyp(integer n)">AArch32.PMUCounterIsHyp</a>(idx) then hpme else PMCR.E;
        if E == '1' &amp;&amp; PMINTENSET&lt;idx&gt; == '1' &amp;&amp; PMOVSSET&lt;idx&gt; == '1' then pmuirq = TRUE;

    SetInterruptRequestLevel(<a href="shared_pseudocode.html#InterruptID_PMUIRQ" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_PMUIRQ</a>, if pmuirq then HIGH else LOW);

    CTI_SetEventLevel(<a href="shared_pseudocode.html#CrossTriggerIn_PMUOverflow" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_PMUOverflow</a>, if pmuirq then HIGH else LOW);

    // The request remains set until the condition is cleared. (For example, an interrupt handler
    // or cross-triggered event handler clears the overflow status flag by writing to PMOVSCLR.)</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.ClearEventCounters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.ClearEventCounters</h3>
      <p class="pseudocode">// AArch32.ClearEventCounters()
// ============================
// Zero all the event counters.

<a id="AArch32.ClearEventCounters.0"/>AArch32.ClearEventCounters()
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        // Force the counter to be cleared as a 64-bit counter.
        <a href="shared_pseudocode.html#AArch64.ClearEventCounters.0" title="function: AArch64.ClearEventCounters()">AArch64.ClearEventCounters</a>();
        return;

    for idx = 0 to <a href="shared_pseudocode.html#AArch32.GetNumEventCountersAccessible.0" title="function: integer AArch32.GetNumEventCountersAccessible()">AArch32.GetNumEventCountersAccessible</a>() - 1
        PMEVCNTR[idx] = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.CountPMUEvents"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.CountPMUEvents</h3>
      <p class="pseudocode">// AArch32.CountPMUEvents()
// ========================
// Return TRUE if counter "idx" should count its event. For the cycle counter, idx == CYCLE_COUNTER_ID.

boolean <a id="AArch32.CountPMUEvents.1"/>AArch32.CountPMUEvents(integer idx)
    assert idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> || idx &lt; <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then return <a href="shared_pseudocode.html#AArch64.CountPMUEvents.1" title="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(idx);
    // Event counting is disabled in Debug state
    debug = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();

    // Software can reserve some counters for EL2
    resvd_for_el2 = <a href="shared_pseudocode.html#AArch32.PMUCounterIsHyp.1" title="function: boolean AArch32.PMUCounterIsHyp(integer n)">AArch32.PMUCounterIsHyp</a>(idx);

    // Main enable controls
    if idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = PMCR.E == '1' &amp;&amp; PMCNTENSET.C == '1';
    else
        if resvd_for_el2 then
            E = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HDCR.HPME else MDCR_EL2.HPME;
        else
            E = PMCR.E;
        enabled = E == '1' &amp;&amp; PMCNTENSET&lt;idx&gt; == '1';

    // Event counting is allowed unless it is prohibited by any rule below
    prohibited = FALSE;

    // Event counting in Secure state is prohibited if all of:
    // * EL3 is implemented
    // * One of the following is true:
    //   - EL3 is using AArch64, MDCR_EL3.SPME == 0, and either:
    //     - FEAT_PMUv3p7 is not implemented
    //     - MDCR_EL3.MPMX == 0
    //   - EL3 is using AArch32 and SDCR.SPME == 0
    // * Not executing at EL0, or SDER.SUNIDEN == 0
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        spme = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SPME else MDCR_EL3.SPME;
        if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
            prohibited = spme == '0' &amp;&amp; MDCR_EL3.MPMX == '0';
        else
            prohibited = spme == '0';
        if prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            prohibited = SDER.SUNIDEN == '0';

    // Event counting at EL2 is prohibited if all of:
    // * The HPMD Extension is implemented
    // * PMNx is not reserved for EL2
    // * HDCR.HPMD == 1
    if !prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveHPMDExt.0" title="function: boolean HaveHPMDExt()">HaveHPMDExt</a>() &amp;&amp; !resvd_for_el2 then
        prohibited = HDCR.HPMD == '1';

    // The IMPLEMENTATION DEFINED authentication interface might override software
    if prohibited &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveNoSecurePMUDisableOverride.0" title="function: boolean HaveNoSecurePMUDisableOverride()">HaveNoSecurePMUDisableOverride</a>() then
        prohibited = !<a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>();

    // PMCR.DP disables the cycle counter when event counting is prohibited
    if prohibited &amp;&amp; idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = enabled &amp;&amp; (PMCR.DP == '0');
        prohibited = FALSE; // Otherwise whether event counting is prohibited does not affect the cycle counter

    // If FEAT_PMUv3p5 is implemented, cycle counting can be prohibited.
    // This is not overridden by PMCR.DP.
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p5.0" title="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() &amp;&amp; idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
            sccd = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.SCCD else MDCR_EL3.SCCD;
            if sccd == '1' then prohibited = TRUE;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; HDCR.HCCD == '1' then
            prohibited = TRUE;

    // Event counting might be frozen
    frozen = FALSE;

    // If FEAT_PMUv3p7 is implemented, event counting can be frozen
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() &amp;&amp; idx != <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            hpmn = if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMN else HDCR.HPMN;
        ovflws = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(PMOVSSET&lt;<a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>()-1:0&gt;);
        if resvd_for_el2 then
            FZ = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HDCR.HPMFZO else MDCR_EL2.HPMFZO;
            ovflws&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(hpmn)-1:0&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
        else
            FZ = PMCR.FZO;
            if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(hpmn) &lt; <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() then
                ovflws&lt;<a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>()-1:<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(hpmn)&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
        frozen = FZ == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ovflws);

    // Event counting can be filtered by the {P, U, NSK, NSU, NSH} bits
    filter = if idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then PMCCFILTR else PMEVTYPER[idx];

    P   = filter&lt;31&gt;;
    U   = filter&lt;30&gt;;
    NSK = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;29&gt; else '0';
    NSU = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;28&gt; else '0';
    NSH = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then filter&lt;27&gt; else '0';

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> filtered = if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then U == '1' else U != NSU;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> filtered = if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then P == '1' else P != NSK;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> filtered = NSH == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> filtered = P == '1';

    return !debug &amp;&amp; enabled &amp;&amp; !prohibited &amp;&amp; !filtered &amp;&amp; !frozen;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.GetNumEventCountersAccessible"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.GetNumEventCountersAccessible</h3>
      <p class="pseudocode">// AArch32.GetNumEventCountersAccessible()
// =======================================
// Return the number of event counters that can be accessed at the current Exception level.

integer <a id="AArch32.GetNumEventCountersAccessible.0"/>AArch32.GetNumEventCountersAccessible()
    // Software can reserve some counters for EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMN else HDCR.HPMN);
    else
        n = <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();

    return n;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.IncrementEventCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.IncrementEventCounter</h3>
      <p class="pseudocode">// AArch32.IncrementEventCounter()
// ===============================
// Increment the specified event counter by the specified amount.

<a id="AArch32.IncrementEventCounter.2"/>AArch32.IncrementEventCounter(integer idx, integer increment)
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        // Force the counter to be incremented as a 64-bit counter.
        <a href="shared_pseudocode.html#AArch64.IncrementEventCounter.2" title="function: AArch64.IncrementEventCounter(integer idx, integer increment)">AArch64.IncrementEventCounter</a>(idx, increment);
        return;

    // In this model, event counters in an AArch32-only implementation are 32 bits and
    // the LP bits are RES0 in this model, even if FEAT_PMUv3p5 is implemented.
    old_value = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMEVCNTR[idx]);
    new_value = old_value + increment;

    PMEVCNTR[idx] = new_value&lt;31:0&gt;;
    ovflw = 32;

    if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
        PMOVSSET&lt;idx&gt; = '1';
        PMOVSR&lt;idx&gt; = '1';
        // Check for the CHAIN event from an even counter
        if idx&lt;0&gt; == '0' &amp;&amp; idx + 1 &lt; <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() then
            <a href="shared_pseudocode.html#AArch32.PMUEvent.3" title="function: AArch32.PMUEvent(bits(16) event, integer increment, integer idx)">AArch32.PMUEvent</a>(<a href="shared_pseudocode.html#PMU_EVENT_CHAIN" title="constant bits(16) PMU_EVENT_CHAIN = 0x001E&lt;15:0&gt;">PMU_EVENT_CHAIN</a>, 1, idx + 1);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.PMUCounterIsHyp"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.PMUCounterIsHyp</h3>
      <p class="pseudocode">// AArch32.PMUCounterIsHyp
// =======================
// Returns TRUE if a counter is reserved for use by EL2, FALSE otherwise.

boolean <a id="AArch32.PMUCounterIsHyp.1"/>AArch32.PMUCounterIsHyp(integer n)
    // Software can reserve some counters for EL2
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        hpmn = if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then MDCR_EL2.HPMN else HDCR.HPMN;
        resvd_for_el2 = n &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(hpmn) &amp;&amp; n != <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>;
        if !<a href="shared_pseudocode.html#impl-shared.HaveFeatHPMN0.0" title="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</a>() &amp;&amp; hpmn == '00000' then
            resvd_for_el2 = boolean UNKNOWN;
    else
        resvd_for_el2 = FALSE;

    return resvd_for_el2;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.PMUCycle"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.PMUCycle</h3>
      <p class="pseudocode">// AArch32.PMUCycle()
// ==================

<a id="AArch32.PMUCycle.0"/>AArch32.PMUCycle()
    if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3.0" title="function: boolean HavePMUv3()">HavePMUv3</a>() || !<a href="shared_pseudocode.html#AArch32.CountPMUEvents.1" title="function: boolean AArch32.CountPMUEvents(integer idx)">AArch32.CountPMUEvents</a>(<a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>) then
        return;

    if PMCR.LC == '0' &amp;&amp; PMCR.D == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HasElapsed64Cycles.0" title="function: boolean HasElapsed64Cycles()">HasElapsed64Cycles</a>() then
        <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(<a href="shared_pseudocode.html#PMU_EVENT_CPU_CYCLES" title="constant bits(16) PMU_EVENT_CPU_CYCLES = 0x0011&lt;15:0&gt;">PMU_EVENT_CPU_CYCLES</a>);
        return;

    old_value = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMCCNTR);
    new_value = old_value + 1;
    PMCCNTR = new_value&lt;63:0&gt;;

    ovflw = if PMCR.LC == '1' then 64 else 32;

    if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
        PMOVSSET.C = '1';
        PMOVSR.C = '1';

    <a href="shared_pseudocode.html#AArch32.CheckForPMUOverflow.0" title="function: AArch32.CheckForPMUOverflow()">AArch32.CheckForPMUOverflow</a>();

    <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(<a href="shared_pseudocode.html#PMU_EVENT_CPU_CYCLES" title="constant bits(16) PMU_EVENT_CPU_CYCLES = 0x0011&lt;15:0&gt;">PMU_EVENT_CPU_CYCLES</a>);</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.PMUEvent"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.PMUEvent</h3>
      <p class="pseudocode">// AArch32.PMUEvent()
// ==================
// Generate a PMU Event. All the event counters are checked for the event.
// If any of the counters overflow then an interrupt is raised.

<a id="AArch32.PMUEvent.2"/>AArch32.PMUEvent(bits(16) event, integer increment)
    if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3.0" title="function: boolean HavePMUv3()">HavePMUv3</a>() then
        return;

    // Count the event
    for idx = 0 to <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() - 1
        if PMEVTYPER[idx].evtCount == event &amp;&amp; <a href="shared_pseudocode.html#AArch32.CountPMUEvents.1" title="function: boolean AArch32.CountPMUEvents(integer idx)">AArch32.CountPMUEvents</a>(idx) then
            <a href="shared_pseudocode.html#AArch32.IncrementEventCounter.2" title="function: AArch32.IncrementEventCounter(integer idx, integer increment)">AArch32.IncrementEventCounter</a>(idx, increment);

    <a href="shared_pseudocode.html#AArch32.CheckForPMUOverflow.0" title="function: AArch32.CheckForPMUOverflow()">AArch32.CheckForPMUOverflow</a>();

// AArch32.PMUEvent()
// ==================
// Generate a PMU Event for a specific event counter.

<a id="AArch32.PMUEvent.3"/>AArch32.PMUEvent(bits(16) event, integer increment, integer idx)
    if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3.0" title="function: boolean HavePMUv3()">HavePMUv3</a>() then
        return;
    // Count the event
    if PMEVTYPER[idx].evtCount == event &amp;&amp; <a href="shared_pseudocode.html#AArch32.CountPMUEvents.1" title="function: boolean AArch32.CountPMUEvents(integer idx)">AArch32.CountPMUEvents</a>(idx) then
        <a href="shared_pseudocode.html#AArch32.IncrementEventCounter.2" title="function: AArch32.IncrementEventCounter(integer idx, integer increment)">AArch32.IncrementEventCounter</a>(idx, increment);

    // This function is only called from other functions which will check for overflow later</p>
    </div>
    <div class="ps"><a id="aarch32.debug.pmu.AArch32.PMUSwIncrement"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/pmu/AArch32.PMUSwIncrement</h3>
      <p class="pseudocode">// AArch32.PMUSwIncrement()
// ========================
// Generate PMU Events on a write to PMSWINC.

<a id="AArch32.PMUSwIncrement.1"/>AArch32.PMUSwIncrement(bits(32) sw_incr)
    for idx = 0 to <a href="shared_pseudocode.html#AArch32.GetNumEventCountersAccessible.0" title="function: integer AArch32.GetNumEventCountersAccessible()">AArch32.GetNumEventCountersAccessible</a>() - 1
        if sw_incr&lt;idx&gt; == '1' then
            <a href="shared_pseudocode.html#AArch32.PMUEvent.3" title="function: AArch32.PMUEvent(bits(16) event, integer increment, integer idx)">AArch32.PMUEvent</a>(<a href="shared_pseudocode.html#PMU_EVENT_SW_INCR" title="constant bits(16) PMU_EVENT_SW_INCR = 0x0000&lt;15:0&gt;">PMU_EVENT_SW_INCR</a>, 1, idx);

    <a href="shared_pseudocode.html#AArch32.CheckForPMUOverflow.0" title="function: AArch32.CheckForPMUOverflow()">AArch32.CheckForPMUOverflow</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.debug.takeexceptiondbg.AArch32.EnterHypModeInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32.EnterHypModeInDebugState</h3>
      <p class="pseudocode">// AArch32.EnterHypModeInDebugState()
// ==================================
// Take an exception in Debug state to Hyp mode.

<a id="AArch32.EnterHypModeInDebugState.1"/>AArch32.EnterHypModeInDebugState(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    <a href="shared_pseudocode.html#AArch32.ReportHypEntry.1" title="function: AArch32.ReportHypEntry(ExceptionRecord exception)">AArch32.ReportHypEntry</a>(exception);
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
    ELR_hyp = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F&gt; = bits(4) UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    PSTATE.E = HSCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    EDSCR.ERR = '1';
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.debug.takeexceptiondbg.AArch32.EnterModeInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32.EnterModeInDebugState</h3>
      <p class="pseudocode">// AArch32.EnterModeInDebugState()
// ===============================
// Take an exception in Debug state to a mode other than Monitor and Hyp mode.

<a id="AArch32.EnterModeInDebugState.1"/>AArch32.EnterModeInDebugState(bits(5) target_mode)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(target_mode);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F&gt; = bits(4) UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    EDSCR.ERR = '1';
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.debug.takeexceptiondbg.AArch32.EnterMonitorModeInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/takeexceptiondbg/AArch32.EnterMonitorModeInDebugState</h3>
      <p class="pseudocode">// AArch32.EnterMonitorModeInDebugState()
// ======================================
// Take an exception in Debug state to Monitor mode.

<a id="AArch32.EnterMonitorModeInDebugState.0"/>AArch32.EnterMonitorModeInDebugState()
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    from_secure = <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = bits(32) UNKNOWN;
    // In Debug state, the PE always execute T32 instructions when in AArch32 state, and
    // PSTATE.{SS,A,I,F} are not observable so behave as UNKNOWN.
    PSTATE.T = '1';                             // PSTATE.J is RES0
    PSTATE.&lt;SS,A,I,F&gt; = bits(4) UNKNOWN;
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR.SPAN == '0' then
            PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
    EDSCR.ERR = '1';
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.debug.watchpoint.AArch32.WatchpointByteMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/watchpoint/AArch32.WatchpointByteMatch</h3>
      <p class="pseudocode">// AArch32.WatchpointByteMatch()
// =============================

boolean <a id="AArch32.WatchpointByteMatch.2"/>AArch32.WatchpointByteMatch(integer n,  bits(32) vaddress)

    integer top = 31;
    bottom = if DBGWVR[n]&lt;2&gt; == '1' then 2 else 3;            // Word or doubleword
    byte_select_match = (DBGWCR[n].BAS&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;bottom-1:0&gt;)&gt; != '0');
    mask = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGWCR[n].MASK);

    // If DBGWCR[n].MASK is non-zero value and DBGWCR[n].BAS is not set to '11111111', or
    // DBGWCR[n].BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGWCR[n].BAS) then
        byte_select_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPMASKANDBAS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WPMASKANDBAS</a>);
    else
        LSB = (DBGWCR[n].BAS AND NOT(DBGWCR[n].BAS - 1));  MSB = (DBGWCR[n].BAS + LSB);
        if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(MSB AND (MSB - 1)) then                     // Not contiguous
            byte_select_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPBASCONTIGUOUS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WPBASCONTIGUOUS</a>);
            bottom = 3;                                        // For the whole doubleword

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; mask &lt;= 2 then
        (c, mask) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(3, 31, <a href="shared_pseudocode.html#Unpredictable_RESWPMASK" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESWPMASK</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        case c of
            when <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;            // Disabled
            when <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      mask = 0;                // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value

    if mask &gt; bottom then
        // If the DBGxVR&lt;n&gt;_EL1.RESS field bits are not a sign extension of the MSB
        // of DBGBVR&lt;n&gt;_EL1.VA, it is UNPREDICTABLE whether they appear to be
        // included in the match.
        if !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGBVR_EL1[n]&lt;63:top&gt;) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGBVR_EL1[n]&lt;63:top&gt;) then
            if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_DBGxVR_RESS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DBGxVR_RESS</a>) then
                top = 63;
        WVR_match = (vaddress&lt;top:mask&gt; == DBGWVR[n]&lt;top:mask&gt;);
        // If masked bits of DBGWVR_EL1[n] are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGWVR[n]&lt;mask-1:bottom&gt;) then
            WVR_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPMASKEDBITS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WPMASKEDBITS</a>);
    else
        WVR_match = vaddress&lt;top:bottom&gt; == DBGWVR[n]&lt;top:bottom&gt;;

    return WVR_match &amp;&amp; byte_select_match;</p>
    </div>
    <div class="ps"><a id="aarch32.debug.watchpoint.AArch32.WatchpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/debug/watchpoint/AArch32.WatchpointMatch</h3>
      <p class="pseudocode">// AArch32.WatchpointMatch()
// =========================
// Watchpoint matching in an AArch32 translation regime.

boolean <a id="AArch32.WatchpointMatch.6"/>AArch32.WatchpointMatch(integer n, bits(32) vaddress, integer size, boolean ispriv,
                                <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#impl-shared.NumWatchpointsImplemented.0" title="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>();

    // "ispriv" is:
    //  * FALSE for all loads, stores, and atomic operations executed at EL0.
    //  * FALSE if the access is unprivileged.
    //  * TRUE for all other loads, stores, and atomic operations.

    enabled = DBGWCR[n].E == '1';
    linked = DBGWCR[n].WT == '1';
    isbreakpnt = FALSE;

    state_match = <a href="shared_pseudocode.html#AArch32.StateMatch.7" title="function: boolean AArch32.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN,&#13; boolean isbreakpnt,  boolean ispriv)">AArch32.StateMatch</a>(DBGWCR[n].SSC, DBGWCR[n].HMC, DBGWCR[n].PAC,
                                     linked, DBGWCR[n].LBN, isbreakpnt, ispriv);
    ls_match = FALSE;
    ls_match = (DBGWCR[n].LSC&lt;(if iswrite then 1 else 0)&gt; == '1');

    value_match = FALSE;
    for byte = 0 to size - 1
        value_match = value_match || <a href="shared_pseudocode.html#AArch32.WatchpointByteMatch.2" title="function: boolean AArch32.WatchpointByteMatch(integer n,  bits(32) vaddress)">AArch32.WatchpointByteMatch</a>(n, vaddress + byte);

    return value_match &amp;&amp; state_match &amp;&amp; ls_match &amp;&amp; enabled;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.Abort"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.Abort</h3>
      <p class="pseudocode">// AArch32.Abort()
// ===============
// Abort and Debug exception handling in an AArch32 translation regime.

<a id="AArch32.Abort.2"/>AArch32.Abort(bits(32) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = (HCR_EL2.TGE == '1' || <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) ||
                            (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                            (<a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; MDCR_EL2.TDE == '1'));

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);

    if route_to_aarch64 then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress), fault);
    elsif fault.acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        <a href="shared_pseudocode.html#AArch32.TakePrefetchAbortException.2" title="function: AArch32.TakePrefetchAbortException(bits(32) vaddress, FaultRecord fault)">AArch32.TakePrefetchAbortException</a>(vaddress, fault);
    else
        <a href="shared_pseudocode.html#AArch32.TakeDataAbortException.2" title="function: AArch32.TakeDataAbortException(bits(32) vaddress, FaultRecord fault)">AArch32.TakeDataAbortException</a>(vaddress, fault);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.AbortSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.AbortSyndrome</h3>
      <p class="pseudocode">// AArch32.AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort  exceptions taken to Hyp mode
// from an AArch32 translation regime.

ExceptionRecord <a id="AArch32.AbortSyndrome.3"/>AArch32.AbortSyndrome(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(32) vaddress)
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(exceptype);

    d_side = exceptype == <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>;

    exception.syndrome = <a href="shared_pseudocode.html#AArch32.FaultSyndrome.2" title="function: bits(25) AArch32.FaultSyndrome(boolean d_side, FaultRecord fault)">AArch32.FaultSyndrome</a>(d_side, fault);
    exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress);
    if <a href="shared_pseudocode.html#impl-shared.IPAValid.1" title="function: boolean IPAValid(FaultRecord fault)">IPAValid</a>(fault) then
        exception.ipavalid = TRUE;
        exception.NS = if fault.ipaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then '1' else '0';
        exception.ipaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(fault.ipaddress.address);
    else
        exception.ipavalid = FALSE;

    return exception;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.CheckPCAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.CheckPCAlignment</h3>
      <p class="pseudocode">// AArch32.CheckPCAlignment()
// ==========================

<a id="AArch32.CheckPCAlignment.0"/>AArch32.CheckPCAlignment()

    bits(32) pc = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    if (<a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> &amp;&amp; pc&lt;1&gt; == '1') || pc&lt;0&gt; == '1' then
        if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then <a href="shared_pseudocode.html#AArch64.PCAlignmentFault.0" title="function: AArch64.PCAlignmentFault()">AArch64.PCAlignmentFault</a>();

        // Generate an Alignment fault Prefetch Abort exception
        vaddress = pc;
        acctype = <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>;
        iswrite = FALSE;
        secondstage = FALSE;
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(vaddress, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.3" title="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.ReportDataAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.ReportDataAbort</h3>
      <p class="pseudocode">// AArch32.ReportDataAbort()
// =========================
// Report syndrome information for aborts taken to modes other than Hyp mode.

<a id="AArch32.ReportDataAbort.3"/>AArch32.ReportDataAbort(boolean route_to_monitor, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(32) vaddress)
    long_format = FALSE;
    if route_to_monitor &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        long_format = ((TTBCR_S.EAE == '1') ||
                       (<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) &amp;&amp; ((PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || TTBCR.EAE == '1') ||
                        (fault.secondstage &amp;&amp; boolean IMPLEMENTATION_DEFINED "Stage 2 synchronous external abort reports using Long-descriptor format when TTBCR_S.EAE is 0b0"))));
    else
        long_format = TTBCR.EAE == '1';
    d_side = TRUE;
    if long_format then
        syndrome = <a href="shared_pseudocode.html#AArch32.FaultStatusLD.2" title="function: bits(32) AArch32.FaultStatusLD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusLD</a>(d_side, fault);
    else
        syndrome = <a href="shared_pseudocode.html#AArch32.FaultStatusSD.2" title="function: bits(32) AArch32.FaultStatusSD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusSD</a>(d_side, fault);

    if fault.acctype == <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a> then
        if (!long_format &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Report I-cache maintenance fault in IFSR") then
            i_syndrome = syndrome;
            syndrome&lt;10,3:0&gt; = <a href="shared_pseudocode.html#impl-aarch32.EncodeSDFSC.2" title="function: bits(5) EncodeSDFSC(Fault statuscode, integer level)">EncodeSDFSC</a>(<a href="shared_pseudocode.html#Fault_ICacheMaint" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_ICacheMaint</a>, 1);
        else
            i_syndrome = bits(32) UNKNOWN;
        if route_to_monitor then
            IFSR_S = i_syndrome;
        else
            IFSR = i_syndrome;

    if route_to_monitor then
        DFSR_S = syndrome;
        DFAR_S = vaddress;
    else
        DFSR = syndrome;
        DFAR = vaddress;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.ReportPrefetchAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.ReportPrefetchAbort</h3>
      <p class="pseudocode">// AArch32.ReportPrefetchAbort()
// =============================
// Report syndrome information for aborts taken to modes other than Hyp mode.

<a id="AArch32.ReportPrefetchAbort.3"/>AArch32.ReportPrefetchAbort(boolean route_to_monitor, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(32) vaddress)
    // The encoding used in the IFSR can be Long-descriptor format or Short-descriptor format.
    // Normally, the current translation table format determines the format. For an abort from
    // Non-secure state to Monitor mode, the IFSR uses the Long-descriptor format if any of the
    // following applies:
    // * The Secure TTBCR.EAE is set to 1.
    // * It is taken from Hyp mode.
    // * It is taken from EL1 or EL0, and the Non-secure TTBCR.EAE is set to 1.
    long_format = FALSE;
    if route_to_monitor &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        long_format = TTBCR_S.EAE == '1' || PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || TTBCR.EAE == '1';
    else
        long_format = TTBCR.EAE == '1';

    d_side = FALSE;
    if long_format then
        fsr = <a href="shared_pseudocode.html#AArch32.FaultStatusLD.2" title="function: bits(32) AArch32.FaultStatusLD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusLD</a>(d_side, fault);
    else
        fsr = <a href="shared_pseudocode.html#AArch32.FaultStatusSD.2" title="function: bits(32) AArch32.FaultStatusSD(boolean d_side, FaultRecord fault)">AArch32.FaultStatusSD</a>(d_side, fault);

    if route_to_monitor then
        IFSR_S = fsr;
        IFAR_S = vaddress;
    else
        IFSR = fsr;
        IFAR = vaddress;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.TakeDataAbortException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.TakeDataAbortException</h3>
      <p class="pseudocode">// AArch32.TakeDataAbortException()
// ================================

<a id="AArch32.TakeDataAbortException.2"/>AArch32.TakeDataAbortException(bits(32) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);
    route_to_hyp = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' ||
                     (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                     (<a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; HDCR.TDE == '1') ||
                     <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x10;
    lr_offset = 8;

    if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then DBGDSCRext.MOE = fault.debugmoe;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#AArch32.AbortSyndrome.3" title="function: ExceptionRecord AArch32.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.aborts.AArch32.TakePrefetchAbortException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/aborts/AArch32.TakePrefetchAbortException</h3>
      <p class="pseudocode">// AArch32.TakePrefetchAbortException()
// ====================================

<a id="AArch32.TakePrefetchAbortException.2"/>AArch32.TakePrefetchAbortException(bits(32) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);
    route_to_hyp = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR.TGE == '1' ||
                     (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                     (<a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) &amp;&amp; HDCR.TDE == '1') ||
                     <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();

    vect_offset = 0x0C;

    lr_offset = 4;

    if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then DBGDSCRext.MOE = fault.debugmoe;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.ReportPrefetchAbort.3" title="function: AArch32.ReportPrefetchAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportPrefetchAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        if fault.statuscode == <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a> then             // PC Alignment fault
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>);
            exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        else
            exception = <a href="shared_pseudocode.html#AArch32.AbortSyndrome.3" title="function: ExceptionRecord AArch32.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, fault, vaddress);
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.ReportPrefetchAbort.3" title="function: AArch32.ReportPrefetchAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportPrefetchAbort</a>(route_to_monitor, fault, vaddress);
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakePhysicalFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakePhysicalFIQException</h3>
      <p class="pseudocode">// AArch32.TakePhysicalFIQException()
// ==================================

<a id="AArch32.TakePhysicalFIQException.0"/>AArch32.TakePhysicalFIQException()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || (HCR_EL2.FMO == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>());

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.FIQ == '1';

    if route_to_aarch64 then <a href="shared_pseudocode.html#AArch64.TakePhysicalFIQException.0" title="function: AArch64.TakePhysicalFIQException()">AArch64.TakePhysicalFIQException</a>();
    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.FIQ == '1';
    route_to_hyp = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR.TGE == '1' || HCR.FMO == '1'));
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x1C;
    lr_offset = 4;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>);
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakePhysicalIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakePhysicalIRQException</h3>
      <p class="pseudocode">// AArch32.TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.

<a id="AArch32.TakePhysicalIRQException.0"/>AArch32.TakePhysicalIRQException()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || (HCR_EL2.IMO == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>());
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.IRQ == '1';

    if route_to_aarch64 then <a href="shared_pseudocode.html#AArch64.TakePhysicalIRQException.0" title="function: AArch64.TakePhysicalIRQException()">AArch64.TakePhysicalIRQException</a>();

    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.IRQ == '1';
    route_to_hyp = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR.TGE == '1' || HCR.IMO == '1'));
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x18;
    lr_offset = 4;
    if route_to_monitor then
        <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>);
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakePhysicalSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakePhysicalSErrorException</h3>
      <p class="pseudocode">// AArch32.TakePhysicalSErrorException()
// =====================================

<a id="AArch32.TakePhysicalSErrorException.4"/>AArch32.TakePhysicalSErrorException(boolean parity, bit extflag, bits(2) pe_error_state,
                                         bits(25) full_syndrome)
    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = (HCR_EL2.TGE == '1' || (!<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; HCR_EL2.AMO == '1'));
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1';

    if route_to_aarch64 then
        <a href="shared_pseudocode.html#AArch64.TakePhysicalSErrorException.1" title="function: AArch64.TakePhysicalSErrorException(bits(25) syndrome)">AArch64.TakePhysicalSErrorException</a>(full_syndrome);

    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1';
    route_to_hyp = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR.TGE == '1' || HCR.AMO == '1'));
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x10;
    lr_offset = 8;

    bits(2) target_el;
    if route_to_monitor then
        target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    if <a href="shared_pseudocode.html#impl-shared.IsSErrorEdgeTriggered.2" title="function: boolean IsSErrorEdgeTriggered(bits(2) target_el, bits(25) syndrome)">IsSErrorEdgeTriggered</a>(target_el, full_syndrome) then
        <a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();

    fault = <a href="shared_pseudocode.html#impl-shared.AsyncExternalAbort.3" title="function: FaultRecord AsyncExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AsyncExternalAbort</a>(parity, pe_error_state, extflag);
    vaddress = bits(32) UNKNOWN;

    case target_el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
            <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            exception = <a href="shared_pseudocode.html#AArch32.AbortSyndrome.3" title="function: ExceptionRecord AArch32.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(32) vaddress)">AArch32.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);
            if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
                <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
            else
                <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
            <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakeVirtualFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakeVirtualFIQException</h3>
      <p class="pseudocode">// AArch32.TakeVirtualFIQException()
// =================================

<a id="AArch32.TakeVirtualFIQException.0"/>AArch32.TakeVirtualFIQException()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then  // Virtual IRQ enabled if TGE==0 and FMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.FMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.FMO == '1';
    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then <a href="shared_pseudocode.html#AArch64.TakeVirtualFIQException.0" title="function: AArch64.TakeVirtualFIQException()">AArch64.TakeVirtualFIQException</a>();

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x1C;
    lr_offset = 4;

    <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakeVirtualIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakeVirtualIRQException</h3>
      <p class="pseudocode">// AArch32.TakeVirtualIRQException()
// =================================

<a id="AArch32.TakeVirtualIRQException.0"/>AArch32.TakeVirtualIRQException()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then   // Virtual IRQs enabled if TGE==0 and IMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.IMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.IMO == '1';

    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then <a href="shared_pseudocode.html#AArch64.TakeVirtualIRQException.0" title="function: AArch64.TakeVirtualIRQException()">AArch64.TakeVirtualIRQException</a>();

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x18;
    lr_offset = 4;

    <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.async.AArch32.TakeVirtualSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/async/AArch32.TakeVirtualSErrorException</h3>
      <p class="pseudocode">// AArch32.TakeVirtualSErrorException()
// ====================================

<a id="AArch32.TakeVirtualSErrorException.3"/>AArch32.TakeVirtualSErrorException(bit extflag, bits(2) pe_error_state, bits(25) full_syndrome)

    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then   // Virtual SError enabled if TGE==0 and AMO==1
        assert HCR.TGE == '0' &amp;&amp; HCR.AMO == '1';
    else
        assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';
    // Check if routed to AArch64 state
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then <a href="shared_pseudocode.html#AArch64.TakeVirtualSErrorException.1" title="function: AArch64.TakeVirtualSErrorException(bits(25) syndrome)">AArch64.TakeVirtualSErrorException</a>(full_syndrome);

    route_to_monitor = FALSE;

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x10;
    lr_offset = 8;

    vaddress = bits(32) UNKNOWN;
    parity = FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            fault = <a href="shared_pseudocode.html#impl-shared.AsyncExternalAbort.3" title="function: FaultRecord AsyncExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AsyncExternalAbort</a>(FALSE, VDFSR.AET, VDFSR.ExT);
        else
            fault = <a href="shared_pseudocode.html#impl-shared.AsyncExternalAbort.3" title="function: FaultRecord AsyncExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AsyncExternalAbort</a>(FALSE, VSESR_EL2.AET, VSESR_EL2.ExT);
    else
        fault = <a href="shared_pseudocode.html#impl-shared.AsyncExternalAbort.3" title="function: FaultRecord AsyncExternalAbort(boolean parity, bits(2) errortype, bit extflag)">AsyncExternalAbort</a>(parity, pe_error_state, extflag);

    <a href="shared_pseudocode.html#impl-shared.ClearPendingVirtualSError.0" title="function: ClearPendingVirtualSError()">ClearPendingVirtualSError</a>();
    <a href="shared_pseudocode.html#AArch32.ReportDataAbort.3" title="function: AArch32.ReportDataAbort(boolean route_to_monitor, FaultRecord fault, bits(32) vaddress)">AArch32.ReportDataAbort</a>(route_to_monitor, fault, vaddress);
    <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.debug.AArch32.SoftwareBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/debug/AArch32.SoftwareBreakpoint</h3>
      <p class="pseudocode">// AArch32.SoftwareBreakpoint()
// ============================

<a id="AArch32.SoftwareBreakpoint.1"/>AArch32.SoftwareBreakpoint(bits(16) immediate)

    if (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
        (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1')) || !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.SoftwareBreakpoint.1" title="function: AArch64.SoftwareBreakpoint(bits(16) immediate)">AArch64.SoftwareBreakpoint</a>(immediate);
    vaddress = bits(32) UNKNOWN;
    acctype = <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>;           // Take as a Prefetch Abort
    iswrite = FALSE;
    entry = <a href="shared_pseudocode.html#DebugException_BKPT" title="constant bits(4) DebugException_BKPT = '0011'">DebugException_BKPT</a>;

    fault = <a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)">AArch32.DebugFault</a>(acctype, iswrite, entry);
    <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(vaddress, fault);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.debug.DebugException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/debug/DebugException</h3>
      <p class="pseudocode">constant bits(4) <a id="DebugException_Breakpoint"/>DebugException_Breakpoint  = '0001';
constant bits(4) <a id="DebugException_BKPT"/>DebugException_BKPT        = '0011';
constant bits(4) <a id="DebugException_VectorCatch"/>DebugException_VectorCatch = '0101';
constant bits(4) <a id="DebugException_Watchpoint"/>DebugException_Watchpoint  = '1010';</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.CheckAdvSIMDOrFPRegisterTraps"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.CheckAdvSIMDOrFPRegisterTraps</h3>
      <p class="pseudocode">// AArch32.CheckAdvSIMDOrFPRegisterTraps()
// =======================================
// Check if an instruction that accesses an Advanced SIMD and
// floating-point System register is trapped by an appropriate HCR.TIDx
// ID group trap control.

<a id="AArch32.CheckAdvSIMDOrFPRegisterTraps.1"/>AArch32.CheckAdvSIMDOrFPRegisterTraps(bits(4) reg)

    if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        tid0 = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HCR.TID0 else HCR_EL2.TID0;
        tid3 = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then HCR.TID3 else HCR_EL2.TID3;

        if (tid0 == '1' &amp;&amp; reg == '0000')                             // FPSID
          || (tid3 == '1' &amp;&amp; reg IN {'0101', '0110', '0111'}) then    // MVFRx
            if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
                <a href="shared_pseudocode.html#AArch32.SystemAccessTrap.2" title="function: AArch32.SystemAccessTrap(bits(5) mode, integer ec)">AArch32.SystemAccessTrap</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>, 0x8);               // Exception_AdvSIMDFPAccessTrap
            else
                <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, 0x8);            // Exception_AdvSIMDFPAccessTrap</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.ExceptionClass"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.ExceptionClass</h3>
      <p class="pseudocode">// AArch32.ExceptionClass()
// ========================
// Returns the Exception Class and Instruction Length fields to be reported in HSR

(integer,bit) <a id="AArch32.ExceptionClass.1"/>AArch32.ExceptionClass(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype)

    il_is_valid = TRUE;
    case exceptype of
        when <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>        ec = 0x00; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>              ec = 0x01;
        when <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>           ec = 0x03;
        when <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>          ec = 0x04;
        when <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>           ec = 0x05;
        when <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>           ec = 0x06;
        when <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>  ec = 0x07;
        when <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>             ec = 0x08;
        when <a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>              ec = 0x09;
        when <a href="shared_pseudocode.html#Exception_TSTARTAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_TSTARTAccessTrap</a>     ec = 0x1B;
        when <a href="shared_pseudocode.html#Exception_GPC" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_GPC</a>                  ec = 0x1E;
        when <a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>          ec = 0x0C;
        when <a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>         ec = 0x0D;
        when <a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>         ec = 0x0E; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>       ec = 0x11;
        when <a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>       ec = 0x12;
        when <a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>          ec = 0x13;
        when <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>     ec = 0x20; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>          ec = 0x22; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>            ec = 0x24;
        when <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>         ec = 0x25;
        when <a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>   ec = 0x28;
        otherwise                           <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    if ec IN {0x20,0x24} &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        ec = ec + 1;
    if il_is_valid then
        il = if <a href="shared_pseudocode.html#impl-shared.ThisInstrLength.0" title="function: integer ThisInstrLength()">ThisInstrLength</a>() == 32 then '1' else '0';
    else
        il = '1';

    return (ec,il);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.GeneralExceptionsToAArch64"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.GeneralExceptionsToAArch64</h3>
      <p class="pseudocode">// AArch32.GeneralExceptionsToAArch64()
// ====================================
// Returns TRUE if exceptions normally routed to EL1 are being handled at an Exception
// level using AArch64, because either EL1 is using AArch64 or TGE is in force and EL2
// is using AArch64.

boolean <a id="AArch32.GeneralExceptionsToAArch64.0"/>AArch32.GeneralExceptionsToAArch64()
    return ((PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) ||
            (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '1'));</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.ReportHypEntry"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.ReportHypEntry</h3>
      <p class="pseudocode">// AArch32.ReportHypEntry()
// ========================
// Report syndrome information to Hyp mode registers.

<a id="AArch32.ReportHypEntry.1"/>AArch32.ReportHypEntry(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception)

    <a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype = exception.exceptype;

    (ec,il) = <a href="shared_pseudocode.html#AArch32.ExceptionClass.1" title="function: (integer,bit) AArch32.ExceptionClass(Exception exceptype)">AArch32.ExceptionClass</a>(exceptype);
    iss = exception.syndrome;

    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss&lt;24&gt; == '0' then
        il = '1';

    HSR = ec&lt;5:0&gt;:il:iss;

    if exceptype IN {<a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>} then
        HIFAR = exception.vaddress&lt;31:0&gt;;
        HDFAR = bits(32) UNKNOWN;
    elsif exceptype == <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a> then
        HIFAR = bits(32) UNKNOWN;
        HDFAR = exception.vaddress&lt;31:0&gt;;

    if exception.ipavalid then
        HPFAR&lt;31:4&gt; = exception.ipaddress&lt;39:12&gt;;
    else
        HPFAR&lt;31:4&gt; = bits(28) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.ResetControlRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.ResetControlRegisters</h3>
      <p class="pseudocode">// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.
<a id="AArch32.ResetControlRegisters.1"/>AArch32.ResetControlRegisters(boolean cold_reset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.AArch32.TakeReset"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/AArch32.TakeReset</h3>
      <p class="pseudocode">// AArch32.TakeReset()
// ===================
// Reset into AArch32 state

<a id="AArch32.TakeReset.1"/>AArch32.TakeReset(boolean cold_reset)
    assert !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>();

    // Enter the highest implemented Exception level in AArch32 state
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);
        SCR.NS = '0';                     // Secure state
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    else
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);

    // Reset System registers in the coproc=0b111x encoding space and other system components
    <a href="shared_pseudocode.html#AArch32.ResetControlRegisters.1" title="function: AArch32.ResetControlRegisters(boolean cold_reset)">AArch32.ResetControlRegisters</a>(cold_reset);
    FPEXC.EN = '0';

    // Reset all other PSTATE fields, including instruction set and endianness according to the
    // SCTLR values produced by the above call to ResetControlRegisters()
    PSTATE.&lt;A,I,F&gt; = '111';       // All asynchronous exceptions masked
    PSTATE.IT = '00000000';       // IT block state reset
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        PSTATE.T = HSCTLR.TE;     // Instruction set: TE=0: A32, TE=1: T32. PSTATE.J is RES0.
        PSTATE.E = HSCTLR.EE;     // Endianness: EE=0: little-endian, EE=1: big-endian
    else
        PSTATE.T = SCTLR.TE;      // Instruction set: TE=0: A32, TE=1: T32. PSTATE.J is RES0.
        PSTATE.E = SCTLR.EE;      // Endianness: EE=0: little-endian, EE=1: big-endian
    PSTATE.IL = '0';              // Clear Illegal Execution state bit

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // R14 or ELR_hyp and SPSR have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.
    <a href="shared_pseudocode.html#AArch32.ResetGeneralRegisters.0" title="function: AArch32.ResetGeneralRegisters()">AArch32.ResetGeneralRegisters</a>();
    <a href="shared_pseudocode.html#AArch32.ResetSIMDFPRegisters.0" title="function: AArch32.ResetSIMDFPRegisters()">AArch32.ResetSIMDFPRegisters</a>();
    <a href="shared_pseudocode.html#AArch32.ResetSpecialRegisters.0" title="function: AArch32.ResetSpecialRegisters()">AArch32.ResetSpecialRegisters</a>();
    <a href="shared_pseudocode.html#impl-shared.ResetExternalDebugRegisters.1" title="function: ResetExternalDebugRegisters(boolean cold_reset)">ResetExternalDebugRegisters</a>(cold_reset);

    bits(32) rv;                      // IMPLEMENTATION DEFINED reset vector

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if MVBAR&lt;0&gt; == '1' then           // Reset vector in MVBAR
            rv = MVBAR&lt;31:1&gt;:'0';
        else
            rv = bits(32) IMPLEMENTATION_DEFINED "reset vector address";
    else
        rv = RVBAR&lt;31:1&gt;:'0';

    // The reset vector must be correctly aligned
    assert rv&lt;0&gt; == '0' &amp;&amp; (PSTATE.T == '1' || rv&lt;1&gt; == '0');

    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(rv, <a href="shared_pseudocode.html#BranchType_RESET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RESET</a>, branch_conditional);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.exceptions.ExcVectorBase"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/exceptions/ExcVectorBase</h3>
      <p class="pseudocode">// ExcVectorBase()
// ===============

bits(32) <a id="impl-aarch32.ExcVectorBase.0"/>ExcVectorBase()
    if SCTLR.V == '1' then  // Hivecs selected, base = 0xFFFF0000
        return <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(16):<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    else
        return VBAR&lt;31:5&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(5);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.ieeefp.AArch32.FPTrappedException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/ieeefp/AArch32.FPTrappedException</h3>
      <p class="pseudocode">// AArch32.FPTrappedException()
// ============================

<a id="AArch32.FPTrappedException.1"/>AArch32.FPTrappedException(bits(8) accumulated_exceptions)
    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        is_ase = FALSE;
        element = 0;
        <a href="shared_pseudocode.html#AArch64.FPTrappedException.2" title="function: AArch64.FPTrappedException(boolean is_ase, bits(8) accumulated_exceptions)">AArch64.FPTrappedException</a>(is_ase, accumulated_exceptions);
    FPEXC.DEX    = '1';
    FPEXC.TFV    = '1';
    FPEXC&lt;7,4:0&gt; = accumulated_exceptions&lt;7,4:0&gt;;                  // IDF,IXF,UFF,OFF,DZF,IOF
    FPEXC&lt;10:8&gt;  = '111';                                          // VECITR is RES1

    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32.CallHypervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.CallHypervisor</h3>
      <p class="pseudocode">// AArch32.CallHypervisor()
// ========================
// Performs a HVC call

<a id="AArch32.CallHypervisor.1"/>AArch32.CallHypervisor(bits(16) immediate)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch64.CallHypervisor.1" title="function: AArch64.CallHypervisor(bits(16) immediate)">AArch64.CallHypervisor</a>(immediate);
    else
        <a href="shared_pseudocode.html#AArch32.TakeHVCException.1" title="function: AArch32.TakeHVCException(bits(16) immediate)">AArch32.TakeHVCException</a>(immediate);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32.CallSupervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.CallSupervisor</h3>
      <p class="pseudocode">// AArch32.CallSupervisor()
// ========================
// Calls the Supervisor

<a id="AArch32.CallSupervisor.1"/>AArch32.CallSupervisor(bits(16) immediate)

    if <a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() != '1110' then
        immediate = bits(16) UNKNOWN;
    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        <a href="shared_pseudocode.html#AArch64.CallSupervisor.1" title="function: AArch64.CallSupervisor(bits(16) immediate)">AArch64.CallSupervisor</a>(immediate);
    else
        <a href="shared_pseudocode.html#AArch32.TakeSVCException.1" title="function: AArch32.TakeSVCException(bits(16) immediate)">AArch32.TakeSVCException</a>(immediate);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32.TakeHVCException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.TakeHVCException</h3>
      <p class="pseudocode">// AArch32.TakeHVCException()
// ==========================

<a id="AArch32.TakeHVCException.1"/>AArch32.TakeHVCException(bits(16) immediate)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x08;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32.TakeSMCException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.TakeSMCException</h3>
      <p class="pseudocode">// AArch32.TakeSMCException()
// ==========================

<a id="AArch32.TakeSMCException.0"/>AArch32.TakeSMCException()
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x08;
    lr_offset = 0;

    <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.syscalls.AArch32.TakeSVCException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/syscalls/AArch32.TakeSVCException</h3>
      <p class="pseudocode">// AArch32.TakeSVCException()
// ==========================

<a id="AArch32.TakeSVCException.1"/>AArch32.TakeSVCException(bits(16) immediate)

    <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    route_to_hyp = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.TGE == '1';

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x08;
    lr_offset = 0;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
        exception.syndrome&lt;15:0&gt; = immediate;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.takeexception.AArch32.EnterHypMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32.EnterHypMode</h3>
      <p class="pseudocode">// AArch32.EnterHypMode()
// ======================
// Take an exception to Hyp mode.

<a id="AArch32.EnterHypMode.3"/>AArch32.EnterHypMode(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception, bits(32) preferred_exception_return,
                     integer vect_offset)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    bits(32) spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.1" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#AArch32_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>);
    if !(exception.exceptype IN {<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>, <a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>}) then
        <a href="shared_pseudocode.html#AArch32.ReportHypEntry.1" title="function: AArch32.ReportHypEntry(ExceptionRecord exception)">AArch32.ReportHypEntry</a>(exception);
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    ELR_hyp = preferred_exception_return;
    PSTATE.T = HSCTLR.TE;                       // PSTATE.J is RES0
    PSTATE.SS = '0';
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].EA == '0' then PSTATE.A = '1';
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].IRQ == '0' then PSTATE.I = '1';
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].FIQ == '0' then PSTATE.F = '1';
    PSTATE.E = HSCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = HSCTLR.DSSBS;
    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(HVBAR&lt;31:5&gt;:vect_offset&lt;4:0&gt;, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.takeexception.AArch32.EnterMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32.EnterMode</h3>
      <p class="pseudocode">// AArch32.EnterMode()
// ===================
// Take an exception to a mode other than Monitor and Hyp mode.

<a id="AArch32.EnterMode.4"/>AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,
                  integer vect_offset)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    bits(32) spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.1" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#AArch32_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>);
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(target_mode);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = preferred_exception_return + lr_offset;
    PSTATE.T = SCTLR.TE;                        // PSTATE.J is RES0
    PSTATE.SS = '0';
    if target_mode == <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a> then
        PSTATE.&lt;A,I,F&gt; = '111';
    elsif target_mode IN {<a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>} then
        PSTATE.&lt;A,I&gt; = '11';
    else
        PSTATE.I = '1';
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = SCTLR.DSSBS;
    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(<a href="shared_pseudocode.html#impl-aarch32.ExcVectorBase.0" title="function: bits(32) ExcVectorBase()">ExcVectorBase</a>()&lt;31:5&gt;:vect_offset&lt;4:0&gt;, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.takeexception.AArch32.EnterMonitorMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/takeexception/AArch32.EnterMonitorMode</h3>
      <p class="pseudocode">// AArch32.EnterMonitorMode()
// ==========================
// Take an exception to Monitor mode.

<a id="AArch32.EnterMonitorMode.3"/>AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,
                         integer vect_offset)
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    from_secure = <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    bits(32) spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.1" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#AArch32_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>);
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
    <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = preferred_exception_return + lr_offset;
    PSTATE.T = SCTLR.TE;                        // PSTATE.J is RES0
    PSTATE.SS = '0';
    PSTATE.&lt;A,I,F&gt; = '111';
    PSTATE.E = SCTLR.EE;
    PSTATE.IL = '0';
    PSTATE.IT = '00000000';
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR.SPAN == '0' then
            PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = SCTLR.DSSBS;
    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(MVBAR&lt;31:5&gt;:vect_offset&lt;4:0&gt;, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckAdvSIMDOrFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckAdvSIMDOrFPEnabled</h3>
      <p class="pseudocode">// AArch32.CheckAdvSIMDOrFPEnabled()
// =================================
// Check against CPACR, FPEXC, HCPTR, NSACR, and CPTR_EL3.

<a id="AArch32.CheckAdvSIMDOrFPEnabled.2"/>AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() || (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '0')) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        // The PE behaves as if FPEXC.EN is 1
        <a href="shared_pseudocode.html#AArch64.CheckFPEnabled.0" title="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();
        <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDEnabled.0" title="function: AArch64.CheckFPAdvSIMDEnabled()">AArch64.CheckFPAdvSIMDEnabled</a>();
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        if fpexc_check &amp;&amp; HCR_EL2.RW == '0' then
            fpexc_en = bits(1) IMPLEMENTATION_DEFINED "FPEXC.EN value when TGE==1 and RW==0";
            if fpexc_en == '0' then UNDEFINED;
        <a href="shared_pseudocode.html#AArch64.CheckFPEnabled.0" title="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();
    else
        cpacr_asedis = CPACR.ASEDIS;
        cpacr_cp10 = CPACR.cp10;

        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
            // Check if access disabled in NSACR
            if NSACR.NSASEDIS == '1' then cpacr_asedis = '1';
            if NSACR.cp10 == '0' then cpacr_cp10 = '00';

        if PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            // Check if Advanced SIMD disabled in CPACR
            if advsimd &amp;&amp; cpacr_asedis == '1' then UNDEFINED;

            // Check if access disabled in CPACR
            case cpacr_cp10 of
                when '00' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
                when '10' disabled = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_RESCPACR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESCPACR</a>);
                when '11' disabled = FALSE;
            if disabled then UNDEFINED;

        // If required, check FPEXC enabled bit.
        if fpexc_check &amp;&amp; FPEXC.EN == '0' then UNDEFINED;

        <a href="shared_pseudocode.html#AArch32.CheckFPAdvSIMDTrap.1" title="function: AArch32.CheckFPAdvSIMDTrap(boolean advsimd)">AArch32.CheckFPAdvSIMDTrap</a>(advsimd);    // Also check against HCPTR and CPTR_EL3</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckFPAdvSIMDTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckFPAdvSIMDTrap</h3>
      <p class="pseudocode">// AArch32.CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.

<a id="AArch32.CheckFPAdvSIMDTrap.1"/>AArch32.CheckFPAdvSIMDTrap(boolean advsimd)
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDTrap.0" title="function: AArch64.CheckFPAdvSIMDTrap()">AArch64.CheckFPAdvSIMDTrap</a>();
    else
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
            hcptr_tase = HCPTR.TASE;
            hcptr_cp10 = HCPTR.TCP10;

            if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
                // Check if access disabled in NSACR
                if NSACR.NSASEDIS == '1' then hcptr_tase = '1';
                if NSACR.cp10 == '0' then hcptr_cp10 = '1';

            // Check if access disabled in HCPTR
            if (advsimd &amp;&amp; hcptr_tase == '1') || hcptr_cp10 == '1' then
                exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
                exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();

                if advsimd then
                    exception.syndrome&lt;5&gt; = '1';
                else
                    exception.syndrome&lt;5&gt; = '0';
                    exception.syndrome&lt;3:0&gt; = '1010';         // coproc field, always 0xA

                if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
                    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.1" title="function: AArch32.TakeUndefInstrException(ExceptionRecord exception)">AArch32.TakeUndefInstrException</a>(exception);
                else
                    <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);

        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            // Check if access disabled in CPTR_EL3
            if CPTR_EL3.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckForSMCUndefOrTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckForSMCUndefOrTrap</h3>
      <p class="pseudocode">// AArch32.CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction

<a id="AArch32.CheckForSMCUndefOrTrap.0"/>AArch32.CheckForSMCUndefOrTrap()
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        UNDEFINED;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch64.CheckForSMCUndefOrTrap.1" title="function: AArch64.CheckForSMCUndefOrTrap(bits(16) imm)">AArch64.CheckForSMCUndefOrTrap</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16));
    else
        route_to_hyp = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; HCR.TSC == '1';
        if route_to_hyp then
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>);
            <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckForSVCTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckForSVCTrap</h3>
      <p class="pseudocode">// AArch32.CheckForSVCTrap()
// =========================
// Check for trap on SVC instruction

<a id="AArch32.CheckForSVCTrap.1"/>AArch32.CheckForSVCTrap(bits(16) immediate)
    if <a href="shared_pseudocode.html#impl-shared.HaveFGTExt.0" title="function: boolean HaveFGTExt()">HaveFGTExt</a>() then
        route_to_el2 = FALSE;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            route_to_el2 = (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HFGITR_EL2.SVC_EL0 == '1' &amp;&amp;
                           (HCR_EL2.&lt;E2H, TGE&gt; != '11' &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1')));

        if route_to_el2 then
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
            exception.syndrome&lt;15:0&gt; = immediate;
            bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
            vect_offset = 0x0;

            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckForWFxTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckForWFxTrap</h3>
      <p class="pseudocode">// AArch32.CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction

<a id="AArch32.CheckForWFxTrap.2"/>AArch32.CheckForWFxTrap(bits(2) target_el, <a href="shared_pseudocode.html#WFxType" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el);

    // Check for routing to AArch64
    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) then
        <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(target_el, wfxtype);
        return;

    boolean is_wfe = wfxtype == <a href="shared_pseudocode.html#WFxType_WFE" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>;
    case target_el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            trap = (if is_wfe then SCTLR.nTWE else SCTLR.nTWI) == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            trap = (if is_wfe then HCR.TWE else HCR.TWI) == '1';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            trap = (if is_wfe then SCR.TWE else SCR.TWI) == '1';

    if trap then
        if target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.TGE == '1' then
            <a href="shared_pseudocode.html#AArch64.WFxTrap.2" title="function: AArch64.WFxTrap(WFxType wfxtype, bits(2) target_el)">AArch64.WFxTrap</a>(wfxtype, target_el);

        if target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            <a href="shared_pseudocode.html#AArch32.TakeMonitorTrapException.0" title="function: AArch32.TakeMonitorTrapException()">AArch32.TakeMonitorTrapException</a>();
        elsif target_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>);
            exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();

            case wfxtype of
                when <a href="shared_pseudocode.html#WFxType_WFI" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFI</a>
                    exception.syndrome&lt;0&gt; = '0';
                when <a href="shared_pseudocode.html#WFxType_WFE" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>
                    exception.syndrome&lt;0&gt; = '1';

            <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);
        else
            <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckITEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckITEnabled</h3>
      <p class="pseudocode">// AArch32.CheckITEnabled()
// ========================
// Check whether the T32 IT instruction is disabled.

<a id="AArch32.CheckITEnabled.1"/>AArch32.CheckITEnabled(bits(4) mask)
    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        it_disabled = HSCTLR.ITD;
    else
        it_disabled = (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then SCTLR.ITD else SCTLR[].ITD);
    if it_disabled == '1' then
        if mask != '1000' then UNDEFINED;

        // Otherwise whether the IT block is allowed depends on hw1 of the next instruction.
        next_instr = <a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned]">AArch32.MemSingle</a>[<a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()">NextInstrAddr</a>(), 2, <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, TRUE];

        if next_instr IN {'11xxxxxxxxxxxxxx', '1011xxxxxxxxxxxx', '10100xxxxxxxxxxx',
                          '01001xxxxxxxxxxx', '010001xxx1111xxx', '010001xx1xxxx111'} then
            // It is IMPLEMENTATION DEFINED whether the Undefined Instruction exception is
            // taken on the IT instruction or the next instruction. This is not reflected in
            // the pseudocode, which always takes the exception on the IT instruction. This
            // also does not take into account cases where the next instruction is UNPREDICTABLE.
            UNDEFINED;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckIllegalState"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckIllegalState</h3>
      <p class="pseudocode">// AArch32.CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.

<a id="AArch32.CheckIllegalState.0"/>AArch32.CheckIllegalState()
    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then
        <a href="shared_pseudocode.html#AArch64.CheckIllegalState.0" title="function: AArch64.CheckIllegalState()">AArch64.CheckIllegalState</a>();
    elsif PSTATE.IL == '1' then
        route_to_hyp = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.TGE == '1';

        bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        vect_offset = 0x04;

        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_hyp then
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>);
            if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
                <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
            else
                <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
        else
            <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.CheckSETENDEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.CheckSETENDEnabled</h3>
      <p class="pseudocode">// AArch32.CheckSETENDEnabled()
// ============================
// Check whether the AArch32 SETEND instruction is disabled.

<a id="AArch32.CheckSETENDEnabled.0"/>AArch32.CheckSETENDEnabled()
    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        setend_disabled = HSCTLR.SED;
    else
        setend_disabled = (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then SCTLR.SED else SCTLR[].SED);
    if setend_disabled == '1' then
        UNDEFINED;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.SystemAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.SystemAccessTrap</h3>
      <p class="pseudocode">// AArch32.SystemAccessTrap()
// ==========================
// Trapped  system register access.

<a id="AArch32.SystemAccessTrap.2"/>AArch32.SystemAccessTrap(bits(5) mode, integer ec)
    (valid, target_el) = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(mode);
    assert valid &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    if target_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        exception = <a href="shared_pseudocode.html#AArch32.SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch32.SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
        <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);
    else
        <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.SystemAccessTrapSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.SystemAccessTrapSyndrome</h3>
      <p class="pseudocode">// AArch32.SystemAccessTrapSyndrome()
// ==================================
// Returns the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS, VMSR instructions,
// other than traps that are due to HCPTR or CPACR.

ExceptionRecord <a id="AArch32.SystemAccessTrapSyndrome.2"/>AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception;

    case ec of
        when 0x0    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        when 0x3    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>);
        when 0x4    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>);
        when 0x5    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>);
        when 0x6    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>);
        when 0x7    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
        when 0x8    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>);
        when 0xC    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>);
        otherwise   <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    bits(20) iss = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    if exception.exceptype == <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a> then
        return exception;
    elsif exception.exceptype IN {<a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>, <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>, <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>} then
        // Trapped MRC/MCR, VMRS on FPSID
        iss&lt;13:10&gt; = instr&lt;19:16&gt;;        // CRn, Reg in case of VMRS
        iss&lt;8:5&gt;   = instr&lt;15:12&gt;;        // Rt
        iss&lt;9&gt;     = '0';                 // RES0

        if exception.exceptype != <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a> then    // When trap is not for VMRS
            iss&lt;19:17&gt; = instr&lt;7:5&gt;;          // opc2
            iss&lt;16:14&gt; = instr&lt;23:21&gt;;        // opc1
            iss&lt;4:1&gt;   = instr&lt;3:0&gt;;          //CRm
        else //VMRS Access
            iss&lt;19:17&gt; = '000';               //opc2 - Hardcoded for VMRS
            iss&lt;16:14&gt; = '111';               //opc1 - Hardcoded for VMRS
            iss&lt;4:1&gt;   = '0000';              //CRm  - Hardcoded for VMRS
    elsif exception.exceptype IN {<a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>, <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>, <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>} then
        // Trapped MRRC/MCRR, VMRS/VMSR
        iss&lt;19:16&gt; = instr&lt;7:4&gt;;          // opc1
        iss&lt;13:10&gt; = instr&lt;19:16&gt;;        // Rt2
        iss&lt;8:5&gt; = instr&lt;15:12&gt;;          // Rt
        iss&lt;4:1&gt;   = instr&lt;3:0&gt;;         // CRm
    elsif exception.exceptype == <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a> then
        // Trapped LDC/STC
        iss&lt;19:12&gt; = instr&lt;7:0&gt;;         // imm8
        iss&lt;4&gt;     = instr&lt;23&gt;;          // U
        iss&lt;2:1&gt;   = instr&lt;24,21&gt;;       // P,W
        if instr&lt;19:16&gt; == '1111' then   // Rn==15, LDC(Literal addressing)/STC
            iss&lt;8:5&gt; = bits(4) UNKNOWN;
            iss&lt;3&gt;   = '1';
    iss&lt;0&gt; = instr&lt;20&gt;;                  // Direction

    exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
    exception.syndrome&lt;19:0&gt;  = iss;

    return exception;</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.TakeHypTrapException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.TakeHypTrapException</h3>
      <p class="pseudocode">// AArch32.TakeHypTrapException()
// ==============================
// Exceptions routed to Hyp mode as a Hyp Trap exception.

<a id="AArch32.TakeHypTrapException.1"/>AArch32.TakeHypTrapException(integer ec)
    exception = <a href="shared_pseudocode.html#AArch32.SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch32.SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch32.SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
    <a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(exception);

// AArch32.TakeHypTrapException()
// ==============================
// Exceptions routed to Hyp mode as a Hyp Trap exception.

<a href="shared_pseudocode.html#AArch32.TakeHypTrapException.1" title="function: AArch32.TakeHypTrapException(integer ec)">AArch32.TakeHypTrapException</a>(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x14;

    <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.TakeMonitorTrapException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.TakeMonitorTrapException</h3>
      <p class="pseudocode">// AArch32.TakeMonitorTrapException()
// ==================================
// Exceptions routed to Monitor mode as a Monitor Trap exception.

<a id="AArch32.TakeMonitorTrapException.0"/>AArch32.TakeMonitorTrapException()
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);

    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x04;
    lr_offset = if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 4 else 2;

    <a href="shared_pseudocode.html#AArch32.EnterMonitorMode.3" title="function: AArch32.EnterMonitorMode(bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMonitorMode</a>(preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.TakeUndefInstrException"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.TakeUndefInstrException</h3>
      <p class="pseudocode">// AArch32.TakeUndefInstrException()
// =================================

<a id="AArch32.TakeUndefInstrException.0"/>AArch32.TakeUndefInstrException()
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.1" title="function: AArch32.TakeUndefInstrException(ExceptionRecord exception)">AArch32.TakeUndefInstrException</a>(exception);

// AArch32.TakeUndefInstrException()
// =================================

<a id="AArch32.TakeUndefInstrException.1"/>AArch32.TakeUndefInstrException(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception)

    route_to_hyp = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.TGE == '1';
    bits(32) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x04;
    lr_offset = if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 4 else 2;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, vect_offset);
    elsif route_to_hyp then
        <a href="shared_pseudocode.html#AArch32.EnterHypMode.3" title="function: AArch32.EnterHypMode(ExceptionRecord exception, bits(32) preferred_exception_return,&#13; integer vect_offset)">AArch32.EnterHypMode</a>(exception, preferred_exception_return, 0x14);
    else
        <a href="shared_pseudocode.html#AArch32.EnterMode.4" title="function: AArch32.EnterMode(bits(5) target_mode, bits(32) preferred_exception_return, integer lr_offset,&#13; integer vect_offset)">AArch32.EnterMode</a>(<a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>, preferred_exception_return, lr_offset, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch32.exceptions.traps.AArch32.UndefinedFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/exceptions/traps/AArch32.UndefinedFault</h3>
      <p class="pseudocode">// AArch32.UndefinedFault()
// ========================

<a id="AArch32.UndefinedFault.0"/>AArch32.UndefinedFault()

    if <a href="shared_pseudocode.html#AArch32.GeneralExceptionsToAArch64.0" title="function: boolean AArch32.GeneralExceptionsToAArch64()">AArch32.GeneralExceptionsToAArch64</a>() then <a href="shared_pseudocode.html#AArch64.UndefinedFault.0" title="function: AArch64.UndefinedFault()">AArch64.UndefinedFault</a>();
    <a href="shared_pseudocode.html#AArch32.TakeUndefInstrException.0" title="function: AArch32.TakeUndefInstrException()">AArch32.TakeUndefInstrException</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.AArch32.DomainValid"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.DomainValid</h3>
      <p class="pseudocode">// AArch32.DomainValid()
// =====================
// Returns TRUE if the Domain is valid for a Short-descriptor translation scheme.

boolean <a id="AArch32.DomainValid.2"/>AArch32.DomainValid(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode, integer level)
    assert statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    case statuscode of
        when <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a>
            return TRUE;
        when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>, <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>, <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>, <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
            return level == 2;
        otherwise
            return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.AArch32.FaultStatusLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.FaultStatusLD</h3>
      <p class="pseudocode">// AArch32.FaultStatusLD()
// =======================
// Creates an exception fault status value for Abort and Watchpoint exceptions taken
// to Abort mode using AArch32 and Long-descriptor format.

bits(32) <a id="AArch32.FaultStatusLD.2"/>AArch32.FaultStatusLD(boolean d_side, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    bits(32) fsr = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault) then fsr&lt;15:14&gt; = fault.errortype;
    if d_side then
        if fault.acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>,
            <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
            fsr&lt;13&gt; = '1'; fsr&lt;11&gt; = '1';
        else
            fsr&lt;11&gt; = if fault.write then '1' else '0';
    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then fsr&lt;12&gt; = fault.extflag;
    fsr&lt;9&gt; = '1';
    fsr&lt;5:0&gt; = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);

    return fsr;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.AArch32.FaultStatusSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.FaultStatusSD</h3>
      <p class="pseudocode">// AArch32.FaultStatusSD()
// =======================
// Creates an exception fault status value for Abort and Watchpoint exceptions taken
// to Abort mode using AArch32 and Short-descriptor format.

bits(32) <a id="AArch32.FaultStatusSD.2"/>AArch32.FaultStatusSD(boolean d_side, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    bits(32) fsr = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault) then fsr&lt;15:14&gt; = fault.errortype;
    if d_side then
        if fault.acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>,
            <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
            fsr&lt;13&gt; = '1'; fsr&lt;11&gt; = '1';
        else
            fsr&lt;11&gt; = if fault.write then '1' else '0';
    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then fsr&lt;12&gt; = fault.extflag;
    fsr&lt;9&gt; = '0';
    fsr&lt;10,3:0&gt; = <a href="shared_pseudocode.html#impl-aarch32.EncodeSDFSC.2" title="function: bits(5) EncodeSDFSC(Fault statuscode, integer level)">EncodeSDFSC</a>(fault.statuscode, fault.level);
    if d_side then
        fsr&lt;7:4&gt; = fault.domain;               // Domain field (data fault only)

    return fsr;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.AArch32.FaultSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/AArch32.FaultSyndrome</h3>
      <p class="pseudocode">// AArch32.FaultSyndrome()
// =======================
// Creates an exception syndrome value for Abort and Watchpoint exceptions taken to
// AArch32 Hyp mode.

bits(25) <a id="AArch32.FaultSyndrome.2"/>AArch32.FaultSyndrome(boolean d_side, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    bits(25) iss = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault) then
        iss&lt;11:10&gt; = fault.errortype; // AET

    if d_side then
        if (<a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) &amp;&amp; !fault.s2fs1walk &amp;&amp;
            (!<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) ||
            (!<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; fault.acctype == <a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a> &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "ISV on second stage translation table walk"))) then
            iss&lt;24:14&gt; = <a href="shared_pseudocode.html#impl-shared.LSInstructionSyndrome.0" title="function: bits(11) LSInstructionSyndrome()">LSInstructionSyndrome</a>();

        if fault.acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
            iss&lt;8&gt; = '1';  iss&lt;6&gt; = '1';
        else
            iss&lt;6&gt; = if fault.write then '1' else '0';

    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then iss&lt;9&gt; = fault.extflag;
    iss&lt;7&gt; = if fault.s2fs1walk then '1' else '0';
    iss&lt;5:0&gt; = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);

    return iss;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.aborts.EncodeSDFSC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/aborts/EncodeSDFSC</h3>
      <p class="pseudocode">// EncodeSDFSC()
// =============
// Function that gives the Short-descriptor FSR code for different types of Fault

bits(5) <a id="impl-aarch32.EncodeSDFSC.2"/>EncodeSDFSC(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode, integer level)

    bits(5) result;
    case statuscode of
        when <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>
            assert level IN {1,2};
            result = if level == 1 then '00011' else '00110';
        when <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>
            result = '00001';
        when <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>
            assert level IN {1,2};
            result = if level == 1 then '01101' else '01111';
        when <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a>
            assert level IN {1,2};
            result = if level == 1 then '01001' else '01011';
        when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>
            assert level IN {1,2};
            result = if level == 1 then '00101' else '00111';
        when <a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>
            result = '01000';
        when <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>
            assert level IN {1,2};
            result = if level == 1 then '01100' else '01110';
        when <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>
            result = '11001';
        when <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
            assert level IN {1,2};
            result = if level == 1 then '11100' else '11110';
        when <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>
            result = '11000';
        when <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>
            result = '10110';
        when <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>
            result = '00010';
        when <a href="shared_pseudocode.html#Fault_TLBConflict" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_TLBConflict</a>
            result = '10000';
        when <a href="shared_pseudocode.html#Fault_Lockdown" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Lockdown</a>
            result = '10100';   // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>
            result = '10101';   // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#Fault_ICacheMaint" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_ICacheMaint</a>
            result = '00100';
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.A32ExpandImm"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/A32ExpandImm</h3>
      <p class="pseudocode">// A32ExpandImm()
// ==============

bits(32) <a id="impl-aarch32.A32ExpandImm.1"/>A32ExpandImm(bits(12) imm12)

    // PSTATE.C argument to following function call does not affect the imm32 result.
    (imm32, -) = <a href="shared_pseudocode.html#impl-aarch32.A32ExpandImm_C.2" title="function: (bits(32), bit) A32ExpandImm_C(bits(12) imm12, bit carry_in)">A32ExpandImm_C</a>(imm12, PSTATE.C);

    return imm32;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.A32ExpandImm_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/A32ExpandImm_C</h3>
      <p class="pseudocode">// A32ExpandImm_C()
// ================

(bits(32), bit) <a id="impl-aarch32.A32ExpandImm_C.2"/>A32ExpandImm_C(bits(12) imm12, bit carry_in)

    unrotated_value = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(imm12&lt;7:0&gt;, 32);
    (imm32, carry_out) = <a href="shared_pseudocode.html#impl-aarch32.Shift_C.4" title="function: (bits(N), bit) Shift_C(bits(N) value, SRType srtype, integer amount, bit carry_in)">Shift_C</a>(unrotated_value, <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>, 2*<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm12&lt;11:8&gt;), carry_in);

    return (imm32, carry_out);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.DecodeImmShift"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/DecodeImmShift</h3>
      <p class="pseudocode">// DecodeImmShift()
// ================

(SRType, integer) <a id="impl-aarch32.DecodeImmShift.2"/>DecodeImmShift(bits(2) srtype, bits(5) imm5)

    case srtype of
        when '00'
            shift_t = <a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>;  shift_n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '01'
            shift_t = <a href="shared_pseudocode.html#SRType_LSR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>;  shift_n = if imm5 == '00000' then 32 else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '10'
            shift_t = <a href="shared_pseudocode.html#SRType_ASR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>;  shift_n = if imm5 == '00000' then 32 else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);
        when '11'
            if imm5 == '00000' then
                shift_t = <a href="shared_pseudocode.html#SRType_RRX" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a>;  shift_n = 1;
            else
                shift_t = <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>;  shift_n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm5);

    return (shift_t, shift_n);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.DecodeRegShift"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/DecodeRegShift</h3>
      <p class="pseudocode">// DecodeRegShift()
// ================

SRType <a id="impl-aarch32.DecodeRegShift.1"/>DecodeRegShift(bits(2) srtype)
    case srtype of
        when '00'  shift_t = <a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>;
        when '01'  shift_t = <a href="shared_pseudocode.html#SRType_LSR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>;
        when '10'  shift_t = <a href="shared_pseudocode.html#SRType_ASR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>;
        when '11'  shift_t = <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>;
    return shift_t;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.RRX"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/RRX</h3>
      <p class="pseudocode">// RRX()
// =====

bits(N) <a id="impl-aarch32.RRX.2"/>RRX(bits(N) x, bit carry_in)
    (result, -) = <a href="shared_pseudocode.html#impl-aarch32.RRX_C.2" title="function: (bits(N), bit) RRX_C(bits(N) x, bit carry_in)">RRX_C</a>(x, carry_in);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.RRX_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/RRX_C</h3>
      <p class="pseudocode">// RRX_C()
// =======

(bits(N), bit) <a id="impl-aarch32.RRX_C.2"/>RRX_C(bits(N) x, bit carry_in)
    result = carry_in : x&lt;N-1:1&gt;;
    carry_out = x&lt;0&gt;;
    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.SRType"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/SRType</h3>
      <p class="pseudocode">enumeration <a id="SRType"/>SRType {<a id="SRType_LSL"/>SRType_LSL, <a id="SRType_LSR"/>SRType_LSR, <a id="SRType_ASR"/>SRType_ASR, <a id="SRType_ROR"/>SRType_ROR, <a id="SRType_RRX"/>SRType_RRX};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.Shift"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/Shift</h3>
      <p class="pseudocode">// Shift()
// =======

bits(N) <a id="impl-aarch32.Shift.4"/>Shift(bits(N) value, <a href="shared_pseudocode.html#SRType" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> srtype, integer amount, bit carry_in)
    (result, -) = <a href="shared_pseudocode.html#impl-aarch32.Shift_C.4" title="function: (bits(N), bit) Shift_C(bits(N) value, SRType srtype, integer amount, bit carry_in)">Shift_C</a>(value, srtype, amount, carry_in);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.Shift_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/Shift_C</h3>
      <p class="pseudocode">// Shift_C()
// =========

(bits(N), bit) <a id="impl-aarch32.Shift_C.4"/>Shift_C(bits(N) value, <a href="shared_pseudocode.html#SRType" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType</a> srtype, integer amount, bit carry_in)
    assert !(srtype == <a href="shared_pseudocode.html#SRType_RRX" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a> &amp;&amp; amount != 1);

    if amount == 0 then
        (result, carry_out) = (value, carry_in);
    else
        case srtype of
            when <a href="shared_pseudocode.html#SRType_LSL" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSL</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.LSL_C.2" title="function: (bits(N), bit) LSL_C(bits(N) x, integer shift)">LSL_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_LSR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_LSR</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.LSR_C.2" title="function: (bits(N), bit) LSR_C(bits(N) x, integer shift)">LSR_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_ASR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ASR</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.ASR_C.2" title="function: (bits(N), bit) ASR_C(bits(N) x, integer shift)">ASR_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_ROR" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_ROR</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-shared.ROR_C.2" title="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(value, amount);
            when <a href="shared_pseudocode.html#SRType_RRX" title="enumeration SRType {SRType_LSL, SRType_LSR, SRType_ASR, SRType_ROR, SRType_RRX}">SRType_RRX</a>
                (result, carry_out) = <a href="shared_pseudocode.html#impl-aarch32.RRX_C.2" title="function: (bits(N), bit) RRX_C(bits(N) x, bit carry_in)">RRX_C</a>(value, carry_in);

    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.T32ExpandImm"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/T32ExpandImm</h3>
      <p class="pseudocode">// T32ExpandImm()
// ==============

bits(32) <a id="impl-aarch32.T32ExpandImm.1"/>T32ExpandImm(bits(12) imm12)

    // PSTATE.C argument to following function call does not affect the imm32 result.
    (imm32, -) = <a href="shared_pseudocode.html#impl-aarch32.T32ExpandImm_C.2" title="function: (bits(32), bit) T32ExpandImm_C(bits(12) imm12, bit carry_in)">T32ExpandImm_C</a>(imm12, PSTATE.C);

    return imm32;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.T32ExpandImm_C"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/T32ExpandImm_C</h3>
      <p class="pseudocode">// T32ExpandImm_C()
// ================

(bits(32), bit) <a id="impl-aarch32.T32ExpandImm_C.2"/>T32ExpandImm_C(bits(12) imm12, bit carry_in)
    if imm12&lt;11:10&gt; == '00' then
        case imm12&lt;9:8&gt; of
            when '00'
                imm32 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(imm12&lt;7:0&gt;, 32);
            when '01'
                imm32 = '00000000' : imm12&lt;7:0&gt; : '00000000' : imm12&lt;7:0&gt;;
            when '10'
                imm32 = imm12&lt;7:0&gt; : '00000000' : imm12&lt;7:0&gt; : '00000000';
            when '11'
                imm32 = imm12&lt;7:0&gt; : imm12&lt;7:0&gt; : imm12&lt;7:0&gt; : imm12&lt;7:0&gt;;
        carry_out = carry_in;
    else
        unrotated_value = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>('1':imm12&lt;6:0&gt;, 32);
        (imm32, carry_out) = <a href="shared_pseudocode.html#impl-shared.ROR_C.2" title="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(unrotated_value, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imm12&lt;11:7&gt;));

    return (imm32, carry_out);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.VCGEType"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/VCGEType</h3>
      <p class="pseudocode">enumeration <a id="VCGEType"/>VCGEType {<a id="VCGEType_signed"/>VCGEType_signed, <a id="VCGEType_unsigned"/>VCGEType_unsigned, <a id="VCGEType_fp"/>VCGEType_fp};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.common.VFPNegMul"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/common/VFPNegMul</h3>
      <p class="pseudocode">enumeration <a id="VFPNegMul"/>VFPNegMul {<a id="VFPNegMul_VNMLA"/>VFPNegMul_VNMLA, <a id="VFPNegMul_VNMLS"/>VFPNegMul_VNMLS, <a id="VFPNegMul_VNMUL"/>VFPNegMul_VNMUL};</p>
    </div>
    <div class="ps"><a id="aarch32.functions.coproc.AArch32.CheckCP15InstrCoarseTraps"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/coproc/AArch32.CheckCP15InstrCoarseTraps</h3>
      <p class="pseudocode">// AArch32.CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained  traps to System registers in the
// coproc=0b1111 encoding space by HSTR and HCR.

<a id="AArch32.CheckCP15InstrCoarseTraps.3"/>AArch32.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) ||
            (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>))) then
        <a href="shared_pseudocode.html#AArch64.CheckCP15InstrCoarseTraps.3" title="function: AArch64.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)">AArch64.CheckCP15InstrCoarseTraps</a>(CRn, nreg, CRm);

    trapped_encoding = ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
                        (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
                        (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}));

    // Check for coarse-grained Hyp traps
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        major = if nreg == 1 then CRn else CRm;
        // Check for MCR, MRC, MCRR, and MRRC disabled by HSTR&lt;CRn/CRm&gt;
        // and MRC and MCR disabled by HCR.TIDCP.
        if ((!(major IN {4,14}) &amp;&amp; HSTR&lt;major&gt; == '1') ||
                (HCR.TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp; trapped_encoding)) then
            if (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp;
                    boolean IMPLEMENTATION_DEFINED "UNDEF unallocated CP15 access at <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>") then
                UNDEFINED;
            if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
                <a href="shared_pseudocode.html#AArch32.SystemAccessTrap.2" title="function: AArch32.SystemAccessTrap(bits(5) mode, integer ec)">AArch32.SystemAccessTrap</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>, 0x3);
            else
                <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, 0x3);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32.ExclusiveMonitorsPass"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32.ExclusiveMonitorsPass</h3>
      <p class="pseudocode">// AArch32.ExclusiveMonitorsPass()
// ===============================
// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

boolean <a id="AArch32.ExclusiveMonitorsPass.2"/>AArch32.ExclusiveMonitorsPass(bits(32) address, integer size)

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
    // before or after the check on the local Exclusives monitor. As a result a failure
    // of the local monitor can occur on some implementations even if the memory
    // access would give an memory abort.

    acctype = <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    iswrite = TRUE;

    aligned = <a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, size, acctype, iswrite);

    passed = <a href="shared_pseudocode.html#AArch32.IsExclusiveVA.3" title="function: boolean AArch32.IsExclusiveVA(bits(32) address, integer processorid, integer size)">AArch32.IsExclusiveVA</a>(address, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);
    if !passed then
        return FALSE;

    memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, memaddrdesc.fault);

    passed = <a href="shared_pseudocode.html#impl-shared.IsExclusiveLocal.3" title="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)">IsExclusiveLocal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());

    if passed then
        if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
            passed = <a href="shared_pseudocode.html#impl-shared.IsExclusiveGlobal.3" title="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">IsExclusiveGlobal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    return passed;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32.IsExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32.IsExclusiveVA</h3>
      <p class="pseudocode">// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.
boolean <a id="AArch32.IsExclusiveVA.3"/>AArch32.IsExclusiveVA(bits(32) address, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32.MarkExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32.MarkExclusiveVA</h3>
      <p class="pseudocode">// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.
<a id="AArch32.MarkExclusiveVA.3"/>AArch32.MarkExclusiveVA(bits(32) address, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.exclusive.AArch32.SetExclusiveMonitors"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/exclusive/AArch32.SetExclusiveMonitors</h3>
      <p class="pseudocode">// AArch32.SetExclusiveMonitors()
// ==============================
// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.

<a id="AArch32.SetExclusiveMonitors.2"/>AArch32.SetExclusiveMonitors(bits(32) address, integer size)
    acctype = <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    iswrite = FALSE;

    aligned = <a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, size, acctype, iswrite);

    memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        return;

    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.MarkExclusiveGlobal.3" title="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveGlobal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a href="shared_pseudocode.html#impl-shared.MarkExclusiveLocal.3" title="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveLocal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a href="shared_pseudocode.html#AArch32.MarkExclusiveVA.3" title="function: AArch32.MarkExclusiveVA(bits(32) address, integer processorid, integer size)">AArch32.MarkExclusiveVA</a>(address, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckAdvSIMDEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckAdvSIMDEnabled</h3>
      <p class="pseudocode">// CheckAdvSIMDEnabled()
// =====================

<a id="impl-aarch32.CheckAdvSIMDEnabled.0"/>CheckAdvSIMDEnabled()

    fpexc_check = TRUE;
    advsimd = TRUE;

    <a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)">AArch32.CheckAdvSIMDOrFPEnabled</a>(fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if Advanced SIMD access is permitted

    // Make temporary copy of D registers
    // _Dclone[] is used as input data for instruction pseudocode
    for i = 0 to 31
        _Dclone[i] = <a href="shared_pseudocode.html#impl-aarch32.D.read.1" title="accessor: bits(64) D[integer n]">D</a>[i];

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckAdvSIMDOrVFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckAdvSIMDOrVFPEnabled</h3>
      <p class="pseudocode">// CheckAdvSIMDOrVFPEnabled()
// ==========================

<a id="impl-aarch32.CheckAdvSIMDOrVFPEnabled.2"/>CheckAdvSIMDOrVFPEnabled(boolean include_fpexc_check, boolean advsimd)
    <a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)">AArch32.CheckAdvSIMDOrFPEnabled</a>(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckCryptoEnabled32"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckCryptoEnabled32</h3>
      <p class="pseudocode">// CheckCryptoEnabled32()
// ======================

<a id="impl-aarch32.CheckCryptoEnabled32.0"/>CheckCryptoEnabled32()
    <a href="shared_pseudocode.html#impl-aarch32.CheckAdvSIMDEnabled.0" title="function: CheckAdvSIMDEnabled()">CheckAdvSIMDEnabled</a>();
    // Return from CheckAdvSIMDEnabled() occurs only if access is permitted
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.CheckVFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/CheckVFPEnabled</h3>
      <p class="pseudocode">// CheckVFPEnabled()
// =================

<a id="impl-aarch32.CheckVFPEnabled.1"/>CheckVFPEnabled(boolean include_fpexc_check)
    advsimd = FALSE;
    <a href="shared_pseudocode.html#AArch32.CheckAdvSIMDOrFPEnabled.2" title="function: AArch32.CheckAdvSIMDOrFPEnabled(boolean fpexc_check, boolean advsimd)">AArch32.CheckAdvSIMDOrFPEnabled</a>(include_fpexc_check, advsimd);
    // Return from CheckAdvSIMDOrFPEnabled() occurs only if VFP access is permitted
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.FPHalvedSub"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/FPHalvedSub</h3>
      <p class="pseudocode">// FPHalvedSub()
// =============

bits(N) <a id="impl-aarch32.FPHalvedSub.3"/>FPHalvedSub(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);     zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 != sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1);
        else
            result_value = (value1 - value2) / 2.0;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(result_value, fpcr);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.FPRSqrtStep"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/FPRSqrtStep</h3>
      <p class="pseudocode">// FPRSqrtStep()
// =============

bits(N) <a id="impl-aarch32.FPRSqrtStep.2"/>FPRSqrtStep(bits(N) op1, bits(N) op2)
    assert N IN {16,32};
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = <a href="shared_pseudocode.html#impl-aarch32.StandardFPSCRValue.0" title="function: FPCRType StandardFPSCRValue()">StandardFPSCRValue</a>();
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);     zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        bits(N) product;
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>('0');
        else
            product = <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(op1, op2, fpcr);
        bits(N) three = <a href="shared_pseudocode.html#impl-shared.FPThree.1" title="function: bits(N) FPThree(bit sign)">FPThree</a>('0');
        result = <a href="shared_pseudocode.html#impl-aarch32.FPHalvedSub.3" title="function: bits(N) FPHalvedSub(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPHalvedSub</a>(three, product, fpcr);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.FPRecipStep"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/FPRecipStep</h3>
      <p class="pseudocode">// FPRecipStep()
// =============

bits(N) <a id="impl-aarch32.FPRecipStep.2"/>FPRecipStep(bits(N) op1, bits(N) op2)
    assert N IN {16,32};
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = <a href="shared_pseudocode.html#impl-aarch32.StandardFPSCRValue.0" title="function: FPCRType StandardFPSCRValue()">StandardFPSCRValue</a>();
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);     zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        bits(N) product;
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            product = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>('0');
        else
            product = <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(op1, op2, fpcr);
        bits(N) two = <a href="shared_pseudocode.html#impl-shared.FPTwo.1" title="function: bits(N) FPTwo(bit sign)">FPTwo</a>('0');
        result = <a href="shared_pseudocode.html#impl-shared.FPSub.3" title="function: bits(N) FPSub(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPSub</a>(two, product, fpcr);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.float.StandardFPSCRValue"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/float/StandardFPSCRValue</h3>
      <p class="pseudocode">// StandardFPSCRValue()
// ====================

FPCRType <a id="impl-aarch32.StandardFPSCRValue.0"/>StandardFPSCRValue()
    bits(32) upper = '00000000000000000000000000000000';
    bits(32) lower = '00000' : FPSCR.AHP : '110000' : FPSCR.FZ16 : '0000000000000000000';
    return upper : lower;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.AArch32.CheckAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/AArch32.CheckAlignment</h3>
      <p class="pseudocode">// AArch32.CheckAlignment()
// ========================

boolean <a id="AArch32.CheckAlignment.4"/>AArch32.CheckAlignment(bits(32) address, integer alignment, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                               boolean iswrite)

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()) then
        A = SCTLR[].A; //use AArch64 register, when higher Exception level is using AArch64
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        A = HSCTLR.A;
    else
        A = SCTLR.A;
    aligned = (address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, alignment));
    atomic  = acctype IN { <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>, <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, <a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>,
                           <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a>, <a href="shared_pseudocode.html#AccType_ATOMICLS64" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a>, <a href="shared_pseudocode.html#AccType_A32LSMD" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a>};
    ordered = acctype IN { <a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</a>, <a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</a>, <a href="shared_pseudocode.html#AccType_LIMITEDORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_LIMITEDORDERED</a>,
                           <a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>, <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a> };
    vector  = acctype == <a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>;

    // AccType_VEC is used for SIMD element alignment checks only
    check = (atomic || ordered || vector || A == '1');

    if check &amp;&amp; !aligned then
        secondstage = FALSE;
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.3" title="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));

    return aligned;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.AArch32.MemSingle"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/AArch32.MemSingle</h3>
      <p class="pseudocode">// AArch32.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <a id="AArch32.MemSingle.read.4"/>AArch32.MemSingle[bits(32) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned]
    boolean ispair = FALSE;
    return <a href="shared_pseudocode.html#AArch32.MemSingle.read.5" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch32.MemSingle</a>[address, size, acctype, aligned, ispair];

// AArch32.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <a id="AArch32.MemSingle.read.5"/>AArch32.MemSingle[bits(32) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    assert address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, size);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    bits(size*8) value;
    iswrite = FALSE;

    memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, memaddrdesc.fault);

    // Memory array access
    accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);

    (memstatus, value) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size, accdesc);
    return value;

// AArch32.MemSingle[] - assignment (write) form
// =============================================

<a id="AArch32.MemSingle.write.4"/>AArch32.MemSingle[bits(32) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned] = bits(size*8) value
    boolean ispair = FALSE;
    <a href="shared_pseudocode.html#AArch32.MemSingle.write.5" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch32.MemSingle</a>[address, size, acctype, aligned, ispair] = value;
    return;

// AArch32.MemSingle[] - assignment (write) form
// =============================================
// Perform an atomic, little-endian write of 'size' bytes.

<a id="AArch32.MemSingle.write.5"/>AArch32.MemSingle[bits(32) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned, boolean ispair] = bits(size*8) value
    assert size IN {1, 2, 4, 8, 16};
    assert address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, size);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    iswrite = TRUE;

    memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    // Memory array access
    accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);

    memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size, accdesc, value);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size, accdesc);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Hint_PreloadData"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Hint_PreloadData</h3>
      <p class="pseudocode"><a id="impl-aarch32.Hint_PreloadData.1"/>Hint_PreloadData(bits(32) address);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Hint_PreloadDataForWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Hint_PreloadDataForWrite</h3>
      <p class="pseudocode"><a id="impl-aarch32.Hint_PreloadDataForWrite.1"/>Hint_PreloadDataForWrite(bits(32) address);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Hint_PreloadInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Hint_PreloadInstr</h3>
      <p class="pseudocode"><a id="impl-aarch32.Hint_PreloadInstr.1"/>Hint_PreloadInstr(bits(32) address);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemA</h3>
      <p class="pseudocode">// MemA[] - non-assignment form
// ============================

bits(8*size) <a id="impl-aarch32.MemA.read.2"/>MemA[bits(32) address, integer size]
    acctype = <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</a>[address, size, acctype];

// MemA[] - assignment form
// ========================

<a id="impl-aarch32.MemA.write.2"/>MemA[bits(32) address, integer size] = bits(8*size) value
    acctype = <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value">Mem_with_type</a>[address, size, acctype] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemO"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemO</h3>
      <p class="pseudocode">// MemO[] - non-assignment form
// ============================

bits(8*size) <a id="impl-aarch32.MemO.read.2"/>MemO[bits(32) address, integer size]
    acctype = <a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</a>;
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</a>[address, size, acctype];

// MemO[] - assignment form
// ========================

<a id="impl-aarch32.MemO.write.2"/>MemO[bits(32) address, integer size] = bits(8*size) value
    acctype = <a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</a>;
    <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value">Mem_with_type</a>[address, size, acctype] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemS"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemS</h3>
      <p class="pseudocode">// MemS[] - non-assignment form
// ============================
// Memory accessor for streaming load multiple instructions

bits(8*size) <a id="impl-aarch32.MemS.read.2"/>MemS[bits(32) address, integer size]
    acctype = <a href="shared_pseudocode.html#AccType_A32LSMD" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a>;
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</a>[address, size, acctype];

// MemS[] - assignment form
// ========================
// Memory accessor for streaming store multiple instructions

<a id="impl-aarch32.MemS.write.2"/>MemS[bits(32) address, integer size] = bits(8*size) value
    acctype = <a href="shared_pseudocode.html#AccType_A32LSMD" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a>;
    <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value">Mem_with_type</a>[address, size, acctype] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemU"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemU</h3>
      <p class="pseudocode">// MemU[] - non-assignment form
// ============================

bits(8*size) <a id="impl-aarch32.MemU.read.2"/>MemU[bits(32) address, integer size]
    acctype = <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>;
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</a>[address, size, acctype];

// MemU[] - assignment form
// ========================

<a id="impl-aarch32.MemU.write.2"/>MemU[bits(32) address, integer size] = bits(8*size) value
    acctype = <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>;
    <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value">Mem_with_type</a>[address, size, acctype] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.MemU_unpriv"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/MemU_unpriv</h3>
      <p class="pseudocode">// MemU_unpriv[] - non-assignment form
// ===================================

bits(8*size) <a id="impl-aarch32.MemU_unpriv.read.2"/>MemU_unpriv[bits(32) address, integer size]
    acctype = <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a>;
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.3" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype]">Mem_with_type</a>[address, size, acctype];

// MemU_unpriv[] - assignment form
// ===============================

<a id="impl-aarch32.MemU_unpriv.write.2"/>MemU_unpriv[bits(32) address, integer size] = bits(8*size) value
    acctype = <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a>;
    <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.3" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype] = bits(size*8) value">Mem_with_type</a>[address, size, acctype] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.memory.Mem_with_type"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/memory/Mem_with_type</h3>
      <p class="pseudocode">// Mem_with_type[] - non-assignment (read) form
// ============================================
// Perform a read of 'size' bytes. The access byte order is reversed for a big-endian access.
// Instruction fetches would call AArch32.MemSingle directly.

bits(size*8) <a id="impl-aarch32.Mem_with_type.read.3"/>Mem_with_type[bits(32) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype]
    boolean ispair = FALSE;
    return <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.read.4" title="accessor: bits(size*8) Mem_with_type[bits(32) address, integer size, AccType acctype, boolean ispair]">Mem_with_type</a>[address, size, acctype, ispair];

bits(size*8) <a id="impl-aarch32.Mem_with_type.read.4"/>Mem_with_type[bits(32) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    constant halfsize = size DIV 2;
    bits(size * 8) value;
    boolean iswrite = FALSE;
    if ispair then
        // check alignment on size of element accessed, not overall access size
        aligned = <a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, halfsize, acctype, iswrite);
    else
        aligned = <a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, size, acctype, iswrite);

    if !aligned then

        assert size &gt; 1;
        value&lt;7:0&gt; = <a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned]">AArch32.MemSingle</a>[address, 1, acctype, aligned];

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DEVPAGE2</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
        if c == <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            value&lt;8*i+7:8*i&gt; = <a href="shared_pseudocode.html#AArch32.MemSingle.read.4" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned]">AArch32.MemSingle</a>[address+i, 1, acctype, aligned];
    else
        value = <a href="shared_pseudocode.html#AArch32.MemSingle.read.5" title="accessor: bits(size*8) AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch32.MemSingle</a>[address, size, acctype, aligned, ispair];

    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a>(acctype) then
        value = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    return value;

// Mem_with_type[] - assignment (write) form
// =========================================
// Perform a write of 'size' bytes. The byte order is reversed for a big-endian access.

<a id="impl-aarch32.Mem_with_type.write.3"/>Mem_with_type[bits(32) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype] = bits(size*8) value
    boolean ispair = FALSE;
    <a href="shared_pseudocode.html#impl-aarch32.Mem_with_type.write.4" title="accessor: Mem_with_type[bits(32) address, integer size, AccType acctype, boolean ispair] = bits(size*8) value">Mem_with_type</a>[address, size, acctype, ispair] = value;

<a id="impl-aarch32.Mem_with_type.write.4"/>Mem_with_type[bits(32) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean ispair] = bits(size*8) value
    boolean iswrite = TRUE;
    constant halfsize = size DIV 2;
    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a>(acctype) then
        value = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    if ispair then
        // check alignment on size of element accessed, not overall access size
        aligned = <a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, halfsize, acctype, iswrite);
    else
        aligned = <a href="shared_pseudocode.html#AArch32.CheckAlignment.4" title="function: boolean AArch32.CheckAlignment(bits(32) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch32.CheckAlignment</a>(address, size, acctype, iswrite);

    if !aligned then
        assert size &gt; 1;
        <a href="shared_pseudocode.html#AArch32.MemSingle.write.4" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch32.MemSingle</a>[address, 1, acctype, aligned] = value&lt;7:0&gt;;

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DEVPAGE2</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
        if c == <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            <a href="shared_pseudocode.html#AArch32.MemSingle.write.4" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch32.MemSingle</a>[address+i, 1, acctype, aligned] = value&lt;8*i+7:8*i&gt;;
    else
        <a href="shared_pseudocode.html#AArch32.MemSingle.write.5" title="accessor: AArch32.MemSingle[bits(32) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch32.MemSingle</a>[address, size, acctype, aligned, ispair] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32.ESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32.ESBOperation</h3>
      <p class="pseudocode">// AArch32.ESBOperation()
// ======================
// Perform the AArch32 ESB operation for ESB executed in AArch32 state

<a id="AArch32.ESBOperation.0"/>AArch32.ESBOperation()

    // Check if routed to AArch64 state
    route_to_aarch64 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        route_to_aarch64 = HCR_EL2.TGE == '1' || HCR_EL2.AMO == '1';
    if !route_to_aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        route_to_aarch64 = SCR_EL3.EA == '1';

    if route_to_aarch64 then
        <a href="shared_pseudocode.html#AArch64.ESBOperation.0" title="function: AArch64.ESBOperation()">AArch64.ESBOperation</a>();
        return;

    route_to_monitor = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.EA == '1';
    route_to_hyp = PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (HCR.TGE == '1' || HCR.AMO == '1');

    if route_to_monitor then
        target = <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>;
    elsif route_to_hyp || PSTATE.M == <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a> then
        target = <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>;
    else
        target = <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>;

    if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        mask_active = TRUE;
    elsif target == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        mask_active = SCR.AW == '1' &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || (HCR.TGE == '0' &amp;&amp; HCR.AMO == '0'));
    else
        mask_active = target == <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a> || PSTATE.M == <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>;

    mask_set = PSTATE.A == '1';
    (-, el)  = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(target);
    intdis   = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(el);
    masked   = intdis || (mask_active &amp;&amp; mask_set);

    // Check for a masked Physical SError pending that can be synchronized
    // by an Error synchronization event.
    if masked &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSynchronizablePhysicalSErrorPending.0" title="function: boolean IsSynchronizablePhysicalSErrorPending()">IsSynchronizablePhysicalSErrorPending</a>() then
        syndrome32 = <a href="shared_pseudocode.html#AArch32.PhysicalSErrorSyndrome.0" title="function: AArch32.SErrorSyndrome AArch32.PhysicalSErrorSyndrome()">AArch32.PhysicalSErrorSyndrome</a>();
        DISR = <a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)">AArch32.ReportDeferredSError</a>(syndrome32.AET, syndrome32.ExT);
        <a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32.PhysicalSErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32.PhysicalSErrorSyndrome</h3>
      <p class="pseudocode">// Return the SError syndrome
AArch32.SErrorSyndrome <a id="AArch32.PhysicalSErrorSyndrome.0"/>AArch32.PhysicalSErrorSyndrome();</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32.ReportDeferredSError"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32.ReportDeferredSError</h3>
      <p class="pseudocode">// AArch32.ReportDeferredSError()
// ==============================
// Return deferred SError syndrome

bits(32) <a id="AArch32.ReportDeferredSError.2"/>AArch32.ReportDeferredSError(bits(2) AET, bit ExT)
    bits(32) target;
    target&lt;31&gt; = '1';                       // A
    syndrome = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        syndrome&lt;11:10&gt; = AET;              // AET
        syndrome&lt;9&gt;     = ExT;              // EA
        syndrome&lt;5:0&gt;   = '010001';         // DFSC
    else
        syndrome&lt;15:14&gt; = AET;              // AET
        syndrome&lt;12&gt;    = ExT;              // ExT
        syndrome&lt;9&gt;     = TTBCR.EAE;        // LPAE
        if TTBCR.EAE == '1' then            // Long-descriptor format
            syndrome&lt;5:0&gt;    = '010001';    // STATUS
        else                                // Short-descriptor format
            syndrome&lt;10,3:0&gt; = '10110';     // FS
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        target&lt;24:0&gt; = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(syndrome);// Any RES0 fields must be set to zero
    else
        target&lt;15:0&gt; = syndrome;
    return target;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32.SErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32.SErrorSyndrome</h3>
      <p class="pseudocode">type <a id="AArch32.SErrorSyndrome"/>AArch32.SErrorSyndrome is (
    bits(2) AET,
    bit ExT
)</p>
    </div>
    <div class="ps"><a id="aarch32.functions.ras.AArch32.vESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/ras/AArch32.vESBOperation</h3>
      <p class="pseudocode">// AArch32.vESBOperation()
// =======================
// Perform the ESB operation for virtual SError interrupts executed in AArch32 state

<a id="AArch32.vESBOperation.0"/>AArch32.vESBOperation()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    // Check for EL2 using AArch64 state
    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        <a href="shared_pseudocode.html#AArch64.vESBOperation.0" title="function: AArch64.vESBOperation()">AArch64.vESBOperation</a>();
        return;

    // If physical SError interrupts are routed to Hyp mode, and TGE is not set, then a
    // virtual SError interrupt might be pending
    vSEI_enabled = HCR.TGE == '0' &amp;&amp; HCR.AMO == '1';
    vSEI_pending = vSEI_enabled &amp;&amp; HCR.VA == '1';
    vintdis      = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    vmasked      = vintdis || PSTATE.A == '1';

    // Check for a masked virtual SError pending
    if vSEI_pending &amp;&amp; vmasked then
        VDISR = <a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)">AArch32.ReportDeferredSError</a>(VDFSR&lt;15:14&gt;, VDFSR&lt;12&gt;);
        HCR.VA = '0';                       // Clear pending virtual SError

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32.ResetGeneralRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32.ResetGeneralRegisters</h3>
      <p class="pseudocode">// AArch32.ResetGeneralRegisters()
// ===============================

<a id="AArch32.ResetGeneralRegisters.0"/>AArch32.ResetGeneralRegisters()

    for i = 0 to 7
        <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[i] = bits(32) UNKNOWN;
    for i = 8 to 12
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>] = bits(32) UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[13, <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>] = bits(32) UNKNOWN;   // No R14_hyp
    for i = 13 to 14
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>] = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>] = bits(32) UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[i, <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>] = bits(32) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32.ResetSIMDFPRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32.ResetSIMDFPRegisters</h3>
      <p class="pseudocode">// AArch32.ResetSIMDFPRegisters()
// ==============================

<a id="AArch32.ResetSIMDFPRegisters.0"/>AArch32.ResetSIMDFPRegisters()

    for i = 0 to 15
        <a href="shared_pseudocode.html#impl-aarch32.Q.write.1" title="accessor: Q[integer n] = bits(128) value">Q</a>[i] = bits(128) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32.ResetSpecialRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32.ResetSpecialRegisters</h3>
      <p class="pseudocode">// AArch32.ResetSpecialRegisters()
// ===============================

<a id="AArch32.ResetSpecialRegisters.0"/>AArch32.ResetSpecialRegisters()

    // AArch32 special registers
    SPSR_fiq&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_irq&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_svc&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_abt&lt;31:0&gt; = bits(32) UNKNOWN;
    SPSR_und&lt;31:0&gt; = bits(32) UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        SPSR_hyp = bits(32) UNKNOWN;
        ELR_hyp = bits(32) UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        SPSR_mon = bits(32) UNKNOWN;

    // External debug special registers
    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.AArch32.ResetSystemRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/AArch32.ResetSystemRegisters</h3>
      <p class="pseudocode"><a id="AArch32.ResetSystemRegisters.1"/>AArch32.ResetSystemRegisters(boolean cold_reset);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.ALUExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/ALUExceptionReturn</h3>
      <p class="pseudocode">// ALUExceptionReturn()
// ====================

<a id="impl-aarch32.ALUExceptionReturn.1"/>ALUExceptionReturn(bits(32) address)
    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        UNDEFINED;
    elsif PSTATE.M IN {<a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>,<a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>} then
        <a href="shared_pseudocode.html#Constraint" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint</a> c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_ALUEXCEPTIONRETURN" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ALUEXCEPTIONRETURN</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>, <a href="shared_pseudocode.html#Constraint_NOP" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NOP</a>};
        case c of
            when <a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>
                UNDEFINED;
            when <a href="shared_pseudocode.html#Constraint_NOP" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NOP</a>
                <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();
    else
        <a href="shared_pseudocode.html#AArch32.ExceptionReturn.2" title="function: AArch32.ExceptionReturn(bits(32) new_pc, bits(32) spsr)">AArch32.ExceptionReturn</a>(address, <a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(N) SPSR[]">SPSR</a>[]);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.ALUWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/ALUWritePC</h3>
      <p class="pseudocode">// ALUWritePC()
// ============

<a id="impl-aarch32.ALUWritePC.1"/>ALUWritePC(bits(32) address)
    if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then
        <a href="shared_pseudocode.html#impl-aarch32.BXWritePC.2" title="function: BXWritePC(bits(32) address, BranchType branch_type)">BXWritePC</a>(address, <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>);
    else
        <a href="shared_pseudocode.html#impl-aarch32.BranchWritePC.2" title="function: BranchWritePC(bits(32) address, BranchType branch_type)">BranchWritePC</a>(address, <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.BXWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/BXWritePC</h3>
      <p class="pseudocode">// BXWritePC()
// ===========

<a id="impl-aarch32.BXWritePC.2"/>BXWritePC(bits(32) address, <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type)
    if address&lt;0&gt; == '1' then
        <a href="shared_pseudocode.html#impl-aarch32.SelectInstrSet.1" title="function: SelectInstrSet(InstrSet iset)">SelectInstrSet</a>(<a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>);
        address&lt;0&gt; = '0';
    else
        <a href="shared_pseudocode.html#impl-aarch32.SelectInstrSet.1" title="function: SelectInstrSet(InstrSet iset)">SelectInstrSet</a>(<a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>);
        // For branches to an unaligned PC counter in A32 state, the processor takes the branch
        // and does one of:
        // * Forces the address to be aligned
        // * Leaves the PC unaligned, meaning the target generates a PC Alignment fault.
        if address&lt;1&gt; == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_A32FORCEALIGNPC" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_A32FORCEALIGNPC</a>) then
            address&lt;1&gt; = '0';
    boolean branch_conditional = <a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() != '111x';
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(address, branch_type, branch_conditional);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.BranchWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/BranchWritePC</h3>
      <p class="pseudocode">// BranchWritePC()
// ===============

<a id="impl-aarch32.BranchWritePC.2"/>BranchWritePC(bits(32) address, <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type)
    if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then
        address&lt;1:0&gt; = '00';
    else
        address&lt;0&gt; = '0';
    boolean branch_conditional = <a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() != '111x';
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(address, branch_type, branch_conditional);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.CBWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/CBWritePC</h3>
      <p class="pseudocode">// CBWritePC()
// ===========
// Takes a branch from a CBNZ/CBZ instruction.

<a id="impl-aarch32.CBWritePC.1"/>CBWritePC(bits(32) address)
    assert <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>;
    address&lt;0&gt; = '0';
    boolean branch_conditional = TRUE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(address, <a href="shared_pseudocode.html#BranchType_DIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</a>, branch_conditional);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.D"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/D</h3>
      <p class="pseudocode">// D[] - non-assignment form
// =========================

bits(64) <a id="impl-aarch32.D.read.1"/>D[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 2) * 64;
    bits(128) vreg = V[n DIV 2];
    return vreg&lt;base+63:base&gt;;

// D[] - assignment form
// =====================

<a id="impl-aarch32.D.write.1"/>D[integer n] = bits(64) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 2) * 64;
    bits(128) vreg = V[n DIV 2];
    vreg&lt;base+63:base&gt; = value;
    V[n DIV 2] = vreg;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Din"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Din</h3>
      <p class="pseudocode">// Din[] - non-assignment form
// ===========================

bits(64) <a id="impl-aarch32.Din.read.1"/>Din[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    return _Dclone[n];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.LR"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/LR</h3>
      <p class="pseudocode">// LR - assignment form
// ====================

<a id="impl-aarch32.LR.write.none"/>LR = bits(32) value
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[14] = value;
    return;

// LR - non-assignment form
// ========================

bits(32) <a id="impl-aarch32.LR.read.none"/>LR
    return <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[14];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.LoadWritePC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/LoadWritePC</h3>
      <p class="pseudocode">// LoadWritePC()
// =============

<a id="impl-aarch32.LoadWritePC.1"/>LoadWritePC(bits(32) address)
    <a href="shared_pseudocode.html#impl-aarch32.BXWritePC.2" title="function: BXWritePC(bits(32) address, BranchType branch_type)">BXWritePC</a>(address, <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.LookUpRIndex"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/LookUpRIndex</h3>
      <p class="pseudocode">// LookUpRIndex()
// ==============

integer <a id="impl-aarch32.LookUpRIndex.2"/>LookUpRIndex(integer n, bits(5) mode)
    assert n &gt;= 0 &amp;&amp; n &lt;= 14;

    case n of  // Select  index by mode:     usr fiq irq svc abt und hyp
        when 8     result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode,  8, 24,  8,  8,  8,  8,  8);
        when 9     result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode,  9, 25,  9,  9,  9,  9,  9);
        when 10    result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 10, 26, 10, 10, 10, 10, 10);
        when 11    result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 11, 27, 11, 11, 11, 11, 11);
        when 12    result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 12, 28, 12, 12, 12, 12, 12);
        when 13    result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 13, 29, 17, 19, 21, 23, 15);
        when 14    result = <a href="shared_pseudocode.html#impl-aarch32.RBankSelect.8" title="function: integer RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,&#13; integer svc, integer abt, integer und, integer hyp)">RBankSelect</a>(mode, 14, 30, 16, 18, 20, 22, 14);
        otherwise  result = n;

    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Monitor_mode_registers"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Monitor_mode_registers</h3>
      <p class="pseudocode">bits(32) <a id="impl-aarch32.SP.read.none"/>SP_mon;
bits(32) <a id="impl-aarch32.LR.read.none_2"/>LR_mon;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.PC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/PC</h3>
      <p class="pseudocode">// PC - non-assignment form
// ========================

bits(32) <a id="impl-aarch32.PC.read.none"/>PC
    return <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[15];               // This includes the offset from AArch32 state</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.PCStoreValue"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/PCStoreValue</h3>
      <p class="pseudocode">// PCStoreValue()
// ==============

bits(32) <a id="impl-aarch32.PCStoreValue.0"/>PCStoreValue()
    // This function returns the PC value. On architecture versions before Armv7, it
    // is permitted to instead return PC+4, provided it does so consistently. It is
    // used only to describe A32 instructions, so it returns the address of the current
    // instruction plus 8 (normally) or 12 (when the alternative is permitted).
    return <a href="shared_pseudocode.html#impl-aarch32.PC.read.none" title="accessor: bits(32) PC">PC</a>;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Q"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Q</h3>
      <p class="pseudocode">// Q[] - non-assignment form
// =========================

bits(128) <a id="impl-aarch32.Q.read.1"/>Q[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 15;
    return V[n];

// Q[] - assignment form
// =====================

<a id="impl-aarch32.Q.write.1"/>Q[integer n] = bits(128) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 15;
    V[n] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Qin"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Qin</h3>
      <p class="pseudocode">// Qin[] - non-assignment form
// ===========================

bits(128) <a id="impl-aarch32.Qin.read.1"/>Qin[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 15;
    return <a href="shared_pseudocode.html#impl-aarch32.Din.read.1" title="accessor: bits(64) Din[integer n]">Din</a>[2*n+1]:<a href="shared_pseudocode.html#impl-aarch32.Din.read.1" title="accessor: bits(64) Din[integer n]">Din</a>[2*n];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.R"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/R</h3>
      <p class="pseudocode">// R[] - assignment form
// =====================

<a id="impl-aarch32.R.write.1"/>R[integer n] = bits(32) value
    <a href="shared_pseudocode.html#impl-aarch32.Rmode.write.2" title="accessor: Rmode[integer n, bits(5) mode] = bits(32) value">Rmode</a>[n, PSTATE.M] = value;
    return;

// R[] - non-assignment form
// =========================

bits(32) <a id="impl-aarch32.R.read.1"/>R[integer n]
    if n == 15 then
        offset = (if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then 8 else 4);
        return _PC&lt;31:0&gt; + offset;
    else
        return <a href="shared_pseudocode.html#impl-aarch32.Rmode.read.2" title="accessor: bits(32) Rmode[integer n, bits(5) mode]">Rmode</a>[n, PSTATE.M];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.RBankSelect"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/RBankSelect</h3>
      <p class="pseudocode">// RBankSelect()
// =============

integer <a id="impl-aarch32.RBankSelect.8"/>RBankSelect(bits(5) mode, integer usr, integer fiq, integer irq,
                    integer svc, integer abt, integer und, integer hyp)

    case mode of
        when <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>    result = usr;  // User mode
        when <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>     result = fiq;  // FIQ mode
        when <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>     result = irq;  // IRQ mode
        when <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>     result = svc;  // Supervisor mode
        when <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>   result = abt;  // Abort mode
        when <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>     result = hyp;  // Hyp mode
        when <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>   result = und;  // Undefined mode
        when <a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>  result = usr;  // System mode uses User mode registers
        otherwise        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>(); // Monitor mode

    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.Rmode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/Rmode</h3>
      <p class="pseudocode">// Rmode[] - non-assignment form
// =============================

bits(32) <a id="impl-aarch32.Rmode.read.2"/>Rmode[integer n, bits(5) mode]
    assert n &gt;= 0 &amp;&amp; n &lt;= 14;

    // Check for attempted use of Monitor mode in Non-secure state.
    if !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then assert mode != <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>;
    assert !<a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)">BadMode</a>(mode);

    if mode == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        if n == 13 then return SP_mon;
        elsif n == 14 then return LR_mon;
        else return _R[n]&lt;31:0&gt;;
    else
        return _R[<a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)">LookUpRIndex</a>(n, mode)]&lt;31:0&gt;;

// Rmode[] - assignment form
// =========================

<a id="impl-aarch32.Rmode.write.2"/>Rmode[integer n, bits(5) mode] = bits(32) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 14;

    // Check for attempted use of Monitor mode in Non-secure state.
    if !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then assert mode != <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>;
    assert !<a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)">BadMode</a>(mode);

    if mode == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        if n == 13 then SP_mon = value;
        elsif n == 14 then LR_mon = value;
        else _R[n]&lt;31:0&gt; = value;
    else
        // It is CONSTRAINED UNPREDICTABLE whether the upper 32 bits of the X
        // register are unchanged or set to zero. This is also tested for on
        // exception entry, as this applies to all AArch32 registers.
        if <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ZEROUPPER</a>) then
            _R[<a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)">LookUpRIndex</a>(n, mode)] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
        else
            _R[<a href="shared_pseudocode.html#impl-aarch32.LookUpRIndex.2" title="function: integer LookUpRIndex(integer n, bits(5) mode)">LookUpRIndex</a>(n, mode)]&lt;31:0&gt; = value;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.S"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/S</h3>
      <p class="pseudocode">// S[] - non-assignment form
// =========================

bits(32) <a id="impl-aarch32.S.read.1"/>S[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 4) * 32;
    bits(128) vreg = V[n DIV 4];
    return vreg&lt;base+31:base&gt;;

// S[] - assignment form
// =====================

<a id="impl-aarch32.S.write.1"/>S[integer n] = bits(32) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    base = (n MOD 4) * 32;
    bits(128) vreg = V[n DIV 4];
    vreg&lt;base+31:base&gt; = value;
    V[n DIV 4] = vreg;
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers.SP"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/SP</h3>
      <p class="pseudocode">// SP - assignment form
// ====================

<a id="impl-aarch32.SP.write.none"/>SP = bits(32) value
    <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[13] = value;
    return;

// SP - non-assignment form
// ========================

bits(32) <a id="impl-aarch32.SP.read.none_2"/>SP
    return <a href="shared_pseudocode.html#impl-aarch32.R.read.1" title="accessor: bits(32) R[integer n]">R</a>[13];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.registers._Dclone"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/registers/_Dclone</h3>
      <p class="pseudocode">array bits(64) _Dclone[0..31];</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.ExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.ExceptionReturn</h3>
      <p class="pseudocode">// AArch32.ExceptionReturn()
// =========================

<a id="AArch32.ExceptionReturn.2"/>AArch32.ExceptionReturn(bits(32) new_pc, bits(32) spsr)

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();
    // Attempts to change to an illegal mode or state will invoke the Illegal Execution state
    // mechanism
    <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());
    <a href="shared_pseudocode.html#impl-shared.SendEventLocal.0" title="function: SendEventLocal()">SendEventLocal</a>();

    if PSTATE.IL == '1' then
        // If the exception return is illegal, PC[1:0] are UNKNOWN
        new_pc&lt;1:0&gt; = bits(2) UNKNOWN;
    else
        // LR[1:0] or LR[0] are treated as being 0, depending on the target instruction set state
        if PSTATE.T == '1' then
            new_pc&lt;0&gt; = '0';                 // T32
        else
            new_pc&lt;1:0&gt; = '00';              // A32

    boolean branch_conditional = <a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>() != '111x';
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc, <a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_ERET</a>, branch_conditional);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(FALSE);              // Check for debug event on exception return</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.ExecutingCP10or11Instr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.ExecutingCP10or11Instr</h3>
      <p class="pseudocode">// AArch32.ExecutingCP10or11Instr()
// ================================

boolean <a id="AArch32.ExecutingCP10or11Instr.0"/>AArch32.ExecutingCP10or11Instr()
    instr =  <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>();
    instr_set = <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>();
    assert instr_set IN {<a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>, <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>};

    if instr_set == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then
        return ((instr&lt;27:24&gt; == '1110' || instr&lt;27:25&gt; == '110') &amp;&amp; instr&lt;11:8&gt; == '101x');
    else // InstrSet_T32
        return (instr&lt;31:28&gt; == '111x' &amp;&amp; (instr&lt;27:24&gt; == '1110' || instr&lt;27:25&gt; == '110') &amp;&amp; instr&lt;11:8&gt; == '101x');</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.ITAdvance"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.ITAdvance</h3>
      <p class="pseudocode">// AArch32.ITAdvance()
// ===================

<a id="AArch32.ITAdvance.0"/>AArch32.ITAdvance()
    if PSTATE.IT&lt;2:0&gt; == '000' then
        PSTATE.IT = '00000000';
    else
        PSTATE.IT&lt;4:0&gt; = <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(PSTATE.IT&lt;4:0&gt;, 1);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegRead"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegRead</h3>
      <p class="pseudocode">// Read from a 32-bit AArch32 System register and return the register's contents.
bits(32) <a id="AArch32.SysRegRead.2"/>AArch32.SysRegRead(integer cp_num, bits(32) instr);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegRead64"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegRead64</h3>
      <p class="pseudocode">// Read from a 64-bit AArch32 System register and return the register's contents.
bits(64) <a id="AArch32.SysRegRead64.2"/>AArch32.SysRegRead64(integer cp_num, bits(32) instr);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegReadCanWriteAPSR"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegReadCanWriteAPSR</h3>
      <p class="pseudocode">// AArch32.SysRegReadCanWriteAPSR()
// ================================
// Determines whether the AArch32 System register read instruction can write to APSR flags.

boolean <a id="AArch32.SysRegReadCanWriteAPSR.2"/>AArch32.SysRegReadCanWriteAPSR(integer cp_num, bits(32) instr)
    assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    assert (cp_num IN {14,15});
    assert cp_num == <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;11:8&gt;);

    opc1 = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;23:21&gt;);
    opc2 = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;7:5&gt;);
    CRn  = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;19:16&gt;);
    CRm  = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(instr&lt;3:0&gt;);

    if cp_num == 14 &amp;&amp; opc1 == 0 &amp;&amp; CRn == 0 &amp;&amp; CRm == 1 &amp;&amp; opc2 == 0 then // DBGDSCRint
        return TRUE;

    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegWrite</h3>
      <p class="pseudocode">// Write to a 32-bit AArch32 System register.
<a id="AArch32.SysRegWrite.3"/>AArch32.SysRegWrite(integer cp_num, bits(32) instr, bits(32) val);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegWrite64"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegWrite64</h3>
      <p class="pseudocode">// Write to a 64-bit AArch32 System register.
<a id="AArch32.SysRegWrite64.3"/>AArch32.SysRegWrite64(integer cp_num, bits(32) instr, bits(64) val);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.SysRegWriteM"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.SysRegWriteM</h3>
      <p class="pseudocode">// Read a value from a virtual address and write it to an AArch32 System register.
<a id="AArch32.SysRegWriteM.3"/>AArch32.SysRegWriteM(integer cp_num, bits(32) instr, bits(32) address);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.WriteMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.WriteMode</h3>
      <p class="pseudocode">// AArch32.WriteMode()
// ===================
// Function for dealing with writes to PSTATE.M from AArch32 state only.
// This ensures that PSTATE.EL and PSTATE.SP are always valid.

<a id="AArch32.WriteMode.1"/>AArch32.WriteMode(bits(5) mode)
    (valid,el) = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(mode);
    assert valid;
    PSTATE.M   = mode;
    PSTATE.EL  = el;
    PSTATE.nRW = '1';
    PSTATE.SP  = (if mode IN {<a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>,<a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>} then '0' else '1');
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.AArch32.WriteModeByInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/AArch32.WriteModeByInstr</h3>
      <p class="pseudocode">// AArch32.WriteModeByInstr()
// ==========================
// Function for dealing with writes to PSTATE.M from an AArch32 instruction, and ensuring that
// illegal state changes are correctly flagged in PSTATE.IL.

<a id="AArch32.WriteModeByInstr.1"/>AArch32.WriteModeByInstr(bits(5) mode)
    (valid,el) = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(mode);

    // 'valid' is set to FALSE if' mode' is invalid for this implementation or the current value
    // of SCR.NS/SCR_EL3.NS. Additionally, it is illegal for an instruction to write 'mode' to
    // PSTATE.EL if it would result in any of:
    // * A change to a mode that would cause entry to a higher Exception level.
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(el) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then
        valid = FALSE;

    // * A change to or from Hyp mode.
    if (PSTATE.M == <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a> || mode == <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>) &amp;&amp; PSTATE.M != mode then
        valid = FALSE;

    // * When EL2 is implemented, the value of HCR.TGE is '1', a change to a Non-secure EL1 mode.
    if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; SCR.NS == '1' &amp;&amp; HCR.TGE == '1' then
        valid = FALSE;

    if !valid then
        PSTATE.IL = '1';
    else
        <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(mode);</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.BadMode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/BadMode</h3>
      <p class="pseudocode">// BadMode()
// =========

boolean <a id="impl-aarch32.BadMode.1"/>BadMode(bits(5) mode)
    // Return TRUE if 'mode' encodes a mode that is not valid for this implementation
    case mode of
        when <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>
            valid = <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        when <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>
            valid = <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        when <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>, <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>, <a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            // Therefore it is sufficient to test this implementation supports EL1 using AArch32.
            valid = <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        when <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>
            valid = <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>);
        otherwise
            valid = FALSE;           // Passed an illegal mode value
    return !valid;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.BankedRegisterAccessValid"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/BankedRegisterAccessValid</h3>
      <p class="pseudocode">// BankedRegisterAccessValid()
// ===========================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to registers
// other than the SPSRs that are invalid. This includes ELR_hyp accesses.

<a id="impl-aarch32.BankedRegisterAccessValid.2"/>BankedRegisterAccessValid(bits(5) SYSm, bits(5) mode)

    case SYSm of
        when '000xx', '00100'                          // R8_usr to R12_usr
            if mode != <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a> then UNPREDICTABLE;
        when '00101'                                   // SP_usr
            if mode == <a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a> then UNPREDICTABLE;
        when '00110'                                   // LR_usr
            if mode IN {<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>,<a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>} then UNPREDICTABLE;
        when '010xx', '0110x', '01110'                 // R8_fiq to R12_fiq, SP_fiq, LR_fiq
            if mode == <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a> then UNPREDICTABLE;
        when '1000x'                                   // LR_irq, SP_irq
            if mode == <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a> then UNPREDICTABLE;
        when '1001x'                                   // LR_svc, SP_svc
            if mode == <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a> then UNPREDICTABLE;
        when '1010x'                                   // LR_abt, SP_abt
            if mode == <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a> then UNPREDICTABLE;
        when '1011x'                                   // LR_und, SP_und
            if mode == <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a> then UNPREDICTABLE;
        when '1110x'                                   // LR_mon, SP_mon
            if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() || mode == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then UNPREDICTABLE;
        when '11110'                                   // ELR_hyp, only from Monitor or Hyp mode
            if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || !(mode IN {<a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>,<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>}) then UNPREDICTABLE;
        when '11111'                                   // SP_hyp, only from Monitor mode
            if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || mode != <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then UNPREDICTABLE;
        otherwise
            UNPREDICTABLE;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.CPSRWriteByInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/CPSRWriteByInstr</h3>
      <p class="pseudocode">// CPSRWriteByInstr()
// ==================
// Update PSTATE.&lt;N,Z,C,V,Q,GE,E,A,I,F,M&gt; from a CPSR value written by an MSR instruction.

<a id="impl-aarch32.CPSRWriteByInstr.2"/>CPSRWriteByInstr(bits(32) value, bits(4) bytemask)
    privileged = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;              // PSTATE.&lt;A,I,F,M&gt; are not writable at EL0

    // Write PSTATE from 'value', ignoring bytes masked by 'bytemask'
    if bytemask&lt;3&gt; == '1' then
        PSTATE.&lt;N,Z,C,V,Q&gt; = value&lt;31:27&gt;;
        // Bits &lt;26:24&gt; are ignored

    if bytemask&lt;2&gt; == '1' then
        if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then
            PSTATE.SSBS = value&lt;23&gt;;
        if privileged then
            PSTATE.PAN = value&lt;22&gt;;
        if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then
            PSTATE.DIT = value&lt;21&gt;;
        // Bit &lt;20&gt; is RES0
        PSTATE.GE = value&lt;19:16&gt;;

    if bytemask&lt;1&gt; == '1' then
        // Bits &lt;15:10&gt; are RES0
        PSTATE.E = value&lt;9&gt;;                    // PSTATE.E is writable at EL0
        if privileged then
            PSTATE.A = value&lt;8&gt;;

    if bytemask&lt;0&gt; == '1' then
        if privileged then
            PSTATE.&lt;I,F&gt; = value&lt;7:6&gt;;
            // Bit &lt;5&gt; is RES0
            // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
            <a href="shared_pseudocode.html#AArch32.WriteModeByInstr.1" title="function: AArch32.WriteModeByInstr(bits(5) mode)">AArch32.WriteModeByInstr</a>(value&lt;4:0&gt;);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.ConditionPassed"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/ConditionPassed</h3>
      <p class="pseudocode">// ConditionPassed()
// =================

boolean <a id="impl-aarch32.ConditionPassed.0"/>ConditionPassed()
    return <a href="shared_pseudocode.html#impl-shared.ConditionHolds.1" title="function: boolean ConditionHolds(bits(4) cond)">ConditionHolds</a>(<a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>());</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.CurrentCond"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/CurrentCond</h3>
      <p class="pseudocode">bits(4) <a id="AArch32.CurrentCond.0"/>AArch32.CurrentCond();</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.InITBlock"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/InITBlock</h3>
      <p class="pseudocode">// InITBlock()
// ===========

boolean <a id="impl-aarch32.InITBlock.0"/>InITBlock()
    if <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() == <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a> then
        return PSTATE.IT&lt;3:0&gt; != '0000';
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.LastInITBlock"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/LastInITBlock</h3>
      <p class="pseudocode">// LastInITBlock()
// ===============

boolean <a id="impl-aarch32.LastInITBlock.0"/>LastInITBlock()
    return (PSTATE.IT&lt;3:0&gt; == '1000');</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.SPSRWriteByInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/SPSRWriteByInstr</h3>
      <p class="pseudocode">// SPSRWriteByInstr()
// ==================

<a id="impl-aarch32.SPSRWriteByInstr.2"/>SPSRWriteByInstr(bits(32) value, bits(4) bytemask)

    bits(32) new_spsr = <a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(N) SPSR[]">SPSR</a>[];

    if bytemask&lt;3&gt; == '1' then
        new_spsr&lt;31:24&gt; = value&lt;31:24&gt;;  // N,Z,C,V,Q flags, IT[1:0],J bits

    if bytemask&lt;2&gt; == '1' then
        new_spsr&lt;23:16&gt; = value&lt;23:16&gt;;  // IL bit, GE[3:0] flags

    if bytemask&lt;1&gt; == '1' then
        new_spsr&lt;15:8&gt; = value&lt;15:8&gt;;    // IT[7:2] bits, E bit, A interrupt mask

    if bytemask&lt;0&gt; == '1' then
        new_spsr&lt;7:0&gt; = value&lt;7:0&gt;;      // I,F interrupt masks, T bit, Mode bits

    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = new_spsr;                   // UNPREDICTABLE if User or System mode

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.SPSRaccessValid"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/SPSRaccessValid</h3>
      <p class="pseudocode">// SPSRaccessValid()
// =================
// Checks for MRS (Banked register) or MSR (Banked register) accesses to the SPSRs
// that are UNPREDICTABLE

<a id="impl-aarch32.SPSRaccessValid.2"/>SPSRaccessValid(bits(5) SYSm, bits(5) mode)
    case SYSm of
        when '01110'                                                   // SPSR_fiq
            if mode == <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>   then UNPREDICTABLE;
        when '10000'                                                   // SPSR_irq
            if mode == <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>   then UNPREDICTABLE;
        when '10010'                                                   // SPSR_svc
            if mode == <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>   then UNPREDICTABLE;
        when '10100'                                                   // SPSR_abt
            if mode == <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a> then UNPREDICTABLE;
        when '10110'                                                   // SPSR_und
            if mode == <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a> then UNPREDICTABLE;
        when '11100'                                                   // SPSR_mon
            if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || mode == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> || !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then UNPREDICTABLE;
        when '11110'                                                   // SPSR_hyp
            if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || mode != <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then UNPREDICTABLE;
        otherwise
            UNPREDICTABLE;

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.system.SelectInstrSet"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/system/SelectInstrSet</h3>
      <p class="pseudocode">// SelectInstrSet()
// ================

<a id="impl-aarch32.SelectInstrSet.1"/>SelectInstrSet(<a href="shared_pseudocode.html#InstrSet" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet</a> iset)
    assert <a href="shared_pseudocode.html#impl-shared.CurrentInstrSet.0" title="function: InstrSet CurrentInstrSet()">CurrentInstrSet</a>() IN {<a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>, <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>};
    assert iset IN {<a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a>, <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>};

    PSTATE.T = if iset == <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> then '0' else '1';

    return;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.v6simd.Sat"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/v6simd/Sat</h3>
      <p class="pseudocode">// Sat()
// =====

bits(N) <a id="impl-aarch32.Sat.3"/>Sat(integer i, integer N, boolean unsigned)
    result = if unsigned then <a href="shared_pseudocode.html#impl-aarch32.UnsignedSat.2" title="function: bits(N) UnsignedSat(integer i, integer N)">UnsignedSat</a>(i, N) else <a href="shared_pseudocode.html#impl-aarch32.SignedSat.2" title="function: bits(N) SignedSat(integer i, integer N)">SignedSat</a>(i, N);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.v6simd.SignedSat"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/v6simd/SignedSat</h3>
      <p class="pseudocode">// SignedSat()
// ===========

bits(N) <a id="impl-aarch32.SignedSat.2"/>SignedSat(integer i, integer N)
    (result, -) = <a href="shared_pseudocode.html#impl-shared.SignedSatQ.2" title="function: (bits(N), boolean) SignedSatQ(integer i, integer N)">SignedSatQ</a>(i, N);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.functions.v6simd.UnsignedSat"/><h3 class="pseudocode">
            Library pseudocode for aarch32/functions/v6simd/UnsignedSat</h3>
      <p class="pseudocode">// UnsignedSat()
// =============

bits(N) <a id="impl-aarch32.UnsignedSat.2"/>UnsignedSat(integer i, integer N)
    (result, -) = <a href="shared_pseudocode.html#impl-shared.UnsignedSatQ.2" title="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)">UnsignedSatQ</a>(i, N);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.ic.AArch32.IC"/><h3 class="pseudocode">
            Library pseudocode for aarch32/ic/AArch32.IC</h3>
      <p class="pseudocode">// AArch32.IC()
// ============
// Perform Instruction Cache Operation.

<a id="AArch32.IC.1"/>AArch32.IC(<a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    regval = bits(32) UNKNOWN;
    <a href="shared_pseudocode.html#AArch32.IC.2" title="function: AArch32.IC(bits(32) regval, CacheOpScope opscope)">AArch32.IC</a>(regval, opscope);

// AArch32.IC()
// ============
// Perform Instruction Cache Operation.

<a id="AArch32.IC.2"/>AArch32.IC(bits(32) regval, <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    <a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;
    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>;

    cache.acctype = acctype;
    cache.cachetype = <a href="shared_pseudocode.html#CacheType_Instruction" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Instruction</a>;
    cache.cacheop = <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a>;
    cache.opscope = opscope;
    cache.security = SecurityStateAtEL(PSTATE.EL);

    if opscope IN {<a href="shared_pseudocode.html#CacheOpScope_ALLU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a>, <a href="shared_pseudocode.html#CacheOpScope_ALLUIS" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a>} then
        if opscope == <a href="shared_pseudocode.html#CacheOpScope_ALLUIS" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a> || (opscope == <a href="shared_pseudocode.html#CacheOpScope_ALLU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR.FB == '1') then
            cache.shareability = <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
        else
            cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.regval = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(regval);
        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    else
        assert opscope == <a href="shared_pseudocode.html#CacheOpScope_PoU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoU</a>;

        if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
                cache.is_vmid_valid = TRUE;
                cache.vmid          = VMID[];
            else
                cache.is_vmid_valid = FALSE;
        else
            cache.is_vmid_valid = FALSE;

        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            cache.is_asid_valid = TRUE;
            cache.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];
        else
            cache.is_asid_valid = FALSE;

        need_translate = <a href="shared_pseudocode.html#impl-shared.ICInstNeedsTranslation.1" title="function: boolean ICInstNeedsTranslation(CacheOpScope opscope)">ICInstNeedsTranslation</a>(opscope);

        cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(regval);
        cache.translated = need_translate;

        if !need_translate then
            cache.paddress = <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> UNKNOWN;
            <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
            return;

        wasaligned = TRUE;
        iswrite = FALSE;
        size = 0;
        memaddrdesc = <a href="shared_pseudocode.html#AArch32.TranslateAddress.5" title="function: AddressDescriptor AArch32.TranslateAddress(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned,&#13; integer size)">AArch32.TranslateAddress</a>(regval, acctype, iswrite, wasaligned, size);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(regval, memaddrdesc.fault);

        cache.paddress = memaddrdesc.paddress;
        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</p>
    </div>
    <div class="ps"><a id="aarch32.predictionrestrict.RestrictPrediction"/><h3 class="pseudocode">
            Library pseudocode for aarch32/predictionrestrict/RestrictPrediction</h3>
      <p class="pseudocode">// RestrictPrediction()
// ====================
// Clear all predictions in the context.

<a id="AArch32.RestrictPrediction.2"/>AArch32.RestrictPrediction(bits(32) val, <a href="shared_pseudocode.html#RestrictType" title="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch&#13; }">RestrictType</a> restriction)

    <a href="shared_pseudocode.html#ExecutionCntxt" title="type ExecutionCntxt is ( boolean is_vmid_valid, boolean all_vmid, bits(16) vmid, boolean is_asid_valid, boolean all_asid, bits(16) asid, bits(2) target_el, SecurityState security, RestrictType restriction )">ExecutionCntxt</a> c;
    target_el    = val&lt;25:24&gt;;

    // If the instruction is executed at an EL lower than the specified
    // level, it is treated as a NOP.
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then return;

    bit ns  = val&lt;26&gt;;
    bit nse = bit UNKNOWN;
    ss = <a href="shared_pseudocode.html#impl-shared.TargetSecurityState.2" title="function: SecurityState TargetSecurityState(bit NS, bit NSE)">TargetSecurityState</a>(ns, nse);

    c.security  = ss;
    c.target_el = target_el;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = FALSE;
            c.vmid          = VMID[];

        elsif target_el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = val&lt;27&gt; == '1';
            c.vmid          = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(val&lt;23:16&gt;, 16);           // Only valid if  val&lt;27&gt; == '0';
        else
            c.is_vmid_valid = FALSE;
    else
        c.is_vmid_valid = FALSE;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = FALSE;
        c.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];

    elsif target_el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = val&lt;8&gt; == '1';
        c.asid          = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(val&lt;7:0&gt;, 16);                  // Only valid if  val&lt;8&gt; == '0';

    else
        c.is_asid_valid = FALSE;

    c.restriction = restriction;
    <a href="shared_pseudocode.html#impl-shared.RESTRICT_PREDICTIONS.1" title="function: RESTRICT_PREDICTIONS(ExecutionCntxt c)">RESTRICT_PREDICTIONS</a>(c);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.attrs.AArch32.DefaultTEXDecode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/attrs/AArch32.DefaultTEXDecode</h3>
      <p class="pseudocode">// AArch32.DefaultTEXDecode()
// ==========================
// Apply short-descriptor format memory region attributes, without TEX remap

MemoryAttributes <a id="AArch32.DefaultTEXDecode.4"/>AArch32.DefaultTEXDecode(bits(3) TEX, bit C, bit B, bit S)
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;

    // Reserved values map to allocated values
    if (TEX == '001' &amp;&amp; C:B == '01') || (TEX == '010' &amp;&amp; C:B != '00') || TEX == '011' then
        bits(5) texcb;
        (-, texcb) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESTEXCB" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESTEXCB</a>);
        TEX = texcb&lt;4:2&gt;;  C = texcb&lt;1&gt;;  B = texcb&lt;0&gt;;

    // Distinction between Inner Shareable and Outer Shareable is not supported in this format
    // A memory region is either Non-shareable or Outer Shareable
    case TEX:C:B of
        when '00000'
            // Device-nGnRnE
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '00001', '01000'
            // Device-nGnRE
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '00010'
            // Write-through Read allocate
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.inner.hints  = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.outer.hints  = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.shareability = if S == '1' then <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        when '00011'
            // Write-back Read allocate
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.inner.hints  = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.outer.hints  = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.shareability = if S == '1' then <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        when '00100'
            // Non-cacheable
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '00110'
            memattrs = <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> IMPLEMENTATION_DEFINED;
        when '00111'
            // Write-back Read and Write allocate
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.inner.hints  = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.outer.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.outer.hints  = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.shareability = if S == '1' then <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        when '1xxxx'
            // Cacheable, TEX&lt;1:0&gt; = Outer attrs, {C,B} = Inner attrs
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner   = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(C:B);
            memattrs.outer   = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(TEX&lt;1:0&gt;);

            if memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
                memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
            else
                memattrs.shareability = if S == '1' then <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> else <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        otherwise
            // Reserved, handled above
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    // The Transient hint is not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;
    memattrs.tagged          = FALSE;

    if memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
        memattrs.xs = '0';
    else
        memattrs.xs = '1';

    return memattrs;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.attrs.AArch32.RemappedTEXDecode"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/attrs/AArch32.RemappedTEXDecode</h3>
      <p class="pseudocode">// AArch32.RemappedTEXDecode()
// ===========================
// Apply short-descriptor format memory region attributes, with TEX remap

MemoryAttributes <a id="AArch32.RemappedTEXDecode.5"/>AArch32.RemappedTEXDecode(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(3) TEX, bit C, bit B, bit S)

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;

    region = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(TEX&lt;0&gt;:C:B);         // TEX&lt;2:1&gt; are ignored in this mapping scheme
    if region == 6 then
        return <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> IMPLEMENTATION_DEFINED;

    if regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        prrr = PRRR_S;
        nmrr = NMRR_S;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        prrr = PRRR_NS;
        nmrr = NMRR_NS;
    else
        prrr = PRRR;
        nmrr = NMRR;

    base = 2 * region;
    attrfield = prrr&lt;base+1:base&gt;;

    if attrfield == '11' then      // Reserved, maps to allocated value
        (-, attrfield) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESPRRR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESPRRR</a>);

    case attrfield of
        when '00'                  // Device-nGnRnE
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '01'                  // Device-nGnRE
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
            memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '10'
            NSn  = if S == '0' then prrr.NS0 else prrr.NS1;
            NOSm = prrr&lt;region+24&gt; AND NSn;
            IRn  = nmrr&lt;base+1:base&gt;;
            ORn  = nmrr&lt;base+17:base+16&gt;;

            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner   = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(IRn);
            memattrs.outer   = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(ORn);
            if memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
                memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
            else
                bits(2) sh = NSn:NOSm;
                memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.DecodeShareability.1" title="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);
        when '11'
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    // The Transient hint is not supported in this format
    memattrs.inner.transient = FALSE;
    memattrs.outer.transient = FALSE;
    memattrs.tagged          = FALSE;

    if memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp; memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
        memattrs.xs = '0';
    else
        memattrs.xs = '1';

    return memattrs;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32.CheckBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32.CheckBreakpoint</h3>
      <p class="pseudocode">// AArch32.CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime, when either debug exceptions are enabled, or halting debug is enabled
// and halting is allowed.

FaultRecord <a id="AArch32.CheckBreakpoint.2"/>AArch32.CheckBreakpoint(bits(32) vaddress,  integer size)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert size IN {2,4};

    match = FALSE;
    mismatch = FALSE;

    for i = 0 to <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1
        (match_i, mismatch_i) = <a href="shared_pseudocode.html#AArch32.BreakpointMatch.3" title="function: (boolean,boolean) AArch32.BreakpointMatch(integer n, bits(32) vaddress,&#13; integer size)">AArch32.BreakpointMatch</a>(i, vaddress, size);
        match = match || match_i;
        mismatch = mismatch || mismatch_i;

    if match &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        reason = <a href="shared_pseudocode.html#DebugHalt_Breakpoint" title="constant bits(6) DebugHalt_Breakpoint = '000111'">DebugHalt_Breakpoint</a>;
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(reason);
    elsif (match || mismatch) then
        acctype = <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>;
        iswrite = FALSE;
        debugmoe = <a href="shared_pseudocode.html#DebugException_Breakpoint" title="constant bits(4) DebugException_Breakpoint = '0001'">DebugException_Breakpoint</a>;
        return <a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)">AArch32.DebugFault</a>(acctype, iswrite, debugmoe);
    else
        return <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32.CheckDebug"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32.CheckDebug</h3>
      <p class="pseudocode">// AArch32.CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.

FaultRecord <a id="AArch32.CheckDebug.4"/>AArch32.CheckDebug(bits(32) vaddress, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, integer size)

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();

    d_side = (acctype != <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>);
    generate_exception = <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()">AArch32.GenerateDebugExceptions</a>() &amp;&amp; DBGDSCRext.MDBGen == '1';
    halt = <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>();
    // Relative priority of Vector Catch and Breakpoint exceptions not defined in the architecture
    vector_catch_first = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPVECTORCATCHPRI" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPVECTORCATCHPRI</a>);

    if !d_side &amp;&amp; vector_catch_first &amp;&amp; generate_exception then
        fault = <a href="shared_pseudocode.html#AArch32.CheckVectorCatch.2" title="function: FaultRecord AArch32.CheckVectorCatch(bits(32) vaddress, integer size)">AArch32.CheckVectorCatch</a>(vaddress, size);

    if fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> &amp;&amp; (generate_exception || halt) then
        if d_side then
            fault = <a href="shared_pseudocode.html#AArch32.CheckWatchpoint.4" title="function: FaultRecord AArch32.CheckWatchpoint(bits(32) vaddress, AccType acctype,&#13; boolean iswrite, integer size)">AArch32.CheckWatchpoint</a>(vaddress, acctype, iswrite, size);
        else
            fault = <a href="shared_pseudocode.html#AArch32.CheckBreakpoint.2" title="function: FaultRecord AArch32.CheckBreakpoint(bits(32) vaddress,  integer size)">AArch32.CheckBreakpoint</a>(vaddress, size);

    if fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> &amp;&amp; !d_side &amp;&amp; !vector_catch_first &amp;&amp; generate_exception then
        return <a href="shared_pseudocode.html#AArch32.CheckVectorCatch.2" title="function: FaultRecord AArch32.CheckVectorCatch(bits(32) vaddress, integer size)">AArch32.CheckVectorCatch</a>(vaddress, size);

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32.CheckVectorCatch"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32.CheckVectorCatch</h3>
      <p class="pseudocode">// AArch32.CheckVectorCatch()
// ==========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch32
// translation regime, when debug exceptions are enabled.

FaultRecord <a id="AArch32.CheckVectorCatch.2"/>AArch32.CheckVectorCatch(bits(32) vaddress, integer size)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());

    match = <a href="shared_pseudocode.html#AArch32.VCRMatch.1" title="function: boolean AArch32.VCRMatch(bits(32) vaddress)">AArch32.VCRMatch</a>(vaddress);
    if size == 4 &amp;&amp; !match &amp;&amp; <a href="shared_pseudocode.html#AArch32.VCRMatch.1" title="function: boolean AArch32.VCRMatch(bits(32) vaddress)">AArch32.VCRMatch</a>(vaddress + 2) then
        match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_VCMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_VCMATCHHALF</a>);

    if match then
        acctype = <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>;
        iswrite = FALSE;
        debugmoe = <a href="shared_pseudocode.html#DebugException_VectorCatch" title="constant bits(4) DebugException_VectorCatch = '0101'">DebugException_VectorCatch</a>;
        return <a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)">AArch32.DebugFault</a>(acctype, iswrite, debugmoe);
    else
        return <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.translation.debug.AArch32.CheckWatchpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/debug/AArch32.CheckWatchpoint</h3>
      <p class="pseudocode">// AArch32.CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address",
// when either debug exceptions are enabled for the access, or halting debug
// is enabled and halting is allowed.

FaultRecord <a id="AArch32.CheckWatchpoint.4"/>AArch32.CheckWatchpoint(bits(32) vaddress, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                    boolean iswrite, integer size)
    assert <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());

    if acctype IN {<a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
        return <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
    if acctype == <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a> then
        if !iswrite then
            return <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
        elsif !(boolean IMPLEMENTATION_DEFINED "DCIMVAC generates watchpoint") then
            return <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();

    match = FALSE;
    ispriv = <a href="shared_pseudocode.html#AArch32.AccessUsesEL.1" title="function: bits(2) AArch32.AccessUsesEL(AccType acctype)">AArch32.AccessUsesEL</a>(acctype) != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;

    for i = 0 to <a href="shared_pseudocode.html#impl-shared.NumWatchpointsImplemented.0" title="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>() - 1
        if <a href="shared_pseudocode.html#AArch32.WatchpointMatch.6" title="function: boolean AArch32.WatchpointMatch(integer n, bits(32) vaddress, integer size, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch32.WatchpointMatch</a>(i, vaddress, size, ispriv, acctype, iswrite) then
            match = TRUE;

    if match &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        reason = <a href="shared_pseudocode.html#DebugHalt_Watchpoint" title="constant bits(6) DebugHalt_Watchpoint = '101011'">DebugHalt_Watchpoint</a>;
        EDWAR = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress);
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(reason);
    elsif match then
        debugmoe = <a href="shared_pseudocode.html#DebugException_Watchpoint" title="constant bits(4) DebugException_Watchpoint = '1010'">DebugException_Watchpoint</a>;
        return <a href="shared_pseudocode.html#AArch32.DebugFault.3" title="function: FaultRecord AArch32.DebugFault(AccType acctype, boolean iswrite, bits(4) debugmoe)">AArch32.DebugFault</a>(acctype, iswrite, debugmoe);
    else
        return <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.DebugFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.DebugFault</h3>
      <p class="pseudocode">// AArch32.DebugFault()
// ====================
// Return a fault record indicating a hardware watchpoint/breakpoint

FaultRecord <a id="AArch32.DebugFault.3"/>AArch32.DebugFault(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, bits(4) debugmoe)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;
    fault.acctype     = acctype;
    fault.write       = iswrite;
    fault.debugmoe    = debugmoe;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.IPAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.IPAIsOutOfRange</h3>
      <p class="pseudocode">// AArch32.IPAIsOutOfRange()
// =========================
// Check intermediate physical address bits not resolved by translation are ZERO

boolean <a id="AArch32.IPAIsOutOfRange.2"/>AArch32.IPAIsOutOfRange(<a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, bits(40) ipa)
    // Input Address size
    iasize = <a href="shared_pseudocode.html#AArch32.S2IASize.1" title="function: integer AArch32.S2IASize(bits(4) t0sz)">AArch32.S2IASize</a>(walkparams.t0sz);

    return iasize &lt; 40 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ipa&lt;39:iasize&gt;);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S1HasAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S1HasAlignmentFault</h3>
      <p class="pseudocode">// AArch32.S1HasAlignmentFault()
// =============================
// Returns whether stage 1 output fails alignment requirement on data accesses
// to Device memory

boolean <a id="AArch32.S1HasAlignmentFault.4"/>AArch32.S1HasAlignmentFault(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                    bit ntlsmd, <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> || memattrs.memtype != <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return FALSE;

    if acctype == <a href="shared_pseudocode.html#AccType_A32LSMD" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a> &amp;&amp; ntlsmd == '0' &amp;&amp; memattrs.device != <a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a> then
        return TRUE;

    return !aligned || acctype == <a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S1LDHasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S1LDHasPermissionsFault</h3>
      <p class="pseudocode">// AArch32.S1LDHasPermissionsFault()
// =================================
// Returns whether an access using stage 1 long-descriptor translation
// violates permissions of target memory

boolean <a id="AArch32.S1LDHasPermissionsFault.9"/>AArch32.S1LDHasPermissionsFault(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams,
                                        <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> perms, <a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a> memtype, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> paspace,
                                        boolean ispriv, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        // Apply leaf permissions
        case perms.ap&lt;2:1&gt; of
            when '00' (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '01' (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            when '10' (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '11' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL

        // Apply hierarchical permissions
        case perms.ap_table of
            when '00' (pr,pw,ur,uw) = ( pr, pw, ur, uw); // No effect
            when '01' (pr,pw,ur,uw) = ( pr, pw,'0','0'); // Privileged access
            when '10' (pr,pw,ur,uw) = ( pr,'0', ur,'0'); // Read-only
            when '11' (pr,pw,ur,uw) = ( pr,'0','0','0'); // Read-only, privileged access

        xn   = perms.xn OR perms.xn_table;
        pxn  = perms.pxn OR perms.pxn_table;

        ux = ur AND NOT(xn OR (uw AND walkparams.wxn));
        px = pr AND NOT(xn OR pxn OR (pw AND walkparams.wxn) OR (uw AND walkparams.uwxn));

        pan_access = !(acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>});
        if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; pan_access then
            pan = PSTATE.PAN AND (ur OR uw);
            pr  = pr AND NOT(pan);
            pw  = pw AND NOT(pan);

        (r,w,x) = if ispriv then (pr,pw,px) else (ur,uw,ux);

        // Prevent execution from Non-secure space by PE in Secure state if SIF is set
        if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
            x = x AND NOT(walkparams.sif);
    else
        // Apply leaf permissions
        case perms.ap&lt;2&gt; of
            when '0' (r,w) = ('1','1'); // No effect
            when '1' (r,w) = ('1','0'); // Read-only

        // Apply hierarchical permissions
        case perms.ap_table&lt;1&gt; of
            when '0' (r,w) = ( r , w ); // No effect
            when '1' (r,w) = ( r ,'0'); // Read-only

        xn = perms.xn OR perms.xn_table;
        x  = NOT(xn OR (w AND walkparams.wxn));

    if acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        constraint = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_INSTRDEVICE</a>);
        if constraint == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp; memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            return TRUE;
        else
            return x == '0';
    elsif acctype IN {<a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>} then
        return FALSE;
    elsif iswrite then
        return w == '0';
    else
        return r == '0';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S1SDHasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S1SDHasPermissionsFault</h3>
      <p class="pseudocode">// AArch32.S1SDHasPermissionsFault()
// =================================
// Returns whether an access using stage 1 short-descriptor translation
// violates permissions of target memory

boolean <a id="AArch32.S1SDHasPermissionsFault.8"/>AArch32.S1SDHasPermissionsFault(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> perms,
                                        <a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a> memtype, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> paspace, boolean ispriv,
                                        <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    if regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        sctlr = SCTLR_S;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        sctlr = SCTLR_NS;
    else
        sctlr = SCTLR;

    if sctlr.AFE == '0' then
        // Map Reserved encoding '100'
        if perms.ap == '100' then
            perms.ap = bits(3) IMPLEMENTATION_DEFINED "Reserved short descriptor AP encoding";

        case perms.ap of
            when '000' (pr,pw,ur,uw) = ('0','0','0','0'); // No access
            when '001' (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '010' (pr,pw,ur,uw) = ('1','1','1','0'); // R/W at PL1, RO at PL0
            when '011' (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            //   '100' is reserved
            when '101' (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '110' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL (deprecated)
            when '111' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL
    else // Simplified access permissions model
        case perms.ap&lt;2:1&gt; of
            when '00' (pr,pw,ur,uw) = ('1','1','0','0'); // R/W at PL1 only
            when '01' (pr,pw,ur,uw) = ('1','1','1','1'); // R/W at any PL
            when '10' (pr,pw,ur,uw) = ('1','0','0','0'); // RO at PL1 only
            when '11' (pr,pw,ur,uw) = ('1','0','1','0'); // RO at any PL

    ux = ur AND NOT(perms.xn OR (uw AND sctlr.WXN));
    px = pr AND NOT(perms.xn OR perms.pxn OR (pw AND sctlr.WXN) OR (uw AND sctlr.UWXN));

    pan_access = !(acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>});
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; pan_access then
        pan = PSTATE.PAN AND (ur OR uw);
        pr  = pr AND NOT(pan);
        pw  = pw AND NOT(pan);

    (r,w,x) = if ispriv then (pr,pw,px) else (ur,uw,ux);

    // Prevent execution from Non-secure space by PE in Secure state if SIF is set
    if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        x = x AND NOT(if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCR.SIF else SCR_EL3.SIF);

    if acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        constraint = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_INSTRDEVICE</a>);
        if constraint == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp; memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            return TRUE;
        else
            return x == '0';
    elsif acctype IN {<a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>} then
        return FALSE;
    elsif iswrite then
        return w == '0';
    else
        return r == '0';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S2HasAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S2HasAlignmentFault</h3>
      <p class="pseudocode">// AArch32.S2HasAlignmentFault()
// =============================
// Returns whether stage 2 output fails alignment requirement on data accesses
// to Device memory

boolean <a id="AArch32.S2HasAlignmentFault.3"/>AArch32.S2HasAlignmentFault(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> || memattrs.memtype != <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return FALSE;

    return !aligned || acctype == <a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S2HasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S2HasPermissionsFault</h3>
      <p class="pseudocode">// AArch32.S2HasPermissionsFault()
// ===============================
// Returns whether stage 2 access violates permissions of target memory

boolean <a id="AArch32.S2HasPermissionsFault.7"/>AArch32.S2HasPermissionsFault(boolean s2fs1walk, <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams,
                                      <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> perms, <a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a> memtype,
                                      boolean ispriv, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                      boolean iswrite)
    r = perms.s2ap&lt;0&gt;;
    w = perms.s2ap&lt;1&gt;;
    if <a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()">HaveExtendedExecuteNeverExt</a>() then
        case perms.s2xn:perms.s2xnx of
            when '00'  (px, ux) = ( r , r );
            when '01'  (px, ux) = ('0', r );
            when '10'  (px, ux) = ('0','0');
            when '11'  (px, ux) = ( r ,'0');

        x = if ispriv then px else ux;
    else
        x = r AND NOT(perms.s2xn);

    if s2fs1walk &amp;&amp; walkparams.ptw == '1' &amp;&amp; memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return TRUE;
    elsif acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        constraint = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_INSTRDEVICE</a>);
        if constraint == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp; memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            return TRUE;
        else
            return x == '0';
    elsif acctype IN {<a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>} then
        return FALSE;
    elsif iswrite then
        return w == '0';
    else
        return r == '0';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.S2InconsistentSL"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.S2InconsistentSL</h3>
      <p class="pseudocode">// AArch32.S2InconsistentSL()
// ==========================
// Detect inconsistent configuration of stage 2 T0SZ and SL fields

boolean <a id="AArch32.S2InconsistentSL.1"/>AArch32.S2InconsistentSL(<a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    startlevel  = <a href="shared_pseudocode.html#AArch32.S2StartLevel.1" title="function: integer AArch32.S2StartLevel(bits(2) sl0)">AArch32.S2StartLevel</a>(walkparams.sl0);
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;

    // Input address size must at least be large enough to be resolved from the start level
    sl_min_iasize = (
        levels * stride // Bits resolved by table walk, except initial level
        + granulebits   // Bits directly mapped to output address
        + 1);           // At least 1 more bit to be decoded by initial level

    // Can accomodate 1 more stride in the level + concatenation of up to 2^4 tables
    sl_max_iasize = sl_min_iasize + (stride-1) + 4;
    // Configured Input Address size
    iasize        = <a href="shared_pseudocode.html#AArch32.S2IASize.1" title="function: integer AArch32.S2IASize(bits(4) t0sz)">AArch32.S2IASize</a>(walkparams.t0sz);

    return iasize &lt; sl_min_iasize || iasize &gt; sl_max_iasize;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.faults.AArch32.VAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/faults/AArch32.VAIsOutOfRange</h3>
      <p class="pseudocode">// AArch32.VAIsOutOfRange()
// ========================
// Check virtual address bits not resolved by translation are identical
// and of accepted value

boolean <a id="AArch32.VAIsOutOfRange.3"/>AArch32.VAIsOutOfRange(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, bits(32) va)
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        // Input Address size
        iasize = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(walkparams.t0sz);
        return walkparams.t0sz != '000' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:iasize&gt;);
    elsif walkparams.t1sz != '000' &amp;&amp; walkparams.t0sz != '000' then
        // Lower range Input Address size
        lo_iasize = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(walkparams.t0sz);
        // Upper range Input Address size
        up_iasize = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(walkparams.t1sz);
        return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:lo_iasize&gt;) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;31:up_iasize&gt;);
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32.GetS1TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32.GetS1TLBContext</h3>
      <p class="pseudocode">// AArch32.GetS1TLBContext()
// =========================
// Gather translation context for accesses with VA to match against TLB entries

TLBContext <a id="AArch32.GetS1TLBContext.3"/>AArch32.GetS1TLBContext(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  tlbcontext = <a href="shared_pseudocode.html#AArch32.TLBContextEL2.1" title="function: TLBContext AArch32.TLBContextEL2(bits(32) va)">AArch32.TLBContextEL2</a>(va);
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> tlbcontext = <a href="shared_pseudocode.html#AArch32.TLBContextEL10.2" title="function: TLBContext AArch32.TLBContextEL10(SecurityState ss, bits(32) va)">AArch32.TLBContextEL10</a>(ss, va);
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> tlbcontext = <a href="shared_pseudocode.html#AArch32.TLBContextEL30.1" title="function: TLBContext AArch32.TLBContextEL30(bits(32) va)">AArch32.TLBContextEL30</a>(va);

    tlbcontext.includes_s1 = TRUE;
    // The following may be amended for EL1&amp;0 Regime if caching of stage 2 is successful
    tlbcontext.includes_s2 = FALSE;
    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32.GetS2TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32.GetS2TLBContext</h3>
      <p class="pseudocode">// AArch32.GetS2TLBContext()
// =========================
// Gather translation context for accesses with IPA to match against TLB entries

TLBContext <a id="AArch32.GetS2TLBContext.1"/>AArch32.GetS2TLBContext(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> ipa)
    assert ipa.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss          = <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    tlbcontext.regime      = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    tlbcontext.ipaspace    = ipa.paspace;
    tlbcontext.vmid        = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(VTTBR.VMID);
    tlbcontext.tg          = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.includes_s1 = FALSE;
    tlbcontext.includes_s2 = TRUE;
    tlbcontext.ia          = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ipa.address);
    tlbcontext.cnp         = if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then VTTBR.CnP else '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32.TLBContextEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32.TLBContextEL10</h3>
      <p class="pseudocode">// AArch32.TLBContextEL10()
// ========================
// Gather translation context for accesses under EL10 regime
// (PL10 when EL3 is A64) to match against TLB entries

TLBContext <a id="AArch32.TLBContextEL10.2"/>AArch32.TLBContextEL10(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        ttbcr      = TTBCR_NS;
        ttbr0      = TTBR0_NS;
        ttbr1      = TTBR1_NS;
        contextidr = CONTEXTIDR_NS;
    else
        ttbcr      = TTBCR;
        ttbr0      = TTBR0;
        ttbr1      = TTBR1;
        contextidr = CONTEXTIDR;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;

    if <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
        tlbcontext.vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(VTTBR.VMID);

    if ttbcr.EAE == '1' then
        tlbcontext.asid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(if ttbcr.A1 == '0' then ttbr0.ASID else ttbr1.ASID);
    else
        tlbcontext.asid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(contextidr.ASID);

    tlbcontext.tg = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.ia = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);

    if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() &amp;&amp; ttbcr.EAE == '1' then
        if <a href="shared_pseudocode.html#AArch32.GetVARange.3" title="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, ttbcr.T0SZ, ttbcr.T1SZ) == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = ttbr0.CnP;
        else
            tlbcontext.cnp = ttbr1.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32.TLBContextEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32.TLBContextEL2</h3>
      <p class="pseudocode">// AArch32.TLBContextEL2()
// =======================
// Gather translation context for accesses under EL2 regime to match against TLB entries

TLBContext <a id="AArch32.TLBContextEL2.1"/>AArch32.TLBContextEL2(bits(32) va)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
    tlbcontext.ia     = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);
    tlbcontext.tg     = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.cnp    = if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then HTTBR.CnP else '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.tlbcontext.AArch32.TLBContextEL30"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/tlbcontext/AArch32.TLBContextEL30</h3>
      <p class="pseudocode">// AArch32.TLBContextEL30()
// ========================
// Gather translation context for accesses under EL30 regime
// (PL10 in Secure state and EL3 is A32) to match against TLB entries

TLBContext <a id="AArch32.TLBContextEL30.1"/>AArch32.TLBContextEL30(bits(32) va)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>;

    if TTBCR_S.EAE == '1' then
        tlbcontext.asid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(if TTBCR_S.A1 == '0' then TTBR0_S.ASID else TTBR1_S.ASID);
    else
        tlbcontext.asid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(CONTEXTIDR_S.ASID);

    tlbcontext.tg = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    tlbcontext.ia = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);

    if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() &amp;&amp; TTBCR_S.EAE == '1' then
        if <a href="shared_pseudocode.html#AArch32.GetVARange.3" title="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, TTBCR_S.T0SZ, TTBCR_S.T1SZ) == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_S.CnP;
        else
            tlbcontext.cnp = TTBR1_S.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.AccessUsesEL"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.AccessUsesEL</h3>
      <p class="pseudocode">// AArch32.AccessUsesEL()
// ======================
// Determine the privilege associated with the access

bits(2) <a id="AArch32.AccessUsesEL.1"/>AArch32.AccessUsesEL(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    if acctype == <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a> then
        return <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    else
        return PSTATE.EL;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.EL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.EL2Enabled</h3>
      <p class="pseudocode">// AArch32.EL2Enabled()
// ====================
// Returns whether EL2 is enabled for the given Security State

boolean <a id="AArch32.EL2Enabled.1"/>AArch32.EL2Enabled(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        if !(<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>()) then
            return FALSE;
        elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            return SCR_EL3.EEL2 == '1';
        else
            return boolean IMPLEMENTATION_DEFINED "Secure-only implementation";
    else
        return <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.FullTranslate"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.FullTranslate</h3>
      <p class="pseudocode">// AArch32.FullTranslate()
// =======================
// Perform address translation as specified by VMSA-A32

AddressDescriptor <a id="AArch32.FullTranslate.4"/>AArch32.FullTranslate(bits(32) va, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                        boolean iswrite, boolean aligned)

    // Prepare fault fields in case a fault is detected
    fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
    fault.acctype = acctype;
    fault.write   = iswrite;

    regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.2" title="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</a>(PSTATE.EL, acctype);
    ispriv = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; acctype != <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a>;
    ss = <a href="shared_pseudocode.html#impl-shared.SecurityStateForRegime.1" title="function: SecurityState SecurityStateForRegime(Regime regime)">SecurityStateForRegime</a>(regime);

    // First Stage Translation
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> || TTBCR.EAE == '1' then
        (fault, ipa) = <a href="shared_pseudocode.html#AArch32.S1TranslateLD.8" title="function: (FaultRecord, AddressDescriptor) AArch32.S1TranslateLD(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateLD</a>(fault, regime, ss, va, acctype,
                                             aligned, iswrite, ispriv);
    else
        (fault, ipa, -) = <a href="shared_pseudocode.html#AArch32.S1TranslateSD.8" title="function: (FaultRecord, AddressDescriptor, SDFType) AArch32.S1TranslateSD(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateSD</a>(fault, regime, ss, va, acctype,
                                                aligned, iswrite, ispriv);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return <a href="shared_pseudocode.html#impl-shared.CreateFaultyAddressDescriptor.2" title="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), fault);

    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        ipa.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);
        s2fs1walk = FALSE;
        (fault, pa) = <a href="shared_pseudocode.html#AArch32.S2Translate.8" title="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</a>(fault, ipa, ss, s2fs1walk, acctype,
                                          aligned, iswrite, ispriv);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return <a href="shared_pseudocode.html#impl-shared.CreateFaultyAddressDescriptor.2" title="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), fault);
        else
            return pa;
    else
        return ipa;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.OutputDomain"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.OutputDomain</h3>
      <p class="pseudocode">// AArch32.OutputDomain()
// ======================
// Determine the domain the translated output address

bits(2) <a id="AArch32.OutputDomain.2"/>AArch32.OutputDomain(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(4) domain)
    index = 2 * <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(domain);
    if regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        Dn = DACR_S&lt;index+1:index&gt;;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        Dn = DACR_NS&lt;index+1:index&gt;;
    else
        Dn = DACR&lt;index+1:index&gt;;

    if Dn == '10' then
        // Reserved value maps to an allocated value
        (-, Dn) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESDACR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESDACR</a>);

    return Dn;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.S1DisabledOutput"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.S1DisabledOutput</h3>
      <p class="pseudocode">// AArch32.S1DisabledOutput()
// ==========================
// Flat map the VA to IPA/PA, depending on the regime, assigning default memory attributes

(FaultRecord, AddressDescriptor) <a id="AArch32.S1DisabledOutput.6"/>AArch32.S1DisabledOutput(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                          <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va,
                                                          <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned)

    // No memory page is guarded when stage 1 address translation is disabled
    SetInGuardedPage(FALSE);

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
        if <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then
            default_cacheable = HCR.DC;
        else
            default_cacheable = HCR_EL2.DC;
    else
        default_cacheable = '0';

    if default_cacheable == '1' then
        // Use default cacheable settings
        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.inner.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        memattrs.inner.hints  = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        memattrs.outer.attrs  = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        memattrs.outer.hints  = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        if !<a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
            memattrs.tagged = HCR_EL2.DCT == '1';
        else
            memattrs.tagged = FALSE;
    elsif acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        memattrs.tagged       = FALSE;
        if <a href="shared_pseudocode.html#AArch32.S1ICacheEnabled.1" title="function: boolean AArch32.S1ICacheEnabled(Regime regime)">AArch32.S1ICacheEnabled</a>(regime) then
            memattrs.inner.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.inner.hints = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.outer.hints = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
        else
            memattrs.inner.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.outer.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
    else
        // Treat memory region as Device
        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        memattrs.tagged       = FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        case regime of
            when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> ntlsmd = SCTLR_S.nTLSMD;
            when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  ntlsmd = HSCTLR.nTLSMD;
            when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> ntlsmd = if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.nTLSMD else SCTLR.nTLSMD;
    else
        ntlsmd = '1';

    if <a href="shared_pseudocode.html#AArch32.S1HasAlignmentFault.4" title="function: boolean AArch32.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch32.S1HasAlignmentFault</a>(acctype, aligned, ntlsmd, memattrs) then
        fault.statuscode  = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> oa;
    oa.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);
    oa.paspace = if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    ipa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), oa, memattrs);

    return (fault, ipa);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.S1Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.S1Enabled</h3>
      <p class="pseudocode">// AArch32.S1Enabled()
// ===================
// Returns whether stage 1 translation is enabled for the active translation regime

boolean <a id="AArch32.S1Enabled.2"/>AArch32.S1Enabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        return HSCTLR.M == '1';
    elsif regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        return SCTLR_S.M == '1';
    elsif !<a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
        return (if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.M else SCTLR.M) == '1';
    elsif <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then
        return HCR.&lt;TGE,DC&gt; == '00' &amp;&amp; (if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.M else SCTLR.M) == '1';
    else
        return HCR_EL2.&lt;TGE,DC&gt; == '00' &amp;&amp; SCTLR.M == '1';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.S1TranslateLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.S1TranslateLD</h3>
      <p class="pseudocode">// AArch32.S1TranslateLD()
// =======================
// Perform a stage 1 translation using long-descriptor format mapping VA to IPA/PA
// depending on the regime

(FaultRecord, AddressDescriptor) <a id="AArch32.S1TranslateLD.8"/>AArch32.S1TranslateLD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                       <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va,
                                                       <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                                       boolean iswrite, boolean ispriv)

    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    if !<a href="shared_pseudocode.html#AArch32.S1Enabled.2" title="function: boolean AArch32.S1Enabled(Regime regime, SecurityState ss)">AArch32.S1Enabled</a>(regime, ss) then
        return <a href="shared_pseudocode.html#AArch32.S1DisabledOutput.6" title="function: (FaultRecord, AddressDescriptor) AArch32.S1DisabledOutput(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned)">AArch32.S1DisabledOutput</a>(fault, regime, ss, va, acctype, aligned);

    walkparams = <a href="shared_pseudocode.html#AArch32.GetS1TTWParams.2" title="function: S1TTWParams AArch32.GetS1TTWParams(Regime regime, bits(32) va)">AArch32.GetS1TTWParams</a>(regime, va);

    if <a href="shared_pseudocode.html#AArch32.VAIsOutOfRange.3" title="function: boolean AArch32.VAIsOutOfRange(Regime regime, S1TTWParams walkparams, bits(32) va)">AArch32.VAIsOutOfRange</a>(regime, walkparams, va) then
        fault.level      = 1;
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    (fault, walkstate) = <a href="shared_pseudocode.html#AArch32.S1WalkLD.6" title="function: (FaultRecord, TTWState) AArch32.S1WalkLD(FaultRecord fault, Regime regime, SecurityState ss,&#13; S1TTWParams walkparams, bits(32) va, boolean ispriv)">AArch32.S1WalkLD</a>(fault, regime, ss, walkparams, va, ispriv);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    SetInGuardedPage(FALSE);  // AArch32-VMSA does not guard any pages

    if <a href="shared_pseudocode.html#AArch32.S1HasAlignmentFault.4" title="function: boolean AArch32.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch32.S1HasAlignmentFault</a>(acctype, aligned, walkparams.ntlsmd, walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.IsAtomicRW.1" title="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) then
        if <a href="shared_pseudocode.html#AArch32.S1LDHasPermissionsFault.9" title="function: boolean AArch32.S1LDHasPermissionsFault(Regime regime, SecurityState ss, S1TTWParams walkparams,&#13; Permissions perms, MemType memtype, PASpace paspace,&#13; boolean ispriv, AccType acctype, boolean iswrite)">AArch32.S1LDHasPermissionsFault</a>(regime, ss, walkparams,
                                           walkstate.permissions,
                                           walkstate.memattrs.memtype,
                                           walkstate.baseaddress.paspace,
                                           ispriv, acctype, FALSE) then
            // The permission fault was not caused by lack of write permissions
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.write      = FALSE;
        elsif <a href="shared_pseudocode.html#AArch32.S1LDHasPermissionsFault.9" title="function: boolean AArch32.S1LDHasPermissionsFault(Regime regime, SecurityState ss, S1TTWParams walkparams,&#13; Permissions perms, MemType memtype, PASpace paspace,&#13; boolean ispriv, AccType acctype, boolean iswrite)">AArch32.S1LDHasPermissionsFault</a>(regime, ss, walkparams,
                                              walkstate.permissions,
                                              walkstate.memattrs.memtype,
                                              walkstate.baseaddress.paspace,
                                              ispriv, acctype, TRUE) then
            // The permission fault _was_ caused by lack of write permissions
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.write      = TRUE;
    elsif <a href="shared_pseudocode.html#AArch32.S1LDHasPermissionsFault.9" title="function: boolean AArch32.S1LDHasPermissionsFault(Regime regime, SecurityState ss, S1TTWParams walkparams,&#13; Permissions perms, MemType memtype, PASpace paspace,&#13; boolean ispriv, AccType acctype, boolean iswrite)">AArch32.S1LDHasPermissionsFault</a>(regime, ss, walkparams,
                                          walkstate.permissions,
                                          walkstate.memattrs.memtype,
                                          walkstate.baseaddress.paspace,
                                          ispriv, acctype, iswrite) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    if ((acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || !<a href="shared_pseudocode.html#AArch32.S1ICacheEnabled.1" title="function: boolean AArch32.S1ICacheEnabled(Regime regime)">AArch32.S1ICacheEnabled</a>(regime))) ||
        (acctype != <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; !<a href="shared_pseudocode.html#AArch32.S1DCacheEnabled.1" title="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    else
        memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) &amp;&amp;
            (if <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);

    // Output Address
    oa = <a href="shared_pseudocode.html#impl-shared.StageOA.3" title="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), walkparams.tgx, walkstate);
    ipa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), oa, memattrs);

    return (fault, ipa);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.S1TranslateSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.S1TranslateSD</h3>
      <p class="pseudocode">// AArch32.S1TranslateSD()
// =======================
// Perform a stage 1 translation using short-descriptor format mapping VA to IPA/PA
// depending on the regime

(FaultRecord, AddressDescriptor, SDFType) <a id="AArch32.S1TranslateSD.8"/>AArch32.S1TranslateSD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                                <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(32) va,
                                                                <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                                                boolean iswrite, boolean ispriv)

    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    if !<a href="shared_pseudocode.html#AArch32.S1Enabled.2" title="function: boolean AArch32.S1Enabled(Regime regime, SecurityState ss)">AArch32.S1Enabled</a>(regime, ss) then
        (fault, ipa) = <a href="shared_pseudocode.html#AArch32.S1DisabledOutput.6" title="function: (FaultRecord, AddressDescriptor) AArch32.S1DisabledOutput(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned)">AArch32.S1DisabledOutput</a>(fault, regime, ss, va, acctype, aligned);
        return (fault, ipa, <a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> UNKNOWN);

    (fault, walkstate) = <a href="shared_pseudocode.html#AArch32.S1WalkSD.5" title="function: (FaultRecord, TTWState) AArch32.S1WalkSD(FaultRecord fault, Regime regime, SecurityState ss,&#13; bits(32) va, boolean ispriv)">AArch32.S1WalkSD</a>(fault, regime, ss, va, ispriv);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> UNKNOWN);

    domain = <a href="shared_pseudocode.html#AArch32.OutputDomain.2" title="function: bits(2) AArch32.OutputDomain(Regime regime, bits(4) domain)">AArch32.OutputDomain</a>(regime, walkstate.domain);
    SetInGuardedPage(FALSE);  // AArch32-VMSA does not guard any pages

    if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        case regime of
            when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> ntlsmd = SCTLR_S.nTLSMD;
            when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> ntlsmd = if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.nTLSMD else SCTLR.nTLSMD;
    else
        ntlsmd = '1';

    if <a href="shared_pseudocode.html#AArch32.S1HasAlignmentFault.4" title="function: boolean AArch32.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch32.S1HasAlignmentFault</a>(acctype, aligned, ntlsmd, walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    elsif !(acctype IN {<a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>}) &amp;&amp; domain == <a href="shared_pseudocode.html#Domain_NoAccess" title="constant bits(2) Domain_NoAccess = '00'">Domain_NoAccess</a> then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a>;
    elsif domain == <a href="shared_pseudocode.html#Domain_Client" title="constant bits(2) Domain_Client = '01'">Domain_Client</a> then
        if <a href="shared_pseudocode.html#impl-shared.IsAtomicRW.1" title="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) then
            if <a href="shared_pseudocode.html#AArch32.S1SDHasPermissionsFault.8" title="function: boolean AArch32.S1SDHasPermissionsFault(Regime regime, SecurityState ss, Permissions perms,&#13; MemType memtype, PASpace paspace, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch32.S1SDHasPermissionsFault</a>(regime, ss, walkstate.permissions,
                                               walkstate.memattrs.memtype,
                                               walkstate.baseaddress.paspace,
                                               ispriv, acctype, FALSE) then
                // The permission fault was not caused by lack of write permissions
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.write      = FALSE;
            elsif <a href="shared_pseudocode.html#AArch32.S1SDHasPermissionsFault.8" title="function: boolean AArch32.S1SDHasPermissionsFault(Regime regime, SecurityState ss, Permissions perms,&#13; MemType memtype, PASpace paspace, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch32.S1SDHasPermissionsFault</a>(regime, ss, walkstate.permissions,
                                                  walkstate.memattrs.memtype,
                                                  walkstate.baseaddress.paspace,
                                                  ispriv, acctype, TRUE) then
                // The permission fault _was_ caused by lack of write permissions
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.write      = TRUE;
        elsif <a href="shared_pseudocode.html#AArch32.S1SDHasPermissionsFault.8" title="function: boolean AArch32.S1SDHasPermissionsFault(Regime regime, SecurityState ss, Permissions perms,&#13; MemType memtype, PASpace paspace, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch32.S1SDHasPermissionsFault</a>(regime, ss, walkstate.permissions,
                                              walkstate.memattrs.memtype,
                                              walkstate.baseaddress.paspace,
                                              ispriv, acctype, iswrite) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        fault.domain = walkstate.domain;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, walkstate.sdftype);

    if ((acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || !<a href="shared_pseudocode.html#AArch32.S1ICacheEnabled.1" title="function: boolean AArch32.S1ICacheEnabled(Regime regime)">AArch32.S1ICacheEnabled</a>(regime))) ||
        (acctype != <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; !<a href="shared_pseudocode.html#AArch32.S1DCacheEnabled.1" title="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    else
        memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) &amp;&amp;
            (if <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);

    // Output Address
    oa = <a href="shared_pseudocode.html#AArch32.SDStageOA.3" title="function: FullAddress AArch32.SDStageOA(FullAddress baseaddress, bits(32) va, SDFType sdftype)">AArch32.SDStageOA</a>(walkstate.baseaddress, va, walkstate.sdftype);
    ipa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va), oa, memattrs);

    return (fault, ipa, walkstate.sdftype);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.S2Translate"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.S2Translate</h3>
      <p class="pseudocode">// AArch32.S2Translate()
// =====================
// Perform a stage 2 translation mapping an IPA to a PA

(FaultRecord, AddressDescriptor) <a id="AArch32.S2Translate.8"/>AArch32.S2Translate(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                                     <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, boolean s2fs1walk,
                                                     <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                                     boolean iswrite, boolean ispriv)

    assert <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ipa.paddress.address&lt;51:40&gt;);

    if !<a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then
        s1aarch64 = FALSE;
        return <a href="shared_pseudocode.html#AArch64.S2Translate.9" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</a>(fault, ipa, s1aarch64, ss, s2fs1walk, acctype,
                                   aligned, iswrite, ispriv);

    // Prepare fault fields in case a fault is detected
    fault.statuscode  = <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    fault.secondstage = TRUE;
    fault.s2fs1walk   = s2fs1walk;
    fault.ipaddress   = ipa.paddress;

    walkparams = <a href="shared_pseudocode.html#AArch32.GetS2TTWParams.0" title="function: S2TTWParams AArch32.GetS2TTWParams()">AArch32.GetS2TTWParams</a>();

    if walkparams.vm == '0' then
        // Stage 2 is disabled
        return (fault, ipa);

    if <a href="shared_pseudocode.html#AArch32.IPAIsOutOfRange.2" title="function: boolean AArch32.IPAIsOutOfRange(S2TTWParams walkparams, bits(40) ipa)">AArch32.IPAIsOutOfRange</a>(walkparams, ipa.paddress.address&lt;39:0&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 1;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    (fault, walkstate) = <a href="shared_pseudocode.html#AArch32.S2Walk.3" title="function: (FaultRecord, TTWState) AArch32.S2Walk(FaultRecord fault, S2TTWParams walkparams,&#13; AddressDescriptor ipa)">AArch32.S2Walk</a>(fault, walkparams, ipa);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    if <a href="shared_pseudocode.html#AArch32.S2HasAlignmentFault.3" title="function: boolean AArch32.S2HasAlignmentFault(AccType acctype, boolean aligned,&#13; MemoryAttributes memattrs)">AArch32.S2HasAlignmentFault</a>(acctype, aligned, walkstate.memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.IsAtomicRW.1" title="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) then
        assert !s2fs1walk; // AArch32 does not support HW update of TT
        if <a href="shared_pseudocode.html#AArch32.S2HasPermissionsFault.7" title="function: boolean AArch32.S2HasPermissionsFault(boolean s2fs1walk, S2TTWParams walkparams,&#13; Permissions perms, MemType memtype,&#13; boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch32.S2HasPermissionsFault</a>(s2fs1walk, walkparams,
                                         walkstate.permissions,
                                         walkstate.memattrs.memtype,
                                         ispriv, acctype, FALSE) then
            // The permission fault was not caused by lack of write permissions
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.write      = FALSE;
        elsif <a href="shared_pseudocode.html#AArch32.S2HasPermissionsFault.7" title="function: boolean AArch32.S2HasPermissionsFault(boolean s2fs1walk, S2TTWParams walkparams,&#13; Permissions perms, MemType memtype,&#13; boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch32.S2HasPermissionsFault</a>(s2fs1walk, walkparams,
                                            walkstate.permissions,
                                            walkstate.memattrs.memtype,
                                            ispriv, acctype, TRUE) then
            // The permission fault _was_ caused by lack of write permissions
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
            fault.write      = TRUE;
    elsif <a href="shared_pseudocode.html#AArch32.S2HasPermissionsFault.7" title="function: boolean AArch32.S2HasPermissionsFault(boolean s2fs1walk, S2TTWParams walkparams,&#13; Permissions perms, MemType memtype,&#13; boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch32.S2HasPermissionsFault</a>(s2fs1walk, walkparams,
                                        walkstate.permissions,
                                        walkstate.memattrs.memtype,
                                        ispriv, acctype, iswrite) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
    if ((s2fs1walk &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>) ||
        (acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || HCR2.ID == '1')) ||
        (acctype != <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; HCR2.CD == '1')) then
        // Treat memory attributes as Normal Non-Cacheable
        s2_memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        s2_memattrs.xs = walkstate.memattrs.xs;
    else
        s2_memattrs = walkstate.memattrs;

    memattrs = <a href="shared_pseudocode.html#impl-shared.S2CombineS1MemAttrs.2" title="function: MemoryAttributes S2CombineS1MemAttrs(MemoryAttributes s1_memattrs,&#13; MemoryAttributes s2_memattrs)">S2CombineS1MemAttrs</a>(ipa.memattrs, s2_memattrs);
    ipa_64 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address&lt;39:0&gt;, 64);
    // Output Address
    oa = <a href="shared_pseudocode.html#impl-shared.StageOA.3" title="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</a>(ipa_64, walkparams.tgx, walkstate);
    pa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(ipa.vaddress, oa, memattrs);

    return (fault, pa);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.SDStageOA"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.SDStageOA</h3>
      <p class="pseudocode">// AArch32.SDStageOA()
// ===================
// Given the final walk state of a short-descriptor translation walk,
// map the untranslated input address bits to the base output address

FullAddress <a id="AArch32.SDStageOA.3"/>AArch32.SDStageOA(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress, bits(32) va, <a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> sdftype)
    case sdftype of
        when <a href="shared_pseudocode.html#SDFType_SmallPage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>      tsize = 12;
        when <a href="shared_pseudocode.html#SDFType_LargePage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>      tsize = 16;
        when <a href="shared_pseudocode.html#SDFType_Section" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>        tsize = 20;
        when <a href="shared_pseudocode.html#SDFType_Supersection" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>   tsize = 24;

    // Output Address
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> oa;
    oa.address = baseaddress.address&lt;51:tsize&gt;:va&lt;tsize-1:0&gt;;
    oa.paspace = baseaddress.paspace;
    return oa;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.translation.AArch32.TranslateAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/translation/AArch32.TranslateAddress</h3>
      <p class="pseudocode">// AArch32.TranslateAddress()
// ==========================
// Main entry point for translating an address

AddressDescriptor <a id="AArch32.TranslateAddress.5"/>AArch32.TranslateAddress(bits(32) va, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                           boolean iswrite, boolean aligned,
                                           integer size)

    regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.2" title="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</a>(PSTATE.EL, acctype);
    if !<a href="shared_pseudocode.html#impl-shared.RegimeUsingAArch32.1" title="function: boolean RegimeUsingAArch32(Regime regime)">RegimeUsingAArch32</a>(regime) then
        return <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(va, 64), acctype, iswrite,
                                        aligned, size);
    result = <a href="shared_pseudocode.html#AArch32.FullTranslate.4" title="function: AddressDescriptor AArch32.FullTranslate(bits(32) va, AccType acctype,&#13; boolean iswrite, boolean aligned)">AArch32.FullTranslate</a>(va, acctype, iswrite, aligned);
    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(result) then
        result.fault = <a href="shared_pseudocode.html#AArch32.CheckDebug.4" title="function: FaultRecord AArch32.CheckDebug(bits(32) vaddress, AccType acctype, boolean iswrite, integer size)">AArch32.CheckDebug</a>(va, acctype, iswrite, size);

    // Update virtual address for abort functions
    result.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.DecodeDescriptorTypeLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.DecodeDescriptorTypeLD</h3>
      <p class="pseudocode">// AArch32.DecodeDescriptorTypeLD()
// ================================
// Determine whether the long-descriptor is a page, block or table

DescriptorType <a id="AArch32.DecodeDescriptorTypeLD.2"/>AArch32.DecodeDescriptorTypeLD(bits(64) descriptor, integer level)
    if descriptor&lt;1:0&gt; == '11' &amp;&amp; level == <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        return <a href="shared_pseudocode.html#DescriptorType_Page" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>;
    elsif descriptor&lt;1:0&gt; == '11' then
        return <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>;
    elsif descriptor&lt;1:0&gt; == '01' &amp;&amp; level != <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        return <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>;
    else
        return <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.DecodeDescriptorTypeSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.DecodeDescriptorTypeSD</h3>
      <p class="pseudocode">// AArch32.DecodeDescriptorTypeSD()
// ================================
// Determine the type of the short-descriptor

SDFType <a id="AArch32.DecodeDescriptorTypeSD.2"/>AArch32.DecodeDescriptorTypeSD(bits(32) descriptor, integer level)
    if level == 1 &amp;&amp; descriptor&lt;1:0&gt; == '01' then
        return <a href="shared_pseudocode.html#SDFType_Table" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Table</a>;
    elsif level == 1 &amp;&amp; descriptor&lt;18,1&gt; == '01' then
        return <a href="shared_pseudocode.html#SDFType_Section" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>;
    elsif level == 1 &amp;&amp; descriptor&lt;18,1&gt; == '11' then
        return <a href="shared_pseudocode.html#SDFType_Supersection" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>;
    elsif level == 2 &amp;&amp; descriptor&lt;1:0&gt; == '01' then
        return <a href="shared_pseudocode.html#SDFType_LargePage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>;
    elsif level == 2 &amp;&amp; descriptor&lt;1:0&gt; == '1x' then
        return <a href="shared_pseudocode.html#SDFType_SmallPage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>;
    else
        return <a href="shared_pseudocode.html#SDFType_Invalid" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Invalid</a>;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S1IASize"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S1IASize</h3>
      <p class="pseudocode">// AArch32.S1IASize()
// ==================
// Retrieve the number of bits containing the input address for stage 1 translation

integer <a id="AArch32.S1IASize.1"/>AArch32.S1IASize(bits(3) txsz)
    return 32 - <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(txsz);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S1WalkLD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S1WalkLD</h3>
      <p class="pseudocode">// AArch32.S1WalkLD()
// ==================
// Traverse stage 1 translation tables in long format to obtain the final descriptor

(FaultRecord, TTWState) <a id="AArch32.S1WalkLD.6"/>AArch32.S1WalkLD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                         <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, bits(32) va, boolean ispriv)
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        ttbr = HTTBR;
        txsz = walkparams.t0sz;
    else
        varange = <a href="shared_pseudocode.html#AArch32.GetVARange.3" title="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, walkparams.t0sz, walkparams.t1sz);
        if regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
            ttbcr = TTBCR_S;
            ttbr0 = TTBR0_S;
            ttbr1 = TTBR1_S;
        elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            ttbcr = TTBCR_NS;
            ttbr0 = TTBR0_NS;
            ttbr1 = TTBR1_NS;
        else
            ttbcr = TTBCR;
            ttbr0 = TTBR0;
            ttbr1 = TTBR1;

        assert ttbcr.EAE == '1';
        if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            txsz = walkparams.t0sz;
            ttbr = ttbr0;
            epd  = ttbcr.EPD0;
        else
            txsz = walkparams.t1sz;
            ttbr = ttbr1;
            epd  = ttbcr.EPD1;

    if regime != <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> &amp;&amp; epd == '1' then
        fault.level      = 1;
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Input Address size
    iasize      = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(txsz);
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;
    startlevel  = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - (((iasize-1) - granulebits) DIV stride);
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ttbr&lt;47:40&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress;
    baselsb = iasize - (levels*stride + granulebits) + 3;
    baseaddress.paspace = if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ttbr&lt;39:baselsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(baselsb));

    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    walkstate.baseaddress = baseaddress;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global
    walkstate.nG          = if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then '1' else '0';
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);
    walkstate.permissions.ap_table  = '00';
    walkstate.permissions.xn_table  = '0';
    walkstate.permissions.pxn_table = '0';

    indexmsb = iasize - 1;
    bits(64) descriptor;
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> walkaddress;
    repeat
        fault.level = walkstate.level;
        indexlsb = (<a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - walkstate.level)*stride + granulebits;
        bits(40) index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va&lt;indexmsb:indexlsb&gt;:'000');

        // VA is needed in the case of reporting an external abort
        walkaddress.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);
        walkaddress.paddress.address = walkstate.baseaddress.address OR <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(index);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        if !<a href="shared_pseudocode.html#AArch32.S1DCacheEnabled.1" title="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime) then
            walkaddress.memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
            walkaddress.memattrs.xs = walkstate.memattrs.xs;
        else
            walkaddress.memattrs = walkstate.memattrs;

        // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
        // to be either effective value or descriptor value
        if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) &amp;&amp;
            (if <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
                !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
            walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
        else
            walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

        // If there are two stages of translation, then the first stage table walk addresses
        // are themselves subject to translation
        if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
            s2fs1walk = TRUE;
            s2acctype = <a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>;
            s2aligned = TRUE;
            s2write   = FALSE;
            (s2fault, s2walkaddress) = <a href="shared_pseudocode.html#AArch32.S2Translate.8" title="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</a>(fault, walkaddress, ss, s2fs1walk,
                                                           s2acctype, s2aligned, s2write, ispriv);
            // Check for a fault on the stage 2 walk
            if s2fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                return (s2fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.3" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; FaultRecord fault)">FetchDescriptor</a>(walkparams.ee, s2walkaddress, fault);
        else
            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.3" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; FaultRecord fault)">FetchDescriptor</a>(walkparams.ee, walkaddress, fault);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

        desctype = <a href="shared_pseudocode.html#AArch32.DecodeDescriptorTypeLD.2" title="function: DescriptorType AArch32.DecodeDescriptorTypeLD(bits(64) descriptor, integer level)">AArch32.DecodeDescriptorTypeLD</a>(descriptor, walkstate.level);

        case desctype of
            when <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
                    fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                    return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;39:12&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12));
                if walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> &amp;&amp; descriptor&lt;63&gt; == '1' then
                    walkstate.baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

                if walkparams.hpd == '0' then
                    walkstate.permissions.xn_table  = (walkstate.permissions.xn_table  OR
                                                        descriptor&lt;60&gt;);
                    walkstate.permissions.ap_table  = (walkstate.permissions.ap_table  OR
                                                        descriptor&lt;62:61&gt;);
                    walkstate.permissions.pxn_table = (walkstate.permissions.pxn_table OR
                                                        descriptor&lt;59&gt;);

                walkstate.level = walkstate.level + 1;
                indexmsb = indexlsb - 1;

            when <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            when <a href="shared_pseudocode.html#DescriptorType_Page" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>
                walkstate.istable = FALSE;

    until desctype IN {<a href="shared_pseudocode.html#DescriptorType_Page" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>};

    // Check the output address is inside the supported range
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Check the access flag
    if descriptor&lt;10&gt; == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    walkstate.permissions.xn  = descriptor&lt;54&gt;;
    walkstate.permissions.pxn = descriptor&lt;53&gt;;
    walkstate.permissions.ap  = descriptor&lt;7:6&gt;:'1';
    walkstate.contiguous      = descriptor&lt;52&gt;;
    if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> then
        // All EL2 regime accesses are treated as Global
        walkstate.nG = '0';
    elsif ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        // When a PE is using the Long-descriptor translation table format,
        // and is in Secure state, a translation must be treated as non-global,
        // regardless of the value of the nG bit,
        // if NSTable is set to 1 at any level of the translation table walk.
        walkstate.nG = '1';
    else
        walkstate.nG = descriptor&lt;11&gt;;

    walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;39:indexlsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(indexlsb));
    if walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> &amp;&amp; descriptor&lt;5&gt; == '1' then
        walkstate.baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    memattr = descriptor&lt;4:2&gt;;
    sh      = descriptor&lt;9:8&gt;;
    attr    = <a href="shared_pseudocode.html#impl-shared.MAIRAttr.2" title="function: bits(8) MAIRAttr(integer index, MAIRType mair)">MAIRAttr</a>(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(memattr), walkparams.mair);
    s1aarch64 = FALSE;
    walkstate.memattrs = <a href="shared_pseudocode.html#impl-shared.S1DecodeMemAttrs.3" title="function: MemoryAttributes S1DecodeMemAttrs(bits(8) attr, bits(2) sh, boolean s1aarch64)">S1DecodeMemAttrs</a>(attr, sh, s1aarch64);

    return (fault, walkstate);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S1WalkSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S1WalkSD</h3>
      <p class="pseudocode">// AArch32.S1WalkSD()
// ==================
// Traverse stage 1 translation tables in short format to obtain the final descriptor

(FaultRecord, TTWState) <a id="AArch32.S1WalkSD.5"/>AArch32.S1WalkSD(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                         bits(32) va, boolean ispriv)
    // Determine correct translation control registers to use.
    if regime == <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> then
        sctlr = SCTLR_S;
        ttbcr = TTBCR_S;
        ttbr0 = TTBR0_S;
        ttbr1 = TTBR1_S;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        sctlr = SCTLR_NS;
        ttbcr = TTBCR_NS;
        ttbr0 = TTBR0_NS;
        ttbr1 = TTBR1_NS;
    else
        sctlr = SCTLR;
        ttbcr = TTBCR;
        ttbr0 = TTBR0;
        ttbr1 = TTBR1;

    assert ttbcr.EAE == '0';
    ee  = sctlr.EE;
    afe = sctlr.AFE;
    tre = sctlr.TRE;
    n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ttbcr.N);
    if n == 0 || <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:(32-n)&gt;) then
        ttb  = ttbr0.TTB0:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(7);
        pd   = ttbcr.PD0;
        irgn = ttbr0.IRGN;
        rgn  = ttbr0.RGN;
        s    = ttbr0.S;
        nos  = ttbr0.NOS;
    else
        n    = 0;  // TTBR1 translation always treats N as 0
        ttb  = ttbr1.TTB1:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(7);
        pd   = ttbcr.PD1;
        irgn = ttbr1.IRGN;
        rgn  = ttbr1.RGN;
        s    = ttbr1.S;
        nos  = ttbr1.NOS;

    // Check if Translation table walk disabled for translations with this Base register.
    if pd == '1' then
        fault.level      = 1;
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress;
    baseaddress.paspace = if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ttb&lt;31:14-n&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(14-n));

    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    walkstate.baseaddress = baseaddress;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global. Translations in Short-Descriptor Format
    // always support global &amp; non-global translations.
    walkstate.nG          = '1';
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(s:nos, irgn, rgn);
    walkstate.level       = 1;
    walkstate.istable     = TRUE;

    bits(4) domain;
    bits(32) descriptor;
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> walkaddress;
    repeat
        fault.level = walkstate.level;

        bits(32) index;
        if walkstate.level == 1 then
            index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va&lt;31-n:20&gt;:'00');
        else
            index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va&lt;19:12&gt;:'00');

        walkaddress.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);
        walkaddress.paddress.address = walkstate.baseaddress.address OR <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(index);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;

        if !<a href="shared_pseudocode.html#AArch32.S1DCacheEnabled.1" title="function: boolean AArch32.S1DCacheEnabled(Regime regime)">AArch32.S1DCacheEnabled</a>(regime) then
            walkaddress.memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
            walkaddress.memattrs.xs = walkstate.memattrs.xs;
        else
            walkaddress.memattrs = walkstate.memattrs;

        // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
        // to be either effective value or descriptor value
        if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) &amp;&amp;
            (if <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>) then HCR.VM else HCR_EL2.VM) == '1' &amp;&amp;
                !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
            walkaddress.memattrs.shareability = walkstate.memattrs.shareability;
        else
            walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

        if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#AArch32.EL2Enabled.1" title="function: boolean AArch32.EL2Enabled(SecurityState ss)">AArch32.EL2Enabled</a>(ss) then
            s2fs1walk = TRUE;
            s2acctype = <a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>;
            s2aligned = TRUE;
            s2write   = FALSE;
            (s2fault, s2walkaddress) = <a href="shared_pseudocode.html#AArch32.S2Translate.8" title="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</a>(fault, walkaddress, ss, s2fs1walk,
                                                           s2acctype, s2aligned, s2write, ispriv);

            if s2fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                return (s2fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.3" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; FaultRecord fault)">FetchDescriptor</a>(ee, s2walkaddress, fault);
        else
            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.3" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; FaultRecord fault)">FetchDescriptor</a>(ee, walkaddress, fault);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

        walkstate.sdftype = <a href="shared_pseudocode.html#AArch32.DecodeDescriptorTypeSD.2" title="function: SDFType AArch32.DecodeDescriptorTypeSD(bits(32) descriptor, integer level)">AArch32.DecodeDescriptorTypeSD</a>(descriptor, walkstate.level);

        case walkstate.sdftype of
            when <a href="shared_pseudocode.html#SDFType_Invalid" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Invalid</a>
                fault.domain     = domain;
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            when <a href="shared_pseudocode.html#SDFType_Table" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Table</a>
                domain = descriptor&lt;8:5&gt;;
                ns     = descriptor&lt;3&gt;;
                pxn    = descriptor&lt;2&gt;;

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;31:10&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(10));
                walkstate.level = 2;

            when <a href="shared_pseudocode.html#SDFType_SmallPage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>
                nG  = descriptor&lt;11&gt;;
                s   = descriptor&lt;10&gt;;
                ap  = descriptor&lt;9,5:4&gt;;
                tex = descriptor&lt;8:6&gt;;
                c   = descriptor&lt;3&gt;;
                b   = descriptor&lt;2&gt;;
                xn  = descriptor&lt;0&gt;;

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;31:12&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12));
                walkstate.istable = FALSE;

            when <a href="shared_pseudocode.html#SDFType_LargePage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>
                xn  = descriptor&lt;15&gt;;
                tex = descriptor&lt;14:12&gt;;
                nG  = descriptor&lt;11&gt;;
                s   = descriptor&lt;10&gt;;
                ap  = descriptor&lt;9,5:4&gt;;
                c   = descriptor&lt;3&gt;;
                b   = descriptor&lt;2&gt;;

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;31:16&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16));
                walkstate.istable = FALSE;

            when <a href="shared_pseudocode.html#SDFType_Section" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>
                ns     = descriptor&lt;19&gt;;
                nG     = descriptor&lt;17&gt;;
                s      = descriptor&lt;16&gt;;
                ap     = descriptor&lt;15,11:10&gt;;
                tex    = descriptor&lt;14:12&gt;;
                domain = descriptor&lt;8:5&gt;;
                xn     = descriptor&lt;4&gt;;
                c      = descriptor&lt;3&gt;;
                b      = descriptor&lt;2&gt;;
                pxn    = descriptor&lt;0&gt;;

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;31:20&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(20));
                walkstate.istable = FALSE;

            when <a href="shared_pseudocode.html#SDFType_Supersection" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>
                ns     = descriptor&lt;19&gt;;
                nG     = descriptor&lt;17&gt;;
                s      = descriptor&lt;16&gt;;
                ap     = descriptor&lt;15,11:10&gt;;
                tex    = descriptor&lt;14:12&gt;;
                xn     = descriptor&lt;4&gt;;
                c      = descriptor&lt;3&gt;;
                b      = descriptor&lt;2&gt;;
                pxn    = descriptor&lt;0&gt;;
                domain = '0000';

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;8:5,23:20,31:24&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24));
                walkstate.istable = FALSE;

    until walkstate.sdftype != <a href="shared_pseudocode.html#SDFType_Table" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Table</a>;

    if afe == '1' &amp;&amp; ap&lt;0&gt; == '0' then
        fault.domain     = domain;
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Decode the TEX, C, B and S bits to produce target memory attributes
    if tre == '1' then
        walkstate.memattrs = <a href="shared_pseudocode.html#AArch32.RemappedTEXDecode.5" title="function: MemoryAttributes AArch32.RemappedTEXDecode(Regime regime, bits(3) TEX, bit C, bit B, bit S)">AArch32.RemappedTEXDecode</a>(regime, tex, c, b, s);
    elsif <a href="shared_pseudocode.html#impl-aarch32.RemapRegsHaveResetValues.0" title="function: boolean RemapRegsHaveResetValues()">RemapRegsHaveResetValues</a>() then
        walkstate.memattrs = <a href="shared_pseudocode.html#AArch32.DefaultTEXDecode.4" title="function: MemoryAttributes AArch32.DefaultTEXDecode(bits(3) TEX, bit C, bit B, bit S)">AArch32.DefaultTEXDecode</a>(tex, c, b, s);
    else
        walkstate.memattrs = <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> IMPLEMENTATION_DEFINED;

    walkstate.permissions.ap  = ap;
    walkstate.permissions.xn  = xn;
    walkstate.permissions.pxn = pxn;
    walkstate.domain = domain;
    walkstate.nG     = nG;

    if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; ns == '0' then
        walkstate.baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
    else
        walkstate.baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    return (fault, walkstate);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S2IASize"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S2IASize</h3>
      <p class="pseudocode">// AArch32.S2IASize()
// ==================
// Retrieve the number of bits containing the input address for stage 2 translation

integer <a id="AArch32.S2IASize.1"/>AArch32.S2IASize(bits(4) t0sz)
    return 32 - <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(t0sz);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S2StartLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S2StartLevel</h3>
      <p class="pseudocode">// AArch32.S2StartLevel()
// ======================
// Determine the initial lookup level when performing a stage 2 translation
// table walk

integer <a id="AArch32.S2StartLevel.1"/>AArch32.S2StartLevel(bits(2) sl0)
    return 2 - <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(sl0);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.S2Walk"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.S2Walk</h3>
      <p class="pseudocode">// AArch32.S2Walk()
// ================
// Traverse stage 2 translation tables in long format to obtain the final descriptor

(FaultRecord, TTWState) <a id="AArch32.S2Walk.3"/>AArch32.S2Walk(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams,
                                       <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa)

    if walkparams.sl0 == '1x' || <a href="shared_pseudocode.html#AArch32.S2InconsistentSL.1" title="function: boolean AArch32.S2InconsistentSL(S2TTWParams walkparams)">AArch32.S2InconsistentSL</a>(walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 1;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Input Address size
    iasize      = <a href="shared_pseudocode.html#AArch32.S2IASize.1" title="function: integer AArch32.S2IASize(bits(4) t0sz)">AArch32.S2IASize</a>(walkparams.t0sz);
    startlevel  = <a href="shared_pseudocode.html#AArch32.S2StartLevel.1" title="function: integer AArch32.S2StartLevel(bits(2) sl0)">AArch32.S2StartLevel</a>(walkparams.sl0);
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(VTTBR&lt;47:40&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress;
    baselsb = iasize - (levels*stride + granulebits) + 3;
    baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(VTTBR&lt;39:baselsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(baselsb));

    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate;
    walkstate.baseaddress = baseaddress;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn,
                                         walkparams.orgn);

    indexmsb = iasize - 1;
    bits(64) descriptor;
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> walkaddress;
    repeat
        fault.level = walkstate.level;

        indexlsb = (<a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - walkstate.level)*stride + granulebits;
        bits(40) index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ipa.paddress.address&lt;indexmsb:indexlsb&gt;:'000');

        // Update virtual address for abort functions
        walkaddress.vaddress = ipa.vaddress;
        walkaddress.paddress.address = walkstate.baseaddress.address OR <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(index);
        walkaddress.paddress.paspace = walkstate.baseaddress.paspace;
        if HCR2.CD == '1' then
            walkaddress.memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
            walkaddress.memattrs.xs = walkstate.memattrs.xs;
        else
            walkaddress.memattrs = walkstate.memattrs;

        walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);

        (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.3" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; FaultRecord fault)">FetchDescriptor</a>(walkparams.ee, walkaddress, fault);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

        desctype   = <a href="shared_pseudocode.html#AArch32.DecodeDescriptorTypeLD.2" title="function: DescriptorType AArch32.DecodeDescriptorTypeLD(bits(64) descriptor, integer level)">AArch32.DecodeDescriptorTypeLD</a>(descriptor, walkstate.level);

        case desctype of
            when <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
                    fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                    return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

                walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;39:12&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12));
                walkstate.level = walkstate.level + 1;
                indexmsb = indexlsb - 1;

            when <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

            when <a href="shared_pseudocode.html#DescriptorType_Page" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>
                walkstate.istable = FALSE;

    until desctype IN {<a href="shared_pseudocode.html#DescriptorType_Page" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>};

    // Check the output address is inside the supported range
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(descriptor&lt;47:40&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Check the access flag
    if descriptor&lt;10&gt; == '0' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;
        return (fault, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN);

    // Unpack the descriptor into address and upper and lower block attributes
    walkstate.baseaddress.address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(descriptor&lt;39:indexlsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(indexlsb));

    walkstate.permissions.s2ap = descriptor&lt;7:6&gt;;
    walkstate.permissions.s2xn = descriptor&lt;54&gt;;
    if <a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()">HaveExtendedExecuteNeverExt</a>() then
        walkstate.permissions.s2xnx = descriptor&lt;53&gt;;
    else
        walkstate.permissions.s2xnx = '0';

    memattr = descriptor&lt;5:2&gt;;
    sh      = descriptor&lt;9:8&gt;;
    walkstate.memattrs   = <a href="shared_pseudocode.html#impl-shared.S2DecodeMemAttrs.2" title="function: MemoryAttributes S2DecodeMemAttrs(bits(4) attr, bits(2) sh)">S2DecodeMemAttrs</a>(memattr, sh);
    walkstate.contiguous = descriptor&lt;52&gt;;

    return (fault, walkstate);</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.AArch32.TranslationSizeSD"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/AArch32.TranslationSizeSD</h3>
      <p class="pseudocode">// AArch32.TranslationSizeSD()
// ===========================
// Determine the size of the translation

integer <a id="AArch32.TranslationSizeSD.1"/>AArch32.TranslationSizeSD(<a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a> sdftype)
    case sdftype of
        when <a href="shared_pseudocode.html#SDFType_SmallPage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_SmallPage</a>      tsize = 12;
        when <a href="shared_pseudocode.html#SDFType_LargePage" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_LargePage</a>      tsize = 16;
        when <a href="shared_pseudocode.html#SDFType_Section" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Section</a>        tsize = 20;
        when <a href="shared_pseudocode.html#SDFType_Supersection" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType_Supersection</a>   tsize = 24;

    return tsize;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walk.RemapRegsHaveResetValues"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walk/RemapRegsHaveResetValues</h3>
      <p class="pseudocode">boolean <a id="impl-aarch32.RemapRegsHaveResetValues.0"/>RemapRegsHaveResetValues();</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.GetS1TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.GetS1TTWParams</h3>
      <p class="pseudocode">// AArch32.GetS1TTWParams()
// ========================
// Returns stage 1 translation table walk parameters from respective controlling
// system registers.

S1TTWParams <a id="AArch32.GetS1TTWParams.2"/>AArch32.GetS1TTWParams(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(32) va)
    <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  walkparams = <a href="shared_pseudocode.html#AArch32.S1TTWParamsEL2.0" title="function: S1TTWParams AArch32.S1TTWParamsEL2()">AArch32.S1TTWParamsEL2</a>();
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> walkparams = <a href="shared_pseudocode.html#AArch32.S1TTWParamsEL10.1" title="function: S1TTWParams AArch32.S1TTWParamsEL10(bits(32) va)">AArch32.S1TTWParamsEL10</a>(va);
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> walkparams = <a href="shared_pseudocode.html#AArch32.S1TTWParamsEL30.1" title="function: S1TTWParams AArch32.S1TTWParamsEL30(bits(32) va)">AArch32.S1TTWParamsEL30</a>(va);

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.GetS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.GetS2TTWParams</h3>
      <p class="pseudocode">// AArch32.GetS2TTWParams()
// ========================
// Gather walk parameters for stage 2 translation

S2TTWParams <a id="AArch32.GetS2TTWParams.0"/>AArch32.GetS2TTWParams()
    <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams;

    walkparams.tgx  = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    walkparams.s    = VTCR.S;
    walkparams.t0sz = VTCR.T0SZ;
    walkparams.sl0  = VTCR.SL0;
    walkparams.irgn = VTCR.IRGN0;
    walkparams.orgn = VTCR.ORGN0;
    walkparams.sh   = VTCR.SH0;
    walkparams.ee   = HSCTLR.EE;
    walkparams.ptw  = HCR.PTW;
    walkparams.vm   = HCR.VM OR HCR.DC;

    // VTCR.S must match VTCR.T0SZ[3]
    if walkparams.s != walkparams.t0sz&lt;3&gt; then
        (-, walkparams.t0sz) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESVTCRS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESVTCRS</a>);

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.GetVARange"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.GetVARange</h3>
      <p class="pseudocode">// AArch32.GetVARange()
// ====================
// Select the translation base address for stage 1 long-descriptor walks

VARange <a id="AArch32.GetVARange.3"/>AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)
    // Lower range Input Address size
    lo_iasize = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(t0sz);
    // Upper range Input Address size
    up_iasize = <a href="shared_pseudocode.html#AArch32.S1IASize.1" title="function: integer AArch32.S1IASize(bits(3) txsz)">AArch32.S1IASize</a>(t1sz);

    if t1sz == '000' &amp;&amp; t0sz == '000' then
        return <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    elsif t1sz == '000' then
        return if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:lo_iasize&gt;) then <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> else <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a>;
    elsif t0sz == '000' then
        return if <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;31:up_iasize&gt;) then <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a> else <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;31:lo_iasize&gt;) then
        return <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;31:up_iasize&gt;) then
        return <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a>;
    else
        // Will be reported as a Translation Fault
        return <a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> UNKNOWN;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.S1DCacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.S1DCacheEnabled</h3>
      <p class="pseudocode">// AArch32.S1DCacheEnabled()
// =========================
// Determine cacheability of stage 1 data accesses

boolean <a id="AArch32.S1DCacheEnabled.1"/>AArch32.S1DCacheEnabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> return SCTLR_S.C == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return HSCTLR.C == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return (if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.C else SCTLR.C) == '1';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.S1ICacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.S1ICacheEnabled</h3>
      <p class="pseudocode">// AArch32.S1ICacheEnabled()
// =========================
// Determine cacheability of stage 1 instruction fetches

boolean <a id="AArch32.S1ICacheEnabled.1"/>AArch32.S1ICacheEnabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> return SCTLR_S.I == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return HSCTLR.I == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return (if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SCTLR_NS.I else SCTLR.I) == '1';</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.S1TTWParamsEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.S1TTWParamsEL10</h3>
      <p class="pseudocode">// AArch32.S1TTWParamsEL10()
// =========================
// Gather stage 1 translation table walk parameters for EL1&amp;0 regime
// (with EL2 enabled or disabled).

S1TTWParams <a id="AArch32.S1TTWParamsEL10.1"/>AArch32.S1TTWParamsEL10(bits(32) va)
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        ttbcr  = TTBCR_NS;
        ttbcr2 = TTBCR2_NS;
        sctlr  = SCTLR_NS;
        mair   = MAIR1_NS:MAIR0_NS;
        sif    = SCR.SIF;
    else
        ttbcr  = TTBCR;
        ttbcr2 = TTBCR2;
        sctlr  = SCTLR;
        mair   = MAIR1:MAIR0;
        sif    = SCR_EL3.SIF;

    assert ttbcr.EAE == '1';
    <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    walkparams.t0sz   = ttbcr.T0SZ;
    walkparams.t1sz   = ttbcr.T1SZ;
    walkparams.ee     = sctlr.EE;
    walkparams.wxn    = sctlr.WXN;
    walkparams.uwxn   = sctlr.UWXN;
    walkparams.ntlsmd = if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then sctlr.nTLSMD else '1';
    walkparams.mair   = mair;
    walkparams.sif    = sif;

    varange = <a href="shared_pseudocode.html#AArch32.GetVARange.3" title="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, walkparams.t0sz, walkparams.t1sz);
    if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.sh   = ttbcr.SH0;
        walkparams.irgn = ttbcr.IRGN0;
        walkparams.orgn = ttbcr.ORGN0;
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then ttbcr.T2E AND ttbcr2.HPD0 else '0';
    else
        walkparams.sh   = ttbcr.SH1;
        walkparams.irgn = ttbcr.IRGN1;
        walkparams.orgn = ttbcr.ORGN1;
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then ttbcr.T2E AND ttbcr2.HPD1 else '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.S1TTWParamsEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.S1TTWParamsEL2</h3>
      <p class="pseudocode">// AArch32.S1TTWParamsEL2()
// ========================
// Gather stage 1 translation table walk parameters for EL2 regime

S1TTWParams <a id="AArch32.S1TTWParamsEL2.0"/>AArch32.S1TTWParamsEL2()
    <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    walkparams.tgx  = <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
    walkparams.t0sz = HTCR.T0SZ;
    walkparams.irgn = HTCR.SH0;
    walkparams.orgn = HTCR.IRGN0;
    walkparams.sh   = HTCR.ORGN0;
    walkparams.hpd  = if <a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then HTCR.HPD else '0';
    walkparams.ee   = HSCTLR.EE;
    walkparams.wxn  = HSCTLR.WXN;
    if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        walkparams.ntlsmd = HSCTLR.nTLSMD;
    else
        walkparams.ntlsmd = '1';

    walkparams.mair = HMAIR1:HMAIR0;

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch32.translation.walkparams.AArch32.S1TTWParamsEL30"/><h3 class="pseudocode">
            Library pseudocode for aarch32/translation/walkparams/AArch32.S1TTWParamsEL30</h3>
      <p class="pseudocode">// AArch32.S1TTWParamsEL30()
// =========================
// Gather stage 1 translation table walk parameters for EL3&amp;0 regime

S1TTWParams <a id="AArch32.S1TTWParamsEL30.1"/>AArch32.S1TTWParamsEL30(bits(32) va)
    assert TTBCR_S.EAE == '1';
    <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    walkparams.t0sz   = TTBCR_S.T0SZ;
    walkparams.t1sz   = TTBCR_S.T1SZ;
    walkparams.ee     = SCTLR_S.EE;
    walkparams.wxn    = SCTLR_S.WXN;
    walkparams.uwxn   = SCTLR_S.UWXN;
    walkparams.ntlsmd = if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then SCTLR_S.nTLSMD else '1';
    walkparams.mair   = MAIR1_S:MAIR0_S;
    walkparams.sif    = SCR.SIF;

    varange = <a href="shared_pseudocode.html#AArch32.GetVARange.3" title="function: VARange AArch32.GetVARange(bits(32) va, bits(3) t0sz, bits(3) t1sz)">AArch32.GetVARange</a>(va, walkparams.t0sz, walkparams.t1sz);
    if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.sh   = TTBCR_S.SH0;
        walkparams.irgn = TTBCR_S.IRGN0;
        walkparams.orgn = TTBCR_S.ORGN0;
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then TTBCR_S.T2E AND TTBCR2_S.HPD0 else '0';
    else
        walkparams.sh   = TTBCR_S.SH1;
        walkparams.irgn = TTBCR_S.IRGN1;
        walkparams.orgn = TTBCR_S.ORGN1;
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch32.HaveHPDExt.0" title="function: boolean AArch32.HaveHPDExt()">AArch32.HaveHPDExt</a>() then TTBCR_S.T2E AND TTBCR2_S.HPD1 else '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBCycleCountingEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBCycleCountingEnabled</h3>
      <p class="pseudocode">// BRBCycleCountingEnabled()
// =========================
// Returns TRUE if the BRBINF&lt;n&gt;_EL1.{CCU, CC} fields are valid, FALSE otherwise.

boolean <a id="impl-aarch64.BRBCycleCountingEnabled.0"/>BRBCycleCountingEnabled()
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; BRBCR_EL2.CC == '0' then return FALSE;
    if BRBCR_EL1.CC == '0' then return FALSE;
    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEBranch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEBranch</h3>
      <p class="pseudocode">// BRBEBranch()
// ============
// Called to write branch record for the following branches when BRB is active:
// direct branches,
// indirect branches,
// direct branches with link,
// indirect branches with link,
// returns from subroutines.

<a id="impl-aarch64.BRBEBranch.3"/>BRBEBranch(<a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> br_type, boolean cond, bits(64) target_address)
    if <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL) &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.FilterBranchRecord.2" title="function: boolean FilterBranchRecord(BranchType br, boolean cond)">FilterBranchRecord</a>(br_type, cond) then
        bits(6) branch_type;
        case br_type of
            when <a href="shared_pseudocode.html#BranchType_DIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</a>
                branch_type = if cond then '001000' else '000000';
            when <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>      branch_type = '000001';
            when <a href="shared_pseudocode.html#BranchType_DIRCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIRCALL</a>    branch_type = '000010';
            when <a href="shared_pseudocode.html#BranchType_INDCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDCALL</a>    branch_type = '000011';
            when <a href="shared_pseudocode.html#BranchType_RET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RET</a>        branch_type = '000101';
            otherwise                  <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

        bit ccu;
        bits(14) cc;
        (ccu, cc) = <a href="shared_pseudocode.html#impl-aarch64.BranchEncCycleCount.0" title="function: (bit, bits(14)) BranchEncCycleCount()">BranchEncCycleCount</a>();
        bit lastfailed = if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then BRBFCR_EL1.LASTFAILED else '0';
        bit transactional = if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then '1' else '0';
        bits(2) el = PSTATE.EL;
        bit mispredict = if <a href="shared_pseudocode.html#impl-aarch64.BRBEMispredictAllowed.0" title="function: boolean BRBEMispredictAllowed()">BRBEMispredictAllowed</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.BranchMispredict.0" title="function: boolean BranchMispredict()">BranchMispredict</a>() then '1' else '0';

        <a href="shared_pseudocode.html#impl-aarch64.UpdateBranchRecordBuffer.10" title="function: UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,&#13; bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)">UpdateBranchRecordBuffer</a>(ccu, cc, lastfailed, transactional, branch_type, el, mispredict,
                                 '11', <a href="shared_pseudocode.html#impl-aarch64.PC.read.0" title="accessor: bits(64) PC[]">PC</a>[], target_address);

        BRBFCR_EL1.LASTFAILED = '0';

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEBranchOnISB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEBranchOnISB</h3>
      <p class="pseudocode">// BRBEBranchOnISB()
// =================
// Returns TRUE if ISBs generate Branch records, and FALSE otherwise.

boolean <a id="impl-aarch64.BRBEBranchOnISB.0"/>BRBEBranchOnISB()
    return boolean IMPLEMENTATION_DEFINED "ISB generates Branch records";</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEDebugStateExit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEDebugStateExit</h3>
      <p class="pseudocode">// BRBEDebugStateExit()
// ====================
// Called to write Debug state exit branch record when BRB is active.

<a id="impl-aarch64.BRBEDebugStateExit.1"/>BRBEDebugStateExit(bits(64) target_address)
    if <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL) then
        // Debug state is a prohibited region, therefore ccu=1, cc=0, source_address=0
        bits(6) branch_type = '111001';
        bit ccu = '1';
        bits(14) cc = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(14);
        bit lastfailed = if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then BRBFCR_EL1.LASTFAILED else '0';
        bit transactional = '0';
        bits(2) el = PSTATE.EL;
        bit mispredict = '0';

        <a href="shared_pseudocode.html#impl-aarch64.UpdateBranchRecordBuffer.10" title="function: UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,&#13; bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)">UpdateBranchRecordBuffer</a>(ccu, cc, lastfailed, transactional, branch_type, el, mispredict,
                                 '01', <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64), target_address);

        BRBFCR_EL1.LASTFAILED = '0';

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEException</h3>
      <p class="pseudocode">// BRBEException()
// ===============
// Called to write exception branch record when BRB is active.

<a id="impl-aarch64.BRBEException.4"/>BRBEException(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exception, bits(64) preferred_exception_return,
              bits(64) target_address, bits(2) target_el)
    case target_el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  if !<a href="shared_pseudocode.html#impl-shared.HaveBRBEv1p1.0" title="function: boolean HaveBRBEv1p1()">HaveBRBEv1p1</a>() || (MDCR_EL3.E3BREC == MDCR_EL3.E3BREW) then return;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  if BRBCR_EL2.EXCEPTION == '0' then return;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  if BRBCR_EL1.EXCEPTION == '0' then return;

    boolean source_valid = <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL);
    boolean target_valid = <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(target_el);

    if source_valid || target_valid then
        bits(6) branch_type;
        case exception of
            when <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>        branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>              branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>           branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>          branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>           branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>           branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>  branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>             branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>              branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_TSTARTAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_TSTARTAccessTrap</a>     branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>          branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>         branch_type = '101011'; // Inst Fault
            when <a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>         branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>       branch_type = '100010'; // Call
            when <a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>       branch_type = '100010'; // Call
            when <a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>          branch_type = '100010'; // Call
            when <a href="shared_pseudocode.html#Exception_SystemRegisterTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SystemRegisterTrap</a>   branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SVEAccessTrap</a>        branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_SMEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SMEAccessTrap</a>        branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_ERetTrap</a>             branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_PACFail" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACFail</a>              branch_type = '101100'; // Data Fault
            when <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>     branch_type = '101011'; // Inst Fault
            when <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>          branch_type = '101010'; // Alignment
            when <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>            branch_type = '101100'; // Data Fault
            when <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>         branch_type = '101100'; // Data Fault
            when <a href="shared_pseudocode.html#Exception_SPAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SPAlignment</a>          branch_type = '101010'; // Alignment
            when <a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>   branch_type = '100011'; // Trap
            when <a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>               branch_type = '100100'; // System Error
            when <a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>           branch_type = '100110'; // Inst debug
            when <a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>         branch_type = '100110'; // Inst debug
            when <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>           branch_type = '100111'; // Data debug
            when <a href="shared_pseudocode.html#Exception_NV2Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>        branch_type = '100111'; // Data debug
            when <a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>   branch_type = '100110'; // Inst debug
            when <a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>                  branch_type = '101110'; // IRQ
            when <a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>                  branch_type = '101111'; // FIQ
            otherwise                           <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

        bit ccu;
        bits(14) cc;
        (ccu, cc) = <a href="shared_pseudocode.html#impl-aarch64.BranchEncCycleCount.0" title="function: (bit, bits(14)) BranchEncCycleCount()">BranchEncCycleCount</a>();
        bit lastfailed = if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then BRBFCR_EL1.LASTFAILED else '0';
        bit transactional = if source_valid &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then '1' else '0';
        bits(2) el = if target_valid then target_el else '00';
        bit mispredict = '0';
        bit sv = if source_valid then '1' else '0';
        bit tv = if target_valid then '1' else '0';
        bits(64) source_address = if source_valid then preferred_exception_return else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        if !target_valid then target_address = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

        <a href="shared_pseudocode.html#impl-aarch64.UpdateBranchRecordBuffer.10" title="function: UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,&#13; bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)">UpdateBranchRecordBuffer</a>(ccu, cc, lastfailed, transactional, branch_type, el, mispredict,
                                 sv:tv, source_address, target_address);

        BRBFCR_EL1.LASTFAILED = '0';

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEExceptionReturn</h3>
      <p class="pseudocode">// BRBEExceptionReturn()
// =====================
// Called to write exception return branch record when BRB is active.

<a id="impl-aarch64.BRBEExceptionReturn.2"/>BRBEExceptionReturn(bits(64) target_address, bits(2) source_el)
    case source_el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  if !<a href="shared_pseudocode.html#impl-shared.HaveBRBEv1p1.0" title="function: boolean HaveBRBEv1p1()">HaveBRBEv1p1</a>() || (MDCR_EL3.E3BREC == MDCR_EL3.E3BREW) then return;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  if BRBCR_EL2.ERTN == '0' then return;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  if BRBCR_EL1.ERTN == '0' then return;

    boolean source_valid = <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(source_el);
    boolean target_valid = <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL);

    if source_valid || target_valid then
        bits(6) branch_type = '000111';
        bit ccu;
        bits(14) cc;
        (ccu, cc) = <a href="shared_pseudocode.html#impl-aarch64.BranchEncCycleCount.0" title="function: (bit, bits(14)) BranchEncCycleCount()">BranchEncCycleCount</a>();
        bit lastfailed = if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then BRBFCR_EL1.LASTFAILED else '0';
        bit transactional = if source_valid &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then '1' else '0';
        bits(2) el = if target_valid then PSTATE.EL else '00';
        bit mispredict = if source_valid &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.BRBEMispredictAllowed.0" title="function: boolean BRBEMispredictAllowed()">BRBEMispredictAllowed</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.BranchMispredict.0" title="function: boolean BranchMispredict()">BranchMispredict</a>() then '1' else '0';
        bit sv = if source_valid then '1' else '0';
        bit tv = if target_valid then '1' else '0';
        bits(64) source_address = if source_valid then <a href="shared_pseudocode.html#impl-aarch64.PC.read.0" title="accessor: bits(64) PC[]">PC</a>[] else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        if !target_valid then target_address = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

        <a href="shared_pseudocode.html#impl-aarch64.UpdateBranchRecordBuffer.10" title="function: UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,&#13; bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)">UpdateBranchRecordBuffer</a>(ccu, cc, lastfailed, transactional, branch_type, el, mispredict,
                                 sv:tv, source_address, target_address);

        BRBFCR_EL1.LASTFAILED = '0';

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBEMispredictAllowed"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBEMispredictAllowed</h3>
      <p class="pseudocode">// BRBEMispredictAllowed()
// =======================
// Returns TRUE if the recording of branch misprediction is allowed, FALSE otherwise.

boolean <a id="impl-aarch64.BRBEMispredictAllowed.0"/>BRBEMispredictAllowed()
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; BRBCR_EL2.MPRED == '0' then return FALSE;
    if BRBCR_EL1.MPRED == '0' then return FALSE;
    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRBETimeStamp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRBETimeStamp</h3>
      <p class="pseudocode">// BRBETimeStamp()
// ===============
// Returns captured timestamp.

TimeStamp <a id="impl-aarch64.BRBETimeStamp.0"/>BRBETimeStamp()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        TS_el2 = BRBCR_EL2.TS;
        if !<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; TS_el2 == '10' then
            // Reserved value
            (-, TS_el2) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_EL2TIMESTAMP" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_EL2TIMESTAMP</a>);
        case TS_el2 of
            when '00'
                // Falls out to check BRBCR_EL1.TS
            when '01'
                return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
            when '10'
                assert <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>(); // Otherwise ConstrainUnpredictableBits removes this case
                return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
            when '11'
                return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;

    TS_el1 = BRBCR_EL1.TS;
    if TS_el1 == '00' || (!<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; TS_el1 == '10') then
        // Reserved value
        (-, TS_el1) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_EL1TIMESTAMP" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_EL1TIMESTAMP</a>);
    case TS_el1 of
        when '01'
            return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
        when '10'
            return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
        when '11'
            return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();           // ConstrainUnpredictableBits removes this case</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRB_IALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRB_IALL</h3>
      <p class="pseudocode">// BRB_IALL()
// ==========
// Called to perform invalidation of branch records

<a id="impl-aarch64.BRB_IALL.0"/>BRB_IALL()
    for i = 0 to <a href="shared_pseudocode.html#impl-aarch64.GetBRBENumRecords.0" title="function: integer GetBRBENumRecords()">GetBRBENumRecords</a>() - 1
        Records_SRC[i] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        Records_TGT[i] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        Records_INF[i] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BRB_INJ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BRB_INJ</h3>
      <p class="pseudocode">// BRB_INJ()
// =========
// Called to perform manual injection of branch records.

<a id="impl-aarch64.BRB_INJ.0"/>BRB_INJ()
    <a href="shared_pseudocode.html#impl-aarch64.UpdateBranchRecordBuffer.10" title="function: UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,&#13; bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)">UpdateBranchRecordBuffer</a>(BRBINFINJ_EL1.CCU, BRBINFINJ_EL1.CC, BRBINFINJ_EL1.LASTFAILED,
                             BRBINFINJ_EL1.T, BRBINFINJ_EL1.TYPE, BRBINFINJ_EL1.EL,
                             BRBINFINJ_EL1.MPRED, BRBINFINJ_EL1.VALID, BRBSRCINJ_EL1.ADDRESS,
                             BRBTGTINJ_EL1.ADDRESS);
    BRBINFINJ_EL1 = bits(64) UNKNOWN;
    BRBSRCINJ_EL1 = bits(64) UNKNOWN;
    BRBTGTINJ_EL1 = bits(64) UNKNOWN;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.Branch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/Branch</h3>
      <p class="pseudocode">type <a id="BRBSRCType"/>BRBSRCType;
type <a id="BRBTGTType"/>BRBTGTType;
type <a id="BRBINFType"/>BRBINFType;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchEncCycleCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchEncCycleCount</h3>
      <p class="pseudocode">// The first return result is '1' if either of the following is true, and '0' otherwise:
// - This is the first Branch record after the PE exited a Prohibited Region.
// - This is the first Branch record after cycle counting has been enabled.
// If the first return return is '0', the second return result is the encoded cycle count
// since the last branch.
// The format of this field uses a mantissa and exponent to express the cycle count value.
//  - bits[7:0] indicate the mantissa M.
//  - bits[13:8] indicate the exponent E.
// The cycle count is expressed using the following function:
//   cycle_count = (if IsZero(E) then UInt(M) else UInt('1':M:Zeros(UInt(E)-1)))
// A value of all ones in both the mantissa and exponent indicates the cycle count value
// exceeded the size of the cycle counter.
// If the cycle count is not known, the second return result is zero.
(bit, bits(14)) <a id="impl-aarch64.BranchEncCycleCount.0"/>BranchEncCycleCount();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchMispredict"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchMispredict</h3>
      <p class="pseudocode">// Returns TRUE if the branch being executed was mispredicted, FALSE otherwise.
boolean <a id="impl-aarch64.BranchMispredict.0"/>BranchMispredict();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchRawCycleCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchRawCycleCount</h3>
      <p class="pseudocode">// If the cycle count is known, the return result is the cycle count since the last branch.
integer <a id="impl-aarch64.BranchRawCycleCount.0"/>BranchRawCycleCount();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.BranchRecordAllowed"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/BranchRecordAllowed</h3>
      <p class="pseudocode">// BranchRecordAllowed()
// =====================
// Returns TRUE if branch recording is allowed, FALSE otherwise.

boolean <a id="impl-aarch64.BranchRecordAllowed.1"/>BranchRecordAllowed(bits(2) el)
    if BRBFCR_EL1.PAUSED == '1' then
        return FALSE;

    if el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveBRBEv1p1.0" title="function: boolean HaveBRBEv1p1()">HaveBRBEv1p1</a>() then
        return (MDCR_EL3.E3BREC != MDCR_EL3.E3BREW);

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; (MDCR_EL3.SBRBE == '00' || (<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; MDCR_EL3.SBRBE == '01')) then
        return FALSE;

    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  return FALSE;                // FEAT_BRBEv1p1 not implemented
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  return BRBCR_EL2.E2BRE == '1';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  return BRBCR_EL1.E1BRE == '1';
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
                return BRBCR_EL2.E0HBRE == '1';
            else
                return BRBCR_EL1.E0BRE == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.Contents"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/Contents</h3>
      <p class="pseudocode">array [0..63] of <a href="shared_pseudocode.html#BRBSRCType" title="type BRBSRCType">BRBSRCType</a> Records_SRC;

array [0..63] of <a href="shared_pseudocode.html#BRBTGTType" title="type BRBTGTType">BRBTGTType</a> Records_TGT;

array [0..63] of <a href="shared_pseudocode.html#BRBINFType" title="type BRBINFType">BRBINFType</a> Records_INF;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.FilterBranchRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/FilterBranchRecord</h3>
      <p class="pseudocode">// FilterBranchRecord()
// ====================
// Returns TRUE if the branch record is not filtered out, FALSE otherwise.

boolean <a id="impl-aarch64.FilterBranchRecord.2"/>FilterBranchRecord(<a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> br, boolean cond)
    case br of
        when <a href="shared_pseudocode.html#BranchType_DIRCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIRCALL</a>
            return BRBFCR_EL1.DIRCALL != BRBFCR_EL1.EnI;
        when <a href="shared_pseudocode.html#BranchType_INDCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDCALL</a>
            return BRBFCR_EL1.INDCALL != BRBFCR_EL1.EnI;
        when <a href="shared_pseudocode.html#BranchType_RET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RET</a>
            return BRBFCR_EL1.RTN != BRBFCR_EL1.EnI;
        when <a href="shared_pseudocode.html#BranchType_DIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</a>
            if cond then
                return BRBFCR_EL1.CONDDIR != BRBFCR_EL1.EnI;
            else
                return BRBFCR_EL1.DIRECT != BRBFCR_EL1.EnI;
        when <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>
            return BRBFCR_EL1.INDIRECT != BRBFCR_EL1.EnI;
        otherwise  <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.FirstBranchAfterProhibited"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/FirstBranchAfterProhibited</h3>
      <p class="pseudocode">// Returns TRUE if branch recorded is the first branch after a prohibited region,
// FALSE otherwise.
<a id="impl-aarch64.FirstBranchAfterProhibited.0"/>FirstBranchAfterProhibited();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.GetBRBENumRecords"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/GetBRBENumRecords</h3>
      <p class="pseudocode">// GetBRBENumRecords()
// ===================
// Returns the number of branch records implemented.

integer <a id="impl-aarch64.GetBRBENumRecords.0"/>GetBRBENumRecords()
    assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(BRBIDR0_EL1.NUMREC) IN {0x08, 0x10, 0x20, 0x40};
    return integer IMPLEMENTATION_DEFINED "Number of BRB records";</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.Getter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/Getter</h3>
      <p class="pseudocode">// Getter functions for branch records
// ===================================
// Functions used by MRS instructions that access branch records

BRBSRCType <a id="impl-aarch64.BRBSRC_EL1.read.1"/>BRBSRC_EL1[integer n]
    assert n IN {0..31};
    integer record = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(BRBFCR_EL1.BANK:n&lt;4:0&gt;);
    if record &lt; <a href="shared_pseudocode.html#impl-aarch64.GetBRBENumRecords.0" title="function: integer GetBRBENumRecords()">GetBRBENumRecords</a>() then
        return Records_SRC[record];
    else
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

BRBTGTType <a id="impl-aarch64.BRBTGT_EL1.read.1"/>BRBTGT_EL1[integer n]
    assert n IN {0..31};
    integer record = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(BRBFCR_EL1.BANK:n&lt;4:0&gt;);
    if record &lt; <a href="shared_pseudocode.html#impl-aarch64.GetBRBENumRecords.0" title="function: integer GetBRBENumRecords()">GetBRBENumRecords</a>() then
        return Records_TGT[record];
    else
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

BRBINFType <a id="impl-aarch64.BRBINF_EL1.read.1"/>BRBINF_EL1[integer n]
    assert n IN {0..31};
    integer record = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(BRBFCR_EL1.BANK:n&lt;4:0&gt;);
    if record &lt; <a href="shared_pseudocode.html#impl-aarch64.GetBRBENumRecords.0" title="function: integer GetBRBENumRecords()">GetBRBENumRecords</a>() then
        return Records_INF[record];
    else
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.brbe.UpdateBranchRecordBuffer"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/brbe/UpdateBranchRecordBuffer</h3>
      <p class="pseudocode">// UpdateBranchRecordBuffer()
// ==========================
// Updates branch record buffer on valid records.

<a id="impl-aarch64.UpdateBranchRecordBuffer.10"/>UpdateBranchRecordBuffer(bit ccu, bits(14) cc, bit lastfailed, bit transactional, bits(6) branch_type, bits(2) el,
                         bit mispredict, bits(2) valid, bits(64) source_address, bits(64) target_address)
    // Shift the Branch Records in the buffer
    for i = <a href="shared_pseudocode.html#impl-aarch64.GetBRBENumRecords.0" title="function: integer GetBRBENumRecords()">GetBRBENumRecords</a>() - 1 downto 1
        Records_SRC[i] = Records_SRC[i - 1];
        Records_TGT[i] = Records_TGT[i - 1];
        Records_INF[i] = Records_INF[i - 1];

    Records_INF[0].CCU        = ccu;
    Records_INF[0].CC         = cc;

    Records_INF[0].EL         = el;
    Records_INF[0].VALID      = valid;
    Records_INF[0].T          = transactional;
    Records_INF[0].LASTFAILED = lastfailed;
    Records_INF[0].MPRED      = mispredict;
    Records_INF[0].TYPE       = branch_type;

    Records_SRC[0] = source_address;
    Records_TGT[0] = target_address;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.AArch64.BreakpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/AArch64.BreakpointMatch</h3>
      <p class="pseudocode">// AArch64.BreakpointMatch()
// =========================
// Breakpoint matching in an AArch64 translation regime.

boolean <a id="AArch64.BreakpointMatch.4"/>AArch64.BreakpointMatch(integer n, bits(64) vaddress,
                                              <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, integer size)
    assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>();

    enabled = DBGBCR_EL1[n].E == '1';
    ispriv = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    linked = DBGBCR_EL1[n].BT == '0x01';
    isbreakpnt = TRUE;
    linked_to = FALSE;

    state_match = <a href="shared_pseudocode.html#AArch64.StateMatch.8" title="function: boolean AArch64.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN,&#13; boolean isbreakpnt, AccType acctype, boolean ispriv)">AArch64.StateMatch</a>(DBGBCR_EL1[n].SSC, DBGBCR_EL1[n].HMC, DBGBCR_EL1[n].PMC,
                                     linked, DBGBCR_EL1[n].LBN, isbreakpnt, acctype, ispriv);
    value_match = <a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)">AArch64.BreakpointValueMatch</a>(n, vaddress, linked_to);

    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() &amp;&amp; size == 4 then                    // Check second halfword
        // If the breakpoint address and BAS of an Address breakpoint match the address of the
        // second halfword of an instruction, but not the address of the first halfword, it is
        // CONSTRAINED UNPREDICTABLE whether or not this breakpoint generates a Breakpoint debug
        // event.
        match_i = <a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)">AArch64.BreakpointValueMatch</a>(n, vaddress + 2, linked_to);
        if !value_match &amp;&amp; match_i then
            value_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPMATCHHALF</a>);
    if vaddress&lt;1&gt; == '1' &amp;&amp; DBGBCR_EL1[n].BAS == '1111' then
        // The above notwithstanding, if DBGBCR_EL1[n].BAS == '1111', then it is CONSTRAINED
        // UNPREDICTABLE whether or not a Breakpoint debug event is generated for an instruction
        // at the address DBGBVR_EL1[n]+2.
        if value_match then value_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPMATCHHALF</a>);

    match = value_match &amp;&amp; state_match &amp;&amp; enabled;

    return match;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.AArch64.BreakpointValueMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/AArch64.BreakpointValueMatch</h3>
      <p class="pseudocode">// AArch64.BreakpointValueMatch()
// ==============================

boolean <a id="AArch64.BreakpointValueMatch.3"/>AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)

    // "n" is the identity of the breakpoint unit to match against.
    // "vaddress" is the current instruction address, ignored if linked_to is TRUE and for Context
    //   matching breakpoints.
    // "linked_to" is TRUE if this is a call from StateMatch for linking.

    // If a non-existent breakpoint then it is CONSTRAINED UNPREDICTABLE whether this gives
    // no match or the breakpoint is mapped to another UNKNOWN implemented breakpoint.
    if n &gt;= <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() then
        (c, n) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(0, <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1, <a href="shared_pseudocode.html#Unpredictable_BPNOTIMPL" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPNOTIMPL</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;

    // If this breakpoint is not enabled, it cannot generate a match. (This could also happen on a
    // call from StateMatch for linking).
    if DBGBCR_EL1[n].E == '0' then return FALSE;

    context_aware = (n &gt;= (<a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - <a href="shared_pseudocode.html#impl-shared.NumContextAwareBreakpointsImplemented.0" title="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>()));

    // If BT is set to a reserved type, behaves either as disabled or as a not-reserved type.
    dbgtype = DBGBCR_EL1[n].BT;

    if ((dbgtype IN {'011x','11xx'} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveV82Debug.0" title="function: boolean HaveV82Debug()">HaveV82Debug</a>()) ||    // Context matching
          dbgtype == '010x' ||                                                      // Reserved
          (dbgtype != '0x0x' &amp;&amp; !context_aware) ||                                  // Context matching
          (dbgtype == '1xxx' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>))) then                                 // EL2 extension
        (c, dbgtype) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESBPTYPE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESBPTYPE</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    // Determine what to compare against.
    match_addr = (dbgtype == '0x0x');
    match_vmid = (dbgtype == '10xx');
    match_cid  = (dbgtype == '001x');
    match_cid1 = (dbgtype IN { '101x', 'x11x'});
    match_cid2 = (dbgtype == '11xx');
    linked     = (dbgtype == 'xxx1');

    // If this is a call from StateMatch, return FALSE if the breakpoint is not programmed for a
    // VMID and/or context ID match, of if not context-aware. The above assertions mean that the
    // code can just test for match_addr == TRUE to confirm all these things.
    if linked_to &amp;&amp; (!linked || match_addr) then return FALSE;

    // If called from BreakpointMatch return FALSE for Linked context ID and/or VMID matches.
    if !linked_to &amp;&amp; linked &amp;&amp; !match_addr then return FALSE;

    // Do the comparison.
    if match_addr then
        byte = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;1:0&gt;);
        if <a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() then
            // T32 instructions can be executed at EL0 in an AArch64 translation regime.
            assert byte IN {0,2};                 // "vaddress" is halfword aligned
            byte_select_match = (DBGBCR_EL1[n].BAS&lt;byte&gt; == '1');
        else
            assert byte == 0;                     // "vaddress" is word aligned
            byte_select_match = TRUE;             // DBGBCR_EL1[n].BAS&lt;byte&gt; is RES1
        // If the DBGxVR&lt;n&gt;_EL1.RESS field bits are not a sign extension of the MSB
        // of DBGBVR&lt;n&gt;_EL1.VA, it is UNPREDICTABLE whether they appear to be
        // included in the match.
        // If 'vaddress' is outside of the current virtual address space, then the access
        // generates a Translation fault.
        integer top = <a href="shared_pseudocode.html#AArch64.VAMax.0" title="function: integer AArch64.VAMax()">AArch64.VAMax</a>();
        if !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGBVR_EL1[n]&lt;63:top&gt;) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGBVR_EL1[n]&lt;63:top&gt;) then
            if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_DBGxVR_RESS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DBGxVR_RESS</a>) then
                top = 63;
        BVR_match = (vaddress&lt;top:2&gt; == DBGBVR_EL1[n]&lt;top:2&gt;) &amp;&amp; byte_select_match;

    elsif match_cid then
        if <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            BVR_match = (CONTEXTIDR_EL2&lt;31:0&gt; == DBGBVR_EL1[n]&lt;31:0&gt;);
        else
            BVR_match = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; CONTEXTIDR_EL1&lt;31:0&gt; == DBGBVR_EL1[n]&lt;31:0&gt;);
    elsif match_cid1 then
        BVR_match = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; CONTEXTIDR_EL1&lt;31:0&gt; == DBGBVR_EL1[n]&lt;31:0&gt;);
    if match_vmid then
        if !<a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()">Have16bitVMID</a>() || VTCR_EL2.VS == '0' then
            vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
            bvr_vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(DBGBVR_EL1[n]&lt;39:32&gt;, 16);
        else
            vmid = VTTBR_EL2.VMID;
            bvr_vmid = DBGBVR_EL1[n]&lt;47:32&gt;;
        BXVR_match = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp;
                      vmid == bvr_vmid);
    elsif match_cid2 then
        BXVR_match = (PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a href="shared_pseudocode.html#impl-shared.HaveV82Debug.0" title="function: boolean HaveV82Debug()">HaveV82Debug</a>()) &amp;&amp;
                      <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      DBGBVR_EL1[n]&lt;63:32&gt; == CONTEXTIDR_EL2&lt;31:0&gt;);

    bvr_match_valid = (match_addr || match_cid || match_cid1);
    bxvr_match_valid = (match_vmid || match_cid2);

    match = (!bxvr_match_valid || BXVR_match) &amp;&amp; (!bvr_match_valid || BVR_match);

    return match;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.breakpoint.AArch64.StateMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/breakpoint/AArch64.StateMatch</h3>
      <p class="pseudocode">// AArch64.StateMatch()
// ====================
// Determine whether a breakpoint or watchpoint is enabled in the current mode and state.

boolean <a id="AArch64.StateMatch.8"/>AArch64.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN,
                           boolean isbreakpnt, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean ispriv)
    // "SSC", "HMC", "PxC" are the control fields from the DBGBCR[n] or DBGWCR[n] register.
    // "linked" is TRUE if this is a linked breakpoint/watchpoint type.
    // "LBN" is the linked breakpoint number from the DBGBCR[n] or DBGWCR[n] register.
    // "isbreakpnt" is TRUE for breakpoints, FALSE for watchpoints.
    // "ispriv" is valid for watchpoints, and selects between privileged and unprivileged accesses.

    // If parameters are set to a reserved type, behaves as either disabled or a defined type
    (c, SSC, HMC, PxC) = <a href="shared_pseudocode.html#impl-shared.CheckValidStateMatch.4" title="function: (Constraint, bits(2), bit, bits(2)) CheckValidStateMatch(bits(2) SSC, bit HMC, bits(2) PxC,&#13; boolean isbreakpnt)">CheckValidStateMatch</a>(SSC, HMC, PxC, isbreakpnt);
    if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then return FALSE;
    // Otherwise the HMC,SSC,PxC values are either valid or the values returned by
    // CheckValidStateMatch are valid.

    EL3_match = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; HMC == '1' &amp;&amp; SSC&lt;0&gt; == '0';
    EL2_match = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; ((HMC == '1' &amp;&amp; (SSC:PxC != '1000')) || SSC == '11');
    EL1_match = PxC&lt;0&gt; == '1';
    EL0_match = PxC&lt;1&gt; == '1';

    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> &amp;&amp; !isbreakpnt then
        priv_match = EL2_match;
    elsif !ispriv &amp;&amp; !isbreakpnt then
        priv_match = EL0_match;
    else
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  priv_match = EL3_match;
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  priv_match = EL2_match;
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  priv_match = EL1_match;
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  priv_match = EL0_match;

    case SSC of
        when '00'  security_state_match = TRUE;                        // Both
        when '01'  security_state_match = !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();                 // Non-secure only
        when '10'  security_state_match = <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();                  // Secure only
        when '11'  security_state_match = (HMC == '1' || <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>());  // HMC=1 -&gt; Both, 0 -&gt; Secure only

    if linked then
        // "LBN" must be an enabled context-aware breakpoint unit. If it is not context-aware then
        // it is CONSTRAINED UNPREDICTABLE whether this gives no match, or LBN is mapped to some
        // UNKNOWN breakpoint that is context-aware.
        lbn = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(LBN);
        first_ctx_cmp = <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - <a href="shared_pseudocode.html#impl-shared.NumContextAwareBreakpointsImplemented.0" title="function: integer NumContextAwareBreakpointsImplemented()">NumContextAwareBreakpointsImplemented</a>();
        last_ctx_cmp = <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1;
        if (lbn &lt; first_ctx_cmp || lbn &gt; last_ctx_cmp) then
            (c, lbn) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(first_ctx_cmp, last_ctx_cmp, <a href="shared_pseudocode.html#Unpredictable_BPNOTCTXCMP" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPNOTCTXCMP</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
            case c of
                when <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;      // Disabled
                when <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      linked = FALSE;    // No linking
                // Otherwise ConstrainUnpredictableInteger returned a context-aware breakpoint

    if linked then
        vaddress = bits(64) UNKNOWN;
        linked_to = TRUE;
        linked_match = <a href="shared_pseudocode.html#AArch64.BreakpointValueMatch.3" title="function: boolean AArch64.BreakpointValueMatch(integer n, bits(64) vaddress, boolean linked_to)">AArch64.BreakpointValueMatch</a>(lbn, vaddress, linked_to);

    return priv_match &amp;&amp; security_state_match &amp;&amp; (!linked || linked_match);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.enables.AArch64.GenerateDebugExceptions"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/enables/AArch64.GenerateDebugExceptions</h3>
      <p class="pseudocode">// AArch64.GenerateDebugExceptions()
// =================================

boolean <a id="AArch64.GenerateDebugExceptions.0"/>AArch64.GenerateDebugExceptions()
    return <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(PSTATE.EL, <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>(), PSTATE.D);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.enables.AArch64.GenerateDebugExceptionsFrom"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/enables/AArch64.GenerateDebugExceptionsFrom</h3>
      <p class="pseudocode">// AArch64.GenerateDebugExceptionsFrom()
// =====================================

boolean <a id="AArch64.GenerateDebugExceptionsFrom.3"/>AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)

    if OSLSR_EL1.OSLK == '1' || <a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()">DoubleLockStatus</a>() || <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then
        return FALSE;

    route_to_el2 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!secure || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1');
    target = (if route_to_el2 then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; secure then
        enabled = MDCR_EL3.SDD == '0';
        if from == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
            enabled = enabled || SDER32_EL3.SUIDEN == '1';
    else
        enabled = TRUE;

    if from == target then
        enabled = enabled &amp;&amp; MDSCR_EL1.KDE == '1' &amp;&amp; mask == '0';
    else
        enabled = enabled &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(from);

    return enabled;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.CheckForPMUOverflow"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.CheckForPMUOverflow</h3>
      <p class="pseudocode">// AArch64.CheckForPMUOverflow()
// =============================
// Signal Performance Monitors overflow IRQ and CTI overflow events

<a id="AArch64.CheckForPMUOverflow.0"/>AArch64.CheckForPMUOverflow()
    pmuirq = PMCR_EL0.E == '1' &amp;&amp; PMINTENSET_EL1.C == '1' &amp;&amp; PMOVSSET_EL0.C == '1';
    for idx = 0 to <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() - 1
        E = if <a href="shared_pseudocode.html#AArch64.PMUCounterIsHyp.1" title="function: boolean AArch64.PMUCounterIsHyp(integer n)">AArch64.PMUCounterIsHyp</a>(idx) then MDCR_EL2.HPME else PMCR_EL0.E;
        if E == '1' &amp;&amp; PMINTENSET_EL1&lt;idx&gt; == '1' &amp;&amp; PMOVSSET_EL0&lt;idx&gt; == '1' then pmuirq = TRUE;

    SetInterruptRequestLevel(<a href="shared_pseudocode.html#InterruptID_PMUIRQ" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_PMUIRQ</a>, if pmuirq then HIGH else LOW);

    CTI_SetEventLevel(<a href="shared_pseudocode.html#CrossTriggerIn_PMUOverflow" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_PMUOverflow</a>, if pmuirq then HIGH else LOW);

    // The request remains set until the condition is cleared. (For example, an interrupt handler
    // or cross-triggered event handler clears the overflow status flag by writing to PMOVSCLR_EL0.)</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.ClearEventCounters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.ClearEventCounters</h3>
      <p class="pseudocode">// AArch64.ClearEventCounters()
// ============================
// Zero all the event counters.

<a id="AArch64.ClearEventCounters.0"/>AArch64.ClearEventCounters()
    for idx = 0 to <a href="shared_pseudocode.html#AArch64.GetNumEventCountersAccessible.0" title="function: integer AArch64.GetNumEventCountersAccessible()">AArch64.GetNumEventCountersAccessible</a>() - 1
        PMEVCNTR_EL0[idx] = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.CountPMUEvents"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.CountPMUEvents</h3>
      <p class="pseudocode">// AArch64.CountPMUEvents()
// ========================
// Return TRUE if counter "idx" should count its event. For the cycle counter, idx == CYCLE_COUNTER_ID.

boolean <a id="AArch64.CountPMUEvents.1"/>AArch64.CountPMUEvents(integer idx)
    assert idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> || idx &lt; <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();
    // Event counting is disabled in Debug state
    debug = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();

    // Software can reserve some counters for EL2
    resvd_for_el2 = <a href="shared_pseudocode.html#AArch64.PMUCounterIsHyp.1" title="function: boolean AArch64.PMUCounterIsHyp(integer n)">AArch64.PMUCounterIsHyp</a>(idx);

    // Main enable controls
    if idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = PMCR_EL0.E == '1' &amp;&amp; PMCNTENSET_EL0.C == '1';
    else
        E = if resvd_for_el2 then MDCR_EL2.HPME else PMCR_EL0.E;
        enabled = E == '1' &amp;&amp; PMCNTENSET_EL0&lt;idx&gt; == '1';

    // Event counting is allowed unless it is prohibited by any rule below
    prohibited = FALSE;

    // Event counting in Secure state is prohibited if all of:
    // * EL3 is implemented
    // * MDCR_EL3.SPME == 0, and either:
    //   - FEAT_PMUv3p7 is not implemented
    //   - MDCR_EL3.MPMX == 0
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
            prohibited = MDCR_EL3.&lt;SPME,MPMX&gt; == '00';
        else
            prohibited = MDCR_EL3.SPME == '0';

    // Event counting at EL3 is prohibited if all of:
    // * FEAT_PMUv3p7 is implemented
    // * One of the following is true:
    //   - MDCR_EL3.SPME == 0
    //   - PMNx is not reserved for EL2
    // * MDCR_EL3.MPMX == 1
    if !prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() then
        prohibited = MDCR_EL3.MPMX == '1' &amp;&amp; (MDCR_EL3.SPME == '0' || !resvd_for_el2);

    // Event counting at EL2 is prohibited if all of:
    // * The HPMD Extension is implemented
    // * PMNx is not reserved for EL2
    // * MDCR_EL2.HPMD == 1
    if !prohibited &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveHPMDExt.0" title="function: boolean HaveHPMDExt()">HaveHPMDExt</a>() &amp;&amp; !resvd_for_el2 then
        prohibited = MDCR_EL2.HPMD == '1';

    // The IMPLEMENTATION DEFINED authentication interface might override software
    if prohibited &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveNoSecurePMUDisableOverride.0" title="function: boolean HaveNoSecurePMUDisableOverride()">HaveNoSecurePMUDisableOverride</a>() then
        prohibited = !<a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>();

    // PMCR_EL0.DP disables the cycle counter when event counting is prohibited
    if prohibited &amp;&amp; idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        enabled = enabled &amp;&amp; (PMCR_EL0.DP == '0');
        prohibited = FALSE; // Otherwise whether event counting is prohibited does not affect the cycle counter

    // If FEAT_PMUv3p5 is implemented, cycle counting can be prohibited.
    // This is not overridden by PMCR_EL0.DP.
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p5.0" title="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() &amp;&amp; idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; MDCR_EL3.SCCD == '1' then
            prohibited = TRUE;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; MDCR_EL2.HCCD == '1' then
            prohibited = TRUE;

    // If FEAT_PMUv3p7 is implemented, cycle counting an be prohibited at EL3.
    // This is not overriden by PMCR_EL0.DP.
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() &amp;&amp; idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; MDCR_EL3.MCCD == '1' then
            prohibited = TRUE;

    // Event counting might be frozen
    frozen = FALSE;

    // If FEAT_PMUv3p7 is implemented, event counting can be frozen
    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p7.0" title="function: boolean HavePMUv3p7()">HavePMUv3p7</a>() &amp;&amp; idx != <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then
        ovflws = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(PMOVSSET_EL0&lt;<a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>()-1:0&gt;);
        if resvd_for_el2 then
            FZ = MDCR_EL2.HPMFZO;
            ovflws&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN)-1:0&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
        else
            FZ = PMCR_EL0.FZO;
            if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN) &lt; <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() then
                ovflws&lt;<a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>()-1:<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN)&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
        frozen = FZ == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ovflws);

    // Event counting can be filtered by the {P, U, NSK, NSU, NSH, M, SH} bits
    filter = if idx == <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a> then PMCCFILTR_EL0&lt;31:0&gt; else PMEVTYPER_EL0[idx]&lt;31:0&gt;;

    P   = filter&lt;31&gt;;
    U   = filter&lt;30&gt;;
    NSK = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;29&gt; else '0';
    NSU = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;28&gt; else '0';
    NSH = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then filter&lt;27&gt; else '0';
    M   = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then filter&lt;26&gt; else '0';
    SH  = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() then filter&lt;24&gt; else '0';

    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> filtered = if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then U == '1' else U != NSU;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> filtered = if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then P == '1' else P != NSK;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> filtered = if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then NSH == SH else NSH == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> filtered = M != P;

    return !debug &amp;&amp; enabled &amp;&amp; !prohibited &amp;&amp; !filtered &amp;&amp; !frozen;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.GetNumEventCountersAccessible"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.GetNumEventCountersAccessible</h3>
      <p class="pseudocode">// AArch64.GetNumEventCountersAccessible()
// =======================================
// Return the number of event counters that can be accessed at the current Exception level.

integer <a id="AArch64.GetNumEventCountersAccessible.0"/>AArch64.GetNumEventCountersAccessible()
    // Software can reserve some counters for EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN);
    else
        n = <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>();

    return n;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.IncrementEventCounter"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.IncrementEventCounter</h3>
      <p class="pseudocode">// AArch64.IncrementEventCounter()
// ===============================
// Increment the specified event counter by the specified amount.

<a id="AArch64.IncrementEventCounter.2"/>AArch64.IncrementEventCounter(integer idx, integer increment)
    old_value = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMEVCNTR_EL0[idx]);
    new_value = old_value + increment;

    if <a href="shared_pseudocode.html#impl-shared.HavePMUv3p5.0" title="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() then
        PMEVCNTR_EL0[idx] = new_value&lt;63:0&gt;;
        lp = if <a href="shared_pseudocode.html#AArch64.PMUCounterIsHyp.1" title="function: boolean AArch64.PMUCounterIsHyp(integer n)">AArch64.PMUCounterIsHyp</a>(idx) then MDCR_EL2.HLP else PMCR_EL0.LP;
        ovflw = if lp == '1' then 64 else 32;
    else
        PMEVCNTR_EL0[idx] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(new_value&lt;31:0&gt;);
        ovflw = 32;

    if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
        PMOVSSET_EL0&lt;idx&gt; = '1';
        PMOVSCLR_EL0&lt;idx&gt; = '1';
        // Check for the CHAIN event from an even counter
        if idx&lt;0&gt; == '0' &amp;&amp; idx + 1 &lt; <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HavePMUv3p5.0" title="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() || lp == '0') then
            <a href="shared_pseudocode.html#AArch64.PMUEvent.3" title="function: AArch64.PMUEvent(bits(16) event, integer increment, integer idx)">AArch64.PMUEvent</a>(<a href="shared_pseudocode.html#PMU_EVENT_CHAIN" title="constant bits(16) PMU_EVENT_CHAIN = 0x001E&lt;15:0&gt;">PMU_EVENT_CHAIN</a>, 1, idx + 1);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.PMUCounterIsHyp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.PMUCounterIsHyp</h3>
      <p class="pseudocode">// AArch64.PMUCounterIsHyp
// =======================
// Returns TRUE if a counter is reserved for use by EL2, FALSE otherwise.

boolean <a id="AArch64.PMUCounterIsHyp.1"/>AArch64.PMUCounterIsHyp(integer n)
    // Software can reserve some counters for EL2
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        resvd_for_el2 = n &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MDCR_EL2.HPMN) &amp;&amp; n != <a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>;
        if !<a href="shared_pseudocode.html#impl-shared.HaveFeatHPMN0.0" title="function: boolean HaveFeatHPMN0()">HaveFeatHPMN0</a>() &amp;&amp; MDCR_EL2.HPMN == '00000' then
            resvd_for_el2 = boolean UNKNOWN;
    else
        resvd_for_el2 = FALSE;

    return resvd_for_el2;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.PMUCycle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.PMUCycle</h3>
      <p class="pseudocode">// AArch64.PMUCycle()
// ==================

<a id="AArch64.PMUCycle.0"/>AArch64.PMUCycle()
    if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3.0" title="function: boolean HavePMUv3()">HavePMUv3</a>() || !<a href="shared_pseudocode.html#AArch64.CountPMUEvents.1" title="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(<a href="shared_pseudocode.html#CYCLE_COUNTER_ID" title="constant integer CYCLE_COUNTER_ID = 31">CYCLE_COUNTER_ID</a>) then
        return;

    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() &amp;&amp; PMCR_EL0.LC == '0' &amp;&amp; PMCR_EL0.D == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HasElapsed64Cycles.0" title="function: boolean HasElapsed64Cycles()">HasElapsed64Cycles</a>() then
        <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(<a href="shared_pseudocode.html#PMU_EVENT_CPU_CYCLES" title="constant bits(16) PMU_EVENT_CPU_CYCLES = 0x0011&lt;15:0&gt;">PMU_EVENT_CPU_CYCLES</a>);
        return;

    old_value = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMCCNTR_EL0);
    new_value = old_value + 1;
    PMCCNTR_EL0 = new_value&lt;63:0&gt;;

    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() then
        ovflw = if PMCR_EL0.LC == '1' then 64 else 32;
    else
        ovflw = 64;

    if old_value&lt;64:ovflw&gt; != new_value&lt;64:ovflw&gt; then
        PMOVSSET_EL0.C = '1';
        PMOVSCLR_EL0.C = '1';

    <a href="shared_pseudocode.html#AArch64.CheckForPMUOverflow.0" title="function: AArch64.CheckForPMUOverflow()">AArch64.CheckForPMUOverflow</a>();

    <a href="shared_pseudocode.html#impl-shared.PMUEvent.1" title="function: PMUEvent(bits(16) event)">PMUEvent</a>(<a href="shared_pseudocode.html#PMU_EVENT_CPU_CYCLES" title="constant bits(16) PMU_EVENT_CPU_CYCLES = 0x0011&lt;15:0&gt;">PMU_EVENT_CPU_CYCLES</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.PMUEvent"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.PMUEvent</h3>
      <p class="pseudocode">// AArch64.PMUEvent()
// ==================
// Generate a PMU Event. All the event counters are checked for the event.
// If any of the counters overflow then an interrupt is raised.

<a id="AArch64.PMUEvent.2"/>AArch64.PMUEvent(bits(16) event, integer increment)
    if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3.0" title="function: boolean HavePMUv3()">HavePMUv3</a>() then
        return;

    // Count the event
    for idx = 0 to <a href="shared_pseudocode.html#impl-shared.GetNumEventCounters.0" title="function: integer GetNumEventCounters()">GetNumEventCounters</a>() - 1
        if PMEVTYPER_EL0[idx].evtCount == event &amp;&amp; <a href="shared_pseudocode.html#AArch64.CountPMUEvents.1" title="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(idx) then
            <a href="shared_pseudocode.html#AArch64.IncrementEventCounter.2" title="function: AArch64.IncrementEventCounter(integer idx, integer increment)">AArch64.IncrementEventCounter</a>(idx, increment);

    <a href="shared_pseudocode.html#AArch64.CheckForPMUOverflow.0" title="function: AArch64.CheckForPMUOverflow()">AArch64.CheckForPMUOverflow</a>();

// AArch64.PMUEvent()
// ==================
// Generate a PMU Event for a specific event counter.

<a id="AArch64.PMUEvent.3"/>AArch64.PMUEvent(bits(16) event, integer increment, integer idx)
    if !<a href="shared_pseudocode.html#impl-shared.HavePMUv3.0" title="function: boolean HavePMUv3()">HavePMUv3</a>() then
        return;
    // Count the event
    if PMEVTYPER_EL0[idx].evtCount == event &amp;&amp; <a href="shared_pseudocode.html#AArch64.CountPMUEvents.1" title="function: boolean AArch64.CountPMUEvents(integer idx)">AArch64.CountPMUEvents</a>(idx) then
        <a href="shared_pseudocode.html#AArch64.IncrementEventCounter.2" title="function: AArch64.IncrementEventCounter(integer idx, integer increment)">AArch64.IncrementEventCounter</a>(idx, increment);

    // This function is only called from other functions which will check for overflow later</p>
    </div>
    <div class="ps"><a id="aarch64.debug.pmu.AArch64.PMUSwIncrement"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/pmu/AArch64.PMUSwIncrement</h3>
      <p class="pseudocode">// AArch64.PMUSwIncrement()
// ========================
// Generate PMU Events on a write to PMSWINC_EL0.

<a id="AArch64.PMUSwIncrement.1"/>AArch64.PMUSwIncrement(bits(32) sw_incr)
    for idx = 0 to <a href="shared_pseudocode.html#AArch64.GetNumEventCountersAccessible.0" title="function: integer AArch64.GetNumEventCountersAccessible()">AArch64.GetNumEventCountersAccessible</a>() - 1
        if sw_incr&lt;idx&gt; == '1' then
            <a href="shared_pseudocode.html#AArch64.PMUEvent.3" title="function: AArch64.PMUEvent(bits(16) event, integer increment, integer idx)">AArch64.PMUEvent</a>(<a href="shared_pseudocode.html#PMU_EVENT_SW_INCR" title="constant bits(16) PMU_EVENT_SW_INCR = 0x0000&lt;15:0&gt;">PMU_EVENT_SW_INCR</a>, 1, idx);

    <a href="shared_pseudocode.html#AArch64.CheckForPMUOverflow.0" title="function: AArch64.CheckForPMUOverflow()">AArch64.CheckForPMUOverflow</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectContextIDR1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectContextIDR1</h3>
      <p class="pseudocode">// CollectContextIDR1()
// ====================

boolean <a id="impl-aarch64.CollectContextIDR1.0"/>CollectContextIDR1()
    if !<a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return FALSE;
    if  PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then return FALSE;
    return PMSCR_EL1.CX == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectContextIDR2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectContextIDR2</h3>
      <p class="pseudocode">// CollectContextIDR2()
// ====================

boolean <a id="impl-aarch64.CollectContextIDR2.0"/>CollectContextIDR2()
    if !<a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return FALSE;
    if !<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then return FALSE;
    return PMSCR_EL2.CX == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectPhysicalAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectPhysicalAddress</h3>
      <p class="pseudocode">// CollectPhysicalAddress()
// ========================

boolean <a id="impl-aarch64.CollectPhysicalAddress.0"/>CollectPhysicalAddress()
    if !<a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return FALSE;
    (secure, el) = <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();
    if ((!secure &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>)) || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then
        return PMSCR_EL2.PA == '1' &amp;&amp; (el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || PMSCR_EL1.PA == '1');
    else
        return PMSCR_EL1.PA == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.CollectTimeStamp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/CollectTimeStamp</h3>
      <p class="pseudocode">// CollectTimeStamp()
// ==================

TimeStamp <a id="impl-aarch64.CollectTimeStamp.0"/>CollectTimeStamp()

    if !<a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>() then return <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>;
    (-, el) = <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();

    if el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        if PMSCR_EL2.TS == '0' then return <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>;
    else
        if PMSCR_EL1.TS == '0' then return <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>;

    if !<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() then
        PCT_el1 = '0':PMSCR_EL1.PCT&lt;0&gt;;       // PCT&lt;1&gt; is RES0
    else
        PCT_el1 = PMSCR_EL1.PCT;
        if PCT_el1 == '10' then
            // Reserved value
            (-, PCT_el1) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_PMSCR_PCT" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_PMSCR_PCT</a>);
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if !<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() then
            PCT_el2 = '0':PMSCR_EL2.PCT&lt;0&gt;;   // PCT&lt;1&gt; is RES0
        else
            PCT_el2 = PMSCR_EL2.PCT;
            if PCT_el2 == '10' then
                // Reserved value
                (-, PCT_el2) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_PMSCR_PCT" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_PMSCR_PCT</a>);
        case PCT_el2 of
            when '00'
                return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
            when '01'
                if el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
            when '11'
                assert <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>();          // FEAT_ECV must be implemented
                if el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; PCT_el1 == '00' then
                    return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
                else
                    return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
            otherwise
                <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    case PCT_el1 of
        when '00' return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
        when '01' return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
        when '11'
            assert <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>();              // FEAT_ECV must be implemented
            return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.OpType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/OpType</h3>
      <p class="pseudocode">enumeration <a id="OpType"/>OpType {
 <a id="OpType_Load"/>OpType_Load,           // Any memory-read operation other than atomics, compare-and-swap, and swap
 <a id="OpType_Store"/>OpType_Store,          // Any memory-write operation, including atomics without return
 <a id="OpType_LoadAtomic"/>OpType_LoadAtomic,     // Atomics with return, compare-and-swap and swap
 <a id="OpType_Branch"/>OpType_Branch,         // Software write to the PC
 <a id="OpType_Other"/>OpType_Other           // Any other class of operation
 };</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.ProfilingBufferEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/ProfilingBufferEnabled</h3>
      <p class="pseudocode">// ProfilingBufferEnabled()
// ========================

boolean <a id="impl-aarch64.ProfilingBufferEnabled.0"/>ProfilingBufferEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()">HaveStatisticalProfiling</a>() then return FALSE;
    (secure, el) = <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();
    non_secure_bit = if secure then '0' else '1';
    return (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el) &amp;&amp; non_secure_bit == SCR_EL3.NS &amp;&amp;
            PMBLIMITR_EL1.E == '1' &amp;&amp; PMBSR_EL1.S == '0');</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.ProfilingBufferOwner"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/ProfilingBufferOwner</h3>
      <p class="pseudocode">// ProfilingBufferOwner()
// ======================

(boolean, bits(2)) <a id="impl-aarch64.ProfilingBufferOwner.0"/>ProfilingBufferOwner()
    secure = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then (MDCR_EL3.NSPB&lt;1&gt; == '0') else <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    el = if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!secure || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) &amp;&amp; MDCR_EL2.E2PB == '00' then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    return (secure, el);</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.ProfilingSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/ProfilingSynchronizationBarrier</h3>
      <p class="pseudocode">// Barrier to ensure that all existing profiling data has been formatted, and profiling buffer
// addresses have been translated such that writes to the profiling buffer have been initiated.
// A following DSB completes when writes to the profiling buffer have completed.
<a id="impl-aarch64.ProfilingSynchronizationBarrier.0"/>ProfilingSynchronizationBarrier();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.SPECollectRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/SPECollectRecord</h3>
      <p class="pseudocode">// SPECollectRecord()
// ==================
// Returns TRUE if the sampled class of instructions or operations, as
// determined by PMSFCR_EL1, are recorded and FALSE otherwise.

boolean <a id="impl-aarch64.SPECollectRecord.3"/>SPECollectRecord(bits(64) events, integer total_latency, <a href="shared_pseudocode.html#OpType" title="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType</a> optype)
    assert <a href="shared_pseudocode.html#impl-aarch64.StatisticalProfilingEnabled.0" title="function: boolean StatisticalProfilingEnabled()">StatisticalProfilingEnabled</a>();

    bits(64) mask = 0xAA&lt;63:0&gt;;                             // Bits [7,5,3,1]
    if <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() then mask&lt;18:17&gt; = <a href="shared_pseudocode.html#impl-shared.Ones.0" title="function: bits(N) Ones()">Ones</a>();                 // Predicate flags
    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then mask&lt;16&gt; = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfilingv1p1.0" title="function: boolean HaveStatisticalProfilingv1p1()">HaveStatisticalProfilingv1p1</a>() then mask&lt;11&gt; = '1';  // Alignment Flag
    if <a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfilingv1p2.0" title="function: boolean HaveStatisticalProfilingv1p2()">HaveStatisticalProfilingv1p2</a>() then mask&lt;6&gt; = '1';   // Not taken flag
    mask&lt;63:48&gt; = bits(16) IMPLEMENTATION_DEFINED;
    mask&lt;31:24&gt; = bits(8) IMPLEMENTATION_DEFINED;
    mask&lt;15:12&gt; = bits(4) IMPLEMENTATION_DEFINED;

    // Check for UNPREDICTABLE case
    if (<a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfilingv1p2.0" title="function: boolean HaveStatisticalProfilingv1p2()">HaveStatisticalProfilingv1p2</a>() &amp;&amp; PMSFCR_EL1.&lt;FnE,FE&gt; == '11' &amp;&amp;
        !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSEVFR_EL1 AND PMSNEVFR_EL1 AND mask)) then
        if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BADPMSFCR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BADPMSFCR</a>) then
            return FALSE;
    else
        // Filtering by event
        if PMSFCR_EL1.FE == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSEVFR_EL1) then
            e = events AND mask;
            m = PMSEVFR_EL1 AND mask;
            if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(NOT(e) AND m) then return FALSE;

        // Filtering by inverse event
        if (<a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfilingv1p2.0" title="function: boolean HaveStatisticalProfilingv1p2()">HaveStatisticalProfilingv1p2</a>() &amp;&amp; PMSFCR_EL1.FnE == '1' &amp;&amp;
            !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSNEVFR_EL1)) then
            e = events AND mask;
            m = PMSNEVFR_EL1 AND mask;
            if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(e AND m) then return FALSE;

    // Filtering by type
    if PMSFCR_EL1.FT == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSFCR_EL1.&lt;B,LD,ST&gt;) then
        case optype of
            when <a href="shared_pseudocode.html#OpType_Branch" title="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_Branch</a>
                if PMSFCR_EL1.B == '0' then return FALSE;
            when <a href="shared_pseudocode.html#OpType_Load" title="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_Load</a>
                if PMSFCR_EL1.LD == '0' then return FALSE;
            when <a href="shared_pseudocode.html#OpType_Store" title="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_Store</a>
                if PMSFCR_EL1.ST == '0' then return FALSE;
            when <a href="shared_pseudocode.html#OpType_LoadAtomic" title="enumeration OpType {&#13; OpType_Load, OpType_Store, OpType_LoadAtomic, OpType_Branch, OpType_Other }">OpType_LoadAtomic</a>
                if PMSFCR_EL1.&lt;LD,ST&gt; == '00' then return FALSE;
            otherwise
                return FALSE;

    // Filtering by latency
    if PMSFCR_EL1.FL == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSLATFR_EL1.MINLAT) then
        if total_latency &lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PMSLATFR_EL1.MINLAT) then
            return FALSE;

    // Check for UNPREDICTABLE cases
    if ((PMSFCR_EL1.FE == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSEVFR_EL1 AND mask)) ||
        (PMSFCR_EL1.FT == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSFCR_EL1.&lt;B,LD,ST&gt;)) ||
        (PMSFCR_EL1.FL == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSLATFR_EL1.MINLAT))) then
        return <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BADPMSFCR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BADPMSFCR</a>);

    if (<a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfilingv1p2.0" title="function: boolean HaveStatisticalProfilingv1p2()">HaveStatisticalProfilingv1p2</a>() &amp;&amp;
        ((PMSFCR_EL1.FnE == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSNEVFR_EL1 AND mask)) ||
        (PMSFCR_EL1.&lt;FnE,FE&gt; == '11' &amp;&amp;
            !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(PMSEVFR_EL1 AND PMSNEVFR_EL1 AND mask)))) then
        return <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_BADPMSFCR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BADPMSFCR</a>);

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.StatisticalProfilingEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/StatisticalProfilingEnabled</h3>
      <p class="pseudocode">// StatisticalProfilingEnabled()
// =============================

boolean <a id="impl-aarch64.StatisticalProfilingEnabled.0"/>StatisticalProfilingEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()">HaveStatisticalProfiling</a>() || <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() || !<a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferEnabled.0" title="function: boolean ProfilingBufferEnabled()">ProfilingBufferEnabled</a>() then
        return FALSE;

    in_host = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';
    (secure, el) = <a href="shared_pseudocode.html#impl-aarch64.ProfilingBufferOwner.0" title="function: (boolean, bits(2)) ProfilingBufferOwner()">ProfilingBufferOwner</a>();
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(el) &lt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) || secure != <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() || (in_host &amp;&amp; el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)  then
        return FALSE;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  spe_bit = PMSCR_EL2.E2SPE;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  spe_bit = PMSCR_EL1.E1SPE;
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  spe_bit = (if in_host then PMSCR_EL2.E0HSPE else PMSCR_EL1.E0SPE);

    return spe_bit == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.debug.statisticalprofiling.TimeStamp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/statisticalprofiling/TimeStamp</h3>
      <p class="pseudocode">enumeration <a id="TimeStamp"/>TimeStamp {
    <a id="TimeStamp_None"/>TimeStamp_None,              // No timestamp
    <a id="TimeStamp_CoreSight"/>TimeStamp_CoreSight,         // CoreSight time (IMPLEMENTATION DEFINED)
    <a id="TimeStamp_Physical"/>TimeStamp_Physical,          // Physical counter value with no offset
    <a id="TimeStamp_OffsetPhysical"/>TimeStamp_OffsetPhysical,    // Physical counter value minus CNTPOFF_EL2
    <a id="TimeStamp_Virtual"/>TimeStamp_Virtual  };        // Physical counter value minus CNTVOFF_EL2</p>
    </div>
    <div class="ps"><a id="aarch64.debug.takeexceptiondbg.AArch64.TakeExceptionInDebugState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/takeexceptiondbg/AArch64.TakeExceptionInDebugState</h3>
      <p class="pseudocode">// AArch64.TakeExceptionInDebugState()
// ===================================
// Take an exception in Debug state to an Exception level using AArch64.

<a id="AArch64.TakeExceptionInDebugState.2"/>AArch64.TakeExceptionInDebugState(bits(2) target_el, <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    if <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() then
        sync_errors = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.1" title="accessor: SCTLRType SCTLR[bits(2) regime]">SCTLR</a>[target_el].IESB == '1';
        if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            sync_errors = sync_errors || (SCR_EL3.&lt;EA,NMEA&gt; == '11' &amp;&amp; target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        // SCTLR[].IESB and/or SCR_EL3.NMEA (if applicable) might be ignored in Debug state.
        if !<a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_IESBinDebug</a>) then
            sync_errors = FALSE;
    else
        sync_errors = FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then
        case exception.exceptype of
            when <a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a> cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>         cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>         cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>       cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            otherwise                         cause = <a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>;
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(cause, FALSE);

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    from_32 = <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    if from_32 then <a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()">AArch64.MaybeZeroRegisterUppers</a>();
    <a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)">MaybeZeroSVEUppers</a>(target_el);

    <a href="shared_pseudocode.html#AArch64.ReportException.2" title="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)">AArch64.ReportException</a>(exception, target_el);

    PSTATE.EL = target_el;
    PSTATE.nRW = '0';
    PSTATE.SP = '1';

    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(64) UNKNOWN;
    <a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value">ELR</a>[] = bits(64) UNKNOWN;

    // PSTATE.{SS,D,A,I,F} are not observable and ignored in Debug state, so behave as if UNKNOWN.
    PSTATE.&lt;SS,D,A,I,F&gt; = bits(5) UNKNOWN;
    PSTATE.IL = '0';
    if from_32 then                             // Coming from AArch32
        PSTATE.IT = '00000000';
        PSTATE.T = '0';                         // PSTATE.J is RES0
    if (<a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>))) &amp;&amp;
        <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SPAN == '0') then
        PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = '00';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = '1';

    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(64) UNKNOWN;

    EDSCR.ERR = '1';
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR processor state flags.

    if sync_errors then
        <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.debug.watchpoint.AArch64.WatchpointByteMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/watchpoint/AArch64.WatchpointByteMatch</h3>
      <p class="pseudocode">// AArch64.WatchpointByteMatch()
// =============================

boolean <a id="AArch64.WatchpointByteMatch.3"/>AArch64.WatchpointByteMatch(integer n, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, bits(64) vaddress)

    integer top = <a href="shared_pseudocode.html#AArch64.VAMax.0" title="function: integer AArch64.VAMax()">AArch64.VAMax</a>();
    bottom = if DBGWVR_EL1[n]&lt;2&gt; == '1' then 2 else 3;            // Word or doubleword
    byte_select_match = (DBGWCR_EL1[n].BAS&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vaddress&lt;bottom-1:0&gt;)&gt; != '0');
    mask = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DBGWCR_EL1[n].MASK);

    // If DBGWCR_EL1[n].MASK is non-zero value and DBGWCR_EL1[n].BAS is not set to '11111111', or
    // DBGWCR_EL1[n].BAS specifies a non-contiguous set of bytes behavior is CONSTRAINED
    // UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGWCR_EL1[n].BAS) then
        byte_select_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPMASKANDBAS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WPMASKANDBAS</a>);
    else
        LSB = (DBGWCR_EL1[n].BAS AND NOT(DBGWCR_EL1[n].BAS - 1));  MSB = (DBGWCR_EL1[n].BAS + LSB);
        if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(MSB AND (MSB - 1)) then                     // Not contiguous
            byte_select_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPBASCONTIGUOUS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WPBASCONTIGUOUS</a>);
            bottom = 3;                                        // For the whole doubleword

    // If the address mask is set to a reserved value, the behavior is CONSTRAINED UNPREDICTABLE.
    if mask &gt; 0 &amp;&amp; mask &lt;= 2 then
        (c, mask) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableInteger.3" title="function: (Constraint,integer) ConstrainUnpredictableInteger(integer low, integer high, Unpredictable which)">ConstrainUnpredictableInteger</a>(3, 31, <a href="shared_pseudocode.html#Unpredictable_RESWPMASK" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESWPMASK</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        case c of
            when <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>  return FALSE;            // Disabled
            when <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>      mask = 0;                // No masking
            // Otherwise the value returned by ConstrainUnpredictableInteger is a not-reserved value

    if mask &gt; bottom then
        // If the DBGxVR&lt;n&gt;_EL1.RESS field bits are not a sign extension of the MSB
        // of DBGBVR&lt;n&gt;_EL1.VA, it is UNPREDICTABLE whether they appear to be
        // included in the match.
        if !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(DBGBVR_EL1[n]&lt;63:top&gt;) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGBVR_EL1[n]&lt;63:top&gt;) then
            if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_DBGxVR_RESS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DBGxVR_RESS</a>) then
                top = 63;
        WVR_match = (vaddress&lt;top:mask&gt; == DBGWVR_EL1[n]&lt;top:mask&gt;);
        // If masked bits of DBGWVR_EL1[n] are not zero, the behavior is CONSTRAINED UNPREDICTABLE.
        if WVR_match &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(DBGWVR_EL1[n]&lt;mask-1:bottom&gt;) then
            WVR_match = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_WPMASKEDBITS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WPMASKEDBITS</a>);
    else
        WVR_match = vaddress&lt;top:bottom&gt; == DBGWVR_EL1[n]&lt;top:bottom&gt;;

    return WVR_match &amp;&amp; byte_select_match;</p>
    </div>
    <div class="ps"><a id="aarch64.debug.watchpoint.AArch64.WatchpointMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/debug/watchpoint/AArch64.WatchpointMatch</h3>
      <p class="pseudocode">// AArch64.WatchpointMatch()
// =========================
// Watchpoint matching in an AArch64 translation regime.

boolean <a id="AArch64.WatchpointMatch.6"/>AArch64.WatchpointMatch(integer n, bits(64) vaddress, integer size, boolean ispriv,
                                <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert n &lt; <a href="shared_pseudocode.html#impl-shared.NumWatchpointsImplemented.0" title="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>();

    // "ispriv" is:
    //  * FALSE for all loads, stores, and atomic operations executed at EL0.
    //  * FALSE if the access is unprivileged.
    //  * TRUE for all other loads, stores, and atomic operations.

    enabled = DBGWCR_EL1[n].E == '1';
    linked = DBGWCR_EL1[n].WT == '1';
    isbreakpnt = FALSE;

    state_match = <a href="shared_pseudocode.html#AArch64.StateMatch.8" title="function: boolean AArch64.StateMatch(bits(2) SSC, bit HMC, bits(2) PxC, boolean linked, bits(4) LBN,&#13; boolean isbreakpnt, AccType acctype, boolean ispriv)">AArch64.StateMatch</a>(DBGWCR_EL1[n].SSC, DBGWCR_EL1[n].HMC, DBGWCR_EL1[n].PAC,
                                     linked, DBGWCR_EL1[n].LBN, isbreakpnt, acctype, ispriv);
    ls_match = FALSE;
    if acctype == <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a> then
        ls_match = (DBGWCR_EL1[n].LSC != '00');
    else
        ls_match = (DBGWCR_EL1[n].LSC&lt;(if iswrite then 1 else 0)&gt; == '1');

    value_match = FALSE;
    for byte = 0 to size - 1
        value_match = value_match || <a href="shared_pseudocode.html#AArch64.WatchpointByteMatch.3" title="function: boolean AArch64.WatchpointByteMatch(integer n, AccType acctype, bits(64) vaddress)">AArch64.WatchpointByteMatch</a>(n, acctype, vaddress + byte);

    return value_match &amp;&amp; state_match &amp;&amp; ls_match &amp;&amp; enabled;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.Abort"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.Abort</h3>
      <p class="pseudocode">// AArch64.Abort()
// ===============
// Abort and Debug exception handling in an AArch64 translation regime.

<a id="AArch64.Abort.2"/>AArch64.Abort(bits(64) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)

    if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(fault) then
        if fault.acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
            if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fault.debugmoe == <a href="shared_pseudocode.html#DebugException_VectorCatch" title="constant bits(4) DebugException_VectorCatch = '0101'">DebugException_VectorCatch</a> then
                <a href="shared_pseudocode.html#AArch64.VectorCatchException.1" title="function: AArch64.VectorCatchException(FaultRecord fault)">AArch64.VectorCatchException</a>(fault);
            else
                <a href="shared_pseudocode.html#AArch64.BreakpointException.1" title="function: AArch64.BreakpointException(FaultRecord fault)">AArch64.BreakpointException</a>(fault);
        else
            <a href="shared_pseudocode.html#AArch64.WatchpointException.2" title="function: AArch64.WatchpointException(bits(64) vaddress, FaultRecord fault)">AArch64.WatchpointException</a>(vaddress, fault);
    elsif fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ReportAsGPCException.1" title="function: boolean ReportAsGPCException(FaultRecord fault)">ReportAsGPCException</a>(fault) then
        <a href="shared_pseudocode.html#impl-aarch64.TakeGPCException.2" title="function: TakeGPCException(bits(64) vaddress, FaultRecord fault)">TakeGPCException</a>(vaddress, fault);
    elsif fault.acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        <a href="shared_pseudocode.html#AArch64.InstructionAbort.2" title="function: AArch64.InstructionAbort(bits(64) vaddress, FaultRecord fault)">AArch64.InstructionAbort</a>(vaddress, fault);
    else
        <a href="shared_pseudocode.html#AArch64.DataAbort.2" title="function: AArch64.DataAbort(bits(64) vaddress, FaultRecord fault)">AArch64.DataAbort</a>(vaddress, fault);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.AbortSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.AbortSyndrome</h3>
      <p class="pseudocode">// AArch64.AbortSyndrome()
// =======================
// Creates an exception syndrome record for Abort and Watchpoint exceptions
// from an AArch64 translation regime.

ExceptionRecord <a id="AArch64.AbortSyndrome.3"/>AArch64.AbortSyndrome(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(64) vaddress)
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(exceptype);

    d_side = exceptype IN {<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>, <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>, <a href="shared_pseudocode.html#Exception_NV2Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>};

    (exception.syndrome, exception.syndrome2) = <a href="shared_pseudocode.html#AArch64.FaultSyndrome.2" title="function: (bits(25), bits(5)) AArch64.FaultSyndrome(boolean d_side, FaultRecord fault)">AArch64.FaultSyndrome</a>(d_side, fault);
    exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress);
    if <a href="shared_pseudocode.html#impl-shared.IPAValid.1" title="function: boolean IPAValid(FaultRecord fault)">IPAValid</a>(fault) then
        exception.ipavalid = TRUE;
        exception.NS = if fault.ipaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then '1' else '0';
        exception.ipaddress = fault.ipaddress.address;
    else
        exception.ipavalid = FALSE;

    return exception;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.CheckPCAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.CheckPCAlignment</h3>
      <p class="pseudocode">// AArch64.CheckPCAlignment()
// ==========================

<a id="AArch64.CheckPCAlignment.0"/>AArch64.CheckPCAlignment()

    bits(64) pc = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    if pc&lt;1:0&gt; != '00' then
        <a href="shared_pseudocode.html#AArch64.PCAlignmentFault.0" title="function: AArch64.PCAlignmentFault()">AArch64.PCAlignmentFault</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.DataAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.DataAbort</h3>
      <p class="pseudocode">// AArch64.DataAbort()
// ===================

<a id="AArch64.DataAbort.2"/>AArch64.DataAbort(bits(64) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    route_to_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);
    route_to_el2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR_EL2.TGE == '1' ||
                     (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                     (<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; fault.gpcf.gpf == <a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a> &amp;&amp; HCR_EL2.GPF == '1') ||
                     (<a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a>) ||
                     <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    if (<a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; (PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3) &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) &amp;&amp; SCR_EL3.EASE == '1') then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;
    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>, fault, vaddress);
    else
        exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>, fault, vaddress);
    bits(2) target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3 then
        target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.EffectiveTCF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.EffectiveTCF</h3>
      <p class="pseudocode">// AArch64.EffectiveTCF()
// ======================
// Returns the TCF field applied to tag check faults in the given Exception level.

bits(2) <a id="AArch64.EffectiveTCF.1"/>AArch64.EffectiveTCF(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    bits(2) tcf, el;
    el = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>();

    if el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        tcf = SCTLR_EL3.TCF;
    elsif el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        if <a href="shared_pseudocode.html#AArch64.AccessUsesEL.1" title="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</a>(acctype) == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            tcf = SCTLR_EL2.TCF0;
        else
            tcf = SCTLR_EL2.TCF;
    elsif el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
        if <a href="shared_pseudocode.html#AArch64.AccessUsesEL.1" title="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</a>(acctype) == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            tcf = SCTLR_EL1.TCF0;
        else
            tcf = SCTLR_EL1.TCF;

    if tcf == '11' then        //reserved value
        if !<a href="shared_pseudocode.html#impl-shared.HaveMTE3Ext.0" title="function: boolean HaveMTE3Ext()">HaveMTE3Ext</a>() then
            (-,tcf) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESTCF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESTCF</a>);

    return tcf;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.InstructionAbort"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.InstructionAbort</h3>
      <p class="pseudocode">// AArch64.InstructionAbort()
// ==========================

<a id="AArch64.InstructionAbort.2"/>AArch64.InstructionAbort(bits(64) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    // External aborts on instruction fetch must be taken synchronously
    if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then assert fault.statuscode != <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;
    route_to_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault);
    route_to_el2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    (HCR_EL2.TGE == '1' ||
                     (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; HCR_EL2.TEA == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault)) ||
                     (<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; fault.gpcf.gpf == <a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a> &amp;&amp; HCR_EL2.GPF == '1') ||
                     <a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault)));

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();

    if (<a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; (PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3) &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) &amp;&amp; SCR_EL3.EASE == '1') then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, fault, vaddress);

    bits(2) target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3 then
        target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.PCAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.PCAlignmentFault</h3>
      <p class="pseudocode">// AArch64.PCAlignmentFault()
// ==========================
// Called on unaligned program counter in AArch64 state.

<a id="AArch64.PCAlignmentFault.0"/>AArch64.PCAlignmentFault()

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>);
    exception.vaddress = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();

    bits(2) target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.RaiseTagCheckFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.RaiseTagCheckFault</h3>
      <p class="pseudocode">// AArch64.RaiseTagCheckFault()
// ============================
// Raise a tag check fault exception.

<a id="AArch64.RaiseTagCheckFault.2"/>AArch64.RaiseTagCheckFault(bits(64) va, boolean write)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    integer vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>);
    exception.syndrome&lt;5:0&gt; = '010001';
    if write then
        exception.syndrome&lt;6&gt; = '1';
    exception.vaddress = bits(4) UNKNOWN : va&lt;59:0&gt;;

    bits(2) target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.ReportTagCheckFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.ReportTagCheckFault</h3>
      <p class="pseudocode">// AArch64.ReportTagCheckFault()
// =============================
// Records a tag check fault exception into the appropriate TCFR_ELx.

<a id="AArch64.ReportTagCheckFault.2"/>AArch64.ReportTagCheckFault(bits(2) el, bit ttbr)
    if el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        assert ttbr == '0';
        TFSR_EL3.TF0 = '1';
    elsif el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        if ttbr == '0' then
            TFSR_EL2.TF0 = '1';
        else
            TFSR_EL2.TF1 = '1';
    elsif el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
        if ttbr == '0' then
            TFSR_EL1.TF0 = '1';
        else
            TFSR_EL1.TF1 = '1';
    elsif el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        if ttbr == '0' then
            TFSRE0_EL1.TF0 = '1';
        else
            TFSRE0_EL1.TF1 = '1';</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.SPAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.SPAlignmentFault</h3>
      <p class="pseudocode">// AArch64.SPAlignmentFault()
// ==========================
// Called on an unaligned stack pointer in AArch64 state.

<a id="AArch64.SPAlignmentFault.0"/>AArch64.SPAlignmentFault()

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SPAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SPAlignment</a>);

    bits(2) target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.AArch64.TagCheckFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/AArch64.TagCheckFault</h3>
      <p class="pseudocode">// AArch64.TagCheckFault()
// =======================
// Handle a tag check fault condition.

<a id="AArch64.TagCheckFault.3"/>AArch64.TagCheckFault(bits(64) vaddress, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    bits(2) tcf, el;
    el = <a href="shared_pseudocode.html#AArch64.AccessUsesEL.1" title="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</a>(acctype);
    tcf = <a href="shared_pseudocode.html#AArch64.EffectiveTCF.1" title="function: bits(2) AArch64.EffectiveTCF(AccType acctype)">AArch64.EffectiveTCF</a>(acctype);
    case tcf of
        when '00'       // Tag Check Faults have no effect on the PE
            return;
        when '01'       // Tag Check Faults cause a synchronous exception
            <a href="shared_pseudocode.html#AArch64.RaiseTagCheckFault.2" title="function: AArch64.RaiseTagCheckFault(bits(64) va, boolean write)">AArch64.RaiseTagCheckFault</a>(vaddress, iswrite);
        when '10'       // Tag Check Faults are asynchronously accumulated
            <a href="shared_pseudocode.html#AArch64.ReportTagCheckFault.2" title="function: AArch64.ReportTagCheckFault(bits(2) el, bit ttbr)">AArch64.ReportTagCheckFault</a>(el, vaddress&lt;55&gt;);
        when '11'       // Tag Check Faults cause a synchronous exception on reads or on
                        // a read-write access, and are asynchronously accumulated on writes
            // Check for access performing both a read and a write.
            readwrite = acctype IN {<a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>,
                                    <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a>,
                                    <a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</a>};

            if !iswrite || readwrite then
                <a href="shared_pseudocode.html#AArch64.RaiseTagCheckFault.2" title="function: AArch64.RaiseTagCheckFault(bits(64) va, boolean write)">AArch64.RaiseTagCheckFault</a>(vaddress, iswrite);
            else
                <a href="shared_pseudocode.html#AArch64.ReportTagCheckFault.2" title="function: AArch64.ReportTagCheckFault(bits(2) el, bit ttbr)">AArch64.ReportTagCheckFault</a>(PSTATE.EL, vaddress&lt;55&gt;);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.BranchTargetException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/BranchTargetException</h3>
      <p class="pseudocode">// BranchTargetException()
// =======================
// Raise branch target exception.

<a id="AArch64.BranchTargetException.1"/>AArch64.BranchTargetException(bits(52) vaddress)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>);
    exception.syndrome&lt;1:0&gt;   = PSTATE.BTYPE;
    exception.syndrome&lt;24:2&gt;  = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();         // RES0

    bits(2) target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.aborts.TakeGPCException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/aborts/TakeGPCException</h3>
      <p class="pseudocode">// TakeGPCException()
// ==================
// Report Granule Protection Exception faults

<a id="impl-aarch64.TakeGPCException.2"/>TakeGPCException(bits(64) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HavePrivATExt.0" title="function: boolean HavePrivATExt()">HavePrivATExt</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveAtomicExt.0" title="function: boolean HaveAtomicExt()">HaveAtomicExt</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>();
    assert <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>();

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception;

    exception.exceptype = <a href="shared_pseudocode.html#Exception_GPC" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_GPC</a>;
    exception.vaddress  = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress);
    exception.paddress  = fault.paddress;

    if <a href="shared_pseudocode.html#impl-shared.IPAValid.1" title="function: boolean IPAValid(FaultRecord fault)">IPAValid</a>(fault) then
        exception.ipavalid  = TRUE;
        exception.NS        = if fault.ipaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then '1' else '0';
        exception.ipaddress = fault.ipaddress.address;
    else
        exception.ipavalid = FALSE;

    // Populate the fields grouped in ISS
    exception.syndrome&lt;24:22&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>(); // RES0
    exception.syndrome&lt;21&gt;    = if fault.gpcfs2walk then '1' else '0';  // S2PTW
    exception.syndrome&lt;20&gt;    = if fault.acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then '1' else '0'; // InD
    exception.syndrome&lt;19:14&gt; = <a href="shared_pseudocode.html#impl-aarch64.EncodeGPCSC.1" title="function: bits(6) EncodeGPCSC(GPCFRecord gpcf)">EncodeGPCSC</a>(fault.gpcf); // GPCSC
    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        exception.syndrome&lt;13&gt; = '1'; // VNCR
    else
        exception.syndrome&lt;13&gt; = '0'; // VNCR
    exception.syndrome&lt;12:11&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>(); // RES0
    exception.syndrome&lt;10:9&gt;  = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>(); // RES0

    if fault.acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
        exception.syndrome&lt;8&gt; = '1'; // CM
    else
        exception.syndrome&lt;8&gt; = '0'; // CM

    exception.syndrome&lt;7&gt; = if fault.s2fs1walk then '1' else '0'; // S1PTW

    if fault.acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
        exception.syndrome&lt;6&gt; = '1';                              // WnR
    elsif fault.statuscode IN {<a href="shared_pseudocode.html#Fault_HWUpdateAccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_HWUpdateAccessFlag</a>, <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>} then
        exception.syndrome&lt;6&gt; = bit UNKNOWN;                      // WnR
    elsif <a href="shared_pseudocode.html#impl-shared.IsAtomicRW.1" title="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(fault.acctype) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then
        exception.syndrome&lt;6&gt; = bit UNKNOWN;                      // WnR
    else
        exception.syndrome&lt;6&gt; = if fault.write then '1' else '0'; // WnR

    exception.syndrome&lt;5:0&gt; = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level); // xFSC

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();

    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) &amp;&amp; SCR_EL3.EASE == '1' then
        vect_offset = 0x180;
    else
        vect_offset = 0x0;

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakePhysicalFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakePhysicalFIQException</h3>
      <p class="pseudocode">// AArch64.TakePhysicalFIQException()
// ==================================

<a id="AArch64.TakePhysicalFIQException.0"/>AArch64.TakePhysicalFIQException()

    route_to_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.FIQ == '1';
    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.FMO == '1'));
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x100;
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>);

    if route_to_el3 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        assert PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakePhysicalIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakePhysicalIRQException</h3>
      <p class="pseudocode">// AArch64.TakePhysicalIRQException()
// ==================================
// Take an enabled physical IRQ exception.

<a id="AArch64.TakePhysicalIRQException.0"/>AArch64.TakePhysicalIRQException()

    route_to_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.IRQ == '1';
    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.IMO == '1'));
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x80;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>);

    if route_to_el3 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        assert PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakePhysicalSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakePhysicalSErrorException</h3>
      <p class="pseudocode">// AArch64.TakePhysicalSErrorException()
// =====================================

<a id="AArch64.TakePhysicalSErrorException.1"/>AArch64.TakePhysicalSErrorException(bits(25) syndrome)

    route_to_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1';
    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || (!<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; HCR_EL2.AMO == '1')));
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x180;

    bits(2) target_el;
    if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> || route_to_el3 then
        target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    if <a href="shared_pseudocode.html#impl-shared.IsSErrorEdgeTriggered.2" title="function: boolean IsSErrorEdgeTriggered(bits(2) target_el, bits(25) syndrome)">IsSErrorEdgeTriggered</a>(target_el, syndrome) then
        <a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>);
    exception.syndrome = syndrome;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakeVirtualFIQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakeVirtualFIQException</h3>
      <p class="pseudocode">// AArch64.TakeVirtualFIQException()
// =================================

<a id="AArch64.TakeVirtualFIQException.0"/>AArch64.TakeVirtualFIQException()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.FMO == '1';  // Virtual IRQ enabled if TGE==0 and FMO==1

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x100;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>);

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakeVirtualIRQException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakeVirtualIRQException</h3>
      <p class="pseudocode">// AArch64.TakeVirtualIRQException()
// =================================

<a id="AArch64.TakeVirtualIRQException.0"/>AArch64.TakeVirtualIRQException()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.IMO == '1';  // Virtual IRQ enabled if TGE==0 and IMO==1

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x80;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>);

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.async.AArch64.TakeVirtualSErrorException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/async/AArch64.TakeVirtualSErrorException</h3>
      <p class="pseudocode">// AArch64.TakeVirtualSErrorException()
// ====================================

<a id="AArch64.TakeVirtualSErrorException.1"/>AArch64.TakeVirtualSErrorException(bits(25) syndrome)

    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    assert HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';  // Virtual SError enabled if TGE==0 and AMO==1

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x180;
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>);

    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        exception.syndrome&lt;24&gt;   = VSESR_EL2.IDS;
        exception.syndrome&lt;23:0&gt; = VSESR_EL2.ISS;
    else
        impdef_syndrome = syndrome&lt;24&gt; == '1';
        if impdef_syndrome then exception.syndrome = syndrome;

    <a href="shared_pseudocode.html#impl-shared.ClearPendingVirtualSError.0" title="function: ClearPendingVirtualSError()">ClearPendingVirtualSError</a>();
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64.BreakpointException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64.BreakpointException</h3>
      <p class="pseudocode">// AArch64.BreakpointException()
// =============================

<a id="AArch64.BreakpointException.1"/>AArch64.BreakpointException(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    vaddress = bits(64) UNKNOWN;
    exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>, fault, vaddress);

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64.SoftwareBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64.SoftwareBreakpoint</h3>
      <p class="pseudocode">// AArch64.SoftwareBreakpoint()
// ============================

<a id="AArch64.SoftwareBreakpoint.1"/>AArch64.SoftwareBreakpoint(bits(16) immediate)

    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp;
                    <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64.SoftwareStepException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64.SoftwareStepException</h3>
      <p class="pseudocode">// AArch64.SoftwareStepException()
// ===============================

<a id="AArch64.SoftwareStepException.0"/>AArch64.SoftwareStepException()
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>);
    if <a href="shared_pseudocode.html#impl-shared.SoftwareStep_DidNotStep.0" title="function: boolean SoftwareStep_DidNotStep()">SoftwareStep_DidNotStep</a>() then
        exception.syndrome&lt;24&gt; = '0';
    else
        exception.syndrome&lt;24&gt; = '1';
        exception.syndrome&lt;6&gt; = if <a href="shared_pseudocode.html#impl-shared.SoftwareStep_SteppedEX.0" title="function: boolean SoftwareStep_SteppedEX()">SoftwareStep_SteppedEX</a>() then '1' else '0';
    exception.syndrome&lt;5:0&gt; = '100010';                // IFSC = Debug Exception

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64.VectorCatchException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64.VectorCatchException</h3>
      <p class="pseudocode">// AArch64.VectorCatchException()
// ==============================
// Vector Catch taken from EL0 or EL1 to EL2. This can only be called when debug exceptions are
// being routed to EL2, as Vector Catch is a legacy debug event.

<a id="AArch64.VectorCatchException.1"/>AArch64.VectorCatchException(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    assert <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1');

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    vaddress = bits(64) UNKNOWN;
    exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_VectorCatch" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_VectorCatch</a>, fault, vaddress);

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.debug.AArch64.WatchpointException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/debug/AArch64.WatchpointException</h3>
      <p class="pseudocode">// AArch64.WatchpointException()
// =============================

<a id="AArch64.WatchpointException.2"/>AArch64.WatchpointException(bits(64) vaddress, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    route_to_el2 = (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || MDCR_EL2.TDE == '1'));

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_NV2Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>, fault, vaddress);
    else
        exception = <a href="shared_pseudocode.html#AArch64.AbortSyndrome.3" title="function: ExceptionRecord AArch64.AbortSyndrome(Exception exceptype, FaultRecord fault, bits(64) vaddress)">AArch64.AbortSyndrome</a>(<a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>, fault, vaddress);

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64.ExceptionClass"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64.ExceptionClass</h3>
      <p class="pseudocode">// AArch64.ExceptionClass()
// ========================
// Returns the Exception Class and Instruction Length fields to be reported in ESR

(integer,bit) <a id="AArch64.ExceptionClass.2"/>AArch64.ExceptionClass(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype, bits(2) target_el)

    il_is_valid = TRUE;
    from_32 = <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    case exceptype of
        when <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>        ec = 0x00; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>              ec = 0x01;
        when <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>           ec = 0x03; assert from_32;
        when <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>          ec = 0x04; assert from_32;
        when <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>           ec = 0x05; assert from_32;
        when <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>           ec = 0x06; assert from_32;
        when <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>  ec = 0x07;
        when <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>             ec = 0x08;
        when <a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>              ec = 0x09;
        when <a href="shared_pseudocode.html#Exception_LDST64BTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_LDST64BTrap</a>          ec = 0x0A;
        when <a href="shared_pseudocode.html#Exception_TSTARTAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_TSTARTAccessTrap</a>     ec = 0x1B;
        when <a href="shared_pseudocode.html#Exception_GPC" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_GPC</a>                  ec = 0x1E;
        when <a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>          ec = 0x0C; assert from_32;
        when <a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>         ec = 0x0D;
        when <a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>         ec = 0x0E; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>       ec = 0x11;
        when <a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>       ec = 0x12;
        when <a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>          ec = 0x13;
        when <a href="shared_pseudocode.html#Exception_SystemRegisterTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SystemRegisterTrap</a>   ec = 0x18; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SVEAccessTrap</a>        ec = 0x19; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_ERetTrap</a>             ec = 0x1A; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_PACFail" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACFail</a>              ec = 0x1C; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_SMEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SMEAccessTrap</a>        ec = 0x1D; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>     ec = 0x20; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>          ec = 0x22; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>            ec = 0x24;
        when <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>         ec = 0x25;
        when <a href="shared_pseudocode.html#Exception_SPAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SPAlignment</a>          ec = 0x26; il_is_valid = FALSE; assert !from_32;
        when <a href="shared_pseudocode.html#Exception_MemCpyMemSet" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</a>         ec = 0x27;
        when <a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>   ec = 0x28;
        when <a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>               ec = 0x2F; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>           ec = 0x30; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>         ec = 0x32; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>           ec = 0x34; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_NV2Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>        ec = 0x35; il_is_valid = FALSE;
        when <a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>   ec = 0x38;
        when <a href="shared_pseudocode.html#Exception_VectorCatch" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_VectorCatch</a>          ec = 0x3A; il_is_valid = FALSE; assert from_32;
        otherwise                           <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    if ec IN {0x20,0x24,0x30,0x32,0x34} &amp;&amp; target_el == PSTATE.EL then
        ec = ec + 1;

    if ec IN {0x11,0x12,0x13,0x28,0x38} &amp;&amp; !from_32 then
        ec = ec + 4;
    if il_is_valid then
        il = if <a href="shared_pseudocode.html#impl-shared.ThisInstrLength.0" title="function: integer ThisInstrLength()">ThisInstrLength</a>() == 32 then '1' else '0';
    else
        il = '1';
    assert from_32 || il == '1';            // AArch64 instructions always 32-bit

    return (ec,il);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64.ReportException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64.ReportException</h3>
      <p class="pseudocode">// AArch64.ReportException()
// =========================
// Report syndrome information for exception taken to AArch64 state.

<a id="AArch64.ReportException.2"/>AArch64.ReportException(<a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception, bits(2) target_el)

    <a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype = exception.exceptype;

    (ec,il) = <a href="shared_pseudocode.html#AArch64.ExceptionClass.2" title="function: (integer,bit) AArch64.ExceptionClass(Exception exceptype, bits(2) target_el)">AArch64.ExceptionClass</a>(exceptype, target_el);
    iss = exception.syndrome;
    iss2 = exception.syndrome2;

    // IL is not valid for Data Abort exceptions without valid instruction syndrome information
    if ec IN {0x24,0x25} &amp;&amp; iss&lt;24&gt; == '0' then
        il = '1';

    <a href="shared_pseudocode.html#impl-aarch64.ESR.write.1" title="accessor: ESR[bits(2) regime] = ESRType value">ESR</a>[target_el] = (<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(27) :   // &lt;63:37&gt;
                      iss2      :   // &lt;36:32&gt;
                      ec&lt;5:0&gt;   :   // &lt;31:26&gt;
                      il        :   // &lt;25&gt;
                      iss);         // &lt;24:0&gt;

    if exceptype IN {
        <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>,
        <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>,
        <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>,
        <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a>,
        <a href="shared_pseudocode.html#Exception_NV2Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2Watchpoint</a>,
        <a href="shared_pseudocode.html#Exception_GPC" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_GPC</a>,
        <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>
    } then
        <a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value">FAR</a>[target_el] = exception.vaddress;
    else
        <a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value">FAR</a>[target_el] = bits(64) UNKNOWN;

    if exception.ipavalid then
        HPFAR_EL2&lt;43:4&gt; = exception.ipaddress&lt;51:12&gt;;
        if <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
            HPFAR_EL2.NS = exception.NS;
        else
            HPFAR_EL2.NS = '0';
    elsif target_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        HPFAR_EL2&lt;43:4&gt; = bits(40) UNKNOWN;

    if exception.exceptype == <a href="shared_pseudocode.html#Exception_GPC" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_GPC</a> then
        MFAR_EL3.FPA = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(exception.paddress.address&lt;<a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>()-1:12&gt;);
        case exception.paddress.paspace of
            when <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>     MFAR_EL3.&lt;NSE,NS&gt; = '00';
            when <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>  MFAR_EL3.&lt;NSE,NS&gt; = '01';
            when <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>       MFAR_EL3.&lt;NSE,NS&gt; = '10';
            when <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>      MFAR_EL3.&lt;NSE,NS&gt; = '11';
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64.ResetControlRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64.ResetControlRegisters</h3>
      <p class="pseudocode">// Resets System registers and memory-mapped control registers that have architecturally-defined
// reset values to those values.
<a id="AArch64.ResetControlRegisters.1"/>AArch64.ResetControlRegisters(boolean cold_reset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.exceptions.AArch64.TakeReset"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/exceptions/AArch64.TakeReset</h3>
      <p class="pseudocode">// AArch64.TakeReset()
// ===================
// Reset into AArch64 state

<a id="AArch64.TakeReset.1"/>AArch64.TakeReset(boolean cold_reset)
    assert <a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>();

    // Enter the highest implemented Exception level in AArch64 state
    PSTATE.nRW = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        PSTATE.EL = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        PSTATE.EL = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        PSTATE.EL = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    // Reset System registers and other system components
    <a href="shared_pseudocode.html#AArch64.ResetControlRegisters.1" title="function: AArch64.ResetControlRegisters(boolean cold_reset)">AArch64.ResetControlRegisters</a>(cold_reset);

    // Reset all other PSTATE fields
    PSTATE.SP = '1';              // Select stack pointer
    PSTATE.&lt;D,A,I,F&gt;  = '1111';   // All asynchronous exceptions masked
    PSTATE.SS = '0';              // Clear software step bit
    PSTATE.DIT = '0';             // PSTATE.DIT is reset to 0 when resetting into AArch64
    PSTATE.IL = '0';              // Clear Illegal Execution state bit

    TSTATE.depth = 0;             // Non-transactional state

    // All registers, bits and fields not reset by the above pseudocode or by the BranchTo() call
    // below are UNKNOWN bitstrings after reset. In particular, the return information registers
    // ELR_ELx and SPSR_ELx have UNKNOWN values, so that it
    // is impossible to return from a reset in an architecturally defined way.
    <a href="shared_pseudocode.html#AArch64.ResetGeneralRegisters.0" title="function: AArch64.ResetGeneralRegisters()">AArch64.ResetGeneralRegisters</a>();
    <a href="shared_pseudocode.html#AArch64.ResetSIMDFPRegisters.0" title="function: AArch64.ResetSIMDFPRegisters()">AArch64.ResetSIMDFPRegisters</a>();
    <a href="shared_pseudocode.html#AArch64.ResetSpecialRegisters.0" title="function: AArch64.ResetSpecialRegisters()">AArch64.ResetSpecialRegisters</a>();
    <a href="shared_pseudocode.html#impl-shared.ResetExternalDebugRegisters.1" title="function: ResetExternalDebugRegisters(boolean cold_reset)">ResetExternalDebugRegisters</a>(cold_reset);

    bits(64) rv;                      // IMPLEMENTATION DEFINED reset vector

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        rv = RVBAR_EL3;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        rv = RVBAR_EL2;
    else
        rv = RVBAR_EL1;

    // The reset vector must be correctly aligned
    assert <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(rv&lt;63:<a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>()&gt;) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(rv&lt;1:0&gt;);

    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(rv, <a href="shared_pseudocode.html#BranchType_RESET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RESET</a>, branch_conditional);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.ieeefp.AArch64.FPTrappedException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/ieeefp/AArch64.FPTrappedException</h3>
      <p class="pseudocode">// AArch64.FPTrappedException()
// ============================

<a id="AArch64.FPTrappedException.2"/>AArch64.FPTrappedException(boolean is_ase, bits(8) accumulated_exceptions)
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FPTrappedException" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPTrappedException</a>);
    if is_ase then
        if boolean IMPLEMENTATION_DEFINED "vector instructions set TFV to 1" then
            exception.syndrome&lt;23&gt; = '1';                          // TFV
        else
            exception.syndrome&lt;23&gt; = '0';                          // TFV
    else
        exception.syndrome&lt;23&gt; = '1';                              // TFV
    exception.syndrome&lt;10:8&gt; = bits(3) UNKNOWN;                    // VECITR
    if exception.syndrome&lt;23&gt; == '1' then
        exception.syndrome&lt;7,4:0&gt; = accumulated_exceptions&lt;7,4:0&gt;; // IDF,IXF,UFF,OFF,DZF,IOF
    else
        exception.syndrome&lt;7,4:0&gt; = bits(6) UNKNOWN;

    route_to_el2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.syscalls.AArch64.CallHypervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/syscalls/AArch64.CallHypervisor</h3>
      <p class="pseudocode">// AArch64.CallHypervisor()
// ========================
// Performs a HVC call

<a id="AArch64.CallHypervisor.1"/>AArch64.CallHypervisor(bits(16) immediate)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_HypervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_HypervisorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.syscalls.AArch64.CallSecureMonitor"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/syscalls/AArch64.CallSecureMonitor</h3>
      <p class="pseudocode">// AArch64.CallSecureMonitor()
// ===========================

<a id="AArch64.CallSecureMonitor.1"/>AArch64.CallSecureMonitor(bits(16) immediate)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.syscalls.AArch64.CallSupervisor"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/syscalls/AArch64.CallSupervisor</h3>
      <p class="pseudocode">// AArch64.CallSupervisor()
// ========================
// Calls the Supervisor

<a id="AArch64.CallSupervisor.1"/>AArch64.CallSupervisor(bits(16) immediate)

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then <a href="shared_pseudocode.html#AArch32.ITAdvance.0" title="function: AArch32.ITAdvance()">AArch32.ITAdvance</a>();
    <a href="shared_pseudocode.html#impl-shared.SSAdvance.0" title="function: SSAdvance()">SSAdvance</a>();
    route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.NextInstrAddr.0" title="function: bits(N) NextInstrAddr()">NextInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
    exception.syndrome&lt;15:0&gt; = immediate;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.takeexception.AArch64.TakeException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/takeexception/AArch64.TakeException</h3>
      <p class="pseudocode">// AArch64.TakeException()
// =======================
// Take an exception to an Exception level using AArch64.

<a id="AArch64.TakeException.4"/>AArch64.TakeException(bits(2) target_el, <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception,
                      bits(64) preferred_exception_return, integer vect_offset)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    if <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() then
        sync_errors = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.1" title="accessor: SCTLRType SCTLR[bits(2) regime]">SCTLR</a>[target_el].IESB == '1';
        if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            sync_errors = sync_errors || (SCR_EL3.&lt;EA,NMEA&gt; == '11' &amp;&amp; target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        if sync_errors &amp;&amp; <a href="shared_pseudocode.html#impl-shared.InsertIESBBeforeException.1" title="function: boolean InsertIESBBeforeException(bits(2) el)">InsertIESBBeforeException</a>(target_el) then
            <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();
            iesb_req = FALSE;
            sync_errors = FALSE;
            <a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)">TakeUnmaskedPhysicalSErrorInterrupts</a>(iesb_req);
    else
        sync_errors = FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then
        case exception.exceptype of
            when <a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a> cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>         cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_Watchpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Watchpoint</a>         cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            when <a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>       cause = <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>;
            otherwise                         cause = <a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>;
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(cause, FALSE);

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    // If coming from AArch32 state, the top parts of the X[] registers might be set to zero
    from_32 = <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    if from_32 then <a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()">AArch64.MaybeZeroRegisterUppers</a>();
    <a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)">MaybeZeroSVEUppers</a>(target_el);

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then
        boolean lower_32;
        if target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
                lower_32 = <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
            else
                lower_32 = <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        elsif <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            lower_32 = <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>);
        else
            lower_32 = <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el - 1);
        vect_offset = vect_offset + (if lower_32 then 0x600 else 0x400);

    elsif PSTATE.SP == '1' then
        vect_offset = vect_offset + 0x200;

    bits(64) spsr = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.1" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#AArch64_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch64_NonDebugState</a>);

    if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; (HCR_EL2.&lt;NV,NV1,NV2&gt; == '100' || HCR_EL2.&lt;NV,NV1,NV2&gt; == '111') then
            spsr&lt;3:2&gt; = '10';
        else
            if <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.&lt;NV,NV1&gt; == '10' then
                spsr&lt;3:2&gt; = '10';

    if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        // SPSR[].BTYPE is only guaranteed valid for these exception types
        if exception.exceptype IN {<a href="shared_pseudocode.html#Exception_SError" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SError</a>, <a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>, <a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>,
                              <a href="shared_pseudocode.html#Exception_SoftwareStep" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareStep</a>, <a href="shared_pseudocode.html#Exception_PCAlignment" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PCAlignment</a>,
                              <a href="shared_pseudocode.html#Exception_InstructionAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_InstructionAbort</a>, <a href="shared_pseudocode.html#Exception_Breakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Breakpoint</a>,
                              <a href="shared_pseudocode.html#Exception_VectorCatch" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_VectorCatch</a>, <a href="shared_pseudocode.html#Exception_SoftwareBreakpoint" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SoftwareBreakpoint</a>,
                              <a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>, <a href="shared_pseudocode.html#Exception_BranchTarget" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_BranchTarget</a>} then
            zero_btype = FALSE;
        else
            zero_btype = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ZEROBTYPE</a>);
        if zero_btype then spsr&lt;11:10&gt; = '00';

    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; exception.exceptype == <a href="shared_pseudocode.html#Exception_NV2DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_NV2DataAbort</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        // External aborts are configured to be taken to EL3
        exception.exceptype = <a href="shared_pseudocode.html#Exception_DataAbort" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_DataAbort</a>;
    if !(exception.exceptype IN {<a href="shared_pseudocode.html#Exception_IRQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IRQ</a>, <a href="shared_pseudocode.html#Exception_FIQ" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FIQ</a>}) then
        <a href="shared_pseudocode.html#AArch64.ReportException.2" title="function: AArch64.ReportException(ExceptionRecord exception, bits(2) target_el)">AArch64.ReportException</a>(exception, target_el);

    if <a href="shared_pseudocode.html#impl-shared.HaveBRBExt.0" title="function: boolean HaveBRBExt()">HaveBRBExt</a>() then
        <a href="shared_pseudocode.html#impl-aarch64.BRBEException.4" title="function: BRBEException(Exception exception, bits(64) preferred_exception_return,&#13; bits(64) target_address, bits(2) target_el)">BRBEException</a>(exception.exceptype, preferred_exception_return,
                      <a href="shared_pseudocode.html#impl-aarch64.VBAR.read.1" title="accessor: bits(64) VBAR[bits(2) regime]">VBAR</a>[target_el]&lt;63:11&gt;:vect_offset&lt;10:0&gt;, target_el);

    if <a href="shared_pseudocode.html#impl-shared.HaveETExt.0" title="function: boolean HaveETExt()">HaveETExt</a>() then
        TraceException(exception.exceptype, preferred_exception_return,
                      <a href="shared_pseudocode.html#impl-aarch64.VBAR.read.1" title="accessor: bits(64) VBAR[bits(2) regime]">VBAR</a>[target_el]&lt;63:11&gt;:vect_offset&lt;10:0&gt;);

    PSTATE.EL = target_el;
    PSTATE.nRW = '0';
    PSTATE.SP = '1';

    <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = spsr;
    <a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value">ELR</a>[] = preferred_exception_return;

    PSTATE.SS = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveFeatNMI.0" title="function: boolean HaveFeatNMI()">HaveFeatNMI</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) then PSTATE.ALLINT = NOT <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SPINTMASK;
    PSTATE.&lt;D,A,I,F&gt; = '1111';
    PSTATE.IL = '0';
    if from_32 then                             // Coming from AArch32
        PSTATE.IT = '00000000';
        PSTATE.T = '0';                         // PSTATE.J is RES0
    if (<a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>))) &amp;&amp;
        <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SPAN == '0') then
        PSTATE.PAN = '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = '00';
    if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].DSSBS;
    if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = '1';

    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(<a href="shared_pseudocode.html#impl-aarch64.VBAR.read.0" title="accessor: bits(64) VBAR[]">VBAR</a>[]&lt;63:11&gt;:vect_offset&lt;10:0&gt;, <a href="shared_pseudocode.html#BranchType_EXCEPTION" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_EXCEPTION</a>, branch_conditional);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(TRUE);                  // Check for debug event on exception entry

    if sync_errors then
        <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();
        iesb_req = TRUE;
        <a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)">TakeUnmaskedPhysicalSErrorInterrupts</a>(iesb_req);

    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.AArch32SystemAccessTrap</h3>
      <p class="pseudocode">// AArch64.AArch32SystemAccessTrap()
// =================================
// Trapped AARCH32 system register access.

<a id="AArch64.AArch32SystemAccessTrap.2"/>AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch64.AArch32SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch64.AArch32SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.AArch32SystemAccessTrapSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.AArch32SystemAccessTrapSyndrome</h3>
      <p class="pseudocode">// AArch64.AArch32SystemAccessTrapSyndrome()
// =========================================
// Returns the syndrome information for traps on AArch32 MCR, MCRR, MRC, MRRC, and VMRS, VMSR instructions,
// other than traps that are due to HCPTR or CPACR.

ExceptionRecord <a id="AArch64.AArch32SystemAccessTrapSyndrome.2"/>AArch64.AArch32SystemAccessTrapSyndrome(bits(32) instr, integer ec)
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception;

    case ec of
        when 0x0    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        when 0x3    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>);
        when 0x4    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>);
        when 0x5    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>);
        when 0x6    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a>);
        when 0x7    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
        when 0x8    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>);
        when 0xC    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>);
        otherwise   <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    bits(20) iss = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    if exception.exceptype == <a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a> then
        return exception;
    elsif exception.exceptype IN {<a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a>, <a href="shared_pseudocode.html#Exception_CP14RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RTTrap</a>, <a href="shared_pseudocode.html#Exception_CP15RTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RTTrap</a>} then
        // Trapped MRC/MCR, VMRS on FPSID
        if exception.exceptype != <a href="shared_pseudocode.html#Exception_FPIDTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_FPIDTrap</a> then    // When trap is not for VMRS
            iss&lt;19:17&gt; = instr&lt;7:5&gt;;           // opc2
            iss&lt;16:14&gt; = instr&lt;23:21&gt;;         // opc1
            iss&lt;13:10&gt; = instr&lt;19:16&gt;;         // CRn
            iss&lt;4:1&gt;   = instr&lt;3:0&gt;;           // CRm
        else
            iss&lt;19:17&gt; = '000';
            iss&lt;16:14&gt; = '111';
            iss&lt;13:10&gt; = instr&lt;19:16&gt;;         // reg
            iss&lt;4:1&gt;   = '0000';

        if instr&lt;20&gt; == '1' &amp;&amp; instr&lt;15:12&gt; == '1111' then    // MRC, Rt==15
            iss&lt;9:5&gt; = '11111';
        elsif instr&lt;20&gt; == '0' &amp;&amp; instr&lt;15:12&gt; == '1111' then // MCR, Rt==15
            iss&lt;9:5&gt; = bits(5) UNKNOWN;
        else
            iss&lt;9:5&gt; = LookUpRIndex(UInt(instr&lt;15:12&gt;), PSTATE.M)&lt;4:0&gt;;
    elsif exception.exceptype IN {<a href="shared_pseudocode.html#Exception_CP14RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14RRTTrap</a>, <a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>, <a href="shared_pseudocode.html#Exception_CP15RRTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP15RRTTrap</a>} then
        // Trapped MRRC/MCRR, VMRS/VMSR
        iss&lt;19:16&gt; = instr&lt;7:4&gt;;          // opc1
        if instr&lt;19:16&gt; == '1111' then    // Rt2==15
            iss&lt;14:10&gt; = bits(5) UNKNOWN;
        else
            iss&lt;14:10&gt; = LookUpRIndex(UInt(instr&lt;19:16&gt;), PSTATE.M)&lt;4:0&gt;;

        if instr&lt;15:12&gt; == '1111' then    // Rt==15
            iss&lt;9:5&gt; = bits(5) UNKNOWN;
        else
            iss&lt;9:5&gt; = LookUpRIndex(UInt(instr&lt;15:12&gt;), PSTATE.M)&lt;4:0&gt;;
        iss&lt;4:1&gt;   = instr&lt;3:0&gt;;         // CRm
    elsif exception.exceptype == <a href="shared_pseudocode.html#Exception_CP14DTTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_CP14DTTrap</a> then
        // Trapped LDC/STC
        iss&lt;19:12&gt; = instr&lt;7:0&gt;;         // imm8
        iss&lt;4&gt;     = instr&lt;23&gt;;          // U
        iss&lt;2:1&gt;   = instr&lt;24,21&gt;;       // P,W
        if instr&lt;19:16&gt; == '1111' then   // Rn==15, LDC(Literal addressing)/STC
            iss&lt;9:5&gt; = bits(5) UNKNOWN;
            iss&lt;3&gt;   = '1';
    iss&lt;0&gt; = instr&lt;20&gt;;                  // Direction

    exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
    exception.syndrome&lt;19:0&gt;  = iss;

    return exception;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.AdvSIMDFPAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.AdvSIMDFPAccessTrap</h3>
      <p class="pseudocode">// AArch64.AdvSIMDFPAccessTrap()
// =============================
// Trapped access to Advanced SIMD or FP registers due to CPACR[].

<a id="AArch64.AdvSIMDFPAccessTrap.1"/>AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    route_to_el2 = (target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1');

    if route_to_el2 then
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
        exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckCP15InstrCoarseTraps"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckCP15InstrCoarseTraps</h3>
      <p class="pseudocode">// AArch64.CheckCP15InstrCoarseTraps()
// ===================================
// Check for coarse-grained AArch32  traps to System registers in the
// coproc=0b1111 encoding space by HSTR_EL2, HCR_EL2, and SCTLR_ELx.

<a id="AArch64.CheckCP15InstrCoarseTraps.3"/>AArch64.CheckCP15InstrCoarseTraps(integer CRn, integer nreg, integer CRm)
    trapped_encoding = ((CRn == 9  &amp;&amp; CRm IN {0,1,2,    5,6,7,8   }) ||
                        (CRn == 10 &amp;&amp; CRm IN {0,1,    4,      8   }) ||
                        (CRn == 11 &amp;&amp; CRm IN {0,1,2,3,4,5,6,7,8,15}));

    // Check for MRC and MCR disabled by SCTLR_EL1.TIDCP.
    if (<a href="shared_pseudocode.html#impl-shared.HaveFeatTIDCP1.0" title="function: boolean HaveFeatTIDCP1()">HaveFeatTIDCP1</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp;
           !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; SCTLR_EL1.TIDCP == '1' &amp;&amp; trapped_encoding) then
        if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
            <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, 0x3);
        else
            <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, 0x3);

    // Check for coarse-grained Hyp traps
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        // Check for MRC and MCR disabled by SCTLR_EL2.TIDCP.
        if (<a href="shared_pseudocode.html#impl-shared.HaveFeatTIDCP1.0" title="function: boolean HaveFeatTIDCP1()">HaveFeatTIDCP1</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp;
                SCTLR_EL2.TIDCP == '1' &amp;&amp; trapped_encoding) then
            <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, 0x3);

        major = if nreg == 1 then CRn else CRm;
        // Check for MCR, MRC, MCRR, and MRRC disabled by HSTR_EL2&lt;CRn/CRm&gt;
        // and MRC and MCR disabled by HCR_EL2.TIDCP.
        if ((!<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; !(major IN {4,14}) &amp;&amp; HSTR_EL2&lt;major&gt; == '1') ||
                (HCR_EL2.TIDCP == '1' &amp;&amp; nreg == 1 &amp;&amp; trapped_encoding)) then
            if (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp;
                    boolean IMPLEMENTATION_DEFINED "UNDEF unallocated CP15 access at <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>") then
                UNDEFINED;
            <a href="shared_pseudocode.html#AArch64.AArch32SystemAccessTrap.2" title="function: AArch64.AArch32SystemAccessTrap(bits(2) target_el, integer ec)">AArch64.AArch32SystemAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, 0x3);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckFPAdvSIMDEnabled</h3>
      <p class="pseudocode">// AArch64.CheckFPAdvSIMDEnabled()
// ===============================

<a id="AArch64.CheckFPAdvSIMDEnabled.0"/>AArch64.CheckFPAdvSIMDEnabled()
    <a href="shared_pseudocode.html#AArch64.CheckFPEnabled.0" title="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();
    // Check for illegal use of Advanced
    // SIMD in Streaming SVE Mode
    if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.IsFullA64Enabled.0" title="function: boolean IsFullA64Enabled()">IsFullA64Enabled</a>() then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_Streaming" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_Streaming</a>, PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckFPAdvSIMDTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckFPAdvSIMDTrap</h3>
      <p class="pseudocode">// AArch64.CheckFPAdvSIMDTrap()
// ============================
// Check against CPTR_EL2 and CPTR_EL3.

<a id="AArch64.CheckFPAdvSIMDTrap.0"/>AArch64.CheckFPAdvSIMDTrap()
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        // Check if access disabled in CPTR_EL2
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            case CPTR_EL2.FPEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        else
            if CPTR_EL2.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckFPEnabled</h3>
      <p class="pseudocode">// AArch64.CheckFPEnabled()
// ========================
// Check against CPACR[]

<a id="AArch64.CheckFPEnabled.0"/>AArch64.CheckFPEnabled()
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check if access disabled in CPACR_EL1
        case CPACR_EL1.FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDTrap.0" title="function: AArch64.CheckFPAdvSIMDTrap()">AArch64.CheckFPAdvSIMDTrap</a>();               // Also check against CPTR_EL2 and CPTR_EL3</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckForERetTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckForERetTrap</h3>
      <p class="pseudocode">// AArch64.CheckForERetTrap()
// ==========================
// Check for trap on ERET, ERETAA, ERETAB instruction

<a id="AArch64.CheckForERetTrap.2"/>AArch64.CheckForERetTrap(boolean eret_with_pac, boolean pac_uses_key_a)

    route_to_el2 = FALSE;
    // Non-secure EL1 execution of ERET, ERETAA, ERETAB when either HCR_EL2.NV or HFGITR_EL2.ERET is set,
    // is trapped to EL2
    route_to_el2 = (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                   ((<a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.NV == '1') ||
                   (<a href="shared_pseudocode.html#impl-shared.HaveFGTExt.0" title="function: boolean HaveFGTExt()">HaveFGTExt</a>() &amp;&amp; HCR_EL2.&lt;E2H, TGE&gt; != '11' &amp;&amp;
                   (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGITR_EL2.ERET == '1')));
    if route_to_el2 then
        <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception;
        bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        vect_offset = 0x0;
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_ERetTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_ERetTrap</a>);
        if !eret_with_pac then                             // ERET
            exception.syndrome&lt;1&gt; = '0';
            exception.syndrome&lt;0&gt; = '0';                   // RES0
        else
            exception.syndrome&lt;1&gt; = '1';
            if pac_uses_key_a then                         // ERETAA
                exception.syndrome&lt;0&gt; = '0';
            else    // ERETAB
                exception.syndrome&lt;0&gt; = '1';
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckForSMCUndefOrTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckForSMCUndefOrTrap</h3>
      <p class="pseudocode">// AArch64.CheckForSMCUndefOrTrap()
// ================================
// Check for UNDEFINED or trap on SMC instruction

<a id="AArch64.CheckForSMCUndefOrTrap.1"/>AArch64.CheckForSMCUndefOrTrap(bits(16) imm)
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then UNDEFINED;
    if (!(PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TSC == '1') &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.SMD == '1') then
        UNDEFINED;
    route_to_el2 = FALSE;
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            if <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.NV == '1' &amp;&amp; HCR_EL2.TSC == '1' then
                route_to_el2 = TRUE;
            else
                UNDEFINED;
        else
            UNDEFINED;
    else
        route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TSC == '1';
    if route_to_el2 then
        bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        vect_offset = 0x0;
        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_MonitorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MonitorCall</a>);
        exception.syndrome&lt;15:0&gt; = imm;
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckForSVCTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckForSVCTrap</h3>
      <p class="pseudocode">// AArch64.CheckForSVCTrap()
// =========================
// Check for trap on SVC instruction

<a id="AArch64.CheckForSVCTrap.1"/>AArch64.CheckForSVCTrap(bits(16) immediate)
    if <a href="shared_pseudocode.html#impl-shared.HaveFGTExt.0" title="function: boolean HaveFGTExt()">HaveFGTExt</a>() then
        route_to_el2 = FALSE;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            route_to_el2 = (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)  &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HFGITR_EL2.SVC_EL0 == '1' &amp;&amp;
                           (HCR_EL2.&lt;E2H, TGE&gt; != '11' &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1')));

        elsif PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
            route_to_el2 = (!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HFGITR_EL2.SVC_EL1 == '1' &amp;&amp;
                           (HCR_EL2.&lt;E2H, TGE&gt; != '11' &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.FGTEn == '1')));

        if route_to_el2 then
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SupervisorCall" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SupervisorCall</a>);
            exception.syndrome&lt;15:0&gt; = immediate;
            bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
            vect_offset = 0x0;

            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckForWFxTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckForWFxTrap</h3>
      <p class="pseudocode">// AArch64.CheckForWFxTrap()
// =========================
// Check for trap on WFE or WFI instruction

<a id="AArch64.CheckForWFxTrap.2"/>AArch64.CheckForWFxTrap(bits(2) target_el, <a href="shared_pseudocode.html#WFxType" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el);

    boolean is_wfe = wfxtype IN {<a href="shared_pseudocode.html#WFxType_WFE" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>, <a href="shared_pseudocode.html#WFxType_WFET" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFET</a>};
    case target_el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            trap = (if is_wfe then <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].nTWE else <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].nTWI) == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            trap = (if is_wfe then HCR_EL2.TWE else HCR_EL2.TWI) == '1';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            trap = (if is_wfe then SCR_EL3.TWE else SCR_EL3.TWI) == '1';

    if trap then
        <a href="shared_pseudocode.html#AArch64.WFxTrap.2" title="function: AArch64.WFxTrap(WFxType wfxtype, bits(2) target_el)">AArch64.WFxTrap</a>(wfxtype, target_el);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.CheckIllegalState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.CheckIllegalState</h3>
      <p class="pseudocode">// AArch64.CheckIllegalState()
// ===========================
// Check PSTATE.IL bit and generate Illegal Execution state exception if set.

<a id="AArch64.CheckIllegalState.0"/>AArch64.CheckIllegalState()
    if PSTATE.IL == '1' then
        route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

        bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        vect_offset = 0x0;

        exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_IllegalState" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_IllegalState</a>);

        if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
        elsif route_to_el2 then
            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
        else
            <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.MonitorModeTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.MonitorModeTrap</h3>
      <p class="pseudocode">// AArch64.MonitorModeTrap()
// =========================
// Trapped use of Monitor mode features in a Secure EL1 AArch32 mode

<a id="AArch64.MonitorModeTrap.0"/>AArch64.MonitorModeTrap()
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);

    if <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.SystemAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.SystemAccessTrap</h3>
      <p class="pseudocode">// AArch64.SystemAccessTrap()
// ==========================
// Trapped access to AArch64 system register or system instruction.

<a id="AArch64.SystemAccessTrap.2"/>AArch64.SystemAccessTrap(bits(2) target_el, integer ec)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#AArch64.SystemAccessTrapSyndrome.2" title="function: ExceptionRecord AArch64.SystemAccessTrapSyndrome(bits(32) instr, integer ec)">AArch64.SystemAccessTrapSyndrome</a>(<a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>(), ec);
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.SystemAccessTrapSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.SystemAccessTrapSyndrome</h3>
      <p class="pseudocode">// AArch64.SystemAccessTrapSyndrome()
// ==================================
// Returns the syndrome information for traps on AArch64 MSR/MRS instructions.

ExceptionRecord <a id="AArch64.SystemAccessTrapSyndrome.2"/>AArch64.SystemAccessTrapSyndrome(bits(32) instr, integer ec)
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception;
    case ec of
        when 0x0                                                     // Trapped access due to unknown reason.
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);
        when 0x7                                                     // Trapped access to SVE, Advance SIMD&amp;FP system register.
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_AdvSIMDFPAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_AdvSIMDFPAccessTrap</a>);
            exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();
        when 0x18                                                    // Trapped access to system register or system instruction.
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SystemRegisterTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SystemRegisterTrap</a>);
            instr = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>();
            exception.syndrome&lt;21:20&gt; = instr&lt;20:19&gt;;          // Op0
            exception.syndrome&lt;19:17&gt; = instr&lt;7:5&gt;;            // Op2
            exception.syndrome&lt;16:14&gt; = instr&lt;18:16&gt;;          // Op1
            exception.syndrome&lt;13:10&gt; = instr&lt;15:12&gt;;          // CRn
            exception.syndrome&lt;9:5&gt;   = instr&lt;4:0&gt;;            // Rt
            exception.syndrome&lt;4:1&gt;   = instr&lt;11:8&gt;;           // CRm
            exception.syndrome&lt;0&gt;     = instr&lt;21&gt;;             // Direction
        when 0x19                                                    // Trapped access to SVE System register
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SVEAccessTrap</a>);
        when 0x1D                                                    // Trapped access to SME System register
            exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SMEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SMEAccessTrap</a>);
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    return exception;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.UndefinedFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.UndefinedFault</h3>
      <p class="pseudocode">// AArch64.UndefinedFault()
// ========================

<a id="AArch64.UndefinedFault.0"/>AArch64.UndefinedFault()

    route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_Uncategorized" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_Uncategorized</a>);

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.AArch64.WFxTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/AArch64.WFxTrap</h3>
      <p class="pseudocode">// AArch64.WFxTrap()
// =================

<a id="AArch64.WFxTrap.2"/>AArch64.WFxTrap(<a href="shared_pseudocode.html#WFxType" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype, bits(2) target_el)
    assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_WFxTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_WFxTrap</a>);
    exception.syndrome&lt;24:20&gt; = <a href="shared_pseudocode.html#impl-shared.ConditionSyndrome.0" title="function: bits(5) ConditionSyndrome()">ConditionSyndrome</a>();

    case wfxtype of
        when <a href="shared_pseudocode.html#WFxType_WFI" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFI</a>
            exception.syndrome&lt;1:0&gt; = '00';
        when <a href="shared_pseudocode.html#WFxType_WFE" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFE</a>
            exception.syndrome&lt;1:0&gt; = '01';
        when <a href="shared_pseudocode.html#WFxType_WFIT" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFIT</a>
            exception.syndrome&lt;1:0&gt; = '10';
            if <a href="shared_pseudocode.html#impl-shared.HaveFeatWFxT2.0" title="function: boolean HaveFeatWFxT2()">HaveFeatWFxT2</a>() then
                exception.syndrome&lt;2&gt;   = '1';   // Register field is valid
                exception.syndrome&lt;9:5&gt; = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>()&lt;4:0&gt;;
            else
                exception.syndrome&lt;2&gt; = '0';     // Register field is invalid
        when <a href="shared_pseudocode.html#WFxType_WFET" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType_WFET</a>
            exception.syndrome&lt;1:0&gt; = '11';
            if <a href="shared_pseudocode.html#impl-shared.HaveFeatWFxT2.0" title="function: boolean HaveFeatWFxT2()">HaveFeatWFxT2</a>() then
                exception.syndrome&lt;2&gt;   = '1';   // Register field is valid
                exception.syndrome&lt;9:5&gt; = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>()&lt;4:0&gt;;
            else
                exception.syndrome&lt;2&gt; = '0';     // Register field is invalid

    if target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckFPAdvSIMDEnabled64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckFPAdvSIMDEnabled64</h3>
      <p class="pseudocode">// CheckFPAdvSIMDEnabled64()
// =========================
// AArch64 instruction wrapper

<a id="impl-aarch64.CheckFPAdvSIMDEnabled64.0"/>CheckFPAdvSIMDEnabled64()
    <a href="shared_pseudocode.html#AArch64.CheckFPAdvSIMDEnabled.0" title="function: AArch64.CheckFPAdvSIMDEnabled()">AArch64.CheckFPAdvSIMDEnabled</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckFPEnabled64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckFPEnabled64</h3>
      <p class="pseudocode">// CheckFPEnabled64()
// ==================
// AArch64 instruction wrapper

<a id="impl-aarch64.CheckFPEnabled64.0"/>CheckFPEnabled64()
    <a href="shared_pseudocode.html#AArch64.CheckFPEnabled.0" title="function: AArch64.CheckFPEnabled()">AArch64.CheckFPEnabled</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckLDST64BEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckLDST64BEnabled</h3>
      <p class="pseudocode">// CheckLDST64BEnabled()
// =====================
// Checks for trap on ST64B and LD64B instructions

<a id="impl-aarch64.CheckLDST64BEnabled.0"/>CheckLDST64BEnabled()
    boolean trap = FALSE;
    bits(25) iss = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>('10');  // 0x2

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        if !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            trap = SCTLR_EL1.EnALS == '0';
            target_el = if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
        else
            trap = SCTLR_EL2.EnALS == '0';
            target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    if (!trap &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatHCX.0" title="function: boolean HaveFeatHCX()">HaveFeatHCX</a>() &amp;&amp;
        ((PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) || PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) then
        trap = !<a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.EnALS == '0';
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if trap then <a href="shared_pseudocode.html#impl-aarch64.LDST64BTrap.2" title="function: LDST64BTrap(bits(2) target_el, bits(25) iss)">LDST64BTrap</a>(target_el, iss);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckST64BV0Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckST64BV0Enabled</h3>
      <p class="pseudocode">// CheckST64BV0Enabled()
// =====================
// Checks for trap on ST64BV0 instruction

<a id="impl-aarch64.CheckST64BV0Enabled.0"/>CheckST64BV0Enabled()
    boolean trap = FALSE;
    bits(25) iss = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>('1');  // 0x1

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        if !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            trap = SCTLR_EL1.EnAS0 == '0';
            target_el = if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
        else
            trap = SCTLR_EL2.EnAS0 == '0';
            target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if (!trap &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatHCX.0" title="function: boolean HaveFeatHCX()">HaveFeatHCX</a>() &amp;&amp;
        ((PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) || PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) then
        trap = !<a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.EnAS0 == '0';
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if !trap &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        trap = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EnAS0 == '0';
        target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    if trap then <a href="shared_pseudocode.html#impl-aarch64.LDST64BTrap.2" title="function: LDST64BTrap(bits(2) target_el, bits(25) iss)">LDST64BTrap</a>(target_el, iss);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.CheckST64BVEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/CheckST64BVEnabled</h3>
      <p class="pseudocode">// CheckST64BVEnabled()
// ====================
// Checks for trap on ST64BV instruction

<a id="impl-aarch64.CheckST64BVEnabled.0"/>CheckST64BVEnabled()
    boolean trap = FALSE;
    bits(25) iss = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        if !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            trap = SCTLR_EL1.EnASR == '0';
            target_el = if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
        else
            trap = SCTLR_EL2.EnASR == '0';
            target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if (!trap &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatHCX.0" title="function: boolean HaveFeatHCX()">HaveFeatHCX</a>() &amp;&amp;
        ((PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) || PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) then
        trap = !<a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.EnASR == '0';
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;

    if trap then <a href="shared_pseudocode.html#impl-aarch64.LDST64BTrap.2" title="function: LDST64BTrap(bits(2) target_el, bits(25) iss)">LDST64BTrap</a>(target_el, iss);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.LDST64BTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/LDST64BTrap</h3>
      <p class="pseudocode">// LDST64BTrap()
// =============
// Trapped access to LD64B, ST64B, ST64BV and ST64BV0 instructions

<a id="impl-aarch64.LDST64BTrap.2"/>LDST64BTrap(bits(2) target_el, bits(25) iss)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_LDST64BTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_LDST64BTrap</a>);
    exception.syndrome = iss;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.WFETrapDelay"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/WFETrapDelay</h3>
      <p class="pseudocode">// WFETrapDelay()
// ==============
// Returns TRUE when delay in trap to WFE is enabled with value to amount of delay,
// FALSE otherwise.

(boolean, integer) <a id="impl-aarch64.WFETrapDelay.1"/>WFETrapDelay(bits(2) target_el)
    case target_el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            if !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
                delay_enabled = SCTLR_EL1.TWEDEn == '1';
                delay         = 1 &lt;&lt; (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SCTLR_EL1.TWEDEL) + 8);
            else
                delay_enabled = SCTLR_EL2.TWEDEn == '1';
                delay         = 1 &lt;&lt; (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SCTLR_EL2.TWEDEL) + 8);
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            assert <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
            delay_enabled = HCR_EL2.TWEDEn == '1';
            delay         = 1 &lt;&lt; (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(HCR_EL2.TWEDEL) + 8);
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            delay_enabled = SCR_EL3.TWEDEn == '1';
            delay         = 1 &lt;&lt; (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SCR_EL3.TWEDEL) + 8);

    return (delay_enabled, delay);</p>
    </div>
    <div class="ps"><a id="aarch64.exceptions.traps.WaitForEventUntilDelay"/><h3 class="pseudocode">
            Library pseudocode for aarch64/exceptions/traps/WaitForEventUntilDelay</h3>
      <p class="pseudocode">// Returns TRUE if WaitForEvent() returns before WFE trap delay expires,
// FALSE otherwise.
boolean <a id="impl-aarch64.WaitForEventUntilDelay.2"/>WaitForEventUntilDelay(boolean delay_enabled, integer delay);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.aborts.AArch64.FaultSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/aborts/AArch64.FaultSyndrome</h3>
      <p class="pseudocode">// AArch64.FaultSyndrome()
// =======================
// Creates an exception syndrome value for Abort and Watchpoint exceptions taken to
// an Exception level using AArch64.

(bits(25), bits(5)) <a id="AArch64.FaultSyndrome.2"/>AArch64.FaultSyndrome(boolean d_side, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    bits(25) iss = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    bits(5) iss2 = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    if !<a href="shared_pseudocode.html#impl-shared.HaveFeatLS64.0" title="function: boolean HaveFeatLS64()">HaveFeatLS64</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault) then
        iss&lt;12:11&gt; = fault.errortype; // SET

    if d_side then
        if <a href="shared_pseudocode.html#impl-shared.HaveFeatLS64.0" title="function: boolean HaveFeatLS64()">HaveFeatLS64</a>() &amp;&amp; fault.acctype == <a href="shared_pseudocode.html#AccType_ATOMICLS64" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a> then
            if (fault.statuscode IN {<a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>,
                <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>, <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>}) then
                (iss2, iss&lt;24:14&gt;, iss&lt;12:11&gt;) = <a href="shared_pseudocode.html#impl-aarch64.LS64InstructionSyndrome.0" title="function: (bits(5), bits(11), bits(2)) LS64InstructionSyndrome()">LS64InstructionSyndrome</a>();
        else
            if (<a href="shared_pseudocode.html#impl-shared.IsSecondStage.1" title="function: boolean IsSecondStage(FaultRecord fault)">IsSecondStage</a>(fault) &amp;&amp; !fault.s2fs1walk &amp;&amp;
                (!<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) ||
                (!<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; fault.acctype == <a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a> &amp;&amp;
                boolean IMPLEMENTATION_DEFINED "ISV on second stage translation table walk"))) then
                iss&lt;24:14&gt; = <a href="shared_pseudocode.html#impl-shared.LSInstructionSyndrome.0" title="function: bits(11) LSInstructionSyndrome()">LSInstructionSyndrome</a>();

        if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; fault.acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
            iss&lt;13&gt; = '1';   // Fault is generated by use of VNCR_EL2

        if fault.acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
            iss&lt;8&gt; = '1';  iss&lt;6&gt; = '1';
        else
            iss&lt;6&gt; = if fault.write then '1' else '0';

    if <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) then iss&lt;9&gt; = fault.extflag;
    iss&lt;7&gt; = if fault.s2fs1walk then '1' else '0';
    iss&lt;5:0&gt; = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);

    return (iss, iss2);

bits(6) <a id="impl-aarch64.EncodeGPCSC.1"/>EncodeGPCSC(<a href="shared_pseudocode.html#GPCFRecord" title="type GPCFRecord is ( GPCF gpf, integer level )">GPCFRecord</a> gpcf)
    assert gpcf.level IN {0,1};

    case gpcf.gpf of
        when <a href="shared_pseudocode.html#GPCF_AddressSize" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_AddressSize</a> return '0000':gpcf.level&lt;1:0&gt;;
        when <a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>        return '0001':gpcf.level&lt;1:0&gt;;
        when <a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a>        return '0011':gpcf.level&lt;1:0&gt;;
        when <a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>        return '1011':gpcf.level&lt;1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.aborts.LS64InstructionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/aborts/LS64InstructionSyndrome</h3>
      <p class="pseudocode">// Returns the syndrome information and LST for a Data Abort by a
// ST64B, ST64BV, ST64BV0, or LD64B instruction. The syndrome information
// includes the ISS2, extended syndrome field, and LST.
(bits(5), bits(11), bits(2)) <a id="impl-aarch64.LS64InstructionSyndrome.0"/>LS64InstructionSyndrome();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cache.AArch64.DataMemZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cache/AArch64.DataMemZero</h3>
      <p class="pseudocode">// AArch64.DataMemZero()
// =====================
// Write Zero to data memory

<a id="AArch64.DataMemZero.4"/>AArch64.DataMemZero(bits(64) regval, bits(64) vaddress, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc, integer size)
    iswrite = TRUE;
    for i = 0 to size-1
        accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(<a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>);
        if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then
            if <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(vaddress, <a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>) then
                bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(vaddress);
                if !<a href="shared_pseudocode.html#AArch64.CheckTag.4" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                    if boolean IMPLEMENTATION_DEFINED "DC_ZVA tag fault reported with lowest faulting address" then
                        <a href="shared_pseudocode.html#AArch64.TagCheckFault.3" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(vaddress, <a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>, iswrite);
                    else
                        <a href="shared_pseudocode.html#AArch64.TagCheckFault.3" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(regval, <a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>, iswrite);
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, 1, accdesc, <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>());
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.cache.AArch64.TagMemZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/cache/AArch64.TagMemZero</h3>
      <p class="pseudocode">// AArch64.TagMemZero()
// ====================
// Write Zero to tag memory

<a id="AArch64.TagMemZero.2"/>AArch64.TagMemZero(bits(64) vaddress, integer size)
    integer count = size &gt;&gt; <a href="shared_pseudocode.html#LOG2_TAG_GRANULE" title="constant integer LOG2_TAG_GRANULE = 4">LOG2_TAG_GRANULE</a>;
    bits(4) tag = <a href="shared_pseudocode.html#AArch64.AllocationTagFromAddress.1" title="function: bits(4) AArch64.AllocationTagFromAddress(bits(64) tagged_address)">AArch64.AllocationTagFromAddress</a>(vaddress);
    for i = 0 to count-1
        <a href="shared_pseudocode.html#AArch64.MemTag.write.2" title="accessor: AArch64.MemTag[bits(64) address, AccType acctype] = bits(4) value">AArch64.MemTag</a>[vaddress, <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>] = tag;
        vaddress = vaddress + <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64.ExclusiveMonitorsPass"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64.ExclusiveMonitorsPass</h3>
      <p class="pseudocode">// AArch64.ExclusiveMonitorsPass()
// ===============================
// Return TRUE if the Exclusives monitors for the current PE include all of the addresses
// associated with the virtual address region of size bytes starting at address.
// The immediately following memory write must be to the same addresses.

boolean <a id="AArch64.ExclusiveMonitorsPass.2"/>AArch64.ExclusiveMonitorsPass(bits(64) address, integer size)

    // It is IMPLEMENTATION DEFINED whether the detection of memory aborts happens
    // before or after the check on the local Exclusives monitor. As a result a failure
    // of the local monitor can occur on some implementations even if the memory
    // access would give an memory abort.

    acctype = <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    iswrite = TRUE;

    aligned = <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);

    passed = <a href="shared_pseudocode.html#AArch64.IsExclusiveVA.3" title="function: boolean AArch64.IsExclusiveVA(bits(64) address, integer processorid, integer size)">AArch64.IsExclusiveVA</a>(address, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);
    if !passed then
        return FALSE;

    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    passed = <a href="shared_pseudocode.html#impl-shared.IsExclusiveLocal.3" title="function: boolean IsExclusiveLocal(FullAddress paddress, integer processorid, integer size)">IsExclusiveLocal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());

    if passed then
        if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
            passed = <a href="shared_pseudocode.html#impl-shared.IsExclusiveGlobal.3" title="function: boolean IsExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">IsExclusiveGlobal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    return passed;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64.IsExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64.IsExclusiveVA</h3>
      <p class="pseudocode">// An optional IMPLEMENTATION DEFINED test for an exclusive access to a virtual
// address region of size bytes starting at address.
//
// It is permitted (but not required) for this function to return FALSE and
// cause a store exclusive to fail if the virtual address region is not
// totally included within the region recorded by MarkExclusiveVA().
//
// It is always safe to return TRUE which will check the physical address only.
boolean <a id="AArch64.IsExclusiveVA.3"/>AArch64.IsExclusiveVA(bits(64) address, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64.MarkExclusiveVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64.MarkExclusiveVA</h3>
      <p class="pseudocode">// Optionally record an exclusive access to the virtual address region of size bytes
// starting at address for processorid.
<a id="AArch64.MarkExclusiveVA.3"/>AArch64.MarkExclusiveVA(bits(64) address, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.exclusive.AArch64.SetExclusiveMonitors"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/exclusive/AArch64.SetExclusiveMonitors</h3>
      <p class="pseudocode">// AArch64.SetExclusiveMonitors()
// ==============================
// Sets the Exclusives monitors for the current PE to record the addresses associated
// with the virtual address region of size bytes starting at address.

<a id="AArch64.SetExclusiveMonitors.2"/>AArch64.SetExclusiveMonitors(bits(64) address, integer size)
    acctype = <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>;
    iswrite = FALSE;

    aligned = <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);

    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        return;

    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.MarkExclusiveGlobal.3" title="function: MarkExclusiveGlobal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveGlobal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a href="shared_pseudocode.html#impl-shared.MarkExclusiveLocal.3" title="function: MarkExclusiveLocal(FullAddress paddress, integer processorid, integer size)">MarkExclusiveLocal</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    <a href="shared_pseudocode.html#AArch64.MarkExclusiveVA.3" title="function: AArch64.MarkExclusiveVA(bits(64) address, integer processorid, integer size)">AArch64.MarkExclusiveVA</a>(address, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fusedrstep.FPRSqrtStepFused"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fusedrstep/FPRSqrtStepFused</h3>
      <p class="pseudocode">// FPRSqrtStepFused()
// ==================

bits(N) <a id="impl-aarch64.FPRSqrtStepFused.2"/>FPRSqrtStepFused(bits(N) op1, bits(N) op2)
    assert N IN {16, 32, 64};
    bits(N) result;
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    op1 = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(op1);
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                         // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             // Flush denormal input and output to zero
    if altfp then fpcr.RMode = '00';                // Use RNE rounding mode

    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.7" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, FALSE, fpexc);
    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPOnePointFive.1" title="function: bits(N) FPOnePointFive(bit sign)">FPOnePointFive</a>('0');
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
        else
            // Fully fused multiply-add and halve
            result_value = (3.0 + (value1 * value2)) / 2.0;
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.fusedrstep.FPRecipStepFused"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/fusedrstep/FPRecipStepFused</h3>
      <p class="pseudocode">// FPRecipStepFused()
// ==================

bits(N) <a id="impl-aarch64.FPRecipStepFused.2"/>FPRecipStepFused(bits(N) op1, bits(N) op2)
    assert N IN {16, 32, 64};
    bits(N) result;
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    op1 = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(op1);

    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                         // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             // Flush denormal input and output to zero
    if altfp then fpcr.RMode    = '00';             // Use RNE rounding mode

    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.7" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, FALSE, fpexc);
    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    if !done then
        inf1  = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2  = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPTwo.1" title="function: bits(N) FPTwo(bit sign)">FPTwo</a>('0');
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
        else
            // Fully fused multiply-add
            result_value = 2.0 + (value1 * value2);
            if result_value == 0.0 then
                // Sign of exact zero result depends on rounding mode
                sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.AccessIsTagChecked"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.AccessIsTagChecked</h3>
      <p class="pseudocode">// AArch64.AccessIsTagChecked()
// ============================
// TRUE if a given access is tag-checked, FALSE otherwise.

boolean <a id="AArch64.AccessIsTagChecked.2"/>AArch64.AccessIsTagChecked(bits(64) vaddr, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    if PSTATE.M&lt;4&gt; == '1' then return FALSE;

    if <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(vaddr, FALSE, PSTATE.EL) == '0' then
        return FALSE;

    if <a href="shared_pseudocode.html#impl-shared.EffectiveTCMA.2" title="function: bit EffectiveTCMA(bits(64) address, bits(2) el)">EffectiveTCMA</a>(vaddr, PSTATE.EL) == '1' &amp;&amp; (vaddr&lt;59:55&gt; == '00000' || vaddr&lt;59:55&gt; == '11111') then
        return FALSE;

    if !<a href="shared_pseudocode.html#AArch64.AllocationTagAccessIsEnabled.1" title="function: boolean AArch64.AllocationTagAccessIsEnabled(AccType acctype)">AArch64.AllocationTagAccessIsEnabled</a>(acctype) then
        return FALSE;

    if acctype IN {<a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>, <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>} then
        return FALSE;

    if acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        return FALSE;

    if PSTATE.TCO=='1' then
        return FALSE;

    if (<a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsSIMDFPLoadStore.0" title="function: boolean IsSIMDFPLoadStore()">IsSIMDFPLoadStore</a>() &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "No tag checking of SIMD&amp;FP loads and stores in Streaming SVE mode") then
        return FALSE;

    if (<a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsZALoadStore.0" title="function: boolean IsZALoadStore()">IsZALoadStore</a>() &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "No tag checking of ZA loads and stores") then
        return FALSE;

    if !<a href="shared_pseudocode.html#impl-aarch64.IsTagCheckedInstruction.0" title="function: boolean IsTagCheckedInstruction()">IsTagCheckedInstruction</a>() then
        return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.AddressWithAllocationTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.AddressWithAllocationTag</h3>
      <p class="pseudocode">// AArch64.AddressWithAllocationTag()
// ==================================
// Generate a 64-bit value containing a Logical Address Tag from a 64-bit
// virtual address and an Allocation Tag.
// If the extension is disabled, treats the Allocation Tag as '0000'.

bits(64) <a id="AArch64.AddressWithAllocationTag.3"/>AArch64.AddressWithAllocationTag(bits(64) address, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, bits(4) allocation_tag)
    bits(64) result = address;
    bits(4) tag;
    if <a href="shared_pseudocode.html#AArch64.AllocationTagAccessIsEnabled.1" title="function: boolean AArch64.AllocationTagAccessIsEnabled(AccType acctype)">AArch64.AllocationTagAccessIsEnabled</a>(acctype) then
        tag = allocation_tag;
    else
        tag = '0000';
    result&lt;59:56&gt; = tag;
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.AllocationTagFromAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.AllocationTagFromAddress</h3>
      <p class="pseudocode">// AArch64.AllocationTagFromAddress()
// ==================================
// Generate an Allocation Tag from a 64-bit value containing a Logical Address Tag.

bits(4) <a id="AArch64.AllocationTagFromAddress.1"/>AArch64.AllocationTagFromAddress(bits(64) tagged_address)
    return tagged_address&lt;59:56&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.CheckAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.CheckAlignment</h3>
      <p class="pseudocode">// AArch64.CheckAlignment()
// ========================

boolean <a id="AArch64.CheckAlignment.4"/>AArch64.CheckAlignment(bits(64) address, integer alignment, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                               boolean iswrite)

    aligned = (address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, alignment));
    atomic  = acctype IN { <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>, <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, <a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>,
                           <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a>, <a href="shared_pseudocode.html#AccType_ATOMICLS64" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a>, <a href="shared_pseudocode.html#AccType_A32LSMD" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a>};
    ordered = acctype IN { <a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</a>, <a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</a>, <a href="shared_pseudocode.html#AccType_LIMITEDORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_LIMITEDORDERED</a>,
                           <a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>, <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a> };
    vector  = acctype == <a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>;
    if <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].A == '1' then check = TRUE;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
        check = (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(address&lt;0+:4&gt;) + alignment &gt; 16) &amp;&amp; ((ordered &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].nAA == '0') || atomic);
    else check = atomic || ordered;

    if check &amp;&amp; !aligned then
        secondstage = FALSE;
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.3" title="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));

    return aligned;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.CheckTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.CheckTag</h3>
      <p class="pseudocode">// AArch64.CheckTag()
// ==================
// Performs a Tag Check operation for a memory access and returns
// whether the check passed

boolean <a id="AArch64.CheckTag.4"/>AArch64.CheckTag(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc, bits(4) ptag, boolean write)
    if memaddrdesc.memattrs.tagged then
        (memstatus, readtag) = <a href="shared_pseudocode.html#impl-aarch64.PhysMemTagRead.2" title="function: (PhysMemRetStatus, bits(4)) PhysMemTagRead(AddressDescriptor desc, AccessDescriptor accdesc)">PhysMemTagRead</a>(memaddrdesc, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, 1, accdesc);
        return ptag == readtag;
    else
        return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.MemSingle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.MemSingle</h3>
      <p class="pseudocode">// AArch64.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <a id="AArch64.MemSingle.read.4"/>AArch64.MemSingle[bits(64) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned]
    boolean ispair = FALSE;
    return <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair];

// AArch64.MemSingle[] - non-assignment (read) form
// ================================================
// Perform an atomic, little-endian read of 'size' bytes.

bits(size*8) <a id="AArch64.MemSingle.read.5"/>AArch64.MemSingle[bits(64) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    constant halfsize = size DIV 2;
    if <a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
        assert <a href="shared_pseudocode.html#impl-aarch64.CheckAllInAlignedQuantity.3" title="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</a>(address, size, 16);
    else
        assert address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, size);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    bits(size*8) value;
    iswrite = FALSE;

    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Memory array access
    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then
        accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
        accdesc.transactional = TSTATE.depth &gt; 0 &amp;&amp; !(acctype IN {<a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>,<a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>});
        if accdesc.transactional &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.MemHasTransactionalAccess.1" title="function: boolean MemHasTransactionalAccess(MemoryAttributes memattrs)">MemHasTransactionalAccess</a>(memaddrdesc.memattrs) then
            <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_IMP" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_IMP</a>, FALSE);
    else
        accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(memaddrdesc, accdesc);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>;
            fault.paddress   = memaddrdesc.paddress;
            fault.acctype    = acctype;
            fault.write      = FALSE;
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        if <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype) then
            bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64));
            if !<a href="shared_pseudocode.html#AArch64.CheckTag.4" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                <a href="shared_pseudocode.html#AArch64.TagCheckFault.3" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype, iswrite);

    (atomic, splitpair) = <a href="shared_pseudocode.html#impl-aarch64.CheckSingleAccessAttributes.7" title="function: (boolean, boolean) CheckSingleAccessAttributes(bits(64) address, MemoryAttributes memattrs, integer size,&#13; AccType acctype, boolean iswrite, boolean aligned, boolean ispair)">CheckSingleAccessAttributes</a>(address, memaddrdesc.memattrs, size, acctype, iswrite, aligned, ispair);
    if atomic then
        (memstatus, value) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size, accdesc);
    elsif splitpair then
        assert ispair;
        (memstatus, lowhalf) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, halfsize, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + halfsize;
        (memstatus, highhalf) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, halfsize, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);

        value = highhalf:lowhalf;
    else
        for i = 0 to size-1
            (memstatus, value&lt;8*i+7:8*i&gt;) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, 1, accdesc);
            if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
                <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, 1, accdesc);
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    return value;

// AArch64.MemSingle[] - assignment (write) form
// =============================================

<a id="AArch64.MemSingle.write.4"/>AArch64.MemSingle[bits(64) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned] = bits(size*8) value
    boolean ispair = FALSE;
    <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair] = value;
    return;

// AArch64.MemSingle[] - assignment (write) form
// =============================================
// Perform an atomic, little-endian write of 'size' bytes.

<a id="AArch64.MemSingle.write.5"/>AArch64.MemSingle[bits(64) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned, boolean ispair] = bits(size*8) value
    assert size IN {1, 2, 4, 8, 16};
    constant halfsize = size DIV 2;
    if <a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
        assert <a href="shared_pseudocode.html#impl-aarch64.CheckAllInAlignedQuantity.3" title="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</a>(address, size, 16);
    else
        assert address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, size);

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    iswrite = TRUE;

    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);
    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    // Memory array access
    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then
        accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
        accdesc.transactional = TSTATE.depth &gt; 0;
        if accdesc.transactional &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.MemHasTransactionalAccess.1" title="function: boolean MemHasTransactionalAccess(MemoryAttributes memattrs)">MemHasTransactionalAccess</a>(memaddrdesc.memattrs) then
            <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_IMP" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_IMP</a>, FALSE);
    else
        accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(memaddrdesc, accdesc);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>;
            fault.paddress   = memaddrdesc.paddress;
            fault.acctype    = acctype;
            fault.write      = TRUE;
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        if <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype) then
            bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64));
            if !<a href="shared_pseudocode.html#AArch64.CheckTag.4" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                <a href="shared_pseudocode.html#AArch64.TagCheckFault.3" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype, iswrite);

    (atomic, splitpair) = <a href="shared_pseudocode.html#impl-aarch64.CheckSingleAccessAttributes.7" title="function: (boolean, boolean) CheckSingleAccessAttributes(bits(64) address, MemoryAttributes memattrs, integer size,&#13; AccType acctype, boolean iswrite, boolean aligned, boolean ispair)">CheckSingleAccessAttributes</a>(address, memaddrdesc.memattrs, size, acctype, iswrite, aligned, ispair);
    if atomic then
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size, accdesc, value);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size, accdesc);
    elsif splitpair then
        assert ispair;
        bits(halfsize*8) lowhalf, highhalf;
        &lt;highhalf, lowhalf&gt; = value;

        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, halfsize, accdesc, lowhalf);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);
        memaddrdesc.paddress.address = memaddrdesc.paddress.address + halfsize;
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, halfsize, accdesc, highhalf);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, halfsize, accdesc);
    else
        for i = 0 to size-1
            memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, 1, accdesc, value&lt;8*i+7:8*i&gt;);
            if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
                <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);
            memaddrdesc.paddress.address = memaddrdesc.paddress.address + 1;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.MemTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.MemTag</h3>
      <p class="pseudocode">// AArch64.MemTag[] - non-assignment (read) form
// =============================================
// Load an Allocation Tag from memory.

bits(4) <a id="AArch64.MemTag.read.2"/>AArch64.MemTag[bits(64) address, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype]
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    bits(4) value;

    iswrite = FALSE;
    aligned = TRUE;
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned,
                                           <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>);
    accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Return the granule tag if tagging is enabled...
    if <a href="shared_pseudocode.html#AArch64.AllocationTagAccessIsEnabled.1" title="function: boolean AArch64.AllocationTagAccessIsEnabled(AccType acctype)">AArch64.AllocationTagAccessIsEnabled</a>(acctype) &amp;&amp; memaddrdesc.memattrs.tagged then
        if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
            fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
            accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
            fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(memaddrdesc, accdesc);
            if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>;
                fault.paddress   = memaddrdesc.paddress;
                fault.acctype    = acctype;
                fault.write      = FALSE;
                <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);

        (memstatus, tag) = <a href="shared_pseudocode.html#impl-aarch64.PhysMemTagRead.2" title="function: (PhysMemRetStatus, bits(4)) PhysMemTagRead(AddressDescriptor desc, AccessDescriptor accdesc)">PhysMemTagRead</a>(memaddrdesc, accdesc);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, 1, accdesc);
        return tag;
    else
        // ...otherwise read tag as zero.
        return '0000';

// AArch64.MemTag[] - assignment (write) form
// ==========================================
// Store an Allocation Tag to memory.

<a id="AArch64.MemTag.write.2"/>AArch64.MemTag[bits(64) address, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype] = bits(4) value
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    iswrite = TRUE;

    // Stores of allocation tags must be aligned
    if address != <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>) then
        boolean secondstage = FALSE;
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.3" title="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));

    aligned = TRUE;
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned,
                                           <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1 &lt;&lt; LOG2_TAG_GRANULE">TAG_GRANULE</a>);

    // It is CONSTRAINED UNPREDICTABLE if tags stored to memory locations marked as Device
    // generate an Alignment Fault or store the data to locations.
    if memaddrdesc.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVICETAGSTORE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DEVICETAGSTORE</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>};
        if c == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> then
            boolean secondstage = FALSE;
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.3" title="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    // Memory array access
    if <a href="shared_pseudocode.html#AArch64.AllocationTagAccessIsEnabled.1" title="function: boolean AArch64.AllocationTagAccessIsEnabled(AccType acctype)">AArch64.AllocationTagAccessIsEnabled</a>(acctype) &amp;&amp; memaddrdesc.memattrs.tagged then
        if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
            fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
            fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(memaddrdesc, accdesc);
            if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
                fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>;
                fault.paddress   = memaddrdesc.paddress;
                fault.acctype    = acctype;
                fault.write      = TRUE;
                <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);

        memstatus = <a href="shared_pseudocode.html#impl-aarch64.PhysMemTagWrite.3" title="function: PhysMemRetStatus PhysMemTagWrite(AddressDescriptor desc, AccessDescriptor accdesc, bits (4) value)">PhysMemTagWrite</a>(memaddrdesc, accdesc, value);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, 1, accdesc);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.PhysicalTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.PhysicalTag</h3>
      <p class="pseudocode">// AArch64.PhysicalTag()
// =====================
// Generate a Physical Tag from a Logical Tag in an address

bits(4) <a id="AArch64.PhysicalTag.1"/>AArch64.PhysicalTag(bits(64) vaddr)
    return vaddr&lt;59:56&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AArch64.TranslateAddressForAtomicAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AArch64.TranslateAddressForAtomicAccess</h3>
      <p class="pseudocode">// AArch64.TranslateAddressForAtomicAccess()
// =========================================
// Performs an alignment check for atomic memory operations.
// Also translates 64-bit Virtual Address into Physical Address.

AddressDescriptor <a id="AArch64.TranslateAddressForAtomicAccess.2"/>AArch64.TranslateAddressForAtomicAccess(bits(64) address, integer sizeinbits)
    boolean iswrite = FALSE;
    size = sizeinbits DIV 8;

    assert size IN {1, 2, 4, 8, 16};

    aligned = <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, iswrite);

    // MMU or MPU lookup
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, iswrite,
                                           aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(address, <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>) then
        bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
        accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(<a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>);
        if !<a href="shared_pseudocode.html#AArch64.CheckTag.4" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
            <a href="shared_pseudocode.html#AArch64.TagCheckFault.3" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(address, <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, iswrite);

    return memaddrdesc;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.AddressSupportsLS64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/AddressSupportsLS64</h3>
      <p class="pseudocode">// Returns TRUE if the 64-byte block following the given address supports the
// LD64B and ST64B instructions, and FALSE otherwise.
boolean <a id="impl-aarch64.AddressSupportsLS64.1"/>AddressSupportsLS64(bits(64) address);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.CheckAllInAlignedQuantity"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/CheckAllInAlignedQuantity</h3>
      <p class="pseudocode">// CheckAllInAlignedQuantity()
// ===========================
// Returns TRUE if all accessed bytes are within one aligned quantity, FALSE otherwise.

boolean <a id="impl-aarch64.CheckAllInAlignedQuantity.3"/>CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)
    assert(size &lt;= alignment);
    return <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address+size-1, alignment) == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, alignment);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.CheckSPAlignment"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/CheckSPAlignment</h3>
      <p class="pseudocode">// CheckSPAlignment()
// ==================
// Check correct stack pointer alignment for AArch64 state.

<a id="impl-aarch64.CheckSPAlignment.0"/>CheckSPAlignment()
    bits(64) sp = <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(width) SP[]">SP</a>[];
    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        stack_align_check = (<a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SA0 != '0');
    else
        stack_align_check = (<a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].SA != '0');

    if stack_align_check &amp;&amp; sp != <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(sp, 16) then
        <a href="shared_pseudocode.html#AArch64.SPAlignmentFault.0" title="function: AArch64.SPAlignmentFault()">AArch64.SPAlignmentFault</a>();

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.CheckSingleAccessAttributes"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/CheckSingleAccessAttributes</h3>
      <p class="pseudocode">// CheckSingleAccessAttributes()
// =============================
//
// When FEAT_LSE2 is implemented, a MemSingle[] access needs to be further assessed once the memory
// attributes are determined.
// If it was aligned to access size or targets Normal Inner Write-Back, Outer Write-Back Cacheable
// memory then it is single copy atomic and there is no alignment fault.
// If not, for exclusives, atomics and non atomic acquire release instructions - it is CONSTRAINED UNPREDICTABLE
// if they generate an alignment fault.  If they do not generate an alignement fault - they are
// single copy atomic.
// Otherwise it is IMPLEMENTATION DEFINED - if they are single copy atomic.
//
// The function returns (atomic, splitpair), where
//     atomic indicates if the access is single copy atomic.
//     splitpair indicates that a load/store pair is split into 2 single copy atomic accesses.
//     when atomic and splitpair are both FALSE - the access is not single copy atomic and may be treated
//        as byte accesses.

(boolean, boolean) <a id="impl-aarch64.CheckSingleAccessAttributes.7"/>CheckSingleAccessAttributes(bits(64) address, <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs, integer size,
                        <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, boolean aligned, boolean ispair)
    isnormalwb = (memattrs.memtype     == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
                  memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
                  memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>);

    atomic    = TRUE;
    splitpair = FALSE;
    if isnormalwb then return (atomic, splitpair);

    accatomic  = acctype IN { <a href="shared_pseudocode.html#AccType_ATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMIC</a>, <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>, <a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>,
                <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a>, <a href="shared_pseudocode.html#AccType_ATOMICLS64" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a>, <a href="shared_pseudocode.html#AccType_A32LSMD" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a>};
    ordered = acctype IN { <a href="shared_pseudocode.html#AccType_ORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDERED</a>, <a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</a>, <a href="shared_pseudocode.html#AccType_LIMITEDORDERED" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_LIMITEDORDERED</a>, <a href="shared_pseudocode.html#AccType_ORDEREDATOMIC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMIC</a>, <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a> };

    if !aligned &amp;&amp; (accatomic || ordered) then
        atomic = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_MISALIGNEDATOMIC" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_MISALIGNEDATOMIC</a>);
        if !atomic then
            secondstage = FALSE;
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, <a href="shared_pseudocode.html#impl-shared.AlignmentFault.3" title="function: FaultRecord AlignmentFault(AccType acctype, boolean iswrite, boolean secondstage)">AlignmentFault</a>(acctype, iswrite, secondstage));
        else
            return (atomic, splitpair);

    if ispair &amp;&amp; aligned then
        // load / store pair requests that are aligned to each register access are split into 2 single copy atomic accesses
        atomic    = FALSE;
        splitpair = TRUE;
        return (atomic, splitpair);

    if aligned then
        return (atomic, splitpair);

    atomic = boolean IMPLEMENTATION_DEFINED "Misaligned accesses within 16 byte aligned memory but not Normal Cacheable Writeback are Atomic";

    return (atomic, splitpair);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.IsSIMDFPLoadStore"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/IsSIMDFPLoadStore</h3>
      <p class="pseudocode">// Returns True if the current instruction is an SME, SVE or SIMD&amp;FP load/store,
// False otherwise.
boolean <a id="impl-aarch64.IsSIMDFPLoadStore.0"/>IsSIMDFPLoadStore();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.IsTagCheckedInstruction"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/IsTagCheckedInstruction</h3>
      <p class="pseudocode">// Returns True if the current instruction uses tag-checked memory access,
// False otherwise.
boolean <a id="impl-aarch64.IsTagCheckedInstruction.0"/>IsTagCheckedInstruction();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.IsZALoadStore"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/IsZALoadStore</h3>
      <p class="pseudocode">// Returns True if the current instruction is a load/store into/from ZA,
// False otherwise.
boolean <a id="impl-aarch64.IsZALoadStore.0"/>IsZALoadStore();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.Mem"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/Mem</h3>
      <p class="pseudocode">// Mem[] - non-assignment (read) form
// ==================================
// Perform a read of 'size' bytes. The access byte order is reversed for a big-endian access.
// Instruction fetches would call AArch64.MemSingle directly.

bits(size*8) <a id="impl-aarch64.Mem.read.3"/>Mem[bits(64) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype]
    boolean ispair = FALSE;
    return <a href="shared_pseudocode.html#impl-aarch64.Mem.read.4" title="accessor: bits(size*8) Mem[bits(64) address, integer size, AccType acctype, boolean ispair]">Mem</a>[address, size, acctype, ispair];

bits(size*8) <a id="impl-aarch64.Mem.read.4"/>Mem[bits(64) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean ispair]
    assert size IN {1, 2, 4, 8, 16};
    constant halfsize = size DIV 2;
    bits(size * 8) value;
    bits(halfsize * 8) lowhalf, highhalf;
    boolean iswrite = FALSE;
    if ispair then
        // check alignment on size of element accessed, not overall access size
        aligned = <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, halfsize, acctype, iswrite);
    else
        aligned = <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);
    if size != 16 || !(acctype IN {<a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>}) then
        if !<a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
            atomic = aligned;
        else
            atomic = <a href="shared_pseudocode.html#impl-aarch64.CheckAllInAlignedQuantity.3" title="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</a>(address, size, 16);
    elsif acctype IN {<a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>} then
        // 128-bit SIMD&amp;FP loads are treated as a pair of 64-bit single-copy atomic accesses
        // 64-bit aligned.
        atomic = address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, 8);
    else
        // 16-byte integer access
        atomic = address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, 16);

    if !atomic &amp;&amp; ispair &amp;&amp; address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, halfsize) then
        single_is_pair = FALSE;
        single_is_aligned = TRUE;
        lowhalf = <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, halfsize, acctype, single_is_aligned, single_is_pair];
        highhalf = <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address + halfsize, halfsize, acctype, single_is_aligned, single_is_pair];
        value = highhalf:lowhalf;
    elsif atomic &amp;&amp; ispair then
        value = <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair];
    elsif !atomic then

        assert size &gt; 1;
        value&lt;7:0&gt; = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned]">AArch64.MemSingle</a>[address, 1, acctype, aligned];

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
            if c == <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            value&lt;8*i+7:8*i&gt; = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned]">AArch64.MemSingle</a>[address+i, 1, acctype, aligned];
    elsif size == 16 &amp;&amp; acctype IN {<a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>} then
        lowhalf = <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, halfsize, acctype, aligned, ispair];
        highhalf = <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address + halfsize, halfsize, acctype, aligned, ispair];
        value = highhalf:lowhalf;
    else
        value = <a href="shared_pseudocode.html#AArch64.MemSingle.read.5" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair]">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair];

    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a>(acctype) then
        value = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    return value;

// Mem[] - assignment (write) form
// ===============================
// Perform a write of 'size' bytes. The byte order is reversed for a big-endian access.

<a id="impl-aarch64.Mem.write.3"/>Mem[bits(64) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype] = bits(size*8) value
    boolean ispair = FALSE;
    <a href="shared_pseudocode.html#impl-aarch64.Mem.write.4" title="accessor: Mem[bits(64) address, integer size, AccType acctype, boolean ispair] = bits(size*8) value">Mem</a>[address, size, acctype, ispair] = value;

<a id="impl-aarch64.Mem.write.4"/>Mem[bits(64) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean ispair] = bits(size*8) value
    boolean iswrite = TRUE;
    constant halfsize = size DIV 2;
    bits(halfsize*8) lowhalf, highhalf;
    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a>(acctype) then
        value = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    if ispair then
        // check alignment on size of element accessed, not overall access size
        aligned = <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, halfsize, acctype, iswrite);
    else
        aligned = <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);
    if ispair then
        atomic = <a href="shared_pseudocode.html#impl-aarch64.CheckAllInAlignedQuantity.3" title="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</a>(address, size, 16);
    elsif size != 16 || !(acctype IN {<a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>}) then
        if !<a href="shared_pseudocode.html#impl-shared.HaveLSE2Ext.0" title="function: boolean HaveLSE2Ext()">HaveLSE2Ext</a>() then
            atomic = aligned;
        else
            atomic = <a href="shared_pseudocode.html#impl-aarch64.CheckAllInAlignedQuantity.3" title="function: boolean CheckAllInAlignedQuantity(bits(64) address, integer size, integer alignment)">CheckAllInAlignedQuantity</a>(address, size, 16);
    elsif (acctype IN {<a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>}) then
        // 128-bit SIMD&amp;FP stores are treated as a pair of 64-bit single-copy atomic accesses
        // 64-bit aligned.
        atomic = address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, 8);
    else
        // 16-byte integer access
        atomic = address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, 16);

    if !atomic &amp;&amp; ispair &amp;&amp; address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, halfsize) then
        single_is_aligned = TRUE;
        &lt;highhalf, lowhalf&gt; = value;
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, halfsize, acctype, single_is_aligned, ispair] = lowhalf;
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address + halfsize, halfsize, acctype, single_is_aligned, ispair] = highhalf;
    elsif atomic &amp;&amp; ispair then
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair] = value;
    elsif !atomic then
        assert size &gt; 1;
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch64.MemSingle</a>[address, 1, acctype, aligned] = value&lt;7:0&gt;;

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
            if c == <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            <a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch64.MemSingle</a>[address+i, 1, acctype, aligned] = value&lt;8*i+7:8*i&gt;;
    elsif size == 16 &amp;&amp; acctype IN {<a href="shared_pseudocode.html#AccType_VEC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VEC</a>, <a href="shared_pseudocode.html#AccType_VECSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_VECSTREAM</a>} then
        &lt;highhalf, lowhalf&gt; = value;
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, halfsize, acctype, aligned, ispair] = lowhalf;
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address + halfsize, halfsize, acctype, aligned, ispair] = highhalf;
    else
        <a href="shared_pseudocode.html#AArch64.MemSingle.write.5" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned, boolean ispair] = bits(size*8) value">AArch64.MemSingle</a>[address, size, acctype, aligned, ispair] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemAtomic"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemAtomic</h3>
      <p class="pseudocode">// MemAtomic()
// ===========
// Performs load and store memory operations for a given virtual address.

bits(size) <a id="impl-aarch64.MemAtomic.5"/>MemAtomic(bits(64) address, <a href="shared_pseudocode.html#MemAtomicOp" title="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp</a> op, bits(size) value, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> ldacctype, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> stacctype)
    bits(size) newvalue;
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddressForAtomicAccess.2" title="function: AddressDescriptor AArch64.TranslateAddressForAtomicAccess(bits(64) address, integer sizeinbits)">AArch64.TranslateAddressForAtomicAccess</a>(address, size);
    ldaccdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(ldacctype);
    staccdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(stacctype);

    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(memaddrdesc, ldaccdesc);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>;
            fault.paddress   = memaddrdesc.paddress;
            fault.acctype    = ldacctype;
            fault.write      = boolean UNKNOWN;
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);

    // All observers in the shareability domain observe the
    // following load and store atomically.
    (memstatus, oldvalue) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size DIV 8, ldaccdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size DIV 8, ldaccdesc);
    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a>(ldacctype) then
        oldvalue = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(oldvalue);

    case op of
        when <a href="shared_pseudocode.html#MemAtomicOp_ADD" title="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_ADD</a>   newvalue = oldvalue + value;
        when <a href="shared_pseudocode.html#MemAtomicOp_BIC" title="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_BIC</a>   newvalue = oldvalue AND NOT(value);
        when <a href="shared_pseudocode.html#MemAtomicOp_EOR" title="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_EOR</a>   newvalue = oldvalue EOR value;
        when <a href="shared_pseudocode.html#MemAtomicOp_ORR" title="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_ORR</a>   newvalue = oldvalue OR value;
        when <a href="shared_pseudocode.html#MemAtomicOp_SMAX" title="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_SMAX</a>  newvalue = if <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(oldvalue) &gt; <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(value) then oldvalue else value;
        when <a href="shared_pseudocode.html#MemAtomicOp_SMIN" title="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_SMIN</a>  newvalue = if <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(oldvalue) &gt; <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(value) then value else oldvalue;
        when <a href="shared_pseudocode.html#MemAtomicOp_UMAX" title="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_UMAX</a>  newvalue = if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(oldvalue) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(value) then oldvalue else value;
        when <a href="shared_pseudocode.html#MemAtomicOp_UMIN" title="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_UMIN</a>  newvalue = if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(oldvalue) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(value) then value else oldvalue;
        when <a href="shared_pseudocode.html#MemAtomicOp_SWP" title="enumeration MemAtomicOp {MemAtomicOp_ADD,&#13; MemAtomicOp_BIC,&#13; MemAtomicOp_EOR,&#13; MemAtomicOp_ORR,&#13; MemAtomicOp_SMAX,&#13; MemAtomicOp_SMIN,&#13; MemAtomicOp_UMAX,&#13; MemAtomicOp_UMIN,&#13; MemAtomicOp_SWP}">MemAtomicOp_SWP</a>   newvalue = value;

    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a>(stacctype) then
        newvalue = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(newvalue);
    memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size DIV 8, staccdesc, newvalue);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size DIV 8, staccdesc);

    // Load operations return the old (pre-operation) value
    return oldvalue;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemAtomicCompareAndSwap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemAtomicCompareAndSwap</h3>
      <p class="pseudocode">// MemAtomicCompareAndSwap()
// =========================
// Compares the value stored at the passed-in memory address against the passed-in expected
// value. If the comparison is successful, the value at the passed-in memory address is swapped
// with the passed-in new_value.

bits(size) <a id="impl-aarch64.MemAtomicCompareAndSwap.5"/>MemAtomicCompareAndSwap(bits(64) address, bits(size) expectedvalue,
                                   bits(size) newvalue, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> ldacctype, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> stacctype)
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddressForAtomicAccess.2" title="function: AddressDescriptor AArch64.TranslateAddressForAtomicAccess(bits(64) address, integer sizeinbits)">AArch64.TranslateAddressForAtomicAccess</a>(address, size);
    ldaccdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(ldacctype);
    staccdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(stacctype);

    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(memaddrdesc, ldaccdesc);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>;
            fault.paddress   = memaddrdesc.paddress;
            fault.acctype    = ldacctype;
            fault.write      = boolean UNKNOWN;
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);

    // All observers in the shareability domain observe the
    // following load and store atomically.
    (memstatus, oldvalue) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size DIV 8, ldaccdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size DIV 8, ldaccdesc);
    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a>(ldacctype) then
        oldvalue = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(oldvalue);

    if oldvalue == expectedvalue then
        if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a>(stacctype) then
            newvalue = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(newvalue);
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size DIV 8, staccdesc, newvalue);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size DIV 8, staccdesc);
    return oldvalue;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemLoad64B"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemLoad64B</h3>
      <p class="pseudocode">// MemLoad64B()
// ============
// Performs an atomic 64-byte read from a given virtual address.

bits(512) <a id="impl-aarch64.MemLoad64B.2"/>MemLoad64B(bits(64) address, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    bits(512) data;
    boolean iswrite = FALSE;
    constant integer size = 64;

    aligned = <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);

    if !<a href="shared_pseudocode.html#impl-aarch64.AddressSupportsLS64.1" title="function: boolean AddressSupportsLS64(bits(64) address)">AddressSupportsLS64</a>(address) then
        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_LS64UNSUPPORTED" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_LS64UNSUPPORTED</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_LIMITED_ATOMICITY" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_LIMITED_ATOMICITY</a>, <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>};

        if c == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> then
            // Generate a stage 1 Data Abort reported using the DFSC code of 110101.
            boolean secondstage = FALSE;
            boolean s2fs1walk = FALSE;
            fault = <a href="shared_pseudocode.html#AArch64.ExclusiveFault.4" title="function: FaultRecord AArch64.ExclusiveFault(AccType acctype, boolean iswrite,&#13; boolean secondstage, boolean s2fs1walk)">AArch64.ExclusiveFault</a>(acctype, iswrite, secondstage, s2fs1walk);
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);
        else
            // Accesses are not single-copy atomic above the byte level
            for i = 0 to 63
                data&lt;7+8*i : 8*i&gt; = <a href="shared_pseudocode.html#AArch64.MemSingle.read.4" title="accessor: bits(size*8) AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned]">AArch64.MemSingle</a>[address+8*i, 1, acctype, aligned];
            return data;

    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), size);

    // Memory array access
    accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then
        accdesc.transactional = TSTATE.depth &gt; 0;
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(memaddrdesc, accdesc);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>;
            fault.paddress   = memaddrdesc.paddress;
            fault.acctype    = acctype;
            fault.write      = iswrite;
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        if <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype) then
            bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64));
            if !<a href="shared_pseudocode.html#AArch64.CheckTag.4" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                <a href="shared_pseudocode.html#AArch64.TagCheckFault.3" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(address, acctype, iswrite);

    (memstatus, data) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalReadAbort.4" title="function: HandleExternalReadAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalReadAbort</a>(memstatus, memaddrdesc, size, accdesc);
    return data;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemStore64B"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemStore64B</h3>
      <p class="pseudocode">// MemStore64B()
// =============
// Performs an atomic 64-byte store to a given virtual address. Function does
// not return the status of the store.

<a id="impl-aarch64.MemStore64B.3"/>MemStore64B(bits(64) address, bits(512) value, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    boolean iswrite = TRUE;
    constant integer size = 64;
    aligned = <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);

    if !<a href="shared_pseudocode.html#impl-aarch64.AddressSupportsLS64.1" title="function: boolean AddressSupportsLS64(bits(64) address)">AddressSupportsLS64</a>(address) then
        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_LS64UNSUPPORTED" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_LS64UNSUPPORTED</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_LIMITED_ATOMICITY" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_LIMITED_ATOMICITY</a>, <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>};

        if c == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> then
            // Generate a Data Abort reported using the DFSC code of 110101.
            boolean secondstage = FALSE;
            boolean s2fs1walk = FALSE;
            fault = <a href="shared_pseudocode.html#AArch64.ExclusiveFault.4" title="function: FaultRecord AArch64.ExclusiveFault(AccType acctype, boolean iswrite,&#13; boolean secondstage, boolean s2fs1walk)">AArch64.ExclusiveFault</a>(acctype, iswrite, secondstage, s2fs1walk);
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);
        else
            // Accesses are not single-copy atomic above the byte level.
            for i = 0 to 63
                <a href="shared_pseudocode.html#AArch64.MemSingle.write.4" title="accessor: AArch64.MemSingle[bits(64) address, integer size, AccType acctype, boolean aligned] = bits(size*8) value">AArch64.MemSingle</a>[address+8*i, 1, acctype, aligned] = value&lt;7+8*i : 8*i&gt;;
    else
        -= <a href="shared_pseudocode.html#impl-aarch64.MemStore64BWithRet.3" title="function: bits(64) MemStore64BWithRet(bits(64) address, bits(512) value, AccType acctype)">MemStore64BWithRet</a>(address, value, acctype);  // Return status is ignored by ST64B
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemStore64BWithRet"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemStore64BWithRet</h3>
      <p class="pseudocode">// MemStore64BWithRet()
// ====================
// Performs an atomic 64-byte store to a given virtual address returning
// the status value of the operation.

bits(64) <a id="impl-aarch64.MemStore64BWithRet.3"/>MemStore64BWithRet(bits(64) address, bits(512) value, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;
    boolean iswrite = TRUE;
    constant integer size = 64;

    aligned     = <a href="shared_pseudocode.html#AArch64.CheckAlignment.4" title="function: boolean AArch64.CheckAlignment(bits(64) address, integer alignment, AccType acctype,&#13; boolean iswrite)">AArch64.CheckAlignment</a>(address, size, acctype, iswrite);
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, memaddrdesc.fault);
        return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>('1');

    // Effect on exclusives
    if memaddrdesc.memattrs.shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then
        <a href="shared_pseudocode.html#impl-shared.ClearExclusiveByAddress.3" title="function: ClearExclusiveByAddress(FullAddress paddress, integer processorid, integer size)">ClearExclusiveByAddress</a>(memaddrdesc.paddress, <a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>(), 64);

    // Memory array access
    accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then
        accdesc.transactional = TSTATE.depth &gt; 0;
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(memaddrdesc, accdesc);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>;
            fault.paddress   = memaddrdesc.paddress;
            fault.acctype    = acctype;
            fault.write      = iswrite;
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, fault);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        if <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64), acctype) then
            bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(<a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(address, 64));
            if !<a href="shared_pseudocode.html#AArch64.CheckTag.4" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                <a href="shared_pseudocode.html#AArch64.TagCheckFault.3" title="function: AArch64.TagCheckFault(bits(64) vaddress, AccType acctype, boolean iswrite)">AArch64.TagCheckFault</a>(address, acctype, iswrite);
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>('1');

    memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(memaddrdesc, size, accdesc, value);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        <a href="shared_pseudocode.html#impl-shared.HandleExternalWriteAbort.4" title="function: HandleExternalWriteAbort(PhysMemRetStatus memstatus, AddressDescriptor memaddrdesc,&#13; integer size, AccessDescriptor accdesc)">HandleExternalWriteAbort</a>(memstatus, memaddrdesc, size, accdesc);
    return memstatus.store64bstatus;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.MemStore64BWithRetStatus"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/MemStore64BWithRetStatus</h3>
      <p class="pseudocode">// Generates the return status of memory write with ST64BV or ST64BV0
// instructions. The status indicates if the operation succeeded, failed,
// or was not supported at this memory location.
bits(64) <a id="impl-aarch64.MemStore64BWithRetStatus.0"/>MemStore64BWithRetStatus();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.NVMem"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/NVMem</h3>
      <p class="pseudocode">// NVMem[] - non-assignment form
// =============================
// This function is the load memory access for the transformed System register read access
// when Enhanced Nested Virtualisation is enabled with HCR_EL2.NV2 = 1.
// The address for the load memory access is calculated using
// the formula SignExtend(VNCR_EL2.BADDR : Offset&lt;11:0&gt;, 64) where,
//  * VNCR_EL2.BADDR holds the base address of the memory location, and
//  * Offset is the unique offset value defined architecturally for each System register that
//    supports transformation of register access to memory access.

bits(64) <a id="impl-aarch64.NVMem.read.1"/>NVMem[integer offset]
    assert offset &gt; 0;
    bits(64) address = <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(VNCR_EL2.BADDR:offset&lt;11:0&gt;, 64);
    return <a href="shared_pseudocode.html#impl-aarch64.Mem.read.3" title="accessor: bits(size*8) Mem[bits(64) address, integer size, AccType acctype]">Mem</a>[address, 8, <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a>];

// NVMem[] - assignment form
// =========================
// This function is the store memory access for the transformed System register write access
// when Enhanced Nested Virtualisation is enabled with HCR_EL2.NV2 = 1.
// The address for the store memory access is calculated using
// the formula SignExtend(VNCR_EL2.BADDR : Offset&lt;11:0&gt;, 64) where,
//  * VNCR_EL2.BADDR holds the base address of the memory location, and
//  * Offset is the unique offset value defined architecturally for each System register that
//    supports transformation of register access to memory access.

<a id="impl-aarch64.NVMem.write.1"/>NVMem[integer offset] = bits(64) value
    assert offset &gt; 0;
    bits(64) address = <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(VNCR_EL2.BADDR:offset&lt;11:0&gt;, 64);
    <a href="shared_pseudocode.html#impl-aarch64.Mem.write.3" title="accessor: Mem[bits(64) address, integer size, AccType acctype] = bits(size*8) value">Mem</a>[address, 8, <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a>] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.PhysMemTagRead"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/PhysMemTagRead</h3>
      <p class="pseudocode">// This is the hardware operation which perform a single-copy atomic,
// Allocation Tag granule aligned, memory access from the tag in PA space.
//
// The function address the array using desc.paddress which supplies:
// * A 52-bit physical address
// * A single NS bit to select between Secure and Non-secure parts of the array.
//
// The accdesc descriptor describes the access type: normal, exclusive, ordered, streaming,
// etc and other parameters required to access the physical memory or for setting syndrome
// register in the event of an External abort.
(PhysMemRetStatus, bits(4)) <a id="impl-aarch64.PhysMemTagRead.2"/>PhysMemTagRead(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> desc, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.PhysMemTagWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/PhysMemTagWrite</h3>
      <p class="pseudocode">// This is the hardware operation which perform a single-copy atomic,
// Allocation Tag granule aligned, memory access to the tag in PA space.
//
// The function address the array using desc.paddress which supplies:
// * A 52-bit physical address
// * A single NS bit to select between Secure and Non-secure parts of the array.
//
// The accdesc descriptor describes the access type: normal, exclusive, ordered, streaming,
// etc and other parameters required to access the physical memory or for setting syndrome
// register in the event of an External abort.
PhysMemRetStatus <a id="impl-aarch64.PhysMemTagWrite.3"/>PhysMemTagWrite(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> desc, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc, bits (4) value);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.memory.SetTagCheckedInstruction"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/memory/SetTagCheckedInstruction</h3>
      <p class="pseudocode">// Flag the current instruction as using/not using memory tag checking.
<a id="impl-aarch64.SetTagCheckedInstruction.1"/>SetTagCheckedInstruction(boolean checked);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYPostSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYPostSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the copy that is performed by the CPYE* instructions for this
// implementation given the parameters of the destination, source and size of the copy.
// Postsize is encoded as -1*size for an option A implementation if cpysize is negative.
bits(64) <a id="impl-aarch64.CPYPostSizeChoice.3"/>CPYPostSizeChoice(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYPreSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYPreSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the copy that is performed by the CPYP* instructions for this
// implementation given the parameters of the destination, source and size of the copy.
// Presize is encoded as -1*size for an option A implementation if cpysize is negative.
bits(64) <a id="impl-aarch64.CPYPreSizeChoice.3"/>CPYPreSizeChoice(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CPYSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CPYSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the block this performed for an iteration of the copy given the
// parameters of the destination, source and size of the copy.
integer <a id="impl-aarch64.CPYSizeChoice.3"/>CPYSizeChoice(bits(64) toaddress, bits(64) fromaddress, bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.CheckMOPSEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/CheckMOPSEnabled</h3>
      <p class="pseudocode">// CheckMOPSEnabled()
// ==================
// Check for EL0 and EL1 access to the CPY* and SET* instructions.

<a id="impl-aarch64.CheckMOPSEnabled.0"/>CheckMOPSEnabled()
    if (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0') &amp;&amp;
        (!<a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() || HCRX_EL2.MSCEn == '0')) then
        UNDEFINED;

    if (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; SCTLR_EL1.MSCEn == '0' &amp;&amp;
        (!<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() || HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0')) then
        UNDEFINED;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() &amp;&amp; SCTLR_EL2.MSCEn == '0' then
        UNDEFINED;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MOPSStage"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MOPSStage</h3>
      <p class="pseudocode">enumeration <a id="MOPSStage"/>MOPSStage { <a id="MOPSStage_Prologue"/>MOPSStage_Prologue, <a id="MOPSStage_Main"/>MOPSStage_Main, <a id="MOPSStage_Epilogue"/>MOPSStage_Epilogue };</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MaxBlockSizeCopiedBytes"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MaxBlockSizeCopiedBytes</h3>
      <p class="pseudocode">// MaxBlockSizeCopiedBytes()
// =========================
// Returns the maximum number of bytes that can used in a single block of the copy.

integer <a id="impl-aarch64.MaxBlockSizeCopiedBytes.0"/>MaxBlockSizeCopiedBytes()
    return integer IMPLEMENTATION_DEFINED "Maximum bytes used in a single block of a copy";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyAccessTypes"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyAccessTypes</h3>
      <p class="pseudocode">// MemCpyAccessTypes()
// ===================
// Return the read and write access types for a CPY* instruction.

(AccType, AccType) <a id="impl-aarch64.MemCpyAccessTypes.1"/>MemCpyAccessTypes(bits(4) options)
    unpriv_at_el1 = PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; !(<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.&lt;NV,NV1&gt; == '11');
    unpriv_at_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11';

    runpriv_at_el1 = options&lt;1&gt; == '1' &amp;&amp; unpriv_at_el1;
    runpriv_at_el2 = options&lt;1&gt; == '1' &amp;&amp; unpriv_at_el2;
    wunpriv_at_el1 = options&lt;0&gt; == '1' &amp;&amp; unpriv_at_el1;
    wunpriv_at_el2 = options&lt;0&gt; == '1' &amp;&amp; unpriv_at_el2;

    user_access_override = <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() &amp;&amp; PSTATE.UAO == '1';

    if !user_access_override &amp;&amp; (runpriv_at_el1 || runpriv_at_el2) then
        racctype = if options&lt;3&gt; == '0' then <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a> else <a href="shared_pseudocode.html#AccType_UNPRIVSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIVSTREAM</a>;
    else
        racctype = if options&lt;3&gt; == '0' then <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a> else <a href="shared_pseudocode.html#AccType_STREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_STREAM</a>;

    if !user_access_override &amp;&amp; (wunpriv_at_el1 || wunpriv_at_el2) then
        wacctype = if options&lt;2&gt; == '0' then <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a> else <a href="shared_pseudocode.html#AccType_UNPRIVSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIVSTREAM</a>;
    else
        wacctype = if options&lt;2&gt; == '0' then <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a> else <a href="shared_pseudocode.html#AccType_STREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_STREAM</a>;

    return (racctype, wacctype);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyDirectionChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyDirectionChoice</h3>
      <p class="pseudocode">// Returns true if in the non-overlapping case of a memcpy of size cpysize bytes
// from the source address fromaddress to destination address toaddress is done
// in the forward direction on this implementation.
boolean <a id="impl-aarch64.MemCpyDirectionChoice.3"/>MemCpyDirectionChoice(bits(64) fromaddress, bits(64) toaddress, bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyOptionA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyOptionA</h3>
      <p class="pseudocode">// MemCpyOptionA()
// ===============
// Returns TRUE if the implementation uses Option A for the
// CPY*/SET* instructions, and FALSE otherwise.

boolean <a id="impl-aarch64.MemCpyOptionA.0"/>MemCpyOptionA()
    return boolean IMPLEMENTATION_DEFINED "CPY*/SET* instructions use Option A";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyParametersIllformedE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyParametersIllformedE</h3>
      <p class="pseudocode">// Returns TRUE if the inputs are not well formed (in terms of their size and/or alignment)
// for a CPYE* instruction for this implementation given the parameters of the destination,
// source and size of the copy.
boolean <a id="impl-aarch64.MemCpyParametersIllformedE.3"/>MemCpyParametersIllformedE(bits(64) toaddress, bits(64) fromaddress,
                                   bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyParametersIllformedM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyParametersIllformedM</h3>
      <p class="pseudocode">// Returns TRUE if the inputs are not well formed (in terms of their size and/or alignment)
// for a CPYM* instruction for this implementation given the parameters of the destination,
// source and size of the copy.
boolean <a id="impl-aarch64.MemCpyParametersIllformedM.3"/>MemCpyParametersIllformedM(bits(64) toaddress, bits(64) fromaddress,
                                   bits(64) cpysize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemCpyZeroSizeCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemCpyZeroSizeCheck</h3>
      <p class="pseudocode">// Returns TRUE if the implementation option is checked on a copy of size zero remaining.
boolean <a id="impl-aarch64.MemCpyZeroSizeCheck.0"/>MemCpyZeroSizeCheck();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetAccessType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetAccessType</h3>
      <p class="pseudocode">// MemSetAccessType()
// ==================
// Return the access type for a SET* instruction.

AccType <a id="impl-aarch64.MemSetAccessType.1"/>MemSetAccessType(bits(2) options)
    unpriv_at_el1 = options&lt;0&gt; == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; !(<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.&lt;NV,NV1&gt; == '11');
    unpriv_at_el2 = (options&lt;0&gt; == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11');

    user_access_override = <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() &amp;&amp; PSTATE.UAO == '1';

    if !user_access_override &amp;&amp; (unpriv_at_el1 || unpriv_at_el2) then
        acctype = if options&lt;1&gt; == '0' then <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a> else <a href="shared_pseudocode.html#AccType_UNPRIVSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIVSTREAM</a>;
    else
        acctype = if options&lt;1&gt; == '0' then <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a> else <a href="shared_pseudocode.html#AccType_STREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_STREAM</a>;

    return acctype;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetParametersIllformedE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetParametersIllformedE</h3>
      <p class="pseudocode">// Returns TRUE if the inputs are not well formed (in terms of their size and/or
// alignment) for a SETE* or SETGE* instruction for this implementation given the
// parameters of the destination and size of the set.
boolean <a id="impl-aarch64.MemSetParametersIllformedE.3"/>MemSetParametersIllformedE(bits(64) toaddress, bits(64) setsize,
                                   boolean IsSETGE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetParametersIllformedM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetParametersIllformedM</h3>
      <p class="pseudocode">// Returns TRUE if the inputs are not well formed (in terms of their size and/or
// alignment) for a SETM* or SETGM* instruction for this implementation given the
// parameters of the destination and size of the copy.
boolean <a id="impl-aarch64.MemSetParametersIllformedM.3"/>MemSetParametersIllformedM(bits(64) toaddress, bits(64) setsize,
                                   boolean IsSETGM);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MemSetZeroSizeCheck"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MemSetZeroSizeCheck</h3>
      <p class="pseudocode">// Returns TRUE if the implementation option is checked on a copy of size zero remaining.
boolean <a id="impl-aarch64.MemSetZeroSizeCheck.0"/>MemSetZeroSizeCheck();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MismatchedCpySetTargetEL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MismatchedCpySetTargetEL</h3>
      <p class="pseudocode">// MismatchedCpySetTargetEL()
// ==========================
// Return the target exception level for an Exception_MemCpyMemSet.

bits(2) <a id="impl-aarch64.MismatchedCpySetTargetEL.0"/>MismatchedCpySetTargetEL()
    bits(2) target_el;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        target_el = PSTATE.EL;
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    elsif (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
        <a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() &amp;&amp; HCRX_EL2.MCE2 == '1') then
        target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    return target_el;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MismatchedMemCpyException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MismatchedMemCpyException</h3>
      <p class="pseudocode">// MismatchedMemCpyException()
// ===========================
// Generates an exception for a CPY* instruction if the version
// is inconsistent with the state of the call.

<a id="impl-aarch64.MismatchedMemCpyException.7"/>MismatchedMemCpyException(boolean option_a, integer destreg, integer srcreg, integer sizereg,
                          boolean wrong_option, boolean from_epilogue, bits(4) options)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    integer vect_offset = 0x0;
    bits(2) target_el = <a href="shared_pseudocode.html#impl-aarch64.MismatchedCpySetTargetEL.0" title="function: bits(2) MismatchedCpySetTargetEL()">MismatchedCpySetTargetEL</a>();

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_MemCpyMemSet" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</a>);
    exception.syndrome&lt;24&gt;    = '0';
    exception.syndrome&lt;23&gt;    = '0';
    exception.syndrome&lt;22:19&gt; = options;
    exception.syndrome&lt;18&gt;    = if from_epilogue then '1' else '0';
    exception.syndrome&lt;17&gt;    = if wrong_option then '1' else '0';
    exception.syndrome&lt;16&gt;    = if option_a then '1' else '0';
    // exception.syndrome&lt;15&gt; is RES0
    exception.syndrome&lt;14:10&gt; = destreg&lt;4:0&gt;;
    exception.syndrome&lt;9:5&gt;   = srcreg&lt;4:0&gt;;
    exception.syndrome&lt;4:0&gt;   = sizereg&lt;4:0&gt;;

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.MismatchedMemSetException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/MismatchedMemSetException</h3>
      <p class="pseudocode">// MismatchedMemSetException()
// ===========================
// Generates an exception for a SET* instruction if the version
// is inconsistent with the state of the call.

<a id="impl-aarch64.MismatchedMemSetException.8"/>MismatchedMemSetException(boolean option_a, integer destreg, integer datareg, integer sizereg,
                          boolean wrong_option, boolean from_epilogue, bits(2) options,
                          boolean is_SETG)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    integer vect_offset = 0x0;
    bits(2) target_el = <a href="shared_pseudocode.html#impl-aarch64.MismatchedCpySetTargetEL.0" title="function: bits(2) MismatchedCpySetTargetEL()">MismatchedCpySetTargetEL</a>();

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_MemCpyMemSet" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_MemCpyMemSet</a>);
    exception.syndrome&lt;24&gt;    = '1';
    exception.syndrome&lt;23&gt;    = if is_SETG then '1' else '0';
    // exception.syndrome&lt;22:21&gt; is RES0
    exception.syndrome&lt;20:19&gt; = options;
    exception.syndrome&lt;18&gt;    = if from_epilogue then '1' else '0';
    exception.syndrome&lt;17&gt;    = if wrong_option then '1' else '0';
    exception.syndrome&lt;16&gt;    = if option_a then '1' else '0';
    // exception.syndrome&lt;15&gt; is RES0
    exception.syndrome&lt;14:10&gt; = destreg&lt;4:0&gt;;
    exception.syndrome&lt;9:5&gt;   = datareg&lt;4:0&gt;;
    exception.syndrome&lt;4:0&gt;   = sizereg&lt;4:0&gt;;

    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETPostSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETPostSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the set that is performed by the SETE* or SETGE* instructions
// for this implementation, given the parameters of the destination and size of the set.
// Postsize is encoded as -1*size for an option A implementation if setsize is negative.
bits(64) <a id="impl-aarch64.SETPostSizeChoice.3"/>SETPostSizeChoice(bits(64) toaddress, bits(64) setsize, boolean IsSETGE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETPreSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETPreSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the set that is performed by the SETP* or SETGP* instructions
// for this implementation, given the parameters of the destination and size of the set.
// Presize is encoded as -1*size for an option A implementation if setsize is negative.
bits(64) <a id="impl-aarch64.SETPreSizeChoice.3"/>SETPreSizeChoice(bits(64) toaddress, bits(64) setsize, boolean IsSETGP);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.mops.SETSizeChoice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/mops/SETSizeChoice</h3>
      <p class="pseudocode">// Returns the size of the block thisperformed for an iteration of the set given
// the parameters of the destination and size of the set. The size of the block
// is an integer multiple of AlignSize.
integer <a id="impl-aarch64.SETSizeChoice.3"/>SETSizeChoice(bits(64) toaddress, bits(64) setsize, integer AlignSize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpac.AddPAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpac/AddPAC</h3>
      <p class="pseudocode">// AddPAC()
// ========
// Calculates the pointer authentication code for a 64-bit quantity and then
// inserts that into pointer authentication code field of that 64-bit quantity.

bits(64) <a id="impl-aarch64.AddPAC.4"/>AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)
    bits(64) PAC;
    bits(64) result;
    bits(64) ext_ptr;
    bits(64) extfield;
    bit selbit;
    boolean tbi = <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(ptr, !data, PSTATE.EL) == '1';
    integer top_bit = if tbi then 55 else 63;

    // If tagged pointers are in use for a regime with two TTBRs, use bit&lt;55&gt; of
    // the pointer to select between upper and lower ranges, and preserve this.
    // This handles the awkward case where there is apparently no correct choice between
    // the upper and lower address range - ie an addr of 1xxxxxxx0... with TBI0=0 and TBI1=1
    // and 0xxxxxxx1 with TBI1=0 and TBI0=1:
    if <a href="shared_pseudocode.html#impl-aarch64.PtrHasUpperAndLowerAddRanges.0" title="function: boolean PtrHasUpperAndLowerAddRanges()">PtrHasUpperAndLowerAddRanges</a>() then
        assert <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};
        if <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
            // EL1 translation regime registers
            if data then
                if TCR_EL1.TBI1 == '1' || TCR_EL1.TBI0 == '1' then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
            else
                if ((TCR_EL1.TBI1 == '1' &amp;&amp; TCR_EL1.TBID1 == '0') ||
                    (TCR_EL1.TBI0 == '1' &amp;&amp; TCR_EL1.TBID0 == '0')) then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
        else
            // EL2 translation regime registers
            if data then
                if TCR_EL2.TBI1 == '1' || TCR_EL2.TBI0 == '1' then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
            else
                if ((TCR_EL2.TBI1 == '1' &amp;&amp; TCR_EL2.TBID1 == '0') ||
                    (TCR_EL2.TBI0 == '1' &amp;&amp; TCR_EL2.TBID0 == '0')) then
                    selbit = ptr&lt;55&gt;;
                else
                    selbit = ptr&lt;63&gt;;
    else selbit = if tbi then ptr&lt;55&gt; else ptr&lt;63&gt;;

    if <a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.ConstPACField.0" title="function: boolean ConstPACField()">ConstPACField</a>() then selbit = ptr&lt;55&gt;;
    integer bottom_PAC_bit = <a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)">CalculateBottomPACBit</a>(selbit);

    // The pointer authentication code field takes all the available bits in between
    extfield = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(selbit, 64);

    // Compute the pointer authentication code for a ptr with good extension bits
    if tbi then
        ext_ptr = ptr&lt;63:56&gt;:extfield&lt;(56-bottom_PAC_bit)-1:0&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;
    else
        ext_ptr = extfield&lt;(64-bottom_PAC_bit)-1:0&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;

    PAC = <a href="shared_pseudocode.html#impl-aarch64.ComputePAC.4" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)">ComputePAC</a>(ext_ptr, modifier, K&lt;127:64&gt;, K&lt;63:0&gt;);

    // Check if the ptr has good extension bits and corrupt the pointer authentication code if not
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ptr&lt;top_bit:bottom_PAC_bit&gt;) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(ptr&lt;top_bit:bottom_PAC_bit&gt;) then
        if <a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC.0" title="function: boolean HaveEnhancedPAC()">HaveEnhancedPAC</a>() then
            PAC = 0x0000000000000000&lt;63:0&gt;;
        elsif !<a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
            PAC&lt;top_bit-1&gt; = NOT(PAC&lt;top_bit-1&gt;);

    // preserve the determination between upper and lower address at bit&lt;55&gt; and insert PAC
    if !<a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
        if tbi then
            result = ptr&lt;63:56&gt;:selbit:PAC&lt;54:bottom_PAC_bit&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;
        else
            result = PAC&lt;63:56&gt;:selbit:PAC&lt;54:bottom_PAC_bit&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;
    else
        if tbi then
            result = ptr&lt;63:56&gt;:selbit:(ptr&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;):ptr&lt;bottom_PAC_bit-1:0&gt;;
        else
            result = (ptr&lt;63:56&gt; EOR PAC&lt;63:56&gt;):selbit:(ptr&lt;54:bottom_PAC_bit&gt; EOR
                        PAC&lt;54:bottom_PAC_bit&gt;):ptr&lt;bottom_PAC_bit-1:0&gt;;
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacda.AddPACDA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacda/AddPACDA</h3>
      <p class="pseudocode">// AddPACDA()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APDAKey_EL1.

bits(64) <a id="impl-aarch64.AddPACDA.2"/>AddPACDA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDAKey_EL1;

    APDAKey_EL1 = APDAKeyHi_EL1&lt;63:0&gt; : APDAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDA else SCTLR_EL2.EnDA;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDA;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else return <a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(X, Y, APDAKey_EL1, TRUE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacdb.AddPACDB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacdb/AddPACDB</h3>
      <p class="pseudocode">// AddPACDB()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APDBKey_EL1.

bits(64) <a id="impl-aarch64.AddPACDB.2"/>AddPACDB(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDBKey_EL1;

    APDBKey_EL1 = APDBKeyHi_EL1&lt;63:0&gt; : APDBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDB else SCTLR_EL2.EnDB;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDB;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else return <a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(X, Y, APDBKey_EL1, TRUE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacga.AddPACGA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacga/AddPACGA</h3>
      <p class="pseudocode">// AddPACGA()
// ==========
// Returns a 64-bit value where the lower 32 bits are 0, and the upper 32 bits contain
// a 32-bit pointer authentication code which is derived using a cryptographic
// algorithm as a combination of X, Y and the APGAKey_EL1.

bits(64) <a id="impl-aarch64.AddPACGA.2"/>AddPACGA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(128) APGAKey_EL1;

    APGAKey_EL1 = APGAKeyHi_EL1&lt;63:0&gt; : APGAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if TrapEL2 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else return <a href="shared_pseudocode.html#impl-aarch64.ComputePAC.4" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)">ComputePAC</a>(X, Y, APGAKey_EL1&lt;127:64&gt;, APGAKey_EL1&lt;63:0&gt;)&lt;63:32&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacia.AddPACIA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacia/AddPACIA</h3>
      <p class="pseudocode">// AddPACIA()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y, and the
// APIAKey_EL1.

bits(64) <a id="impl-aarch64.AddPACIA.2"/>AddPACIA(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIAKey_EL1;

    APIAKey_EL1 = APIAKeyHi_EL1&lt;63:0&gt;:APIAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIA else SCTLR_EL2.EnIA;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIA;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else return <a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(X, Y, APIAKey_EL1, FALSE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.addpacib.AddPACIB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/addpacib/AddPACIB</h3>
      <p class="pseudocode">// AddPACIB()
// ==========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with a pointer authentication code, where the pointer authentication
// code is derived using a cryptographic algorithm as a combination of X, Y and the
// APIBKey_EL1.

bits(64) <a id="impl-aarch64.AddPACIB.2"/>AddPACIB(bits(64) X, bits(64) Y)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIBKey_EL1;

    APIBKey_EL1 = APIBKeyHi_EL1&lt;63:0&gt; : APIBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIB else SCTLR_EL2.EnIB;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIB;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else return <a href="shared_pseudocode.html#impl-aarch64.AddPAC.4" title="function: bits(64) AddPAC(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data)">AddPAC</a>(X, Y, APIBKey_EL1, FALSE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.auth.AArch64.PACFailException"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/auth/AArch64.PACFailException</h3>
      <p class="pseudocode">// AArch64.PACFailException()
// ==========================
// Generates a PAC Fail Exception

<a id="AArch64.PACFailException.1"/>AArch64.PACFailException(bits(2) syndrome)
    route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_PACFail" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACFail</a>);
    exception.syndrome&lt;1:0&gt;   = syndrome;
    exception.syndrome&lt;24:2&gt;  = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();                // RES0

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>) then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(PSTATE.EL, exception, preferred_exception_return, vect_offset);
    elsif route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.auth.Auth"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/auth/Auth</h3>
      <p class="pseudocode">// Auth()
// ======
// Restores the upper bits of the address to be all zeros or all ones (based on the
// value of bit[55]) and computes and checks the pointer authentication code. If the
// check passes, then the restored address is returned. If the check fails, the
// second-top and third-top bits of the extension bits in the pointer authentication code
// field are corrupted to ensure that accessing the address will give a translation fault.

bits(64) <a id="impl-aarch64.Auth.6"/>Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,
              boolean is_combined)
    bits(64) PAC;
    bits(64) result;
    bits(64) original_ptr;
    bits(2) error_code;
    bits(64) extfield;

    // Reconstruct the extension field used of adding the PAC to the pointer
    boolean tbi = <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(ptr, !data, PSTATE.EL) == '1';
    integer bottom_PAC_bit = <a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)">CalculateBottomPACBit</a>(ptr&lt;55&gt;);
    extfield = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(ptr&lt;55&gt;, 64);

    if tbi then
        original_ptr = ptr&lt;63:56&gt;:extfield&lt;56-bottom_PAC_bit-1:0&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;
    else
        original_ptr = extfield&lt;64-bottom_PAC_bit-1:0&gt;:ptr&lt;bottom_PAC_bit-1:0&gt;;

    PAC = <a href="shared_pseudocode.html#impl-aarch64.ComputePAC.4" title="function: bits(64) ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)">ComputePAC</a>(original_ptr, modifier, K&lt;127:64&gt;, K&lt;63:0&gt;);
    // Check pointer authentication code
    if tbi then
        if !<a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
            if PAC&lt;54:bottom_PAC_bit&gt; == ptr&lt;54:bottom_PAC_bit&gt; then
                result = original_ptr;
            else
                error_code = key_number:NOT(key_number);
                result = original_ptr&lt;63:55&gt;:error_code:original_ptr&lt;52:0&gt;;
        else
            result = ptr;
            result&lt;54:bottom_PAC_bit&gt; = result&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;;
            if <a href="shared_pseudocode.html#impl-aarch64.HaveFPACCombined.0" title="function: boolean HaveFPACCombined()">HaveFPACCombined</a>() || (<a href="shared_pseudocode.html#impl-aarch64.HaveFPAC.0" title="function: boolean HaveFPAC()">HaveFPAC</a>() &amp;&amp; !is_combined) then
                if result&lt;54:bottom_PAC_bit&gt; != <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(result&lt;55&gt;, (55-bottom_PAC_bit)) then
                    error_code = (if data then '1' else '0'):key_number;
                    <a href="shared_pseudocode.html#AArch64.PACFailException.1" title="function: AArch64.PACFailException(bits(2) syndrome)">AArch64.PACFailException</a>(error_code);
    else
        if !<a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() then
            if PAC&lt;54:bottom_PAC_bit&gt; == ptr&lt;54:bottom_PAC_bit&gt; &amp;&amp; PAC&lt;63:56&gt; == ptr&lt;63:56&gt; then
                result = original_ptr;
            else
                error_code = key_number:NOT(key_number);
                result = original_ptr&lt;63&gt;:error_code:original_ptr&lt;60:0&gt;;
        else
            result = ptr;
            result&lt;54:bottom_PAC_bit&gt; = result&lt;54:bottom_PAC_bit&gt; EOR PAC&lt;54:bottom_PAC_bit&gt;;
            result&lt;63:56&gt; = result&lt;63:56&gt; EOR PAC&lt;63:56&gt;;
            if <a href="shared_pseudocode.html#impl-aarch64.HaveFPACCombined.0" title="function: boolean HaveFPACCombined()">HaveFPACCombined</a>() || (<a href="shared_pseudocode.html#impl-aarch64.HaveFPAC.0" title="function: boolean HaveFPAC()">HaveFPAC</a>() &amp;&amp; !is_combined) then
                if result&lt;63:bottom_PAC_bit&gt; != <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(result&lt;55&gt;, (64-bottom_PAC_bit)) then
                    error_code = (if data then '1' else '0'):key_number;
                    <a href="shared_pseudocode.html#AArch64.PACFailException.1" title="function: AArch64.PACFailException(bits(2) syndrome)">AArch64.PACFailException</a>(error_code);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authda.AuthDA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authda/AuthDA</h3>
      <p class="pseudocode">// AuthDA()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACDA().

bits(64) <a id="impl-aarch64.AuthDA.3"/>AuthDA(bits(64) X, bits(64) Y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDAKey_EL1;

    APDAKey_EL1 = APDAKeyHi_EL1&lt;63:0&gt; : APDAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDA else SCTLR_EL2.EnDA;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDA;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else  return <a href="shared_pseudocode.html#impl-aarch64.Auth.6" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(X, Y, APDAKey_EL1, TRUE, '0', is_combined);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authdb.AuthDB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authdb/AuthDB</h3>
      <p class="pseudocode">// AuthDB()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a
// pointer authentication code in the pointer authentication code field bits of X, using
// the same algorithm and key as AddPACDB().

bits(64) <a id="impl-aarch64.AuthDB.3"/>AuthDB(bits(64) X, bits(64) Y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APDBKey_EL1;

    APDBKey_EL1 = APDBKeyHi_EL1&lt;63:0&gt; : APDBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnDB else SCTLR_EL2.EnDB;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                        (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnDB;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnDB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else  return <a href="shared_pseudocode.html#impl-aarch64.Auth.6" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(X, Y, APDBKey_EL1, TRUE, '1', is_combined);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authia.AuthIA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authia/AuthIA</h3>
      <p class="pseudocode">// AuthIA()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACIA().

bits(64) <a id="impl-aarch64.AuthIA.3"/>AuthIA(bits(64) X, bits(64) Y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIAKey_EL1;

    APIAKey_EL1 = APIAKeyHi_EL1&lt;63:0&gt; : APIAKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIA else SCTLR_EL2.EnIA;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIA;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIA;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else  return <a href="shared_pseudocode.html#impl-aarch64.Auth.6" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(X, Y, APIAKey_EL1, FALSE, '0', is_combined);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.authib.AuthIB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/authib/AuthIB</h3>
      <p class="pseudocode">// AuthIB()
// ========
// Returns a 64-bit value containing X, but replacing the pointer authentication code
// field bits with the extension of the address bits. The instruction checks a pointer
// authentication code in the pointer authentication code field bits of X, using the same
// algorithm and key as AddPACIB().

bits(64) <a id="impl-aarch64.AuthIB.3"/>AuthIB(bits(64) X, bits(64) Y, boolean is_combined)
    boolean TrapEL2;
    boolean TrapEL3;
    bits(1)  Enable;
    bits(128) APIBKey_EL1;

    APIBKey_EL1 = APIBKeyHi_EL1&lt;63:0&gt; : APIBKeyLo_EL1&lt;63:0&gt;;
    case PSTATE.EL of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            boolean IsEL1Regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            Enable = if IsEL1Regime then SCTLR_EL1.EnIB else SCTLR_EL2.EnIB;
            TrapEL2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0' &amp;&amp;
                       (HCR_EL2.TGE == '0' || HCR_EL2.E2H == '0'));
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            Enable = SCTLR_EL1.EnIB;
            TrapEL2 = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.API == '0';
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            Enable = SCTLR_EL2.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.API == '0';
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            Enable = SCTLR_EL3.EnIB;
            TrapEL2 = FALSE;
            TrapEL3 = FALSE;

    if Enable == '0' then return X;
    elsif TrapEL2 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
    elsif TrapEL3 then <a href="shared_pseudocode.html#impl-aarch64.TrapPACUse.1" title="function: TrapPACUse(bits(2) target_el)">TrapPACUse</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    else  return <a href="shared_pseudocode.html#impl-aarch64.Auth.6" title="function: bits(64) Auth(bits(64) ptr, bits(64) modifier, bits(128) K, boolean data, bit key_number,&#13; boolean is_combined)">Auth</a>(X, Y, APIBKey_EL1, FALSE, '1', is_combined);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.calcbottompacbit.CalculateBottomPACBit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/calcbottompacbit/CalculateBottomPACBit</h3>
      <p class="pseudocode">// CalculateBottomPACBit()
// =======================

integer <a id="impl-aarch64.CalculateBottomPACBit.1"/>CalculateBottomPACBit(bit top_bit)
    integer tsz_field;

    if <a href="shared_pseudocode.html#impl-aarch64.PtrHasUpperAndLowerAddRanges.0" title="function: boolean PtrHasUpperAndLowerAddRanges()">PtrHasUpperAndLowerAddRanges</a>() then
        assert <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};
        if <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>() == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
            // EL1 translation regime registers
            tsz_field = if top_bit == '1' then <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL1.T1SZ) else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL1.T0SZ);
            using64k = if top_bit == '1' then TCR_EL1.TG1 == '11' else TCR_EL1.TG0 == '01';
        else
            // EL2 translation regime registers
            assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
            tsz_field = if top_bit == '1' then <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL2.T1SZ) else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL2.T0SZ);
            using64k = if top_bit == '1' then TCR_EL2.TG1 == '11' else TCR_EL2.TG0 == '01';
    else
        tsz_field = if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL2.T0SZ) else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(TCR_EL3.T0SZ);
        using64k = if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then TCR_EL2.TG0 == '01' else TCR_EL3.TG0 == '01';

    max_limit_tsz_field = (if !<a href="shared_pseudocode.html#impl-shared.HaveSmallTranslationTableExt.0" title="function: boolean HaveSmallTranslationTableExt()">HaveSmallTranslationTableExt</a>() then 39 else if using64k then 47 else 48);
    if tsz_field &gt; max_limit_tsz_field then
        // TCR_ELx.TySZ is out of range
        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESTnSZ</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
        if c == <a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a> then tsz_field = max_limit_tsz_field;
    tszmin = if using64k &amp;&amp; <a href="shared_pseudocode.html#AArch64.VAMax.0" title="function: integer AArch64.VAMax()">AArch64.VAMax</a>() == 52 then 12 else 16;
    if tsz_field &lt; tszmin then
        c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESTnSZ</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
        if c == <a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a> then tsz_field = tszmin;
    return (64-tsz_field);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.ComputePAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/ComputePAC</h3>
      <p class="pseudocode">// ComputePAC()
// ============

bits(64) <a id="impl-aarch64.ComputePAC.4"/>ComputePAC(bits(64) data, bits(64) modifier, bits(64) key0, bits(64) key1)
    bits(64)  workingval;
    bits(64)  runningmod;
    bits(64)  roundkey;
    bits(64)  modk0;
    constant bits(64) Alpha = 0xC0AC29B7C97C50DD&lt;63:0&gt;;

    integer iterations;
    if <a href="shared_pseudocode.html#impl-aarch64.HavePACQARMA3.0" title="function: boolean HavePACQARMA3()">HavePACQARMA3</a>() then
        iterations = 2;
        RC[0] = 0x0000000000000000&lt;63:0&gt;;
        RC[1] = 0x13198A2E03707344&lt;63:0&gt;;
        RC[2] = 0xA4093822299F31D0&lt;63:0&gt;;
    else
        iterations = 4;
        RC[0] = 0x0000000000000000&lt;63:0&gt;;
        RC[1] = 0x13198A2E03707344&lt;63:0&gt;;
        RC[2] = 0xA4093822299F31D0&lt;63:0&gt;;
        RC[3] = 0x082EFA98EC4E6C89&lt;63:0&gt;;
        RC[4] = 0x452821E638D01377&lt;63:0&gt;;

    modk0 = key0&lt;0&gt;:key0&lt;63:2&gt;:(key0&lt;63&gt; EOR key0&lt;1&gt;);
    runningmod = modifier;
    workingval = data EOR key0;
    for i = 0 to iterations
        roundkey = key1 EOR runningmod;
        workingval  = workingval EOR roundkey;
        workingval = workingval EOR RC[i];
        if i &gt; 0 then
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)">PACCellShuffle</a>(workingval);
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
        if <a href="shared_pseudocode.html#impl-aarch64.HavePACQARMA3.0" title="function: boolean HavePACQARMA3()">HavePACQARMA3</a>() then
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub1.1" title="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
        else
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub.1" title="function: bits(64) PACSub(bits(64) Tinput)">PACSub</a>(workingval);
        runningmod = <a href="shared_pseudocode.html#impl-aarch64.TweakShuffle.1" title="function: bits(64) TweakShuffle(bits(64) indata)">TweakShuffle</a>(runningmod&lt;63:0&gt;);
    roundkey = modk0 EOR runningmod;
    workingval = workingval EOR roundkey;
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)">PACCellShuffle</a>(workingval);
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
    if <a href="shared_pseudocode.html#impl-aarch64.HavePACQARMA3.0" title="function: boolean HavePACQARMA3()">HavePACQARMA3</a>() then
        workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub1.1" title="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
    else
        workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub.1" title="function: bits(64) PACSub(bits(64) Tinput)">PACSub</a>(workingval);
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellShuffle.1" title="function: bits(64) PACCellShuffle(bits(64) indata)">PACCellShuffle</a>(workingval);
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
    workingval = key1 EOR workingval;
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)">PACCellInvShuffle</a>(workingval);
    if <a href="shared_pseudocode.html#impl-aarch64.HavePACQARMA3.0" title="function: boolean HavePACQARMA3()">HavePACQARMA3</a>() then
        workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub1.1" title="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
    else
        workingval = <a href="shared_pseudocode.html#impl-aarch64.PACInvSub.1" title="function: bits(64) PACInvSub(bits(64) Tinput)">PACInvSub</a>(workingval);
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
    workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)">PACCellInvShuffle</a>(workingval);
    workingval = workingval EOR key0;
    workingval = workingval EOR runningmod;
    for i = 0 to iterations
        if <a href="shared_pseudocode.html#impl-aarch64.HavePACQARMA3.0" title="function: boolean HavePACQARMA3()">HavePACQARMA3</a>() then
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACSub1.1" title="function: bits(64) PACSub1(bits(64) Tinput)">PACSub1</a>(workingval);
        else
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACInvSub.1" title="function: bits(64) PACInvSub(bits(64) Tinput)">PACInvSub</a>(workingval);
        if i &lt; iterations then
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACMult.1" title="function: bits(64) PACMult(bits(64) Sinput)">PACMult</a>(workingval);
            workingval = <a href="shared_pseudocode.html#impl-aarch64.PACCellInvShuffle.1" title="function: bits(64) PACCellInvShuffle(bits(64) indata)">PACCellInvShuffle</a>(workingval);
        runningmod = <a href="shared_pseudocode.html#impl-aarch64.TweakInvShuffle.1" title="function: bits(64) TweakInvShuffle(bits(64) indata)">TweakInvShuffle</a>(runningmod&lt;63:0&gt;);
        roundkey = key1 EOR runningmod;
        workingval = workingval EOR RC[iterations-i];
        workingval = workingval EOR roundkey;
        workingval = workingval EOR Alpha;
    workingval = workingval EOR modk0;

    return workingval;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACCellInvShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACCellInvShuffle</h3>
      <p class="pseudocode">// PACCellInvShuffle()
// ===================

bits(64) <a id="impl-aarch64.PACCellInvShuffle.1"/>PACCellInvShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = indata&lt;15:12&gt;;
    outdata&lt;7:4&gt; = indata&lt;27:24&gt;;
    outdata&lt;11:8&gt; = indata&lt;51:48&gt;;
    outdata&lt;15:12&gt; = indata&lt;39:36&gt;;
    outdata&lt;19:16&gt; = indata&lt;59:56&gt;;
    outdata&lt;23:20&gt; = indata&lt;47:44&gt;;
    outdata&lt;27:24&gt; = indata&lt;7:4&gt;;
    outdata&lt;31:28&gt; = indata&lt;19:16&gt;;
    outdata&lt;35:32&gt; = indata&lt;35:32&gt;;
    outdata&lt;39:36&gt; = indata&lt;55:52&gt;;
    outdata&lt;43:40&gt; = indata&lt;31:28&gt;;
    outdata&lt;47:44&gt; = indata&lt;11:8&gt;;
    outdata&lt;51:48&gt; = indata&lt;23:20&gt;;
    outdata&lt;55:52&gt; = indata&lt;3:0&gt;;
    outdata&lt;59:56&gt; = indata&lt;43:40&gt;;
    outdata&lt;63:60&gt; = indata&lt;63:60&gt;;
    return outdata;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACCellShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACCellShuffle</h3>
      <p class="pseudocode">// PACCellShuffle()
// ================

bits(64) <a id="impl-aarch64.PACCellShuffle.1"/>PACCellShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = indata&lt;55:52&gt;;
    outdata&lt;7:4&gt; = indata&lt;27:24&gt;;
    outdata&lt;11:8&gt; = indata&lt;47:44&gt;;
    outdata&lt;15:12&gt; = indata&lt;3:0&gt;;
    outdata&lt;19:16&gt; = indata&lt;31:28&gt;;
    outdata&lt;23:20&gt; = indata&lt;51:48&gt;;
    outdata&lt;27:24&gt; = indata&lt;7:4&gt;;
    outdata&lt;31:28&gt; = indata&lt;43:40&gt;;
    outdata&lt;35:32&gt; = indata&lt;35:32&gt;;
    outdata&lt;39:36&gt; = indata&lt;15:12&gt;;
    outdata&lt;43:40&gt; = indata&lt;59:56&gt;;
    outdata&lt;47:44&gt; = indata&lt;23:20&gt;;
    outdata&lt;51:48&gt; = indata&lt;11:8&gt;;
    outdata&lt;55:52&gt; = indata&lt;39:36&gt;;
    outdata&lt;59:56&gt; = indata&lt;19:16&gt;;
    outdata&lt;63:60&gt; = indata&lt;63:60&gt;;
    return outdata;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACInvSub"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACInvSub</h3>
      <p class="pseudocode">// PACInvSub()
// ===========

bits(64) <a id="impl-aarch64.PACInvSub.1"/>PACInvSub(bits(64) Tinput)
    // This is a 4-bit substitution from the PRINCE-family cipher
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i&gt; of
            when '0000'  Toutput&lt;4*i+3:4*i&gt; = '0101';
            when '0001'  Toutput&lt;4*i+3:4*i&gt; = '1110';
            when '0010'  Toutput&lt;4*i+3:4*i&gt; = '1101';
            when '0011'  Toutput&lt;4*i+3:4*i&gt; = '1000';
            when '0100'  Toutput&lt;4*i+3:4*i&gt; = '1010';
            when '0101'  Toutput&lt;4*i+3:4*i&gt; = '1011';
            when '0110'  Toutput&lt;4*i+3:4*i&gt; = '0001';
            when '0111'  Toutput&lt;4*i+3:4*i&gt; = '1001';
            when '1000'  Toutput&lt;4*i+3:4*i&gt; = '0010';
            when '1001'  Toutput&lt;4*i+3:4*i&gt; = '0110';
            when '1010'  Toutput&lt;4*i+3:4*i&gt; = '1111';
            when '1011'  Toutput&lt;4*i+3:4*i&gt; = '0000';
            when '1100'  Toutput&lt;4*i+3:4*i&gt; = '0100';
            when '1101'  Toutput&lt;4*i+3:4*i&gt; = '1100';
            when '1110'  Toutput&lt;4*i+3:4*i&gt; = '0111';
            when '1111'  Toutput&lt;4*i+3:4*i&gt; = '0011';
    return Toutput;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACMult"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACMult</h3>
      <p class="pseudocode">// PACMult()
// =========

bits(64) <a id="impl-aarch64.PACMult.1"/>PACMult(bits(64) Sinput)
    bits(4)  t0;
    bits(4)  t1;
    bits(4)  t2;
    bits(4)  t3;
    bits(64) Soutput;

    for i = 0 to 3
        t0&lt;3:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+8)+3:4*(i+8)&gt;, 1) EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+4)+3:4*(i+4)&gt;, 2);
        t0&lt;3:0&gt; = t0&lt;3:0&gt; EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i)+3:4*(i)&gt;, 1);
        t1&lt;3:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+12)+3:4*(i+12)&gt;, 1) EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+4)+3:4*(i+4)&gt;, 1);
        t1&lt;3:0&gt; = t1&lt;3:0&gt; EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i)+3:4*(i)&gt;, 2);
        t2&lt;3:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+12)+3:4*(i+12)&gt;, 2) EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+8)+3:4*(i+8)&gt;, 1);
        t2&lt;3:0&gt; = t2&lt;3:0&gt; EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i)+3:4*(i)&gt;, 1);
        t3&lt;3:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+12)+3:4*(i+12)&gt;, 1) EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+8)+3:4*(i+8)&gt;, 2);
        t3&lt;3:0&gt; = t3&lt;3:0&gt; EOR <a href="shared_pseudocode.html#impl-aarch64.RotCell.2" title="function: bits(4) RotCell(bits(4) incell, integer amount)">RotCell</a>(Sinput&lt;4*(i+4)+3:4*(i+4)&gt;, 1);
        Soutput&lt;4*i+3:4*i&gt; = t3&lt;3:0&gt;;
        Soutput&lt;4*(i+4)+3:4*(i+4)&gt; = t2&lt;3:0&gt;;
        Soutput&lt;4*(i+8)+3:4*(i+8)&gt; = t1&lt;3:0&gt;;
        Soutput&lt;4*(i+12)+3:4*(i+12)&gt; = t0&lt;3:0&gt;;
    return Soutput;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PACSub"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PACSub</h3>
      <p class="pseudocode">// PACSub()
// ========

bits(64) <a id="impl-aarch64.PACSub.1"/>PACSub(bits(64) Tinput)
    // This is a 4-bit substitution from the PRINCE-family cipher
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i&gt; of
            when '0000'  Toutput&lt;4*i+3:4*i&gt; = '1011';
            when '0001'  Toutput&lt;4*i+3:4*i&gt; = '0110';
            when '0010'  Toutput&lt;4*i+3:4*i&gt; = '1000';
            when '0011'  Toutput&lt;4*i+3:4*i&gt; = '1111';
            when '0100'  Toutput&lt;4*i+3:4*i&gt; = '1100';
            when '0101'  Toutput&lt;4*i+3:4*i&gt; = '0000';
            when '0110'  Toutput&lt;4*i+3:4*i&gt; = '1001';
            when '0111'  Toutput&lt;4*i+3:4*i&gt; = '1110';
            when '1000'  Toutput&lt;4*i+3:4*i&gt; = '0011';
            when '1001'  Toutput&lt;4*i+3:4*i&gt; = '0111';
            when '1010'  Toutput&lt;4*i+3:4*i&gt; = '0100';
            when '1011'  Toutput&lt;4*i+3:4*i&gt; = '0101';
            when '1100'  Toutput&lt;4*i+3:4*i&gt; = '1101';
            when '1101'  Toutput&lt;4*i+3:4*i&gt; = '0010';
            when '1110'  Toutput&lt;4*i+3:4*i&gt; = '0001';
            when '1111'  Toutput&lt;4*i+3:4*i&gt; = '1010';
    return Toutput;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.PacSub1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/PacSub1</h3>
      <p class="pseudocode">// PacSub1()
// =========

bits(64) <a id="impl-aarch64.PACSub1.1"/>PACSub1(bits(64) Tinput)
    // This is a 4-bit substitution from Qarma sigma1
    bits(64) Toutput;
    for i = 0 to 15
        case Tinput&lt;4*i+3:4*i&gt; of
            when '0000' Toutput&lt;4*i+3:4*i&gt; = '1010';
            when '0001' Toutput&lt;4*i+3:4*i&gt; = '1101';
            when '0010' Toutput&lt;4*i+3:4*i&gt; = '1110';
            when '0011' Toutput&lt;4*i+3:4*i&gt; = '0110';
            when '0100' Toutput&lt;4*i+3:4*i&gt; = '1111';
            when '0101' Toutput&lt;4*i+3:4*i&gt; = '0111';
            when '0110' Toutput&lt;4*i+3:4*i&gt; = '0011';
            when '0111' Toutput&lt;4*i+3:4*i&gt; = '0101';
            when '1000' Toutput&lt;4*i+3:4*i&gt; = '1001';
            when '1001' Toutput&lt;4*i+3:4*i&gt; = '1000';
            when '1010' Toutput&lt;4*i+3:4*i&gt; = '0000';
            when '1011' Toutput&lt;4*i+3:4*i&gt; = '1100';
            when '1100' Toutput&lt;4*i+3:4*i&gt; = '1011';
            when '1101' Toutput&lt;4*i+3:4*i&gt; = '0001';
            when '1110' Toutput&lt;4*i+3:4*i&gt; = '0010';
            when '1111' Toutput&lt;4*i+3:4*i&gt; = '0100';
    return Toutput;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.RC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/RC</h3>
      <p class="pseudocode">array bits(64) RC[0..4];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.RotCell"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/RotCell</h3>
      <p class="pseudocode">// RotCell()
// =========

bits(4) <a id="impl-aarch64.RotCell.2"/>RotCell(bits(4) incell, integer amount)
    bits(8) tmp;
    bits(4) outcell;

    // assert amount&gt;3 || amount&lt;1;
    tmp&lt;7:0&gt; = incell&lt;3:0&gt;:incell&lt;3:0&gt;;
    outcell = tmp&lt;7-amount:4-amount&gt;;
    return outcell;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakCellInvRot"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakCellInvRot</h3>
      <p class="pseudocode">// TweakCellInvRot()
// =================

bits(4) <a id="impl-aarch64.TweakCellInvRot.1"/>TweakCellInvRot(bits(4) incell)
    bits(4) outcell;
    outcell&lt;3&gt; = incell&lt;2&gt;;
    outcell&lt;2&gt; = incell&lt;1&gt;;
    outcell&lt;1&gt; = incell&lt;0&gt;;
    outcell&lt;0&gt; = incell&lt;0&gt; EOR incell&lt;3&gt;;
    return outcell;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakCellRot"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakCellRot</h3>
      <p class="pseudocode">// TweakCellRot()
// ==============

bits(4) <a id="impl-aarch64.TweakCellRot.1"/>TweakCellRot(bits(4) incell)
    bits(4) outcell;
    outcell&lt;3&gt; = incell&lt;0&gt; EOR incell&lt;1&gt;;
    outcell&lt;2&gt; = incell&lt;3&gt;;
    outcell&lt;1&gt; = incell&lt;2&gt;;
    outcell&lt;0&gt; = incell&lt;1&gt;;
    return outcell;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakInvShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakInvShuffle</h3>
      <p class="pseudocode">// TweakInvShuffle()
// =================

bits(64) <a id="impl-aarch64.TweakInvShuffle.1"/>TweakInvShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;51:48&gt;);
    outdata&lt;7:4&gt; = indata&lt;55:52&gt;;
    outdata&lt;11:8&gt; = indata&lt;23:20&gt;;
    outdata&lt;15:12&gt; = indata&lt;27:24&gt;;
    outdata&lt;19:16&gt; = indata&lt;3:0&gt;;
    outdata&lt;23:20&gt; = indata&lt;7:4&gt;;
    outdata&lt;27:24&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;11:8&gt;);
    outdata&lt;31:28&gt; = indata&lt;15:12&gt;;
    outdata&lt;35:32&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;31:28&gt;);
    outdata&lt;39:36&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;63:60&gt;);
    outdata&lt;43:40&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;59:56&gt;);
    outdata&lt;47:44&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;19:16&gt;);
    outdata&lt;51:48&gt; = indata&lt;35:32&gt;;
    outdata&lt;55:52&gt; = indata&lt;39:36&gt;;
    outdata&lt;59:56&gt; = indata&lt;43:40&gt;;
    outdata&lt;63:60&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellInvRot.1" title="function: bits(4) TweakCellInvRot(bits(4) incell)">TweakCellInvRot</a>(indata&lt;47:44&gt;);
    return outdata;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.computepac.TweakShuffle"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/computepac/TweakShuffle</h3>
      <p class="pseudocode">// TweakShuffle()
// ==============

bits(64) <a id="impl-aarch64.TweakShuffle.1"/>TweakShuffle(bits(64) indata)
    bits(64) outdata;
    outdata&lt;3:0&gt; = indata&lt;19:16&gt;;
    outdata&lt;7:4&gt; = indata&lt;23:20&gt;;
    outdata&lt;11:8&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;27:24&gt;);
    outdata&lt;15:12&gt; = indata&lt;31:28&gt;;
    outdata&lt;19:16&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;47:44&gt;);
    outdata&lt;23:20&gt; = indata&lt;11:8&gt;;
    outdata&lt;27:24&gt; = indata&lt;15:12&gt;;
    outdata&lt;31:28&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;35:32&gt;);
    outdata&lt;35:32&gt; = indata&lt;51:48&gt;;
    outdata&lt;39:36&gt; = indata&lt;55:52&gt;;
    outdata&lt;43:40&gt; = indata&lt;59:56&gt;;
    outdata&lt;47:44&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;63:60&gt;);
    outdata&lt;51:48&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;3:0&gt;);
    outdata&lt;55:52&gt; = indata&lt;7:4&gt;;
    outdata&lt;59:56&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;43:40&gt;);
    outdata&lt;63:60&gt; = <a href="shared_pseudocode.html#impl-aarch64.TweakCellRot.1" title="function: bits(4) TweakCellRot(bits(4) incell)">TweakCellRot</a>(indata&lt;39:36&gt;);
    return outdata;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.ConstPACField"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/ConstPACField</h3>
      <p class="pseudocode">// ConstPACField()
// ===============
// Returns TRUE if bit&lt;55&gt; can be used to determine the size of the PAC field, FALSE otherwise.

boolean <a id="impl-aarch64.ConstPACField.0"/>ConstPACField()
    return boolean IMPLEMENTATION_DEFINED "Bit 55 determines the size of the PAC field";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HaveEnhancedPAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HaveEnhancedPAC</h3>
      <p class="pseudocode">// HaveEnhancedPAC()
// =================
// Returns TRUE if support for EnhancedPAC is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveEnhancedPAC.0"/>HaveEnhancedPAC()
    return ( <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()
        &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has enhanced PAC functionality" );</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HaveEnhancedPAC2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HaveEnhancedPAC2</h3>
      <p class="pseudocode">// HaveEnhancedPAC2()
// ==================
// Returns TRUE if support for EnhancedPAC2 is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveEnhancedPAC2.0"/>HaveEnhancedPAC2()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p6" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>) || (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has enhanced PAC 2 functionality");</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HaveFPAC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HaveFPAC</h3>
      <p class="pseudocode">// HaveFPAC()
// ==========
// Returns TRUE if support for FPAC is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveFPAC.0"/>HaveFPAC()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveEnhancedPAC2.0" title="function: boolean HaveEnhancedPAC2()">HaveEnhancedPAC2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has FPAC functionality";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HaveFPACCombined"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HaveFPACCombined</h3>
      <p class="pseudocode">// HaveFPACCombined()
// ==================
// Returns TRUE if support for FPACCombined is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveFPACCombined.0"/>HaveFPACCombined()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveFPAC.0" title="function: boolean HaveFPAC()">HaveFPAC</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has FPAC Combined functionality";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACExt"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACExt</h3>
      <p class="pseudocode">// HavePACExt()
// ============
// Returns TRUE if support for the PAC extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACExt.0"/>HavePACExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACIMP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACIMP</h3>
      <p class="pseudocode">// HavePACIMP()
// ============
// Returns TRUE if support for PAC IMP is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACIMP.0"/>HavePACIMP()
    return <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has PAC IMP functionality";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACQARMA3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACQARMA3</h3>
      <p class="pseudocode">// HavePACQARMA3()
// ===============
// Returns TRUE if support for PAC QARMA3 is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACQARMA3.0"/>HavePACQARMA3()
    return <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has PAC QARMA3 functionality";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.HavePACQARMA5"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/HavePACQARMA5</h3>
      <p class="pseudocode">// HavePACQARMA5()
// ===============
// Returns TRUE if support for PAC QARMA5 is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HavePACQARMA5.0"/>HavePACQARMA5()
    return <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has PAC QARMA5 functionality";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.pac.PtrHasUpperAndLowerAddRanges"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/pac/PtrHasUpperAndLowerAddRanges</h3>
      <p class="pseudocode">// PtrHasUpperAndLowerAddRanges()
// ==============================
// Returns TRUE if the pointer has upper and lower address ranges, FALSE otherwise.

boolean <a id="impl-aarch64.PtrHasUpperAndLowerAddRanges.0"/>PtrHasUpperAndLowerAddRanges()
    regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.2" title="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</a>(PSTATE.EL, <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>);
    return <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.strip.Strip"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/strip/Strip</h3>
      <p class="pseudocode">// Strip()
// =======
// Strip() returns a 64-bit value containing A, but replacing the pointer authentication
// code field bits with the extension of the address bits. This can apply to either
// instructions or data, where, as the use of tagged pointers is distinct, it might be
// handled differently.

bits(64) <a id="impl-aarch64.Strip.2"/>Strip(bits(64) A, boolean data)
    bits(64) original_ptr;
    bits(64) extfield;
    boolean tbi = <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(A, !data, PSTATE.EL) == '1';
    integer bottom_PAC_bit = <a href="shared_pseudocode.html#impl-aarch64.CalculateBottomPACBit.1" title="function: integer CalculateBottomPACBit(bit top_bit)">CalculateBottomPACBit</a>(A&lt;55&gt;);
    extfield = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(A&lt;55&gt;, 64);

    if tbi then
        original_ptr = A&lt;63:56&gt;:extfield&lt; 56-bottom_PAC_bit-1:0&gt;:A&lt;bottom_PAC_bit-1:0&gt;;
    else
        original_ptr = extfield&lt; 64-bottom_PAC_bit-1:0&gt;:A&lt;bottom_PAC_bit-1:0&gt;;

    return original_ptr;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.pac.trappacuse.TrapPACUse"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/pac/trappacuse/TrapPACUse</h3>
      <p class="pseudocode">// TrapPACUse()
// ============
// Used for the trapping of the pointer authentication functions by higher exception
// levels.

<a id="impl-aarch64.TrapPACUse.1"/>TrapPACUse(bits(2) target_el)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el) &amp;&amp; target_el !=  <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);

    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> exception;
    vect_offset = 0;
    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_PACTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_PACTrap</a>);
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64.ESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64.ESBOperation</h3>
      <p class="pseudocode">// AArch64.ESBOperation()
// ======================
// Perform the AArch64 ESB operation, either for ESB executed in AArch64 state, or for
// ESB in AArch32 state when SError interrupts are routed to an Exception level using
// AArch64

<a id="AArch64.ESBOperation.0"/>AArch64.ESBOperation()

    route_to_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EA == '1';
    route_to_el2 = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                    (HCR_EL2.TGE == '1' || HCR_EL2.AMO == '1'));

    target = if route_to_el3 then <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> elsif route_to_el2 then <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    if target == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
        mask_active = PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};
    elsif <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; target == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11' then
        mask_active = PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};
    else
        mask_active = PSTATE.EL == target;

    mask_set = (PSTATE.A == '1' &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() || SCR_EL3.EA == '0' ||
                                    PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> || SCR_EL3.NMEA == '0'));
    intdis = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(target);
    masked = (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target) &lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL)) || intdis || (mask_active &amp;&amp; mask_set);

    // Check for a masked Physical SError pending that can be synchronized
    // by an Error synchronization event.
    if masked &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSynchronizablePhysicalSErrorPending.0" title="function: boolean IsSynchronizablePhysicalSErrorPending()">IsSynchronizablePhysicalSErrorPending</a>() then
        // This function might be called for an interworking case, and INTdis is masking
        // the SError interrupt.
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()) then
            syndrome32 = <a href="shared_pseudocode.html#AArch32.PhysicalSErrorSyndrome.0" title="function: AArch32.SErrorSyndrome AArch32.PhysicalSErrorSyndrome()">AArch32.PhysicalSErrorSyndrome</a>();
            DISR = <a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)">AArch32.ReportDeferredSError</a>(syndrome32.AET, syndrome32.ExT);
        else
            implicit_esb = FALSE;
            syndrome64 = <a href="shared_pseudocode.html#AArch64.PhysicalSErrorSyndrome.1" title="function: bits(25) AArch64.PhysicalSErrorSyndrome(boolean implicit_esb)">AArch64.PhysicalSErrorSyndrome</a>(implicit_esb);
            DISR_EL1 = <a href="shared_pseudocode.html#AArch64.ReportDeferredSError.1" title="function: bits(64) AArch64.ReportDeferredSError(bits(25) syndrome)">AArch64.ReportDeferredSError</a>(syndrome64);
        <a href="shared_pseudocode.html#impl-shared.ClearPendingPhysicalSError.0" title="function: ClearPendingPhysicalSError()">ClearPendingPhysicalSError</a>();               // Set ISR_EL1.A to 0

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64.PhysicalSErrorSyndrome"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64.PhysicalSErrorSyndrome</h3>
      <p class="pseudocode">// Return the SError syndrome
bits(25) <a id="AArch64.PhysicalSErrorSyndrome.1"/>AArch64.PhysicalSErrorSyndrome(boolean implicit_esb);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64.ReportDeferredSError"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64.ReportDeferredSError</h3>
      <p class="pseudocode">// AArch64.ReportDeferredSError()
// ==============================
// Generate deferred SError syndrome

bits(64) <a id="AArch64.ReportDeferredSError.1"/>AArch64.ReportDeferredSError(bits(25) syndrome)
    bits(64) target;
    target&lt;31&gt;   = '1';              // A
    target&lt;24&gt;   = syndrome&lt;24&gt;;     // IDS
    target&lt;23:0&gt; = syndrome&lt;23:0&gt;;   // ISS
    return target;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.ras.AArch64.vESBOperation"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/ras/AArch64.vESBOperation</h3>
      <p class="pseudocode">// AArch64.vESBOperation()
// =======================
// Perform the AArch64 ESB operation for virtual SError interrupts, either for ESB
// executed in AArch64 state, or for ESB in AArch32 state with EL2 using AArch64 state

<a id="AArch64.vESBOperation.0"/>AArch64.vESBOperation()
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    // If physical SError interrupts are routed to EL2, and TGE is not set, then a virtual
    // SError interrupt might be pending
    vSEI_enabled = HCR_EL2.TGE == '0' &amp;&amp; HCR_EL2.AMO == '1';
    vSEI_pending = vSEI_enabled &amp;&amp; HCR_EL2.VSE == '1';
    vintdis      = <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalDebugInterruptsDisabled.1" title="function: boolean ExternalDebugInterruptsDisabled(bits(2) target)">ExternalDebugInterruptsDisabled</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    vmasked      = vintdis || PSTATE.A == '1';

    // Check for a masked virtual SError pending
    if vSEI_pending &amp;&amp; vmasked then
        // This function might be called for the interworking case, and INTdis is masking
        // the virtual SError interrupt.
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
            VDISR = <a href="shared_pseudocode.html#AArch32.ReportDeferredSError.2" title="function: bits(32) AArch32.ReportDeferredSError(bits(2) AET, bit ExT)">AArch32.ReportDeferredSError</a>(VDFSR&lt;15:14&gt;, VDFSR&lt;12&gt;);
        else
            VDISR_EL2 = <a href="shared_pseudocode.html#AArch64.ReportDeferredSError.1" title="function: bits(64) AArch64.ReportDeferredSError(bits(25) syndrome)">AArch64.ReportDeferredSError</a>(VSESR_EL2&lt;24:0&gt;);
        HCR_EL2.VSE = '0';                       // Clear pending virtual SError

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64.MaybeZeroRegisterUppers"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64.MaybeZeroRegisterUppers</h3>
      <p class="pseudocode">// AArch64.MaybeZeroRegisterUppers()
// =================================
// On taking an exception to  AArch64 from AArch32, it is CONSTRAINED UNPREDICTABLE whether the top
// 32 bits of registers visible at any lower Exception level using AArch32 are set to zero.

<a id="AArch64.MaybeZeroRegisterUppers.0"/>AArch64.MaybeZeroRegisterUppers()
    assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();         // Always called from AArch32 state before entering AArch64 state

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        first = 0;  last = 14;  include_R15 = FALSE;
    elsif PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        first = 0;  last = 30;  include_R15 = FALSE;
    else
        first = 0;  last = 30;  include_R15 = TRUE;

    for n = first to last
        if (n != 15 || include_R15) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ZEROUPPER</a>) then
            _R[n]&lt;63:32&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64.ResetGeneralRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64.ResetGeneralRegisters</h3>
      <p class="pseudocode">// AArch64.ResetGeneralRegisters()
// ===============================

<a id="AArch64.ResetGeneralRegisters.0"/>AArch64.ResetGeneralRegisters()

    for i = 0 to 30
        <a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value">X</a>[i] = bits(64) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64.ResetSIMDFPRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64.ResetSIMDFPRegisters</h3>
      <p class="pseudocode">// AArch64.ResetSIMDFPRegisters()
// ==============================

<a id="AArch64.ResetSIMDFPRegisters.0"/>AArch64.ResetSIMDFPRegisters()

    for i = 0 to 31
        <a href="shared_pseudocode.html#impl-aarch64.V.write.1" title="accessor: V[integer n] = bits(width) value">V</a>[i] = bits(128) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64.ResetSpecialRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64.ResetSpecialRegisters</h3>
      <p class="pseudocode">// AArch64.ResetSpecialRegisters()
// ===============================

<a id="AArch64.ResetSpecialRegisters.0"/>AArch64.ResetSpecialRegisters()

    // AArch64 special registers
    SP_EL0 = bits(64) UNKNOWN;
    SP_EL1 = bits(64) UNKNOWN;
    SPSR_EL1 = bits(64) UNKNOWN;
    ELR_EL1  = bits(64) UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        SP_EL2 = bits(64) UNKNOWN;
        SPSR_EL2 = bits(64) UNKNOWN;
        ELR_EL2  = bits(64) UNKNOWN;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        SP_EL3 = bits(64) UNKNOWN;
        SPSR_EL3 = bits(64) UNKNOWN;
        ELR_EL3  = bits(64) UNKNOWN;

    // AArch32 special registers that are not architecturally mapped to AArch64 registers
    if <a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        SPSR_fiq&lt;31:0&gt; = bits(32) UNKNOWN;
        SPSR_irq&lt;31:0&gt; = bits(32) UNKNOWN;
        SPSR_abt&lt;31:0&gt; = bits(32) UNKNOWN;
        SPSR_und&lt;31:0&gt; = bits(32) UNKNOWN;

    // External debug special registers
    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(64) UNKNOWN;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.AArch64.ResetSystemRegisters"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/AArch64.ResetSystemRegisters</h3>
      <p class="pseudocode"><a id="AArch64.ResetSystemRegisters.1"/>AArch64.ResetSystemRegisters(boolean cold_reset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.PC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/PC</h3>
      <p class="pseudocode">// PC - non-assignment form
// ========================
// Read program counter.

bits(64) <a id="impl-aarch64.PC.read.0"/>PC[]
    return _PC;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.SP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/SP</h3>
      <p class="pseudocode">// SP[] - assignment form
// ======================
// Write to stack pointer from either a 32-bit or a 64-bit value.

<a id="impl-aarch64.SP.write.0"/>SP[] = bits(width) value
    assert width IN {32,64};
    if PSTATE.SP == '0' then
        SP_EL0 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    else
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  SP_EL0 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  SP_EL1 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  SP_EL2 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  SP_EL3 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    return;

// SP[] - non-assignment form
// ==========================
// Read stack pointer with implicit slice of 8, 16, 32 or 64 bits.

bits(width) <a id="impl-aarch64.SP.read.0"/>SP[]
    assert width IN {8,16,32,64};
    if PSTATE.SP == '0' then
        return SP_EL0&lt;width-1:0&gt;;
    else
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  return SP_EL0&lt;width-1:0&gt;;
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  return SP_EL1&lt;width-1:0&gt;;
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  return SP_EL2&lt;width-1:0&gt;;
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  return SP_EL3&lt;width-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.V"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/V</h3>
      <p class="pseudocode">// V[] - assignment form
// =====================
// Write to SIMD&amp;FP register with implicit extension from
// 8, 16, 32, 64 or 128 bits.

<a id="impl-aarch64.V.write.1"/>V[integer n] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64,128};
    integer vlen = if <a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)">IsSVEEnabled</a>(PSTATE.EL) then <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a> else 128;
    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SVEZEROUPPER</a>) then
        _Z[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    else
        _Z[n]&lt;vlen-1:0&gt; = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);

// V[] - non-assignment form
// =========================
// Read from SIMD&amp;FP register with implicit slice of 8, 16
// 32, 64 or 128 bits.

bits(width) <a id="impl-aarch64.V.read.1"/>V[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64,128};
    return _Z[n]&lt;width-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.Vpart"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/Vpart</h3>
      <p class="pseudocode">// Vpart[] - non-assignment form
// =============================
// Reads a 128-bit SIMD&amp;FP register in up to two parts:
//  part 0 returns the bottom 8, 16, 32 or 64 bits of a value held in the register;
//  part 1 returns the top half of the bottom 64 bits or the top half of the 128-bit
//  value held in the register.

bits(width) <a id="impl-aarch64.Vpart.read.2"/>Vpart[integer n, integer part]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert part IN {0, 1};
    if part == 0 then
        assert width &lt; 128;
        return <a href="shared_pseudocode.html#impl-aarch64.V.read.1" title="accessor: bits(width) V[integer n]">V</a>[n];
    else
        assert width IN {32,64};
        bits(128) vreg = <a href="shared_pseudocode.html#impl-aarch64.V.read.1" title="accessor: bits(width) V[integer n]">V</a>[n];
        return vreg&lt;(width * 2)-1:width&gt;;

// Vpart[] - assignment form
// =========================
// Writes a 128-bit SIMD&amp;FP register in up to two parts:
//  part 0 zero extends a 8, 16, 32, or 64-bit value to fill the whole register;
//  part 1 inserts a 64-bit value into the top half of the register.

<a id="impl-aarch64.Vpart.write.2"/>Vpart[integer n, integer part] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert part IN {0, 1};
    if part == 0 then
        assert width &lt; 128;
        <a href="shared_pseudocode.html#impl-aarch64.V.write.1" title="accessor: V[integer n] = bits(width) value">V</a>[n] = value;
    else
        assert width == 64;
        bits(64) vreg = <a href="shared_pseudocode.html#impl-aarch64.V.read.1" title="accessor: bits(width) V[integer n]">V</a>[n];
        <a href="shared_pseudocode.html#impl-aarch64.V.write.1" title="accessor: V[integer n] = bits(width) value">V</a>[n] = value&lt;63:0&gt; : vreg;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.registers.X"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/registers/X</h3>
      <p class="pseudocode">// X[] - assignment form
// =====================
// Write to general-purpose register from either a 32-bit or a 64-bit value.

<a id="impl-aarch64.X.write.1"/>X[integer n] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {32,64};
    if n != 31 then
        _R[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    return;

// X[] - non-assignment form
// =========================
// Read from general-purpose register with implicit slice of 8, 16, 32 or 64 bits.

bits(width) <a id="impl-aarch64.X.read.1"/>X[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width IN {8,16,32,64};
    if n != 31 then
        return _R[n]&lt;width-1:0&gt;;
    else
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(width);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveEBF16"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveEBF16</h3>
      <p class="pseudocode">// HaveEBF16()
// ===========
// Returns TRUE if the EBF16 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveEBF16.0"/>HaveEBF16()
    return boolean IMPLEMENTATION_DEFINED "Have EBF16 extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveSME"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveSME</h3>
      <p class="pseudocode">// HaveSME()
// =========
// Returns TRUE if the SME extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSME.0"/>HaveSME()
    return boolean IMPLEMENTATION_DEFINED "Have SME extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveSMEF64F64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveSMEF64F64</h3>
      <p class="pseudocode">// HaveSMEF64F64()
// ===============
// Returns TRUE if the SMEF64F64 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSMEF64F64.0"/>HaveSMEF64F64()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SMEF64F64 extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.HaveSMEI16I64"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/HaveSMEI16I64</h3>
      <p class="pseudocode">// HaveSMEI16I64()
// ===============
// Returns TRUE if the SMEI16I64 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSMEI16I64.0"/>HaveSMEI16I64()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SMEI16I64 extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.System"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/System</h3>
      <p class="pseudocode">array bits(<a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>) _ZA[0..255];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAhslice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAhslice</h3>
      <p class="pseudocode">// ZAhslice[] - non-assignment form
// ================================

bits(width) <a id="impl-aarch64.ZAhslice.read.3"/>ZAhslice[integer tile, integer esize, integer slice]
    assert esize IN {8, 16, 32, 64, 128};
    integer tiles = esize DIV 8;
    assert tile &gt;= 0 &amp;&amp; tile &lt; tiles;
    integer slices = <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a> DIV esize;
    assert slice &gt;= 0 &amp;&amp; slice &lt; slices;

    return <a href="shared_pseudocode.html#impl-aarch64.ZAvector.read.1" title="accessor: bits(width) ZAvector[integer index]">ZAvector</a>[tile + slice * tiles];

// ZAhslice[] - assignment form
// ============================

<a id="impl-aarch64.ZAhslice.write.3"/>ZAhslice[integer tile, integer esize, integer slice] = bits(width) value
    assert esize IN {8, 16, 32, 64, 128};
    integer tiles = esize DIV 8;
    assert tile &gt;= 0 &amp;&amp; tile &lt; tiles;
    integer slices = <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a> DIV esize;
    assert slice &gt;= 0 &amp;&amp; slice &lt; slices;

    <a href="shared_pseudocode.html#impl-aarch64.ZAvector.write.1" title="accessor: ZAvector[integer index] = bits(width) value">ZAvector</a>[tile + slice * tiles] = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAslice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAslice</h3>
      <p class="pseudocode">// ZAslice[] - non-assignment form
// ===============================

bits(width) <a id="impl-aarch64.ZAslice.read.4"/>ZAslice[integer tile, integer esize, boolean vertical, integer slice]
    bits(width) result;

    if vertical then
        result = <a href="shared_pseudocode.html#impl-aarch64.ZAvslice.read.3" title="accessor: bits(width) ZAvslice[integer tile, integer esize, integer slice]">ZAvslice</a>[tile, esize, slice];
    else
        result = <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.read.3" title="accessor: bits(width) ZAhslice[integer tile, integer esize, integer slice]">ZAhslice</a>[tile, esize, slice];

    return result;

// ZAslice[] - assignment form
// ===========================

<a id="impl-aarch64.ZAslice.write.4"/>ZAslice[integer tile, integer esize, boolean vertical, integer slice] = bits(width) value
    if vertical then
        <a href="shared_pseudocode.html#impl-aarch64.ZAvslice.write.3" title="accessor: ZAvslice[integer tile, integer esize, integer slice] = bits(width) value">ZAvslice</a>[tile, esize, slice] = value;
    else
        <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.write.3" title="accessor: ZAhslice[integer tile, integer esize, integer slice] = bits(width) value">ZAhslice</a>[tile, esize, slice] = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAtile"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAtile</h3>
      <p class="pseudocode">// ZAtile[] - non-assignment form
// ==============================

bits(width) <a id="impl-aarch64.ZAtile.read.2"/>ZAtile[integer tile, integer esize]
    integer slices = <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a> DIV esize;
    assert width == <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a> * slices;
    bits(width) result;

    for slice = 0 to slices-1
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, slice, <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a>] = <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.read.3" title="accessor: bits(width) ZAhslice[integer tile, integer esize, integer slice]">ZAhslice</a>[tile, esize, slice];

    return result;

// ZAtile[] - assignment form
// ==========================

<a id="impl-aarch64.ZAtile.write.2"/>ZAtile[integer tile, integer esize] = bits(width) value
    integer slices = <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a> DIV esize;
    assert width == <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a> * slices;

    for slice = 0 to slices-1
        <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.write.3" title="accessor: ZAhslice[integer tile, integer esize, integer slice] = bits(width) value">ZAhslice</a>[tile, esize, slice] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[value, slice, <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a>];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAvector"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAvector</h3>
      <p class="pseudocode">// ZAvector[] - non-assignment form
// ================================

bits(width) <a id="impl-aarch64.ZAvector.read.1"/>ZAvector[integer index]
    assert width == <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a>;
    assert index &gt;= 0 &amp;&amp; index &lt; (width DIV 8);

    return _ZA[index]&lt;width-1:0&gt;;

// ZAvector[] - assignment form
// ============================

<a id="impl-aarch64.ZAvector.write.1"/>ZAvector[integer index] = bits(width) value
    assert width == <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a>;
    assert index &gt;= 0 &amp;&amp; index &lt; (width DIV 8);

    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SMEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SMEZEROUPPER</a>) then
        _ZA[index] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    else
        _ZA[index]&lt;width-1:0&gt; = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sme.ZAvslice"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sme/ZAvslice</h3>
      <p class="pseudocode">// ZAvslice[] - non-assignment form
// ================================

bits(width) <a id="impl-aarch64.ZAvslice.read.3"/>ZAvslice[integer tile, integer esize, integer slice]
    integer slices = <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a> DIV esize;
    bits(width) result;

    for s = 0 to slices-1
        bits(width) hslice = <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.read.3" title="accessor: bits(width) ZAhslice[integer tile, integer esize, integer slice]">ZAhslice</a>[tile, esize, s];
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, s, esize] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[hslice, slice, esize];

    return result;

// ZAvslice[] - assignment form
// ============================

<a id="impl-aarch64.ZAvslice.write.3"/>ZAvslice[integer tile, integer esize, integer slice] = bits(width) value
    integer slices = <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a> DIV esize;

    for s = 0 to slices-1
        bits(width) hslice = <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.read.3" title="accessor: bits(width) ZAhslice[integer tile, integer esize, integer slice]">ZAhslice</a>[tile, esize, s];
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[hslice, slice, esize] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[value, s, esize];
        <a href="shared_pseudocode.html#impl-aarch64.ZAhslice.write.3" title="accessor: ZAhslice[integer tile, integer esize, integer slice] = bits(width) value">ZAhslice</a>[tile, esize, s] = hslice;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.AArch32.IsFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/AArch32.IsFPEnabled</h3>
      <p class="pseudocode">// AArch32.IsFPEnabled()
// =====================
// Returns TRUE if access to the SIMD&amp;FP instructions or System registers are
// enabled at the target exception level in AArch32 state and FALSE otherwise.

boolean <a id="AArch32.IsFPEnabled.1"/>AArch32.IsFPEnabled(bits(2) el)
    if el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        return <a href="shared_pseudocode.html#AArch64.IsFPEnabled.1" title="function: boolean AArch64.IsFPEnabled(bits(2) el)">AArch64.IsFPEnabled</a>(el);

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        // Check if access disabled in NSACR
        if NSACR.cp10 == '0' then return FALSE;

    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
        // Check if access disabled in CPACR
        case CPACR.cp10 of
            when '00' disabled = TRUE;
            when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '10' disabled = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_RESCPACR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESCPACR</a>);
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            return <a href="shared_pseudocode.html#AArch64.IsFPEnabled.1" title="function: boolean AArch64.IsFPEnabled(bits(2) el)">AArch64.IsFPEnabled</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        if HCPTR.TCP10 == '1' then return FALSE;

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        // Check if access disabled in CPTR_EL3
        if CPTR_EL3.TFP == '1' then return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.AArch64.IsFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/AArch64.IsFPEnabled</h3>
      <p class="pseudocode">// AArch64.IsFPEnabled()
// =====================
// Returns TRUE if access to the SIMD&amp;FP instructions or System registers are
// enabled at the target exception level in AArch64 state and FALSE otherwise.

boolean <a id="AArch64.IsFPEnabled.1"/>AArch64.IsFPEnabled(bits(2) el)
    // Check if access disabled in CPACR_EL1
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check FP&amp;SIMD at EL0/EL1
        case CPACR_EL1.FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    // Check if access disabled in CPTR_EL2
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            case CPTR_EL2.FPEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then return FALSE;
        else
            if CPTR_EL2.TFP == '1' then return FALSE;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.TFP == '1' then return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.AnyActiveElement"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/AnyActiveElement</h3>
      <p class="pseudocode">// AnyActiveElement()
// ==================
// Return TRUE if there is at least one active element in mask. Otherwise,
// return FALSE.

boolean <a id="impl-aarch64.AnyActiveElement.2"/>AnyActiveElement(bits(N) mask, integer esize)
    return <a href="shared_pseudocode.html#impl-aarch64.LastActiveElement.2" title="function: integer LastActiveElement(bits(N) mask, integer esize)">LastActiveElement</a>(mask, esize) &gt;= 0;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.BitDeposit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/BitDeposit</h3>
      <p class="pseudocode">// BitDeposit()
// ============
// Deposit the least significant bits from DATA into result positions
// selected by non-zero bits in MASK, setting other result bits to zero.

bits(N) <a id="impl-aarch64.BitDeposit.2"/>BitDeposit (bits(N) data, bits(N) mask)
    bits(N) res = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    integer db = 0;
    for rb = 0 to N-1
        if mask&lt;rb&gt; == '1' then
            res&lt;rb&gt; = data&lt;db&gt;;
            db = db + 1;
    return res;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.BitExtract"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/BitExtract</h3>
      <p class="pseudocode">// BitExtract()
// ============
// Extract and pack DATA bits selected by the non-zero bits in MASK into
// the least significant result bits, setting other result bits to zero.

bits(N) <a id="impl-aarch64.BitExtract.2"/>BitExtract (bits(N) data, bits(N) mask)
    bits(N) res = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    integer rb = 0;
    for db = 0 to N-1
        if mask&lt;db&gt; == '1' then
            res&lt;rb&gt; = data&lt;db&gt;;
            rb = rb + 1;
    return res;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.BitGroup"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/BitGroup</h3>
      <p class="pseudocode">// BitGroup()
// ==========
// Extract and pack DATA bits selected by the non-zero bits in MASK into
// the least significant result bits, and pack unselected bits into the
// most significant result bits.

bits(N) <a id="impl-aarch64.BitGroup.2"/>BitGroup (bits(N) data, bits(N) mask)
    bits(N) res;
    integer rb = 0;

    // compress masked bits to right
    for db = 0 to N-1
        if mask&lt;db&gt; == '1' then
            res&lt;rb&gt; = data&lt;db&gt;;
            rb = rb + 1;
    // compress unmasked bits to left
    for db = 0 to N-1
        if mask&lt;db&gt; == '0' then
            res&lt;rb&gt; = data&lt;db&gt;;
            rb = rb + 1;
    return res;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CeilPow2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CeilPow2</h3>
      <p class="pseudocode">// CeilPow2()
// ==========

// For a positive integer X, return the smallest power of 2 &gt;= X

integer <a id="impl-aarch64.CeilPow2.1"/>CeilPow2(integer x)
    if x == 0 then return 0;
    if x == 1 then return 2;
    return <a href="shared_pseudocode.html#impl-aarch64.FloorPow2.1" title="function: integer FloorPow2(integer x)">FloorPow2</a>(x - 1) * 2;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckNonStreamingSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckNonStreamingSVEEnabled</h3>
      <p class="pseudocode">// CheckNonStreamingSVEEnabled()
// =============================
// Checks for traps on SVE instructions that are not legal in streaming mode.

<a id="impl-aarch64.CheckNonStreamingSVEEnabled.0"/>CheckNonStreamingSVEEnabled()
    <a href="shared_pseudocode.html#impl-aarch64.CheckSVEEnabled.0" title="function: CheckSVEEnabled()">CheckSVEEnabled</a>();

    if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.IsFullA64Enabled.0" title="function: boolean IsFullA64Enabled()">IsFullA64Enabled</a>() then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_Streaming" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_Streaming</a>, PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckNormalSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckNormalSVEEnabled</h3>
      <p class="pseudocode">// CheckNormalSVEEnabled()
// =======================
// Checks for traps on normal SVE instructions and instructions that
// access SVE System registers.

<a id="impl-aarch64.CheckNormalSVEEnabled.0"/>CheckNormalSVEEnabled()
    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SVE at EL0/EL1
        case CPACR_EL1.ZEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)">SVEAccessTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

        // Check SIMD&amp;FP at EL0/EL1
        case CPACR_EL1.FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    // Check if access disabled in CPTR_EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            // Check SVE at EL2
            case CPTR_EL2.ZEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)">SVEAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

            // Check SIMD&amp;FP at EL2
            case CPTR_EL2.FPEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        else
            if CPTR_EL2.TZ == '1' then <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)">SVEAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
            if CPTR_EL2.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.EZ == '0' then <a href="shared_pseudocode.html#impl-aarch64.SVEAccessTrap.1" title="function: SVEAccessTrap(bits(2) target_el)">SVEAccessTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        if CPTR_EL3.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEAccess</h3>
      <p class="pseudocode">// CheckSMEAccess()
// ================
// Check that access to SME System registers is enabled.

<a id="impl-aarch64.CheckSMEAccess.0"/>CheckSMEAccess()
    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SME at EL0/EL1
        case CPACR_EL1.SMEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            // Check SME at EL2
            case CPTR_EL2.SMEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        else
            if CPTR_EL2.TSM == '1' then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.ESM == '0' then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEAndZAEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEAndZAEnabled</h3>
      <p class="pseudocode">// CheckSMEAndZAEnabled()
// ======================

<a id="impl-aarch64.CheckSMEAndZAEnabled.0"/>CheckSMEAndZAEnabled()
    <a href="shared_pseudocode.html#impl-aarch64.CheckSMEEnabled.0" title="function: CheckSMEEnabled()">CheckSMEEnabled</a>();

    if PSTATE.ZA == '0' then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_InactiveZA" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_InactiveZA</a>, PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSMEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSMEEnabled</h3>
      <p class="pseudocode">// CheckSMEEnabled()
// =================

<a id="impl-aarch64.CheckSMEEnabled.0"/>CheckSMEEnabled()
    // Check if access disabled in CPACR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SME at EL0/EL1
        case CPACR_EL1.SMEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

        // Check SIMD&amp;FP at EL0/EL1
        case CPACR_EL1.FPEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);

    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            // Check SME at EL2
            case CPTR_EL2.SMEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

            // Check SIMD&amp;FP at EL2
            case CPTR_EL2.FPEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        else
            if CPTR_EL2.TSM == '1' then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
            if CPTR_EL2.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.ESM == '0' then <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_AccessTrap</a>, <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        if CPTR_EL3.TFP == '1' then <a href="shared_pseudocode.html#AArch64.AdvSIMDFPAccessTrap.1" title="function: AArch64.AdvSIMDFPAccessTrap(bits(2) target_el)">AArch64.AdvSIMDFPAccessTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckSVEEnabled</h3>
      <p class="pseudocode">// CheckSVEEnabled()
// =================
// Checks for traps on SVE instructions and instructions that
// access SVE System registers.

<a id="impl-aarch64.CheckSVEEnabled.0"/>CheckSVEEnabled()
    if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; (PSTATE.SM == '1' || !<a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>()) then
        <a href="shared_pseudocode.html#impl-aarch64.CheckStreamingSVEEnabled.0" title="function: CheckStreamingSVEEnabled()">CheckStreamingSVEEnabled</a>();
    else
        <a href="shared_pseudocode.html#impl-aarch64.CheckNormalSVEEnabled.0" title="function: CheckNormalSVEEnabled()">CheckNormalSVEEnabled</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckStreamingSVEAndZAEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckStreamingSVEAndZAEnabled</h3>
      <p class="pseudocode">// CheckStreamingSVEAndZAEnabled()
// ===============================

<a id="impl-aarch64.CheckStreamingSVEAndZAEnabled.0"/>CheckStreamingSVEAndZAEnabled()
    <a href="shared_pseudocode.html#impl-aarch64.CheckStreamingSVEEnabled.0" title="function: CheckStreamingSVEEnabled()">CheckStreamingSVEEnabled</a>();

    if PSTATE.ZA == '0' then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_InactiveZA" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_InactiveZA</a>, PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.CheckStreamingSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/CheckStreamingSVEEnabled</h3>
      <p class="pseudocode">// CheckStreamingSVEEnabled()
// ==========================

<a id="impl-aarch64.CheckStreamingSVEEnabled.0"/>CheckStreamingSVEEnabled()
    <a href="shared_pseudocode.html#impl-aarch64.CheckSMEEnabled.0" title="function: CheckSMEEnabled()">CheckSMEEnabled</a>();

    if PSTATE.SM == '0' then
        <a href="shared_pseudocode.html#impl-aarch64.SMEAccessTrap.2" title="function: SMEAccessTrap(SMEExceptionType etype, bits(2) target_el)">SMEAccessTrap</a>(<a href="shared_pseudocode.html#SMEExceptionType_NotStreaming" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_NotStreaming</a>, PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.DecodePredCount"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/DecodePredCount</h3>
      <p class="pseudocode">// DecodePredCount()
// =================

integer <a id="impl-aarch64.DecodePredCount.2"/>DecodePredCount(bits(5) pattern, integer esize)
    integer elements = <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a> DIV esize;
    integer numElem;
    case pattern of
        when '00000' numElem = <a href="shared_pseudocode.html#impl-aarch64.FloorPow2.1" title="function: integer FloorPow2(integer x)">FloorPow2</a>(elements);
        when '00001' numElem = if elements &gt;= 1 then 1 else 0;
        when '00010' numElem = if elements &gt;= 2 then 2 else 0;
        when '00011' numElem = if elements &gt;= 3 then 3 else 0;
        when '00100' numElem = if elements &gt;= 4 then 4 else 0;
        when '00101' numElem = if elements &gt;= 5 then 5 else 0;
        when '00110' numElem = if elements &gt;= 6 then 6 else 0;
        when '00111' numElem = if elements &gt;= 7 then 7 else 0;
        when '01000' numElem = if elements &gt;= 8 then 8 else 0;
        when '01001' numElem = if elements &gt;= 16 then 16 else 0;
        when '01010' numElem = if elements &gt;= 32 then 32 else 0;
        when '01011' numElem = if elements &gt;= 64 then 64 else 0;
        when '01100' numElem = if elements &gt;= 128 then 128 else 0;
        when '01101' numElem = if elements &gt;= 256 then 256 else 0;
        when '11101' numElem = elements - (elements MOD 4);
        when '11110' numElem = elements - (elements MOD 3);
        when '11111' numElem = elements;
        otherwise    numElem = 0;
    return numElem;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ElemFFR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ElemFFR</h3>
      <p class="pseudocode">// ElemFFR[] - non-assignment form
// ===============================

bit <a id="impl-aarch64.ElemFFR.read.2"/>ElemFFR[integer e, integer esize]
    return <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[_FFR, e, esize];

// ElemFFR[] - assignment form
// ===========================

<a id="impl-aarch64.ElemFFR.write.2"/>ElemFFR[integer e, integer esize] = bit value
    integer psize = esize DIV 8;
    integer n = e * psize;
    assert n &gt;= 0 &amp;&amp; (n + psize) &lt;= <a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL">PL</a>;
    _FFR&lt;n+psize-1:n&gt; = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, psize);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ElemP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ElemP</h3>
      <p class="pseudocode">// ElemP[] - non-assignment form
// =============================

bit <a id="impl-aarch64.ElemP.read.3"/>ElemP[bits(N) pred, integer e, integer esize]
    assert esize IN {8, 16, 32, 64, 128};
    integer n = e * (esize DIV 8);
    assert n &gt;= 0 &amp;&amp; n &lt; N;
    return pred&lt;n&gt;;

// ElemP[] - assignment form
// =========================

<a id="impl-aarch64.ElemP.write.3"/>ElemP[bits(N) &amp;pred, integer e, integer esize] = bit value
    assert esize IN {8, 16, 32, 64, 128};
    integer psize = esize DIV 8;
    integer n = e * psize;
    assert n &gt;= 0 &amp;&amp; (n + psize) &lt;= N;
    pred&lt;n+psize-1:n&gt; = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(value, psize);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FFR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FFR</h3>
      <p class="pseudocode">// FFR[] - non-assignment form
// ===========================

bits(width) <a id="impl-aarch64.FFR.read.0"/>FFR[]
    assert width == <a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL">PL</a>;
    return _FFR&lt;width-1:0&gt;;

// FFR[] - assignment form
// =======================

<a id="impl-aarch64.FFR.write.0"/>FFR[] = bits(width) value
    assert width == <a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL">PL</a>;
    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SVEZEROUPPER</a>) then
        _FFR = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    else
        _FFR&lt;width-1:0&gt; = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPCompareNE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPCompareNE</h3>
      <p class="pseudocode">// FPCompareNE()
// =============

boolean <a id="impl-aarch64.FPCompareNE.3"/>FPCompareNE(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);
    op1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    op2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};

    if op1_nan || op2_nan then
        result = TRUE;
        if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 != value2);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPCompareUN"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPCompareUN</h3>
      <p class="pseudocode">// FPCompareUN()
// =============

boolean <a id="impl-aarch64.FPCompareUN.3"/>FPCompareUN(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    result = type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};

    if !result then
        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPConvertSVE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPConvertSVE</h3>
      <p class="pseudocode">// FPConvertSVE()
// ==============

bits(M) <a id="impl-aarch64.FPConvertSVE.3"/>FPConvertSVE(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)
    fpcr.AHP = '0';
    return <a href="shared_pseudocode.html#impl-shared.FPConvert.3" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)">FPConvert</a>(op, fpcr, rounding);

// FPConvertSVE()
// ==============

bits(M) <a id="impl-aarch64.FPConvertSVE.2"/>FPConvertSVE(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    fpcr.AHP = '0';
    return <a href="shared_pseudocode.html#impl-shared.FPConvert.3" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)">FPConvert</a>(op, fpcr, <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr));</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPExpA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPExpA</h3>
      <p class="pseudocode">// FPExpA()
// ========

bits(N) <a id="impl-aarch64.FPExpA.1"/>FPExpA(bits(N) op)
    assert N IN {16,32,64};
    bits(N) result;
    bits(N) coeff;
    integer idx = if N == 16 then <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(op&lt;4:0&gt;) else <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(op&lt;5:0&gt;);
    coeff = <a href="shared_pseudocode.html#impl-aarch64.FPExpCoefficient.read.1" title="accessor: bits(N) FPExpCoefficient[integer index]">FPExpCoefficient</a>[idx];
    if N == 16 then
        result&lt;15:0&gt; = '0':op&lt;9:5&gt;:coeff&lt;9:0&gt;;
    elsif N == 32 then
        result&lt;31:0&gt; = '0':op&lt;13:6&gt;:coeff&lt;22:0&gt;;
    else // N == 64
        result&lt;63:0&gt; = '0':op&lt;16:6&gt;:coeff&lt;51:0&gt;;

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPExpCoefficient"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPExpCoefficient</h3>
      <p class="pseudocode">// FPExpCoefficient()
// ==================

bits(N) <a id="impl-aarch64.FPExpCoefficient.read.1"/>FPExpCoefficient[integer index]
    assert N IN {16,32,64};
    integer result;

    if N == 16 then
        case index of
            when  0 result = 0x0000;
            when  1 result = 0x0016;
            when  2 result = 0x002d;
            when  3 result = 0x0045;
            when  4 result = 0x005d;
            when  5 result = 0x0075;
            when  6 result = 0x008e;
            when  7 result = 0x00a8;
            when  8 result = 0x00c2;
            when  9 result = 0x00dc;
            when 10 result = 0x00f8;
            when 11 result = 0x0114;
            when 12 result = 0x0130;
            when 13 result = 0x014d;
            when 14 result = 0x016b;
            when 15 result = 0x0189;
            when 16 result = 0x01a8;
            when 17 result = 0x01c8;
            when 18 result = 0x01e8;
            when 19 result = 0x0209;
            when 20 result = 0x022b;
            when 21 result = 0x024e;
            when 22 result = 0x0271;
            when 23 result = 0x0295;
            when 24 result = 0x02ba;
            when 25 result = 0x02e0;
            when 26 result = 0x0306;
            when 27 result = 0x032e;
            when 28 result = 0x0356;
            when 29 result = 0x037f;
            when 30 result = 0x03a9;
            when 31 result = 0x03d4;

    elsif N == 32 then
        case index of
            when  0 result = 0x000000;
            when  1 result = 0x0164d2;
            when  2 result = 0x02cd87;
            when  3 result = 0x043a29;
            when  4 result = 0x05aac3;
            when  5 result = 0x071f62;
            when  6 result = 0x08980f;
            when  7 result = 0x0a14d5;
            when  8 result = 0x0b95c2;
            when  9 result = 0x0d1adf;
            when 10 result = 0x0ea43a;
            when 11 result = 0x1031dc;
            when 12 result = 0x11c3d3;
            when 13 result = 0x135a2b;
            when 14 result = 0x14f4f0;
            when 15 result = 0x16942d;
            when 16 result = 0x1837f0;
            when 17 result = 0x19e046;
            when 18 result = 0x1b8d3a;
            when 19 result = 0x1d3eda;
            when 20 result = 0x1ef532;
            when 21 result = 0x20b051;
            when 22 result = 0x227043;
            when 23 result = 0x243516;
            when 24 result = 0x25fed7;
            when 25 result = 0x27cd94;
            when 26 result = 0x29a15b;
            when 27 result = 0x2b7a3a;
            when 28 result = 0x2d583f;
            when 29 result = 0x2f3b79;
            when 30 result = 0x3123f6;
            when 31 result = 0x3311c4;
            when 32 result = 0x3504f3;
            when 33 result = 0x36fd92;
            when 34 result = 0x38fbaf;
            when 35 result = 0x3aff5b;
            when 36 result = 0x3d08a4;
            when 37 result = 0x3f179a;
            when 38 result = 0x412c4d;
            when 39 result = 0x4346cd;
            when 40 result = 0x45672a;
            when 41 result = 0x478d75;
            when 42 result = 0x49b9be;
            when 43 result = 0x4bec15;
            when 44 result = 0x4e248c;
            when 45 result = 0x506334;
            when 46 result = 0x52a81e;
            when 47 result = 0x54f35b;
            when 48 result = 0x5744fd;
            when 49 result = 0x599d16;
            when 50 result = 0x5bfbb8;
            when 51 result = 0x5e60f5;
            when 52 result = 0x60ccdf;
            when 53 result = 0x633f89;
            when 54 result = 0x65b907;
            when 55 result = 0x68396a;
            when 56 result = 0x6ac0c7;
            when 57 result = 0x6d4f30;
            when 58 result = 0x6fe4ba;
            when 59 result = 0x728177;
            when 60 result = 0x75257d;
            when 61 result = 0x77d0df;
            when 62 result = 0x7a83b3;
            when 63 result = 0x7d3e0c;

    else // N == 64
        case index of
            when  0 result = 0x0000000000000;
            when  1 result = 0x02C9A3E778061;
            when  2 result = 0x059B0D3158574;
            when  3 result = 0x0874518759BC8;
            when  4 result = 0x0B5586CF9890F;
            when  5 result = 0x0E3EC32D3D1A2;
            when  6 result = 0x11301D0125B51;
            when  7 result = 0x1429AAEA92DE0;
            when  8 result = 0x172B83C7D517B;
            when  9 result = 0x1A35BEB6FCB75;
            when 10 result = 0x1D4873168B9AA;
            when 11 result = 0x2063B88628CD6;
            when 12 result = 0x2387A6E756238;
            when 13 result = 0x26B4565E27CDD;
            when 14 result = 0x29E9DF51FDEE1;
            when 15 result = 0x2D285A6E4030B;
            when 16 result = 0x306FE0A31B715;
            when 17 result = 0x33C08B26416FF;
            when 18 result = 0x371A7373AA9CB;
            when 19 result = 0x3A7DB34E59FF7;
            when 20 result = 0x3DEA64C123422;
            when 21 result = 0x4160A21F72E2A;
            when 22 result = 0x44E086061892D;
            when 23 result = 0x486A2B5C13CD0;
            when 24 result = 0x4BFDAD5362A27;
            when 25 result = 0x4F9B2769D2CA7;
            when 26 result = 0x5342B569D4F82;
            when 27 result = 0x56F4736B527DA;
            when 28 result = 0x5AB07DD485429;
            when 29 result = 0x5E76F15AD2148;
            when 30 result = 0x6247EB03A5585;
            when 31 result = 0x6623882552225;
            when 32 result = 0x6A09E667F3BCD;
            when 33 result = 0x6DFB23C651A2F;
            when 34 result = 0x71F75E8EC5F74;
            when 35 result = 0x75FEB564267C9;
            when 36 result = 0x7A11473EB0187;
            when 37 result = 0x7E2F336CF4E62;
            when 38 result = 0x82589994CCE13;
            when 39 result = 0x868D99B4492ED;
            when 40 result = 0x8ACE5422AA0DB;
            when 41 result = 0x8F1AE99157736;
            when 42 result = 0x93737B0CDC5E5;
            when 43 result = 0x97D829FDE4E50;
            when 44 result = 0x9C49182A3F090;
            when 45 result = 0xA0C667B5DE565;
            when 46 result = 0xA5503B23E255D;
            when 47 result = 0xA9E6B5579FDBF;
            when 48 result = 0xAE89F995AD3AD;
            when 49 result = 0xB33A2B84F15FB;
            when 50 result = 0xB7F76F2FB5E47;
            when 51 result = 0xBCC1E904BC1D2;
            when 52 result = 0xC199BDD85529C;
            when 53 result = 0xC67F12E57D14B;
            when 54 result = 0xCB720DCEF9069;
            when 55 result = 0xD072D4A07897C;
            when 56 result = 0xD5818DCFBA487;
            when 57 result = 0xDA9E603DB3285;
            when 58 result = 0xDFC97337B9B5F;
            when 59 result = 0xE502EE78B3FF6;
            when 60 result = 0xEA4AFA2A490DA;
            when 61 result = 0xEFA1BEE615A27;
            when 62 result = 0xF50765B6E4540;
            when 63 result = 0xFA7C1819E90D8;

    return result&lt;N-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPLogB"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPLogB</h3>
      <p class="pseudocode">// FPLogB()
// ========

bits(N) <a id="impl-aarch64.FPLogB.2"/>FPLogB(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};

    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op, fpcr);

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        result = -(2^(N-1));            // MinInt, 100..00
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = 2^(N-1) - 1;           // MaxInt, 011..11
    else
        // FPUnpack has already scaled a subnormal input
        value = <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value);
        result = 0;
        while value &lt; 1.0 do
            value = value * 2.0;
            result = result - 1;
        while value &gt;= 2.0 do
            value = value / 2.0;
            result = result + 1;

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result&lt;N-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPMinNormal"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPMinNormal</h3>
      <p class="pseudocode">// FPMinNormal()
// =============

bits(N) <a id="impl-aarch64.FPMinNormal.1"/>FPMinNormal(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(E-1):'1';
    frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPOne"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPOne</h3>
      <p class="pseudocode">// FPOne()
// =======

bits(N) <a id="impl-aarch64.FPOne.1"/>FPOne(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp = '0':<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E-1);
    frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPPointFive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPPointFive</h3>
      <p class="pseudocode">// FPPointFive()
// =============

bits(N) <a id="impl-aarch64.FPPointFive.1"/>FPPointFive(bit sign)
    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp = '0':<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E-2):'0';
    frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPProcess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPProcess</h3>
      <p class="pseudocode">// FPProcess()
// ===========

bits(N) <a id="impl-aarch64.FPProcess.1"/>FPProcess(bits(N) input)
    bits(N) result;
    assert N IN {16,32,64};
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(input, fpcr);

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr)">FPProcessNaN</a>(fptype, input, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(value, fpcr);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPScale"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPScale</h3>
      <p class="pseudocode">// FPScale()
// =========

bits(N) <a id="impl-aarch64.FPScale.3"/>FPScale(bits (N) op, integer scale, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op, fpcr);

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr)">FPProcessNaN</a>(fptype, op, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(value * (2.0^scale), fpcr);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigMAdd"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigMAdd</h3>
      <p class="pseudocode">// FPTrigMAdd()
// ============

bits(N) <a id="impl-aarch64.FPTrigMAdd.4"/>FPTrigMAdd(integer x, bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    assert x &gt;= 0;
    assert x &lt; 8;
    bits(N) coeff;

    if op2&lt;N-1&gt; == '1' then
        x = x + 8;

    coeff  = <a href="shared_pseudocode.html#impl-aarch64.FPTrigMAddCoefficient.read.1" title="accessor: bits(N) FPTrigMAddCoefficient[integer index]">FPTrigMAddCoefficient</a>[x];
    op2    = <a href="shared_pseudocode.html#impl-shared.FPAbs.1" title="function: bits(N) FPAbs(bits(N) op)">FPAbs</a>(op2);
    result = <a href="shared_pseudocode.html#impl-shared.FPMulAdd.4" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMulAdd</a>(coeff, op1, op2, fpcr);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigMAddCoefficient"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigMAddCoefficient</h3>
      <p class="pseudocode">// FPTrigMAddCoefficient()
// =======================

bits(N) <a id="impl-aarch64.FPTrigMAddCoefficient.read.1"/>FPTrigMAddCoefficient[integer index]
    assert N IN {16,32,64};
    integer result;

    if N == 16 then
        case index of
            when  0 result = 0x3c00;
            when  1 result = 0xb155;
            when  2 result = 0x2030;
            when  3 result = 0x0000;
            when  4 result = 0x0000;
            when  5 result = 0x0000;
            when  6 result = 0x0000;
            when  7 result = 0x0000;
            when  8 result = 0x3c00;
            when  9 result = 0xb800;
            when 10 result = 0x293a;
            when 11 result = 0x0000;
            when 12 result = 0x0000;
            when 13 result = 0x0000;
            when 14 result = 0x0000;
            when 15 result = 0x0000;
    elsif N == 32 then
        case index of
            when  0 result = 0x3f800000;
            when  1 result = 0xbe2aaaab;
            when  2 result = 0x3c088886;
            when  3 result = 0xb95008b9;
            when  4 result = 0x36369d6d;
            when  5 result = 0x00000000;
            when  6 result = 0x00000000;
            when  7 result = 0x00000000;
            when  8 result = 0x3f800000;
            when  9 result = 0xbf000000;
            when 10 result = 0x3d2aaaa6;
            when 11 result = 0xbab60705;
            when 12 result = 0x37cd37cc;
            when 13 result = 0x00000000;
            when 14 result = 0x00000000;
            when 15 result = 0x00000000;
    else // N == 64
        case index of
            when  0 result = 0x3ff0000000000000;
            when  1 result = 0xbfc5555555555543;
            when  2 result = 0x3f8111111110f30c;
            when  3 result = 0xbf2a01a019b92fc6;
            when  4 result = 0x3ec71de351f3d22b;
            when  5 result = 0xbe5ae5e2b60f7b91;
            when  6 result = 0x3de5d8408868552f;
            when  7 result = 0x0000000000000000;
            when  8 result = 0x3ff0000000000000;
            when  9 result = 0xbfe0000000000000;
            when 10 result = 0x3fa5555555555536;
            when 11 result = 0xbf56c16c16c13a0b;
            when 12 result = 0x3efa01a019b1e8d8;
            when 13 result = 0xbe927e4f7282f468;
            when 14 result = 0x3e21ee96d2641b13;
            when 15 result = 0xbda8f76380fbb401;

    return result&lt;N-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigSMul"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigSMul</h3>
      <p class="pseudocode">// FPTrigSMul()
// ============

bits(N) <a id="impl-aarch64.FPTrigSMul.3"/>FPTrigSMul(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N IN {16,32,64};
    result = <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(op1, op1, fpcr);
    fpexc = FALSE;
    (fptype, sign, value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(result, fpcr, fpexc);

    if !(fptype IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>}) then
        result&lt;N-1&gt; = op2&lt;0&gt;;

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FPTrigSSel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FPTrigSSel</h3>
      <p class="pseudocode">// FPTrigSSel()
// ============

bits(N) <a id="impl-aarch64.FPTrigSSel.2"/>FPTrigSSel(bits(N) op1, bits(N) op2)
    assert N IN {16,32,64};
    bits(N) result;

    if op2&lt;0&gt; == '1' then
        result = <a href="shared_pseudocode.html#impl-aarch64.FPOne.1" title="function: bits(N) FPOne(bit sign)">FPOne</a>(op2&lt;1&gt;);
    elsif op2&lt;1&gt; == '1' then
        result = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(op1);
    else
        result = op1;

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FirstActive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FirstActive</h3>
      <p class="pseudocode">// FirstActive()
// =============

bit <a id="impl-aarch64.FirstActive.3"/>FirstActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = 0 to elements-1
        if <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[mask, e, esize] == '1' then return <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[x, e, esize];
    return '0';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.FloorPow2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/FloorPow2</h3>
      <p class="pseudocode">// FloorPow2()
// ===========
// For a positive integer X, return the largest power of 2 &lt;= X

integer <a id="impl-aarch64.FloorPow2.1"/>FloorPow2(integer x)
    assert x &gt;= 0;
    integer n = 1;
    if x == 0 then return 0;
    while x &gt;= 2^n do
        n = n + 1;
    return 2^(n - 1);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE</h3>
      <p class="pseudocode">// HaveSVE()
// =========

boolean <a id="impl-aarch64.HaveSVE.0"/>HaveSVE()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE ISA";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2</h3>
      <p class="pseudocode">// HaveSVE2()
// ==========
// Returns TRUE if the SVE2 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2.0"/>HaveSVE2()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE2 extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2AES"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2AES</h3>
      <p class="pseudocode">// HaveSVE2AES()
// =============
// Returns TRUE if the SVE2 AES extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2AES.0"/>HaveSVE2AES()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE2 AES extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2BitPerm"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2BitPerm</h3>
      <p class="pseudocode">// HaveSVE2BitPerm()
// =================
// Returns TRUE if the SVE2 Bit Permissions extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2BitPerm.0"/>HaveSVE2BitPerm()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE2 BitPerm extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2PMULL128"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2PMULL128</h3>
      <p class="pseudocode">// HaveSVE2PMULL128()
// ==================
// Returns TRUE if the SVE2 128 bit PMULL extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2PMULL128.0"/>HaveSVE2PMULL128()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE2 128 bit PMULL extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2SHA3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2SHA3</h3>
      <p class="pseudocode">// HaveSVE2SHA3()
// ==============
// Returns TRUE if the SVE2 SHA3 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2SHA3.0"/>HaveSVE2SHA3()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE2 SHA3 extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVE2SM4"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVE2SM4</h3>
      <p class="pseudocode">// HaveSVE2SM4()
// =============
// Returns TRUE if the SVE2 SM4 extension is implemented, FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVE2SM4.0"/>HaveSVE2SM4()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE2 SM4 extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVEFP32MatMulExt"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVEFP32MatMulExt</h3>
      <p class="pseudocode">// HaveSVEFP32MatMulExt()
// ======================
// Returns TRUE if single-precision floating-point matrix multiply instruction support implemented and FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVEFP32MatMulExt.0"/>HaveSVEFP32MatMulExt()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE FP32 Matrix Multiply extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.HaveSVEFP64MatMulExt"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/HaveSVEFP64MatMulExt</h3>
      <p class="pseudocode">// HaveSVEFP64MatMulExt()
// ======================
// Returns TRUE if double-precision floating-point matrix multiply instruction support implemented and FALSE otherwise.

boolean <a id="impl-aarch64.HaveSVEFP64MatMulExt.0"/>HaveSVEFP64MatMulExt()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Have SVE FP64 Matrix Multiply extension";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ImplementedSMEVectorLength"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ImplementedSMEVectorLength</h3>
      <p class="pseudocode">// ImplementedSMEVectorLength()
// ============================
// Reduce SVE/SME vector length to a supported value (e.g. power of two)

integer <a id="impl-aarch64.ImplementedSMEVectorLength.1"/>ImplementedSMEVectorLength(integer nbits)
    return integer IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ImplementedSVEVectorLength"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ImplementedSVEVectorLength</h3>
      <p class="pseudocode">// ImplementedSVEVectorLength()
// ============================
// Reduce SVE vector length to a supported value (e.g. power of two)

integer <a id="impl-aarch64.ImplementedSVEVectorLength.1"/>ImplementedSVEVectorLength(integer nbits)
    return integer IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.InStreamingMode"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/InStreamingMode</h3>
      <p class="pseudocode">// InStreamingMode()
// =================

boolean <a id="impl-aarch64.InStreamingMode.0"/>InStreamingMode()
    return <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsEven"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsEven</h3>
      <p class="pseudocode">// IsEven()
// ========

boolean <a id="impl-aarch64.IsEven.1"/>IsEven(integer val)
    return val MOD 2 == 0;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsFPEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsFPEnabled</h3>
      <p class="pseudocode">// IsFPEnabled()
// =============
// Returns TRUE if accesses to the Advanced SIMD and floating-point
// registers are enabled at the target exception level in the current
// execution state and FALSE otherwise.

boolean <a id="impl-aarch64.IsFPEnabled.1"/>IsFPEnabled(bits(2) el)
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el) then
        return <a href="shared_pseudocode.html#AArch32.IsFPEnabled.1" title="function: boolean AArch32.IsFPEnabled(bits(2) el)">AArch32.IsFPEnabled</a>(el);
    else
        return <a href="shared_pseudocode.html#AArch64.IsFPEnabled.1" title="function: boolean AArch64.IsFPEnabled(bits(2) el)">AArch64.IsFPEnabled</a>(el);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsFullA64Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsFullA64Enabled</h3>
      <p class="pseudocode">// IsFullA64Enabled()
// ==================
// Returns TRUE is full A64 is enabled in Streaming mode and FALSE othersise.

boolean <a id="impl-aarch64.IsFullA64Enabled.0"/>IsFullA64Enabled()
    // Check if full SVE disabled in SMCR_EL1
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check full SVE at EL0/EL1
        if SMCR_EL1.FA64 == '0' then return FALSE;

    // Check if full SVE disabled in SMCR_EL2
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if SMCR_EL2.FA64 == '0' then return FALSE;

    // Check if full SVE disabled in SMCR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if SMCR_EL3.FA64 == '0' then return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsNormalSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsNormalSVEEnabled</h3>
      <p class="pseudocode">// IsNormalSVEEnabled()
// ====================
// Returns TRUE if access to normal SVE is enabled at the target
// exception level and FALSE otherwise.

boolean <a id="impl-aarch64.IsNormalSVEEnabled.1"/>IsNormalSVEEnabled(bits(2) el)
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el) then
        return FALSE;

    // Check if access disabled in CPACR_EL1
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SVE at EL0/EL1
        case CPACR_EL1.ZEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    // Check if access disabled in CPTR_EL2
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            case CPTR_EL2.ZEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then return FALSE;
        else
            if CPTR_EL2.TZ == '1' then return FALSE;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.EZ == '0' then return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsOdd"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsOdd</h3>
      <p class="pseudocode">// IsOdd()
// =======

boolean <a id="impl-aarch64.IsOdd.1"/>IsOdd(integer val)
    return val MOD 2 == 1;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsSVEEnabled</h3>
      <p class="pseudocode">// IsSVEEnabled()
// ==============
// Returns TRUE if access to SVE instructions and System registers is
// enabled at the target exception level and FALSE otherwise.

boolean <a id="impl-aarch64.IsSVEEnabled.1"/>IsSVEEnabled(bits(2) el)
    if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' then
        return <a href="shared_pseudocode.html#impl-aarch64.IsStreamingSVEEnabled.1" title="function: boolean IsStreamingSVEEnabled(bits(2) el)">IsStreamingSVEEnabled</a>(el);
    elsif <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() then
        return <a href="shared_pseudocode.html#impl-aarch64.IsNormalSVEEnabled.1" title="function: boolean IsNormalSVEEnabled(bits(2) el)">IsNormalSVEEnabled</a>(el);
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.IsStreamingSVEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/IsStreamingSVEEnabled</h3>
      <p class="pseudocode">// IsStreamingSVEEnabled()
// =======================
// Returns TRUE if access to streaming SVE is enabled at the
// target exception level and FALSE otherwise.

boolean <a id="impl-aarch64.IsStreamingSVEEnabled.1"/>IsStreamingSVEEnabled(bits(2) el)
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el) then
        return FALSE;

    // Check if access disabled in CPACR_EL1
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        // Check SME at EL0/EL1
        case CPACR_EL1.SMEN of
            when 'x0' disabled = TRUE;
            when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
            when '11' disabled = FALSE;
        if disabled then return FALSE;

    // Check if access disabled in CPTR_EL2
    if el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.E2H == '1' then
            case CPTR_EL2.SMEN of
                when 'x0' disabled = TRUE;
                when '01' disabled = el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; HCR_EL2.TGE == '1';
                when '11' disabled = FALSE;
            if disabled then return FALSE;
        else
            if CPTR_EL2.TSM == '1' then return FALSE;

    // Check if access disabled in CPTR_EL3
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CPTR_EL3.ESM == '0' then return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.LastActive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/LastActive</h3>
      <p class="pseudocode">// LastActive()
// ============

bit <a id="impl-aarch64.LastActive.3"/>LastActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = elements-1 downto 0
        if <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[mask, e, esize] == '1' then return <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[x, e, esize];
    return '0';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.LastActiveElement"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/LastActiveElement</h3>
      <p class="pseudocode">// LastActiveElement()
// ===================

integer <a id="impl-aarch64.LastActiveElement.2"/>LastActiveElement(bits(N) mask, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = elements-1 downto 0
        if <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[mask, e, esize] == '1' then return e;
    return -1;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MaybeZeroSVEUppers"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MaybeZeroSVEUppers</h3>
      <p class="pseudocode">// MaybeZeroSVEUppers()
// ====================

<a id="impl-aarch64.MaybeZeroSVEUppers.1"/>MaybeZeroSVEUppers(bits(2) target_el)
    boolean lower_enabled;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) || !<a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)">IsSVEEnabled</a>(target_el) then
        return;

    if target_el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            lower_enabled = <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        else
            lower_enabled = <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
    elsif target_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        if HCR_EL2.TGE == '0' then
            lower_enabled = <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        else
            lower_enabled = <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>);
    else
        assert target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        lower_enabled = <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>);

    if lower_enabled then
        integer vl = if <a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)">IsSVEEnabled</a>(PSTATE.EL) then <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a> else 128;
        integer pl = vl DIV 8;
        for n = 0 to 31
            if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SVEZEROUPPER</a>) then
                _Z[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(_Z[n]&lt;vl-1:0&gt;);
        for n = 0 to 15
            if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SVEZEROUPPER</a>) then
                _P[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(_P[n]&lt;pl-1:0&gt;);
        if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SVEZEROUPPER</a>) then
            _FFR = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(_FFR&lt;pl-1:0&gt;);
        if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.ZA == '1' then
            integer accessiblerows = <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a> DIV 8;
            integer allrows = <a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a> DIV 8;

            for n = 0 to accessiblerows - 1
                if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SMEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SMEZEROUPPER</a>) then
                    _ZA[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(_ZA[n]&lt;<a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a>-1:0&gt;);
            for n = accessiblerows to allrows - 1
                if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SMEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SMEZEROUPPER</a>) then
                    _ZA[n] = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MemNF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MemNF</h3>
      <p class="pseudocode">// MemNF[] - non-assignment form
// =============================

(bits(8*size), boolean) <a id="impl-aarch64.MemNF.read.3"/>MemNF[bits(64) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype]
    assert size IN {1, 2, 4, 8, 16};
    bits(8*size) value;

    aligned = (address == <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(address, size));
    A = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].A;

    if !aligned &amp;&amp; (A == '1') then
        return (bits(8*size) UNKNOWN, TRUE);

    atomic = aligned || size == 1;

    if !atomic then
        (value&lt;7:0&gt;, bad) = <a href="shared_pseudocode.html#impl-aarch64.MemSingleNF.read.4" title="accessor: (bits(8*size), boolean) MemSingleNF[bits(64) address, integer size, AccType acctype, boolean aligned]">MemSingleNF</a>[address, 1, acctype, aligned];

        if bad then
            return (bits(8*size) UNKNOWN, TRUE);

        // For subsequent bytes it is CONSTRAINED UNPREDICTABLE whether an unaligned Device memory
        // access will generate an Alignment Fault, as to get this far means the first byte did
        // not, so we must be changing to a new translation page.
        if !aligned then
            c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DEVPAGE2</a>);
            assert c IN {<a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>, <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>};
            if c == <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a> then aligned = TRUE;

        for i = 1 to size-1
            (value&lt;8*i+7:8*i&gt;, bad) = <a href="shared_pseudocode.html#impl-aarch64.MemSingleNF.read.4" title="accessor: (bits(8*size), boolean) MemSingleNF[bits(64) address, integer size, AccType acctype, boolean aligned]">MemSingleNF</a>[address+i, 1, acctype, aligned];

            if bad then
                return (bits(8*size) UNKNOWN, TRUE);
    else
        (value, bad) = <a href="shared_pseudocode.html#impl-aarch64.MemSingleNF.read.4" title="accessor: (bits(8*size), boolean) MemSingleNF[bits(64) address, integer size, AccType acctype, boolean aligned]">MemSingleNF</a>[address, size, acctype, aligned];
        if bad then
            return (bits(8*size) UNKNOWN, TRUE);

    if <a href="shared_pseudocode.html#impl-shared.BigEndian.1" title="function: boolean BigEndian(AccType acctype)">BigEndian</a>(acctype) then
        value = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value);

    return (value, FALSE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.MemSingleNF"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/MemSingleNF</h3>
      <p class="pseudocode">// MemSingleNF[] - non-assignment form
// ===================================

(bits(8*size), boolean) <a id="impl-aarch64.MemSingleNF.read.4"/>MemSingleNF[bits(64) address, integer size, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned]
    assert acctype IN {<a href="shared_pseudocode.html#AccType_CNOTFIRST" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_CNOTFIRST</a>, <a href="shared_pseudocode.html#AccType_NONFAULT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NONFAULT</a>};
    bits(8*size) value;
    boolean iswrite = FALSE;
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc;

    // Implementation may suppress NF load for any reason
    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_NONFAULT" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_NONFAULT</a>) then
        return (bits(8*size) UNKNOWN, TRUE);

    // MMU or MPU
    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(address, acctype, iswrite, aligned, size);

    // Non-fault load from Device memory must not be performed externally
    if memaddrdesc.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return (bits(8*size) UNKNOWN, TRUE);

    // Check for aborts or debug exceptions
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        return (bits(8*size) UNKNOWN, TRUE);

    // Memory array access
    accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(acctype);
    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then
        accdesc.transactional = TSTATE.depth &gt; 0;
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(memaddrdesc, accdesc);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            return (bits(8*size) UNKNOWN, TRUE);

    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        if <a href="shared_pseudocode.html#AArch64.AccessIsTagChecked.2" title="function: boolean AArch64.AccessIsTagChecked(bits(64) vaddr, AccType acctype)">AArch64.AccessIsTagChecked</a>(address, acctype) then
            bits(4) ptag = <a href="shared_pseudocode.html#AArch64.PhysicalTag.1" title="function: bits(4) AArch64.PhysicalTag(bits(64) vaddr)">AArch64.PhysicalTag</a>(address);
            if !<a href="shared_pseudocode.html#AArch64.CheckTag.4" title="function: boolean AArch64.CheckTag(AddressDescriptor memaddrdesc, AccessDescriptor accdesc, bits(4) ptag, boolean write)">AArch64.CheckTag</a>(memaddrdesc, accdesc, ptag, iswrite) then
                return (bits(8*size) UNKNOWN, TRUE);

    (memstatus, value) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(memaddrdesc, size, accdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        if <a href="shared_pseudocode.html#impl-shared.IsExternalAbortTakenSynchronously.5" title="function: boolean IsExternalAbortTakenSynchronously(PhysMemRetStatus memstatus,&#13; boolean iswrite,&#13; AddressDescriptor desc,&#13; integer size,&#13; AccessDescriptor accdesc)">IsExternalAbortTakenSynchronously</a>(memstatus, iswrite, memaddrdesc,
                                             size, accdesc) then
            return (bits(8*size) UNKNOWN, TRUE);
        fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
        fault.errortype = memstatus.errortype;
        fault.acctype = memstatus.acctype;
        fault.extflag = memstatus.extflag;
        fault.statuscode = memstatus.statuscode;
        <a href="shared_pseudocode.html#impl-shared.PendSErrorInterrupt.1" title="function: PendSErrorInterrupt(FaultRecord fault)">PendSErrorInterrupt</a>(fault);

    return (value, FALSE);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.NVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/NVL</h3>
      <p class="pseudocode">// NVL - non-assignment form
// =========================
// Normal VL

integer <a id="impl-aarch64.NVL.read.none"/>NVL
    integer vl;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ZCR_EL1.LEN);

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ZCR_EL2.LEN);
    elsif PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        vl = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(vl, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ZCR_EL2.LEN));

    if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ZCR_EL3.LEN);
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        vl = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(vl, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ZCR_EL3.LEN));

    vl = (vl + 1) * 128;
    vl = <a href="shared_pseudocode.html#impl-aarch64.ImplementedSVEVectorLength.1" title="function: integer ImplementedSVEVectorLength(integer nbits)">ImplementedSVEVectorLength</a>(vl);

    return vl;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.NoneActive"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/NoneActive</h3>
      <p class="pseudocode">// NoneActive()
// ============

bit <a id="impl-aarch64.NoneActive.3"/>NoneActive(bits(N) mask, bits(N) x, integer esize)
    integer elements = N DIV (esize DIV 8);
    for e = 0 to elements-1
        if <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[mask, e, esize] == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[x, e, esize] == '1' then return '0';
    return '1';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.P"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/P</h3>
      <p class="pseudocode">// P[] - non-assignment form
// =========================

bits(width) <a id="impl-aarch64.P.read.1"/>P[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width == <a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL">PL</a>;
    return _P[n]&lt;width-1:0&gt;;

// P[] - assignment form
// =====================

<a id="impl-aarch64.P.write.1"/>P[integer n] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width == <a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL">PL</a>;
    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SVEZEROUPPER</a>) then
        _P[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    else
        _P[n]&lt;width-1:0&gt; = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.PL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/PL</h3>
      <p class="pseudocode">// PL - non-assignment form
// ========================

integer <a id="impl-aarch64.PL.read.none"/>PL
    return <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a> DIV 8;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.PredTest"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/PredTest</h3>
      <p class="pseudocode">// PredTest()
// ==========

bits(4) <a id="impl-aarch64.PredTest.3"/>PredTest(bits(N) mask, bits(N) result, integer esize)
    bit n = <a href="shared_pseudocode.html#impl-aarch64.FirstActive.3" title="function: bit FirstActive(bits(N) mask, bits(N) x, integer esize)">FirstActive</a>(mask, result, esize);
    bit z = <a href="shared_pseudocode.html#impl-aarch64.NoneActive.3" title="function: bit NoneActive(bits(N) mask, bits(N) x, integer esize)">NoneActive</a>(mask, result, esize);
    bit c = NOT <a href="shared_pseudocode.html#impl-aarch64.LastActive.3" title="function: bit LastActive(bits(N) mask, bits(N) x, integer esize)">LastActive</a>(mask, result, esize);
    bit v = '0';
    return n:z:c:v;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ReducePredicated"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ReducePredicated</h3>
      <p class="pseudocode">// ReducePredicated()
// ==================

bits(esize) <a id="impl-aarch64.ReducePredicated.4"/>ReducePredicated(<a href="shared_pseudocode.html#ReduceOp" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp</a> op, bits(N) input, bits(M) mask, bits(esize) identity)
    assert(N == M * 8);
    integer p2bits = <a href="shared_pseudocode.html#impl-aarch64.CeilPow2.1" title="function: integer CeilPow2(integer x)">CeilPow2</a>(N);
    bits(p2bits) operand;
    integer elements = p2bits DIV esize;

    for e = 0 to elements-1
        if e * esize &lt; N &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.ElemP.read.3" title="accessor: bit ElemP[bits(N) pred, integer e, integer esize]">ElemP</a>[mask, e, esize] == '1' then
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[operand, e, esize] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[input, e, esize];
        else
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[operand, e, esize] = identity;

    return <a href="shared_pseudocode.html#impl-aarch64.Reduce.3" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize)">Reduce</a>(op, operand, esize);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ResetSMEState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ResetSMEState</h3>
      <p class="pseudocode">// ResetSMEState()
// ===============

<a id="impl-aarch64.ResetSMEState.0"/>ResetSMEState()
    integer vectors = <a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a> DIV 8;
    for n = 0 to vectors - 1
        _ZA[n] = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ResetSVEState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ResetSVEState</h3>
      <p class="pseudocode">// ResetSVEState()
// ===============

<a id="impl-aarch64.ResetSVEState.0"/>ResetSVEState()
    for n = 0 to 31
        _Z[n] = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    for n = 0 to 15
        _P[n] = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    _FFR = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    FPSR = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(0x0800009f&lt;31:0&gt;);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.Reverse"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/Reverse</h3>
      <p class="pseudocode">// Reverse()
// =========
// Reverse subwords of M bits in an N-bit word

bits(N) <a id="impl-aarch64.Reverse.2"/>Reverse(bits(N) word, integer M)
    bits(N) result;
    integer sw = N DIV M;
    assert N == sw * M;
    for s = 0 to sw-1
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, sw - 1 - s, M] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[word, s, M];
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SMEAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SMEAccessTrap</h3>
      <p class="pseudocode">// SMEAccessTrap()
// ===============
// Trapped access to SME registers due to CPACR_EL1, CPTR_EL2, or CPTR_EL3.

<a id="impl-aarch64.SMEAccessTrap.2"/>SMEAccessTrap(<a href="shared_pseudocode.html#SMEExceptionType" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType</a> etype, bits(2) target_el)
    assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL);
    if target_el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    boolean route_to_el2 = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SMEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SMEAccessTrap</a>);
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    case etype of
        when <a href="shared_pseudocode.html#SMEExceptionType_AccessTrap" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_AccessTrap</a>
            exception.syndrome&lt;1:0&gt; = '00';
        when <a href="shared_pseudocode.html#SMEExceptionType_Streaming" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_Streaming</a>
            exception.syndrome&lt;1:0&gt; = '01';
        when <a href="shared_pseudocode.html#SMEExceptionType_NotStreaming" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_NotStreaming</a>
            exception.syndrome&lt;1:0&gt; = '10';
        when <a href="shared_pseudocode.html#SMEExceptionType_InactiveZA" title="enumeration SMEExceptionType {&#13; SMEExceptionType_AccessTrap, SMEExceptionType_Streaming, SMEExceptionType_NotStreaming, SMEExceptionType_InactiveZA, }">SMEExceptionType_InactiveZA</a>
            exception.syndrome&lt;1:0&gt; = '11';

    if route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SMEExceptionType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SMEExceptionType</h3>
      <p class="pseudocode">enumeration <a id="SMEExceptionType"/>SMEExceptionType {
    <a id="SMEExceptionType_AccessTrap"/>SMEExceptionType_AccessTrap,     // SME functionality trapped or disabled
    <a id="SMEExceptionType_Streaming"/>SMEExceptionType_Streaming,      // Illegal instruction in Streaming SVE mode
    <a id="SMEExceptionType_NotStreaming"/>SMEExceptionType_NotStreaming,   // Illegal instruction not in Streaming SVE mode
    <a id="SMEExceptionType_InactiveZA"/>SMEExceptionType_InactiveZA,     // Illegal instruction when ZA is inactive
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SVEAccessTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SVEAccessTrap</h3>
      <p class="pseudocode">// SVEAccessTrap()
// ===============
// Trapped access to SVE registers due to CPACR_EL1, CPTR_EL2, or CPTR_EL3.

<a id="impl-aarch64.SVEAccessTrap.1"/>SVEAccessTrap(bits(2) target_el)
    assert <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &amp;&amp; target_el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(target_el);
    route_to_el2 = target_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1';

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_SVEAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_SVEAccessTrap</a>);
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    if route_to_el2 then
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, exception, preferred_exception_return, vect_offset);
    else
        <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(target_el, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SVECmp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SVECmp</h3>
      <p class="pseudocode">enumeration <a id="SVECmp"/>SVECmp { <a id="Cmp_EQ"/>Cmp_EQ, <a id="Cmp_NE"/>Cmp_NE, <a id="Cmp_GE"/>Cmp_GE, <a id="Cmp_GT"/>Cmp_GT, <a id="Cmp_LT"/>Cmp_LT, <a id="Cmp_LE"/>Cmp_LE, <a id="Cmp_UN"/>Cmp_UN };</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SVEMoveMaskPreferred"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SVEMoveMaskPreferred</h3>
      <p class="pseudocode">// SVEMoveMaskPreferred()
// ======================
// Return FALSE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single DUP instruction.
// Used as a condition for the preferred MOV&lt;-DUPM alias.

boolean <a id="impl-aarch64.SVEMoveMaskPreferred.1"/>SVEMoveMaskPreferred(bits(13) imm13)
    bits(64) imm;
    (imm, -) = <a href="shared_pseudocode.html#impl-aarch64.DecodeBitMasks.4" title="function: (bits(M), bits(M)) DecodeBitMasks(bit immN, bits(6) imms, bits(6) immr, boolean immediate)">DecodeBitMasks</a>(imm13&lt;12&gt;, imm13&lt;5:0&gt;, imm13&lt;11:6&gt;, TRUE);

    // Check for 8 bit immediates
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;7:0&gt;) then
        // Check for 'ffffffffffffffxy' or '00000000000000xy'
        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;63:7&gt;) || <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(imm&lt;63:7&gt;) then
            return FALSE;

        // Check for 'ffffffxyffffffxy' or '000000xy000000xy'
        if imm&lt;63:32&gt; == imm&lt;31:0&gt; &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;31:7&gt;) || <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(imm&lt;31:7&gt;)) then
            return FALSE;

        // Check for 'ffxyffxyffxyffxy' or '00xy00xy00xy00xy'
        if imm&lt;63:32&gt; == imm&lt;31:0&gt; &amp;&amp; imm&lt;31:16&gt; == imm&lt;15:0&gt; &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;15:7&gt;) || <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(imm&lt;15:7&gt;)) then
            return FALSE;

        // Check for 'xyxyxyxyxyxyxyxy'
        if imm&lt;63:32&gt; == imm&lt;31:0&gt; &amp;&amp; imm&lt;31:16&gt; == imm&lt;15:0&gt; &amp;&amp; (imm&lt;15:8&gt; == imm&lt;7:0&gt;) then
            return FALSE;

    // Check for 16 bit immediates
    else
        // Check for 'ffffffffffffxy00' or '000000000000xy00'
        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;63:15&gt;) || <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(imm&lt;63:15&gt;) then
            return FALSE;

        // Check for 'ffffxy00ffffxy00' or '0000xy000000xy00'
        if imm&lt;63:32&gt; == imm&lt;31:0&gt; &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(imm&lt;31:7&gt;) || <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(imm&lt;31:7&gt;)) then
            return FALSE;

        // Check for 'xy00xy00xy00xy00'
        if imm&lt;63:32&gt; == imm&lt;31:0&gt; &amp;&amp; imm&lt;31:16&gt; == imm&lt;15:0&gt; then
            return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SVL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SVL</h3>
      <p class="pseudocode">// SVL - non-assignment form
// =========================
// Streaming SVL

integer <a id="impl-aarch64.SVL.read.none"/>SVL
    integer vl;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SMCR_EL1.LEN);

    if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SMCR_EL2.LEN);
    elsif PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        vl = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(vl, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SMCR_EL2.LEN));

    if PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        vl = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SMCR_EL3.LEN);
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        vl = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(vl, <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(SMCR_EL3.LEN));

    vl = (vl + 1) * 128;
    vl = <a href="shared_pseudocode.html#impl-aarch64.ImplementedSMEVectorLength.1" title="function: integer ImplementedSMEVectorLength(integer nbits)">ImplementedSMEVectorLength</a>(vl);

    return vl;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SetPSTATE_SM"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SetPSTATE_SM</h3>
      <p class="pseudocode">// SetPSTATE_SM()
// ==============

<a id="impl-aarch64.SetPSTATE_SM.1"/>SetPSTATE_SM(bit value)
    if PSTATE.SM != value then
        <a href="shared_pseudocode.html#impl-aarch64.ResetSVEState.0" title="function: ResetSVEState()">ResetSVEState</a>();
        PSTATE.SM = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SetPSTATE_SVCR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SetPSTATE_SVCR</h3>
      <p class="pseudocode">// SetPSTATE_SVCR
// ==============

<a id="impl-aarch64.SetPSTATE_SVCR.1"/>SetPSTATE_SVCR(bits(32) svcr)
    <a href="shared_pseudocode.html#impl-aarch64.SetPSTATE_SM.1" title="function: SetPSTATE_SM(bit value)">SetPSTATE_SM</a>(svcr&lt;0&gt;);
    <a href="shared_pseudocode.html#impl-aarch64.SetPSTATE_ZA.1" title="function: SetPSTATE_ZA(bit value)">SetPSTATE_ZA</a>(svcr&lt;1&gt;);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.SetPSTATE_ZA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/SetPSTATE_ZA</h3>
      <p class="pseudocode">// SetPSTATE_ZA()
// ==============

<a id="impl-aarch64.SetPSTATE_ZA.1"/>SetPSTATE_ZA(bit value)
    if PSTATE.ZA != value then
        <a href="shared_pseudocode.html#impl-aarch64.ResetSMEState.0" title="function: ResetSMEState()">ResetSMEState</a>();
        PSTATE.ZA = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.ShiftSat"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/ShiftSat</h3>
      <p class="pseudocode">// ShiftSat()
// ==========

integer <a id="impl-aarch64.ShiftSat.2"/>ShiftSat(integer shift, integer esize)
    if shift &gt; esize+1 then return esize+1;
    elsif shift &lt; -(esize+1) then return -(esize+1);
    return shift;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.System"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/System</h3>
      <p class="pseudocode">constant integer <a id="MAX_VL"/>MAX_VL = 2048;
constant integer <a id="MAX_PL"/>MAX_PL = 256;
array bits(<a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>) _Z[0..31];
array bits(<a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>) _P[0..15];
bits(<a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>) _FFR;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.VL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/VL</h3>
      <p class="pseudocode">// VL - non-assignment form
// ========================

integer <a id="impl-aarch64.VL.read.none"/>VL
    return if <a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() &amp;&amp; PSTATE.SM == '1' then <a href="shared_pseudocode.html#impl-aarch64.SVL.read.none" title="accessor: integer SVL">SVL</a> else <a href="shared_pseudocode.html#impl-aarch64.NVL.read.none" title="accessor: integer NVL">NVL</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sve.Z"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sve/Z</h3>
      <p class="pseudocode">// Z[] - non-assignment form
// =========================

bits(width) <a id="impl-aarch64.Z.read.1"/>Z[integer n]
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width == <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a>;
    return _Z[n]&lt;width-1:0&gt;;

// Z[] - assignment form
// =====================

<a id="impl-aarch64.Z.write.1"/>Z[integer n] = bits(width) value
    assert n &gt;= 0 &amp;&amp; n &lt;= 31;
    assert width == <a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a>;
    if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SVEZEROUPPER</a>) then
        _Z[n] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
    else
        _Z[n]&lt;width-1:0&gt; = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.CNTKCTL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/CNTKCTL</h3>
      <p class="pseudocode">// CNTKCTL[] - non-assignment form
// ===============================

CNTKCTLType <a id="impl-aarch64.CNTKCTL.read.0"/>CNTKCTL[]
    bits(64) r;
    if <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        r = CNTHCTL_EL2;
        return r;
    r = CNTKCTL_EL1;
    return r;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.CNTKCTLType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/CNTKCTLType</h3>
      <p class="pseudocode">type <a id="CNTKCTLType"/>CNTKCTLType;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.CPACR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/CPACR</h3>
      <p class="pseudocode">// CPACR[] - non-assignment form
// =============================

CPACRType <a id="impl-aarch64.CPACR.read.0"/>CPACR[]
    bits(64) r;
    if <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        r = CPTR_EL2;
        return r;
    r = CPACR_EL1;
    return r;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.CPACRType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/CPACRType</h3>
      <p class="pseudocode">type <a id="CPACRType"/>CPACRType;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.ELR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/ELR</h3>
      <p class="pseudocode">// ELR[] - non-assignment form
// ===========================

bits(64) <a id="impl-aarch64.ELR.read.1"/>ELR[bits(2) el]
    bits(64) r;
    case el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = ELR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = ELR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = ELR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// ELR[] - non-assignment form
// ===========================

bits(64) <a id="impl-aarch64.ELR.read.0"/>ELR[]
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    return <a href="shared_pseudocode.html#impl-aarch64.ELR.read.1" title="accessor: bits(64) ELR[bits(2) el]">ELR</a>[PSTATE.EL];

// ELR[] - assignment form
// =======================

<a id="impl-aarch64.ELR.write.1"/>ELR[bits(2) el] = bits(64) value
    bits(64) r = value;
    case el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  ELR_EL1 = r;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  ELR_EL2 = r;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  ELR_EL3 = r;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return;

// ELR[] - assignment form
// =======================

<a id="impl-aarch64.ELR.write.0"/>ELR[] = bits(64) value
    assert PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    <a href="shared_pseudocode.html#impl-aarch64.ELR.write.1" title="accessor: ELR[bits(2) el] = bits(64) value">ELR</a>[PSTATE.EL] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.ESR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/ESR</h3>
      <p class="pseudocode">// ESR[] - non-assignment form
// ===========================

ESRType <a id="impl-aarch64.ESR.read.1"/>ESR[bits(2) regime]
    bits(64) r;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = ESR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = ESR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = ESR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// ESR[] - non-assignment form
// ===========================

ESRType <a id="impl-aarch64.ESR.read.0"/>ESR[]
    return <a href="shared_pseudocode.html#impl-aarch64.ESR.read.1" title="accessor: ESRType ESR[bits(2) regime]">ESR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];

// ESR[] - assignment form
// =======================

<a id="impl-aarch64.ESR.write.1"/>ESR[bits(2) regime] = <a href="shared_pseudocode.html#ESRType" title="type ESRType">ESRType</a> value
    bits(64) r = value;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  ESR_EL1 = r;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  ESR_EL2 = r;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  ESR_EL3 = r;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return;

// ESR[] - assignment form
// =======================

<a id="impl-aarch64.ESR.write.0"/>ESR[] = <a href="shared_pseudocode.html#ESRType" title="type ESRType">ESRType</a> value
    <a href="shared_pseudocode.html#impl-aarch64.ESR.write.1" title="accessor: ESR[bits(2) regime] = ESRType value">ESR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()] = value;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.ESRType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/ESRType</h3>
      <p class="pseudocode">type <a id="ESRType"/>ESRType;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.FAR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/FAR</h3>
      <p class="pseudocode">// FAR[] - non-assignment form
// ===========================

bits(64) <a id="impl-aarch64.FAR.read.1"/>FAR[bits(2) regime]
    bits(64) r;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = FAR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = FAR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = FAR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// FAR[] - non-assignment form
// ===========================

bits(64) <a id="impl-aarch64.FAR.read.0"/>FAR[]
    return <a href="shared_pseudocode.html#impl-aarch64.FAR.read.1" title="accessor: bits(64) FAR[bits(2) regime]">FAR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];

// FAR[] - assignment form
// =======================

<a id="impl-aarch64.FAR.write.1"/>FAR[bits(2) regime] = bits(64) value
    bits(64) r = value;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  FAR_EL1 = r;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  FAR_EL2 = r;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  FAR_EL3 = r;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return;

// FAR[] - assignment form
// =======================

<a id="impl-aarch64.FAR.write.0"/>FAR[] = bits(64) value
    <a href="shared_pseudocode.html#impl-aarch64.FAR.write.1" title="accessor: FAR[bits(2) regime] = bits(64) value">FAR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()] = value;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.MAIR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/MAIR</h3>
      <p class="pseudocode">// MAIR[] - non-assignment form
// ============================

MAIRType <a id="impl-aarch64.MAIR.read.1"/>MAIR[bits(2) regime]
    bits(64) r;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = MAIR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = MAIR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = MAIR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// MAIR[] - non-assignment form
// ============================

MAIRType <a id="impl-aarch64.MAIR.read.0"/>MAIR[]
    return <a href="shared_pseudocode.html#impl-aarch64.MAIR.read.1" title="accessor: MAIRType MAIR[bits(2) regime]">MAIR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.MAIRType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/MAIRType</h3>
      <p class="pseudocode">type <a id="MAIRType"/>MAIRType;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.SCTLR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/SCTLR</h3>
      <p class="pseudocode">// SCTLR[] - non-assignment form
// =============================

SCTLRType <a id="impl-aarch64.SCTLR.read.1"/>SCTLR[bits(2) regime]
    bits(64) r;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = SCTLR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = SCTLR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = SCTLR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// SCTLR[] - non-assignment form
// =============================

SCTLRType <a id="impl-aarch64.SCTLR.read.0"/>SCTLR[]
    return <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.1" title="accessor: SCTLRType SCTLR[bits(2) regime]">SCTLR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.SCTLRType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/SCTLRType</h3>
      <p class="pseudocode">type <a id="SCTLRType"/>SCTLRType;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.sysregisters.VBAR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/sysregisters/VBAR</h3>
      <p class="pseudocode">// VBAR[] - non-assignment form
// ============================

bits(64) <a id="impl-aarch64.VBAR.read.1"/>VBAR[bits(2) regime]
    bits(64) r;
    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  r = VBAR_EL1;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  r = VBAR_EL2;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  r = VBAR_EL3;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return r;

// VBAR[] - non-assignment form
// ============================

bits(64) <a id="impl-aarch64.VBAR.read.0"/>VBAR[]
    return <a href="shared_pseudocode.html#impl-aarch64.VBAR.read.1" title="accessor: bits(64) VBAR[bits(2) regime]">VBAR</a>[<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>()];</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.AllocationTagAccessIsEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.AllocationTagAccessIsEnabled</h3>
      <p class="pseudocode">// AArch64.AllocationTagAccessIsEnabled()
// ======================================
// Check whether access to Allocation Tags is enabled.

boolean <a id="AArch64.AllocationTagAccessIsEnabled.1"/>AArch64.AllocationTagAccessIsEnabled(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    bits(2) el = <a href="shared_pseudocode.html#AArch64.AccessUsesEL.1" title="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</a>(acctype);

    if SCR_EL3.ATA == '0' &amp;&amp; el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} then
        return FALSE;
    elsif HCR_EL2.ATA == '0' &amp;&amp; el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' then
        return FALSE;
    elsif SCTLR_EL3.ATA == '0' &amp;&amp; el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        return FALSE;
    elsif SCTLR_EL2.ATA == '0' &amp;&amp; el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        return FALSE;
    elsif SCTLR_EL1.ATA == '0' &amp;&amp; el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
        return FALSE;
    elsif SCTLR_EL2.ATA0 == '0' &amp;&amp; el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11' then
        return FALSE;
    elsif SCTLR_EL1.ATA0 == '0' &amp;&amp; el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !(<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11') then
        return FALSE;
    else
        return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.CheckSystemAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.CheckSystemAccess</h3>
      <p class="pseudocode">// AArch64.CheckSystemAccess()
// ===========================

<a id="AArch64.CheckSystemAccess.7"/>AArch64.CheckSystemAccess(bits(2) op0, bits(3) op1, bits(4) crn,
                          bits(4) crm, bits(3) op2, bits(5) rt, bit read)
    if (TSTATE.depth &gt; 0 &amp;&amp;
          !<a href="shared_pseudocode.html#impl-aarch64.CheckTransactionalSystemAccess.6" title="function: boolean CheckTransactionalSystemAccess(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bit read)">CheckTransactionalSystemAccess</a>(op0, op1, crn, crm, op2, read)) then
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>, FALSE);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ChooseNonExcludedTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ChooseNonExcludedTag</h3>
      <p class="pseudocode">// AArch64.ChooseNonExcludedTag()
// ==============================
// Return a tag derived from the start and the offset values, excluding
// any tags in the given mask.

bits(4) <a id="AArch64.ChooseNonExcludedTag.3"/>AArch64.ChooseNonExcludedTag(bits(4) tag, bits(4) offset, bits(16) exclude)
    if <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exclude) then
        return '0000';

    if offset == '0000' then
        while exclude&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tag)&gt; == '1' do
            tag = tag + '0001';

    while offset != '0000' do
        offset = offset - '0001';
        tag = tag + '0001';
        while exclude&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tag)&gt; == '1' do
            tag = tag + '0001';

    return tag;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ExecutingBROrBLROrRetInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ExecutingBROrBLROrRetInstr</h3>
      <p class="pseudocode">// AArch64.ExecutingBROrBLROrRetInstr()
// ====================================
// Returns TRUE if current instruction is a BR, BLR, RET, B[L]RA[B][Z], or RETA[B].

boolean <a id="AArch64.ExecutingBROrBLROrRetInstr.0"/>AArch64.ExecutingBROrBLROrRetInstr()
    if !<a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then return FALSE;

    instr = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>();
    if instr&lt;31:25&gt; == '1101011' &amp;&amp; instr&lt;20:16&gt; == '11111' then
        opc = instr&lt;24:21&gt;;
        return opc != '0101';
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ExecutingBTIInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ExecutingBTIInstr</h3>
      <p class="pseudocode">// AArch64.ExecutingBTIInstr()
// ===========================
// Returns TRUE if current instruction is a BTI.

boolean <a id="AArch64.ExecutingBTIInstr.0"/>AArch64.ExecutingBTIInstr()
    if !<a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then return FALSE;

    instr = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>();
    if instr&lt;31:22&gt; == '1101010100' &amp;&amp; instr&lt;21:12&gt; == '0000110010' &amp;&amp; instr&lt;4:0&gt; == '11111' then
        CRm  = instr&lt;11:8&gt;;
        op2  = instr&lt;7:5&gt;;
        return (CRm == '0100' &amp;&amp; op2&lt;0&gt; == '0');
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.ExecutingERETInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.ExecutingERETInstr</h3>
      <p class="pseudocode">// AArch64.ExecutingERETInstr()
// ============================
// Returns TRUE if current instruction is ERET.

boolean <a id="AArch64.ExecutingERETInstr.0"/>AArch64.ExecutingERETInstr()
    instr = <a href="shared_pseudocode.html#impl-shared.ThisInstr.0" title="function: bits(32) ThisInstr()">ThisInstr</a>();
    return instr&lt;31:12&gt; == '11010110100111110000';</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.NextRandomTagBit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.NextRandomTagBit</h3>
      <p class="pseudocode">// AArch64.NextRandomTagBit()
// ==========================
// Generate a random bit suitable for generating a random Allocation Tag.

bit <a id="AArch64.NextRandomTagBit.0"/>AArch64.NextRandomTagBit()
    bits(16) lfsr = RGSR_EL1.SEED;
    bit top = lfsr&lt;5&gt; EOR lfsr&lt;3&gt; EOR lfsr&lt;2&gt; EOR lfsr&lt;0&gt;;
    RGSR_EL1.SEED = top:lfsr&lt;15:1&gt;;
    return top;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.RandomTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.RandomTag</h3>
      <p class="pseudocode">// AArch64.RandomTag()
// ===================
// Generate a random Allocation Tag.

bits(4) <a id="AArch64.RandomTag.0"/>AArch64.RandomTag()
    bits(4) tag;
    for i = 0 to 3
        tag&lt;i&gt; = <a href="shared_pseudocode.html#AArch64.NextRandomTagBit.0" title="function: bit AArch64.NextRandomTagBit()">AArch64.NextRandomTagBit</a>();
    return tag;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.SysInstr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.SysInstr</h3>
      <p class="pseudocode">// Execute a system instruction with write (source operand).
<a id="AArch64.SysInstr.6"/>AArch64.SysInstr(integer op0, integer op1, integer crn, integer crm, integer op2, bits(64) val);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.SysInstrWithResult"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.SysInstrWithResult</h3>
      <p class="pseudocode">// Execute a system instruction with read (result operand).
// Returns the result of the instruction.
bits(64) <a id="AArch64.SysInstrWithResult.5"/>AArch64.SysInstrWithResult(integer op0, integer op1, integer crn, integer crm, integer op2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.SysRegRead"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.SysRegRead</h3>
      <p class="pseudocode">// Read from a system register and return the contents of the register.
bits(64) <a id="AArch64.SysRegRead.5"/>AArch64.SysRegRead(integer op0, integer op1, integer crn, integer crm, integer op2);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.AArch64.SysRegWrite"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/AArch64.SysRegWrite</h3>
      <p class="pseudocode">// Write to a system register.
<a id="AArch64.SysRegWrite.6"/>AArch64.SysRegWrite(integer op0, integer op1, integer crn, integer crm, integer op2, bits(64) val);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeCompatible"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeCompatible</h3>
      <p class="pseudocode">boolean BTypeCompatible;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeCompatible_BTI"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeCompatible_BTI</h3>
      <p class="pseudocode">// BTypeCompatible_BTI
// ===================
// This function determines whether a given hint encoding is compatible with the current value of
// PSTATE.BTYPE. A value of TRUE here indicates a valid Branch Target Identification instruction.

boolean <a id="impl-aarch64.BTypeCompatible_BTI.1"/>BTypeCompatible_BTI(bits(2) hintcode)
    case hintcode of
        when '00'
            return FALSE;
        when '01'
            return PSTATE.BTYPE != '11';
        when '10'
            return PSTATE.BTYPE != '10';
        when '11'
            return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeCompatible_PACIXSP"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeCompatible_PACIXSP</h3>
      <p class="pseudocode">// BTypeCompatible_PACIXSP()
// =========================
// Returns TRUE if PACIASP, PACIBSP instruction is implicit compatible with PSTATE.BTYPE,
// FALSE otherwise.

boolean <a id="impl-aarch64.BTypeCompatible_PACIXSP.0"/>BTypeCompatible_PACIXSP()
    if PSTATE.BTYPE IN {'01', '10'} then
        return TRUE;
    elsif PSTATE.BTYPE == '11' then
        index = if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then 35 else 36;
        return <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[]&lt;index&gt; == '0';
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.BTypeNext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/BTypeNext</h3>
      <p class="pseudocode">bits(2) BTypeNext;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.ChooseRandomNonExcludedTag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/ChooseRandomNonExcludedTag</h3>
      <p class="pseudocode">// The ChooseRandomNonExcludedTag function is used when GCR_EL1.RRND == '1' to generate random
// Allocation Tags.
//
// The resulting Allocation Tag is selected from the set [0,15], excluding any Allocation Tag where
// exclude[tag_value] == 1. If 'exclude' is all Ones, the returned Allocation Tag is '0000'.
//
// This function is permitted to generate a non-deterministic selection from the set of non-excluded
// Allocation Tags. A reasonable implementation is described by the Pseudocode used when
// GCR_EL1.RRND is 0, but with a non-deterministic implementation of NextRandomTagBit(). Implementations
// may choose to behave the same as GCR_EL1.RRND=0.
bits(4) <a id="impl-aarch64.ChooseRandomNonExcludedTag.1"/>ChooseRandomNonExcludedTag(bits(16) exclude);</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.InGuardedPage"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/InGuardedPage</h3>
      <p class="pseudocode">boolean InGuardedPage;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.IsHCRXEL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/IsHCRXEL2Enabled</h3>
      <p class="pseudocode">// IsHCRXEL2Enabled()
// ==================
// Returns TRUE if access to HCRX_EL2 register is enabled, and FALSE otherwise.
// Indirect read of HCRX_EL2 returns 0 when access is not enabled.

boolean <a id="impl-aarch64.IsHCRXEL2Enabled.0"/>IsHCRXEL2Enabled()
    assert(<a href="shared_pseudocode.html#impl-shared.HaveFeatHCX.0" title="function: boolean HaveFeatHCX()">HaveFeatHCX</a>());
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.HXEn == '0' then
        return FALSE;

    return <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.SetBTypeCompatible"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/SetBTypeCompatible</h3>
      <p class="pseudocode">// SetBTypeCompatible()
// ====================
// Sets the value of BTypeCompatible global variable used by BTI

<a id="impl-aarch64.SetBTypeCompatible.1"/>SetBTypeCompatible(boolean x)
    BTypeCompatible = x;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.SetBTypeNext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/SetBTypeNext</h3>
      <p class="pseudocode">// SetBTypeNext()
// ==============
// Set the value of BTypeNext global variable used by BTI

<a id="impl-aarch64.SetBTypeNext.1"/>SetBTypeNext(bits(2) x)
    BTypeNext = x;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.system.SetInGuardedPage"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/system/SetInGuardedPage</h3>
      <p class="pseudocode">// SetInGuardedPage()
// ==================
// Global state updated to denote if memory access is from a guarded page.

<a id="impl-aarch64.SetInGuardedPage.1"/>SetInGuardedPage(boolean guardedpage)
    InGuardedPage = guardedpage;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.CheckTMEEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/CheckTMEEnabled</h3>
      <p class="pseudocode">// CheckTMEEnabled()
// =================
// Returns TRUE if access to TME instruction is enabled, FALSE otherwise.

<a id="impl-aarch64.CheckTMEEnabled.0"/>CheckTMEEnabled()
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if SCR_EL3.TME == '0' then UNDEFINED;
    if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if HCR_EL2.TME == '0' then UNDEFINED;
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.CheckTransactionalSystemAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/CheckTransactionalSystemAccess</h3>
      <p class="pseudocode">// CheckTransactionalSystemAccess()
// ================================
// Returns TRUE if an AArch64 MSR, MRS, or SYS instruction is permitted in
// Transactional state, based on the opcode's encoding, and FALSE otherwise.

boolean <a id="impl-aarch64.CheckTransactionalSystemAccess.6"/>CheckTransactionalSystemAccess(bits(2) op0, bits(3) op1, bits(4) crn, bits(4) crm, bits(3) op2, bit read)
    case read:op0:op1:crn:crm:op2 of
        when '0 00 011 0100 xxxx 11x' return TRUE;      // MSR (imm): DAIFSet, DAIFClr
        when '0 01 011 0111 0100 001' return TRUE;      // DC ZVA
        when '0 11 011 0100 0010 00x' return TRUE;      // MSR: NZCV, DAIF
        when '0 11 011 0100 0100 00x' return TRUE;      // MSR: FPCR, FPSR
        when '0 11 000 0100 0110 000' return TRUE;      // MSR: ICC_PMR_EL1
        when '0 11 011 1001 1100 100' return TRUE;      // MRS: PMSWINC_EL0
        when '1 11 xxx 0xxx xxxx xxx' return TRUE;      // MRS: op1=3, CRn=0..7
        when '1 11 xxx 100x xxxx xxx' return TRUE;      // MRS: op1=3, CRn=8..9
        when '1 11 xxx 1010 xxxx xxx' return TRUE;      // MRS: op1=3, CRn=10
        when '1 11 000 1100 1x00 010' return TRUE;      // MRS: op1=3, CRn=12 - ICC_HPPIRx_EL1
        when '1 11 000 1100 1011 011' return TRUE;      // MRS: op1=3, CRn=12 - ICC_RPR_EL1
        when '1 11 xxx 1101 xxxx xxx' return TRUE;      // MRS: op1=3, CRn=13
        when '1 11 xxx 1110 xxxx xxx' return TRUE;      // MRS: op1=3, CRn=14
        when '0 01 011 0111 0011 111' return TRUE;      // CPP RCTX
        when '0 01 011 0111 0011 10x' return TRUE;      // CFP RCTX, DVP RCTX
        when 'x 11 xxx 1x11 xxxx xxx' return boolean IMPLEMENTATION_DEFINED; // MRS: op1=3, CRn=11,15
        otherwise return FALSE;                         // all other SYS, SYSL, MRS, MSR</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.CommitTransactionalWrites"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/CommitTransactionalWrites</h3>
      <p class="pseudocode">// Makes all transactional writes to memory observable by other PEs and reset
// the transactional read and write sets.
<a id="impl-aarch64.CommitTransactionalWrites.0"/>CommitTransactionalWrites();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.DiscardTransactionalWrites"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/DiscardTransactionalWrites</h3>
      <p class="pseudocode">// Discards all transactional writes to memory and reset the transactional
// read and write sets.
<a id="impl-aarch64.DiscardTransactionalWrites.0"/>DiscardTransactionalWrites();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.FailTransaction"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/FailTransaction</h3>
      <p class="pseudocode">// FailTransaction()
// =================

<a id="impl-aarch64.FailTransaction.2"/>FailTransaction(<a href="shared_pseudocode.html#TMFailure" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure</a> cause, boolean retry)
    <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.4" title="function: FailTransaction(TMFailure cause, boolean retry, boolean interrupt, bits(15) reason)">FailTransaction</a>(cause, retry, FALSE, <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(15));
    return;

// FailTransaction()
// =================
// Exits Transactional state and discards transactional updates to registers
// and memory.

<a id="impl-aarch64.FailTransaction.4"/>FailTransaction(<a href="shared_pseudocode.html#TMFailure" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure</a> cause, boolean retry, boolean interrupt, bits(15) reason)
    assert !retry || !interrupt;

    if <a href="shared_pseudocode.html#impl-shared.HaveBRBExt.0" title="function: boolean HaveBRBExt()">HaveBRBExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.BranchRecordAllowed.1" title="function: boolean BranchRecordAllowed(bits(2) el)">BranchRecordAllowed</a>(PSTATE.EL) then BRBFCR_EL1.LASTFAILED = '1';

    <a href="shared_pseudocode.html#impl-aarch64.DiscardTransactionalWrites.0" title="function: DiscardTransactionalWrites()">DiscardTransactionalWrites</a>();
    // For trivial implementation no transaction checkpoint was taken
    if cause != <a href="shared_pseudocode.html#TMFailure_TRIVIAL" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_TRIVIAL</a> then
        <a href="shared_pseudocode.html#impl-aarch64.RestoreTransactionCheckpoint.0" title="function: RestoreTransactionCheckpoint()">RestoreTransactionCheckpoint</a>();
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());

    bits(64) result = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    result&lt;23&gt; = if interrupt then '1' else '0';
    result&lt;15&gt; = if retry &amp;&amp; !interrupt then '1' else '0';
    case cause of
        when <a href="shared_pseudocode.html#TMFailure_TRIVIAL" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_TRIVIAL</a> result&lt;24&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_DBG" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_DBG</a>     result&lt;22&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_NEST" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_NEST</a>    result&lt;21&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_SIZE" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_SIZE</a>    result&lt;20&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>     result&lt;19&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_IMP" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_IMP</a>     result&lt;18&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_MEM" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_MEM</a>     result&lt;17&gt; = '1';
        when <a href="shared_pseudocode.html#TMFailure_CNCL" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_CNCL</a>    result&lt;16&gt; = '1'; result&lt;14:0&gt; = reason;

    TSTATE.depth = 0;
    <a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value">X</a>[TSTATE.Rt] = result;
    boolean branch_conditional = FALSE;
    <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(TSTATE.nPC, <a href="shared_pseudocode.html#BranchType_TMFAIL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_TMFAIL</a>, branch_conditional);
    <a href="shared_pseudocode.html#impl-shared.EndOfInstruction.0" title="function: EndOfInstruction()">EndOfInstruction</a>();
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.MemHasTransactionalAccess"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/MemHasTransactionalAccess</h3>
      <p class="pseudocode">// MemHasTransactionalAccess()
// ===========================
// Function checks if transactional accesses are not supported for an address
// range or memory type.

boolean <a id="impl-aarch64.MemHasTransactionalAccess.1"/>MemHasTransactionalAccess(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if ((memattrs.shareability == <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a> ||
            memattrs.shareability == <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>) &amp;&amp;
            memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
            memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
            memattrs.inner.hints == <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a> &amp;&amp;
            memattrs.inner.transient == FALSE &amp;&amp;
            memattrs.outer.hints == <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a> &amp;&amp;
            memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
            memattrs.outer.transient == FALSE) then
        return TRUE;
    else
        return boolean IMPLEMENTATION_DEFINED "Memory Region does not support Transactional access";</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.RestoreTransactionCheckpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/RestoreTransactionCheckpoint</h3>
      <p class="pseudocode">// RestoreTransactionCheckpoint()
// ==============================
// Restores part of the PE registers from the transaction checkpoint.

<a id="impl-aarch64.RestoreTransactionCheckpoint.0"/>RestoreTransactionCheckpoint()
    <a href="shared_pseudocode.html#impl-aarch64.SP.write.0" title="accessor: SP[] = bits(width) value">SP</a>[]             = TSTATE.SP;
    ICC_PMR_EL1      = TSTATE.ICC_PMR_EL1;
    PSTATE.&lt;N,Z,C,V&gt; = TSTATE.nzcv;
    PSTATE.&lt;D,A,I,F&gt; = TSTATE.&lt;D,A,I,F&gt;;

    for n = 0 to 30
        <a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value">X</a>[n] = TSTATE.<a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]">X</a>[n];

    if <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(PSTATE.EL) then
        if <a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)">IsSVEEnabled</a>(PSTATE.EL) then
            for n = 0 to 31
                <a href="shared_pseudocode.html#impl-aarch64.Z.write.1" title="accessor: Z[integer n] = bits(width) value">Z</a>[n] = TSTATE.<a href="shared_pseudocode.html#impl-aarch64.Z.read.1" title="accessor: bits(width) Z[integer n]">Z</a>[n]&lt;<a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a>-1:0&gt;;
            for n = 0 to 15
                <a href="shared_pseudocode.html#impl-aarch64.P.write.1" title="accessor: P[integer n] = bits(width) value">P</a>[n] = TSTATE.<a href="shared_pseudocode.html#impl-aarch64.P.read.1" title="accessor: bits(width) P[integer n]">P</a>[n]&lt;<a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL">PL</a>-1:0&gt;;
            <a href="shared_pseudocode.html#impl-aarch64.FFR.write.0" title="accessor: FFR[] = bits(width) value">FFR</a>[] = TSTATE.FFR&lt;<a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL">PL</a>-1:0&gt;;
        else
            for n = 0 to 31
                <a href="shared_pseudocode.html#impl-aarch64.V.write.1" title="accessor: V[integer n] = bits(width) value">V</a>[n] = TSTATE.<a href="shared_pseudocode.html#impl-aarch64.Z.read.1" title="accessor: bits(width) Z[integer n]">Z</a>[n]&lt;127:0&gt;;
        FPCR = TSTATE.FPCR;
        FPSR = TSTATE.FPSR;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.StartTrackingTransactionalReadsWrites"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/StartTrackingTransactionalReadsWrites</h3>
      <p class="pseudocode">// Starts tracking transactional reads and writes to memory.
<a id="impl-aarch64.StartTrackingTransactionalReadsWrites.0"/>StartTrackingTransactionalReadsWrites();</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.TMFailure"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/TMFailure</h3>
      <p class="pseudocode">enumeration <a id="TMFailure"/>TMFailure {
    <a id="TMFailure_CNCL"/>TMFailure_CNCL,    // Executed a TCANCEL instruction
    <a id="TMFailure_DBG"/>TMFailure_DBG,     // A debug event was generated
    <a id="TMFailure_ERR"/>TMFailure_ERR,     // A non-permissible operation was attempted
    <a id="TMFailure_NEST"/>TMFailure_NEST,    // The maximum transactional nesting level was exceeded
    <a id="TMFailure_SIZE"/>TMFailure_SIZE,    // The transactional read or write set limit was exceeded
    <a id="TMFailure_MEM"/>TMFailure_MEM,     // A transactional conflict occurred
    <a id="TMFailure_TRIVIAL"/>TMFailure_TRIVIAL, // Only a TRIVIAL version of TM is available
    <a id="TMFailure_IMP"/>TMFailure_IMP      // Any other failure cause
};</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.TMState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/TMState</h3>
      <p class="pseudocode">type TMState is (
    integer       depth,              // Transaction nesting depth
    integer       Rt,                 // TSTART destination register
    bits(64)      nPC,                // Fallback instruction address
    array[0..30] of bits(64)     X,   // General purpose registers
    array[0..31] of bits(<a href="shared_pseudocode.html#MAX_VL" title="constant integer MAX_VL = 2048">MAX_VL</a>) Z,   // Vector registers
    array[0..15] of bits(<a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>) P,   // Predicate registers
    bits(<a href="shared_pseudocode.html#MAX_PL" title="constant integer MAX_PL = 256">MAX_PL</a>)  FFR,                // First Fault Register
    bits(64)      SP,                 // Stack Pointer at current EL
    bits(64)      FPCR,               // Floating-point Control Register
    bits(64)      FPSR,               // Floating-point Status Register
    bits(64)      ICC_PMR_EL1,        // Interrupt Controller Interrupt Priority Mask Register
    bits(4)       nzcv,               // Condition flags
    bits(1)       D,                  // Debug mask bit
    bits(1)       A,                  // SError interrupt mask bit
    bits(1)       I,                  // IRQ mask bit
    bits(1)       F,                  // FIQ mask bit
)</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.TSTATE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/TSTATE</h3>
      <p class="pseudocode">TMState TSTATE;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.TakeTransactionCheckpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/TakeTransactionCheckpoint</h3>
      <p class="pseudocode">// TakeTransactionCheckpoint()
// ===========================
// Captures part of the PE registers into the transaction checkpoint.

<a id="impl-aarch64.TakeTransactionCheckpoint.0"/>TakeTransactionCheckpoint()
    TSTATE.SP             = <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(width) SP[]">SP</a>[];
    TSTATE.ICC_PMR_EL1    = ICC_PMR_EL1;
    TSTATE.nzcv           = PSTATE.&lt;N,Z,C,V&gt;;
    TSTATE.&lt;D,A,I,F&gt;      = PSTATE.&lt;D,A,I,F&gt;;

    for n = 0 to 30
        TSTATE.<a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value">X</a>[n] = <a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]">X</a>[n];

    if <a href="shared_pseudocode.html#impl-aarch64.IsFPEnabled.1" title="function: boolean IsFPEnabled(bits(2) el)">IsFPEnabled</a>(PSTATE.EL) then
        if <a href="shared_pseudocode.html#impl-aarch64.IsSVEEnabled.1" title="function: boolean IsSVEEnabled(bits(2) el)">IsSVEEnabled</a>(PSTATE.EL) then
            for n = 0 to 31
                TSTATE.<a href="shared_pseudocode.html#impl-aarch64.Z.write.1" title="accessor: Z[integer n] = bits(width) value">Z</a>[n]&lt;<a href="shared_pseudocode.html#impl-aarch64.VL.read.none" title="accessor: integer VL">VL</a>-1:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.Z.read.1" title="accessor: bits(width) Z[integer n]">Z</a>[n];
            for n = 0 to 15
                TSTATE.<a href="shared_pseudocode.html#impl-aarch64.P.write.1" title="accessor: P[integer n] = bits(width) value">P</a>[n]&lt;<a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL">PL</a>-1:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.P.read.1" title="accessor: bits(width) P[integer n]">P</a>[n];
            TSTATE.FFR&lt;<a href="shared_pseudocode.html#impl-aarch64.PL.read.none" title="accessor: integer PL">PL</a>-1:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.FFR.read.0" title="accessor: bits(width) FFR[]">FFR</a>[];
        else
            for n = 0 to 31
                TSTATE.<a href="shared_pseudocode.html#impl-aarch64.Z.write.1" title="accessor: Z[integer n] = bits(width) value">Z</a>[n]&lt;127:0&gt; = <a href="shared_pseudocode.html#impl-aarch64.V.read.1" title="accessor: bits(width) V[integer n]">V</a>[n];
        TSTATE.FPCR = FPCR;
        TSTATE.FPSR = FPSR;

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.functions.tme.TransactionStartTrap"/><h3 class="pseudocode">
            Library pseudocode for aarch64/functions/tme/TransactionStartTrap</h3>
      <p class="pseudocode">// TransactionStartTrap()
// ======================
// Traps the execution of TSTART instruction.

<a id="impl-aarch64.TransactionStartTrap.1"/>TransactionStartTrap(integer dreg)
    bits(64) preferred_exception_return = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    vect_offset = 0x0;

    exception = <a href="shared_pseudocode.html#impl-shared.ExceptionSyndrome.1" title="function: ExceptionRecord ExceptionSyndrome(Exception exceptype)">ExceptionSyndrome</a>(<a href="shared_pseudocode.html#Exception_TSTARTAccessTrap" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception_TSTARTAccessTrap</a>);
    exception.syndrome&lt;9:5&gt; = dreg&lt;4:0&gt;;

    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        targetEL = PSTATE.EL;
    elsif <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then
        targetEL = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        targetEL = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    <a href="shared_pseudocode.html#AArch64.TakeException.4" title="function: AArch64.TakeException(bits(2) target_el, ExceptionRecord exception,&#13; bits(64) preferred_exception_return, integer vect_offset)">AArch64.TakeException</a>(targetEL, exception, preferred_exception_return, vect_offset);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.branch.eret.AArch64.ExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/branch/eret/AArch64.ExceptionReturn</h3>
      <p class="pseudocode">// AArch64.ExceptionReturn()
// =========================

<a id="AArch64.ExceptionReturn.2"/>AArch64.ExceptionReturn(bits(64) new_pc, bits(64) spsr)

    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>, FALSE);

    if <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() then
        sync_errors = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].IESB == '1';
        if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            sync_errors = sync_errors || (SCR_EL3.&lt;EA,NMEA&gt; == '11' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        if sync_errors then
            <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();
            iesb_req = TRUE;
            <a href="shared_pseudocode.html#impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1" title="function: TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req)">TakeUnmaskedPhysicalSErrorInterrupts</a>(iesb_req);
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    // Attempts to change to an illegal state will invoke the Illegal Execution state mechanism
    bits(2) source_el = PSTATE.EL;
    boolean illegal_psr_state = <a href="shared_pseudocode.html#impl-shared.IllegalExceptionReturn.1" title="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</a>(spsr);
    <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.2" title="function: SetPSTATEFromPSR(bits(N) spsr, boolean illegal_psr_state)">SetPSTATEFromPSR</a>(spsr, illegal_psr_state);
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());
    <a href="shared_pseudocode.html#impl-shared.SendEventLocal.0" title="function: SendEventLocal()">SendEventLocal</a>();

    if illegal_psr_state &amp;&amp; spsr&lt;4&gt; == '1' then
        // If the exception return is illegal, PC[63:32,1:0] are UNKNOWN
        new_pc&lt;63:32&gt; = bits(32) UNKNOWN;
        new_pc&lt;1:0&gt; = bits(2) UNKNOWN;
    elsif <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then                // Return to AArch32
        // ELR_ELx[1:0] or ELR_ELx[0] are treated as being 0, depending on the
        // target instruction set state
        if PSTATE.T == '1' then
            new_pc&lt;0&gt; = '0';                 // T32
        else
            new_pc&lt;1:0&gt; = '00';              // A32
    else                                     // Return to AArch64
        // ELR_ELx[63:56] might include a tag
        new_pc = <a href="shared_pseudocode.html#AArch64.BranchAddr.1" title="function: bits(64) AArch64.BranchAddr(bits(64) vaddress)">AArch64.BranchAddr</a>(new_pc);

    if <a href="shared_pseudocode.html#impl-shared.HaveBRBExt.0" title="function: boolean HaveBRBExt()">HaveBRBExt</a>() then
        <a href="shared_pseudocode.html#impl-aarch64.BRBEExceptionReturn.2" title="function: BRBEExceptionReturn(bits(64) target_address, bits(2) source_el)">BRBEExceptionReturn</a>(new_pc, source_el);

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        // 32 most significant bits are ignored.
        boolean branch_conditional = FALSE;
        <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc&lt;31:0&gt;, <a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_ERET</a>, branch_conditional);
    else
        <a href="shared_pseudocode.html#impl-shared.BranchToAddr.2" title="function: BranchToAddr(bits(N) target, BranchType branch_type)">BranchToAddr</a>(new_pc, <a href="shared_pseudocode.html#BranchType_ERET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_ERET</a>);

    <a href="shared_pseudocode.html#impl-shared.CheckExceptionCatch.1" title="function: CheckExceptionCatch(boolean exception_entry)">CheckExceptionCatch</a>(FALSE);              // Check for debug event on exception return</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.countop.CountOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/countop/CountOp</h3>
      <p class="pseudocode">enumeration <a id="CountOp"/>CountOp     {<a id="CountOp_CLZ"/>CountOp_CLZ, <a id="CountOp_CLS"/>CountOp_CLS, <a id="CountOp_CNT"/>CountOp_CNT};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.extendreg.DecodeRegExtend"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/extendreg/DecodeRegExtend</h3>
      <p class="pseudocode">// DecodeRegExtend()
// =================
// Decode a register extension option

ExtendType <a id="impl-aarch64.DecodeRegExtend.1"/>DecodeRegExtend(bits(3) op)
    case op of
        when '000' return <a href="shared_pseudocode.html#ExtendType_UXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTB</a>;
        when '001' return <a href="shared_pseudocode.html#ExtendType_UXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTH</a>;
        when '010' return <a href="shared_pseudocode.html#ExtendType_UXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTW</a>;
        when '011' return <a href="shared_pseudocode.html#ExtendType_UXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTX</a>;
        when '100' return <a href="shared_pseudocode.html#ExtendType_SXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTB</a>;
        when '101' return <a href="shared_pseudocode.html#ExtendType_SXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTH</a>;
        when '110' return <a href="shared_pseudocode.html#ExtendType_SXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTW</a>;
        when '111' return <a href="shared_pseudocode.html#ExtendType_SXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTX</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.extendreg.ExtendReg"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/extendreg/ExtendReg</h3>
      <p class="pseudocode">// ExtendReg()
// ===========
// Perform a register extension and shift

bits(N) <a id="impl-aarch64.ExtendReg.3"/>ExtendReg(integer reg, <a href="shared_pseudocode.html#ExtendType" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType</a> exttype, integer shift)
    assert shift &gt;= 0 &amp;&amp; shift &lt;= 4;
    bits(N) val = <a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]">X</a>[reg];
    boolean unsigned;
    integer len;

    case exttype of
        when <a href="shared_pseudocode.html#ExtendType_SXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTB</a> unsigned = FALSE; len = 8;
        when <a href="shared_pseudocode.html#ExtendType_SXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTH</a> unsigned = FALSE; len = 16;
        when <a href="shared_pseudocode.html#ExtendType_SXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTW</a> unsigned = FALSE; len = 32;
        when <a href="shared_pseudocode.html#ExtendType_SXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_SXTX</a> unsigned = FALSE; len = 64;
        when <a href="shared_pseudocode.html#ExtendType_UXTB" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTB</a> unsigned = TRUE;  len = 8;
        when <a href="shared_pseudocode.html#ExtendType_UXTH" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTH</a> unsigned = TRUE;  len = 16;
        when <a href="shared_pseudocode.html#ExtendType_UXTW" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTW</a> unsigned = TRUE;  len = 32;
        when <a href="shared_pseudocode.html#ExtendType_UXTX" title="enumeration ExtendType  {ExtendType_SXTB, ExtendType_SXTH, ExtendType_SXTW, ExtendType_SXTX,&#13; ExtendType_UXTB, ExtendType_UXTH, ExtendType_UXTW, ExtendType_UXTX}">ExtendType_UXTX</a> unsigned = TRUE;  len = 64;

    // Note the extended width of the intermediate value and
    // that sign extension occurs from bit &lt;len+shift-1&gt;, not
    // from bit &lt;len-1&gt;. This is equivalent to the instruction
    //   [SU]BFIZ Rtmp, Rreg, #shift, #len
    // It may also be seen as a sign/zero extend followed by a shift:
    //   LSL(Extend(val&lt;len-1:0&gt;, N, unsigned), shift);

    len = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(len, N - shift);
    return <a href="shared_pseudocode.html#impl-shared.Extend.3" title="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)">Extend</a>(val&lt;len-1:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(shift), N, unsigned);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.extendreg.ExtendType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/extendreg/ExtendType</h3>
      <p class="pseudocode">enumeration <a id="ExtendType"/>ExtendType  {<a id="ExtendType_SXTB"/>ExtendType_SXTB, <a id="ExtendType_SXTH"/>ExtendType_SXTH, <a id="ExtendType_SXTW"/>ExtendType_SXTW, <a id="ExtendType_SXTX"/>ExtendType_SXTX,
                         <a id="ExtendType_UXTB"/>ExtendType_UXTB, <a id="ExtendType_UXTH"/>ExtendType_UXTH, <a id="ExtendType_UXTW"/>ExtendType_UXTW, <a id="ExtendType_UXTX"/>ExtendType_UXTX};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.float.arithmetic.max-min.fpmaxminop.FPMaxMinOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/float/arithmetic/max-min/fpmaxminop/FPMaxMinOp</h3>
      <p class="pseudocode">enumeration <a id="FPMaxMinOp"/>FPMaxMinOp  {<a id="FPMaxMinOp_MAX"/>FPMaxMinOp_MAX, <a id="FPMaxMinOp_MIN"/>FPMaxMinOp_MIN,
                         <a id="FPMaxMinOp_MAXNUM"/>FPMaxMinOp_MAXNUM, <a id="FPMaxMinOp_MINNUM"/>FPMaxMinOp_MINNUM};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.float.arithmetic.unary.fpunaryop.FPUnaryOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/float/arithmetic/unary/fpunaryop/FPUnaryOp</h3>
      <p class="pseudocode">enumeration <a id="FPUnaryOp"/>FPUnaryOp   {<a id="FPUnaryOp_ABS"/>FPUnaryOp_ABS, <a id="FPUnaryOp_MOV"/>FPUnaryOp_MOV,
                         <a id="FPUnaryOp_NEG"/>FPUnaryOp_NEG, <a id="FPUnaryOp_SQRT"/>FPUnaryOp_SQRT};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.float.convert.fpconvop.FPConvOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/float/convert/fpconvop/FPConvOp</h3>
      <p class="pseudocode">enumeration <a id="FPConvOp"/>FPConvOp    {<a id="FPConvOp_CVT_FtoI"/>FPConvOp_CVT_FtoI, <a id="FPConvOp_CVT_ItoF"/>FPConvOp_CVT_ItoF,
                         <a id="FPConvOp_MOV_FtoI"/>FPConvOp_MOV_FtoI, <a id="FPConvOp_MOV_ItoF"/>FPConvOp_MOV_ItoF
                         , <a id="FPConvOp_CVT_FtoI_JS"/>FPConvOp_CVT_FtoI_JS
};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.bitfield.bfxpreferred.BFXPreferred"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/bitfield/bfxpreferred/BFXPreferred</h3>
      <p class="pseudocode">// BFXPreferred()
// ==============
//
// Return TRUE if UBFX or SBFX is the preferred disassembly of a
// UBFM or SBFM bitfield instruction. Must exclude more specific
// aliases UBFIZ, SBFIZ, UXT[BH], SXT[BHW], LSL, LSR and ASR.

boolean <a id="impl-aarch64.BFXPreferred.4"/>BFXPreferred(bit sf, bit uns, bits(6) imms, bits(6) immr)
    integer S = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imms);
    integer R = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(immr);

    // must not match UBFIZ/SBFIX alias
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imms) &lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(immr) then
        return FALSE;

    // must not match LSR/ASR/LSL alias (imms == 31 or 63)
    if imms == sf:'11111' then
        return FALSE;

    // must not match UXTx/SXTx alias
    if immr == '000000' then
        // must not match 32-bit UXT[BH] or SXT[BH]
        if sf == '0' &amp;&amp; imms IN {'000111', '001111'} then
            return FALSE;
        // must not match 64-bit SXT[BHW]
        if sf:uns == '10' &amp;&amp; imms IN {'000111', '001111', '011111'} then
            return FALSE;

    // must be UBFX/SBFX alias
    return TRUE;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.bitmasks.DecodeBitMasks"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/bitmasks/DecodeBitMasks</h3>
      <p class="pseudocode">// DecodeBitMasks()
// ================

// Decode AArch64 bitfield and logical immediate masks which use a similar encoding structure

(bits(M), bits(M)) <a id="impl-aarch64.DecodeBitMasks.4"/>DecodeBitMasks(bit immN, bits(6) imms, bits(6) immr, boolean immediate)
    bits(64) tmask, wmask;
    bits(6) tmask_and, wmask_and;
    bits(6) tmask_or, wmask_or;
    bits(6) levels;

    // Compute log2 of element size
    // 2^len must be in range [2, M]
    len = <a href="shared_pseudocode.html#impl-shared.HighestSetBit.1" title="function: integer HighestSetBit(bits(N) x)">HighestSetBit</a>(immN:NOT(imms));
    if len &lt; 1 then UNDEFINED;
    assert M &gt;= (1 &lt;&lt; len);

    // Determine S, R and S - R parameters
    levels = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(len), 6);

    // For logical immediates an all-ones value of S is reserved
    // since it would generate a useless all-ones result (many times)
    if immediate &amp;&amp; (imms AND levels) == levels then
        UNDEFINED;

    S = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imms AND levels);
    R = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(immr AND levels);
    diff = S - R;    // 6-bit subtract with borrow

    // From a software perspective, the remaining code is equivalant to:
    //   esize = 1 &lt;&lt; len;
    //   d = UInt(diff&lt;len-1:0&gt;);
    //   welem = ZeroExtend(Ones(S + 1), esize);
    //   telem = ZeroExtend(Ones(d + 1), esize);
    //   wmask = Replicate(ROR(welem, R));
    //   tmask = Replicate(telem);
    //   return (wmask, tmask);

    // Compute "top mask"
    tmask_and = diff&lt;5:0&gt; OR NOT(levels);
    tmask_or  = diff&lt;5:0&gt; AND levels;

    tmask = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(64);
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;0&gt;, 1) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(1), 32))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(1) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;0&gt;, 1), 32));
    // optimization of first step:
    // tmask = Replicate(tmask_and&lt;0&gt; : '1', 32);
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;1&gt;, 2) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(2), 16))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(2) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;1&gt;, 2), 16));
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;2&gt;, 4) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(4), 8))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(4) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;2&gt;, 4), 8));
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;3&gt;, 8) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(8), 4))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;3&gt;, 8), 4));
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;4&gt;, 16) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(16), 2))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;4&gt;, 16), 2));
    tmask = ((tmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_and&lt;5&gt;, 32) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(32), 1))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(tmask_or&lt;5&gt;, 32), 1));

    // Compute "wraparound mask"
    wmask_and = immr OR NOT(levels);
    wmask_or  = immr AND levels;

    wmask = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(1) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;0&gt;, 1), 32))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;0&gt;, 1) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(1), 32));
    // optimization of first step:
    // wmask = Replicate(wmask_or&lt;0&gt; : '0', 32);
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(2) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;1&gt;, 2), 16))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;1&gt;, 2) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(2), 16));
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(4) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;2&gt;, 4), 8))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;2&gt;, 4) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(4), 8));
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(8) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;3&gt;, 8), 4))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;3&gt;, 8) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8), 4));
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(16) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;4&gt;, 16), 2))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;4&gt;, 16) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16), 2));
    wmask = ((wmask
              AND <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(32) : <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_and&lt;5&gt;, 32), 1))
               OR  <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(wmask_or&lt;5&gt;, 32) : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32), 1));

    if diff&lt;6&gt; != '0' then // borrow from S - R
        wmask = wmask AND tmask;
    else
        wmask = wmask OR tmask;

    return (wmask&lt;M-1:0&gt;, tmask&lt;M-1:0&gt;);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.ins-ext.insert.movewide.movewideop.MoveWideOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/ins-ext/insert/movewide/movewideop/MoveWideOp</h3>
      <p class="pseudocode">enumeration <a id="MoveWideOp"/>MoveWideOp  {<a id="MoveWideOp_N"/>MoveWideOp_N, <a id="MoveWideOp_Z"/>MoveWideOp_Z, <a id="MoveWideOp_K"/>MoveWideOp_K};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.logical.movwpreferred.MoveWidePreferred"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/logical/movwpreferred/MoveWidePreferred</h3>
      <p class="pseudocode">// MoveWidePreferred()
// ===================
//
// Return TRUE if a bitmask immediate encoding would generate an immediate
// value that could also be represented by a single MOVZ or MOVN instruction.
// Used as a condition for the preferred MOV&lt;-ORR alias.

boolean <a id="impl-aarch64.MoveWidePreferred.4"/>MoveWidePreferred(bit sf, bit immN, bits(6) imms, bits(6) immr)
    integer S = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(imms);
    integer R = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(immr);
    integer width = if sf == '1' then 64 else 32;

    // element size must equal total immediate size
    if sf == '1' &amp;&amp; immN:imms != '1xxxxxx' then
        return FALSE;
    if sf == '0' &amp;&amp; immN:imms != '00xxxxx' then
        return FALSE;

    // for MOVZ must contain no more than 16 ones
    if S &lt; 16 then
        // ones must not span halfword boundary when rotated
        return (-R MOD 16) &lt;= (15 - S);

    // for MOVN must contain no more than 16 zeros
    if S &gt;= width - 15 then
        // zeros must not span halfword boundary when rotated
        return (R MOD 16) &lt;= (S - (width - 15));

    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.shiftreg.DecodeShift"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/shiftreg/DecodeShift</h3>
      <p class="pseudocode">// DecodeShift()
// =============
// Decode shift encodings

ShiftType <a id="impl-aarch64.DecodeShift.1"/>DecodeShift(bits(2) op)
    case op of
        when '00'  return <a href="shared_pseudocode.html#ShiftType_LSL" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSL</a>;
        when '01'  return <a href="shared_pseudocode.html#ShiftType_LSR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSR</a>;
        when '10'  return <a href="shared_pseudocode.html#ShiftType_ASR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ASR</a>;
        when '11'  return <a href="shared_pseudocode.html#ShiftType_ROR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ROR</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.shiftreg.ShiftReg"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/shiftreg/ShiftReg</h3>
      <p class="pseudocode">// ShiftReg()
// ==========
// Perform shift of a register operand

bits(N) <a id="impl-aarch64.ShiftReg.3"/>ShiftReg(integer reg, <a href="shared_pseudocode.html#ShiftType" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType</a> shiftype, integer amount)
    bits(N) result = <a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]">X</a>[reg];
    case shiftype of
        when <a href="shared_pseudocode.html#ShiftType_LSL" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSL</a> result = <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(result, amount);
        when <a href="shared_pseudocode.html#ShiftType_LSR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_LSR</a> result = <a href="shared_pseudocode.html#impl-shared.LSR.2" title="function: bits(N) LSR(bits(N) x, integer shift)">LSR</a>(result, amount);
        when <a href="shared_pseudocode.html#ShiftType_ASR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ASR</a> result = <a href="shared_pseudocode.html#impl-shared.ASR.2" title="function: bits(N) ASR(bits(N) x, integer shift)">ASR</a>(result, amount);
        when <a href="shared_pseudocode.html#ShiftType_ROR" title="enumeration ShiftType   {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}">ShiftType_ROR</a> result = <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(result, amount);
    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.integer.shiftreg.ShiftType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/integer/shiftreg/ShiftType</h3>
      <p class="pseudocode">enumeration <a id="ShiftType"/>ShiftType   {<a id="ShiftType_LSL"/>ShiftType_LSL, <a id="ShiftType_LSR"/>ShiftType_LSR, <a id="ShiftType_ASR"/>ShiftType_ASR, <a id="ShiftType_ROR"/>ShiftType_ROR};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.logicalop.LogicalOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/logicalop/LogicalOp</h3>
      <p class="pseudocode">enumeration <a id="LogicalOp"/>LogicalOp   {<a id="LogicalOp_AND"/>LogicalOp_AND, <a id="LogicalOp_EOR"/>LogicalOp_EOR, <a id="LogicalOp_ORR"/>LogicalOp_ORR};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.memory.memop.MemAtomicOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/memory/memop/MemAtomicOp</h3>
      <p class="pseudocode">enumeration <a id="MemAtomicOp"/>MemAtomicOp {<a id="MemAtomicOp_ADD"/>MemAtomicOp_ADD,
                         <a id="MemAtomicOp_BIC"/>MemAtomicOp_BIC,
                         <a id="MemAtomicOp_EOR"/>MemAtomicOp_EOR,
                         <a id="MemAtomicOp_ORR"/>MemAtomicOp_ORR,
                         <a id="MemAtomicOp_SMAX"/>MemAtomicOp_SMAX,
                         <a id="MemAtomicOp_SMIN"/>MemAtomicOp_SMIN,
                         <a id="MemAtomicOp_UMAX"/>MemAtomicOp_UMAX,
                         <a id="MemAtomicOp_UMIN"/>MemAtomicOp_UMIN,
                         <a id="MemAtomicOp_SWP"/>MemAtomicOp_SWP};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.memory.memop.MemOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/memory/memop/MemOp</h3>
      <p class="pseudocode">enumeration <a id="MemOp"/>MemOp {<a id="MemOp_LOAD"/>MemOp_LOAD, <a id="MemOp_STORE"/>MemOp_STORE, <a id="MemOp_PREFETCH"/>MemOp_PREFETCH};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.memory.prefetch.Prefetch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/memory/prefetch/Prefetch</h3>
      <p class="pseudocode">// Prefetch()
// ==========

// Decode and execute the prefetch hint on ADDRESS specified by PRFOP

<a id="impl-aarch64.Prefetch.2"/>Prefetch(bits(64) address, bits(5) prfop)
    <a href="shared_pseudocode.html#PrefetchHint" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">PrefetchHint</a> hint;
    integer target;
    boolean stream;

    case prfop&lt;4:3&gt; of
        when '00' hint = <a href="shared_pseudocode.html#Prefetch_READ" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_READ</a>;         // PLD: prefetch for load
        when '01' hint = <a href="shared_pseudocode.html#Prefetch_EXEC" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_EXEC</a>;         // PLI: preload instructions
        when '10' hint = <a href="shared_pseudocode.html#Prefetch_WRITE" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">Prefetch_WRITE</a>;        // PST: prepare for store
        when '11' return;                       // unallocated hint
    target = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(prfop&lt;2:1&gt;);                  // target cache level
    stream = (prfop&lt;0&gt; != '0');                 // streaming (non-temporal)
    <a href="shared_pseudocode.html#impl-shared.Hint_Prefetch.4" title="function: Hint_Prefetch(bits(64) address, PrefetchHint hint, integer target, boolean stream)">Hint_Prefetch</a>(address, hint, target, stream);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.barriers.barrierop.MemBarrierOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/barriers/barrierop/MemBarrierOp</h3>
      <p class="pseudocode">enumeration <a id="MemBarrierOp"/>MemBarrierOp   {  <a id="MemBarrierOp_DSB"/>MemBarrierOp_DSB         // Data Synchronization Barrier
                            , <a id="MemBarrierOp_DMB"/>MemBarrierOp_DMB         // Data Memory Barrier
                            , <a id="MemBarrierOp_ISB"/>MemBarrierOp_ISB         // Instruction Synchronization Barrier
                            , <a id="MemBarrierOp_SSBB"/>MemBarrierOp_SSBB        // Speculative Synchronization Barrier to VA
                            , <a id="MemBarrierOp_PSSBB"/>MemBarrierOp_PSSBB       // Speculative Synchronization Barrier to PA
                            , <a id="MemBarrierOp_SB"/>MemBarrierOp_SB          // Speculation Barrier
                           };</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.hints.syshintop.SystemHintOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/hints/syshintop/SystemHintOp</h3>
      <p class="pseudocode">enumeration <a id="SystemHintOp"/>SystemHintOp {
    <a id="SystemHintOp_NOP"/>SystemHintOp_NOP,
    <a id="SystemHintOp_YIELD"/>SystemHintOp_YIELD,
    <a id="SystemHintOp_WFE"/>SystemHintOp_WFE,
    <a id="SystemHintOp_WFI"/>SystemHintOp_WFI,
    <a id="SystemHintOp_SEV"/>SystemHintOp_SEV,
    <a id="SystemHintOp_SEVL"/>SystemHintOp_SEVL,
    <a id="SystemHintOp_DGH"/>SystemHintOp_DGH,
    <a id="SystemHintOp_ESB"/>SystemHintOp_ESB,
    <a id="SystemHintOp_PSB"/>SystemHintOp_PSB,
    <a id="SystemHintOp_TSB"/>SystemHintOp_TSB,
    <a id="SystemHintOp_BTI"/>SystemHintOp_BTI,
    <a id="SystemHintOp_WFET"/>SystemHintOp_WFET,
    <a id="SystemHintOp_WFIT"/>SystemHintOp_WFIT,
    <a id="SystemHintOp_CSDB"/>SystemHintOp_CSDB
};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.register.cpsr.pstatefield.PSTATEField"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/register/cpsr/pstatefield/PSTATEField</h3>
      <p class="pseudocode">enumeration <a id="PSTATEField"/>PSTATEField {<a id="PSTATEField_DAIFSet"/>PSTATEField_DAIFSet, <a id="PSTATEField_DAIFClr"/>PSTATEField_DAIFClr,
                         <a id="PSTATEField_PAN"/>PSTATEField_PAN, // Armv8.1
                         <a id="PSTATEField_UAO"/>PSTATEField_UAO, // Armv8.2
                         <a id="PSTATEField_DIT"/>PSTATEField_DIT, // Armv8.4
                         <a id="PSTATEField_SSBS"/>PSTATEField_SSBS,
                         <a id="PSTATEField_TCO"/>PSTATEField_TCO, // Armv8.5
                         <a id="PSTATEField_SVCRSM"/>PSTATEField_SVCRSM,
                         <a id="PSTATEField_SVCRZA"/>PSTATEField_SVCRZA,
                         <a id="PSTATEField_SVCRSMZA"/>PSTATEField_SVCRSMZA,
                         <a id="PSTATEField_ALLINT"/>PSTATEField_ALLINT,
                         <a id="PSTATEField_SP"/>PSTATEField_SP
                         };</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.at.AArch64.AT"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/at/AArch64.AT</h3>
      <p class="pseudocode">// AArch64.AT()
// ============
// Perform address translation as per AT instructions.

<a id="AArch64.AT.4"/>AArch64.AT(bits(64) address, <a href="shared_pseudocode.html#TranslationStage" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage</a> stage, bits(2) el, <a href="shared_pseudocode.html#ATAccess" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess</a> ataccess)

    // For stage 1 translation, when HCR_EL2.{E2H, TGE} is {1,1} and requested EL is EL1,
    // the EL2&amp;0 translation regime is used.
    if HCR_EL2.&lt;E2H, TGE&gt; == '11' &amp;&amp; el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; stage == <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a> then
        el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        stage = <a href="shared_pseudocode.html#TranslationStage_1" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_1</a>;

    acctype = if ataccess IN {<a href="shared_pseudocode.html#ATAccess_Read" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Read</a>, <a href="shared_pseudocode.html#ATAccess_Write" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</a>} then <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a> else <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>;
    iswrite = ataccess IN {<a href="shared_pseudocode.html#ATAccess_WritePAN" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_WritePAN</a>, <a href="shared_pseudocode.html#ATAccess_Write" title="enumeration ATAccess {&#13; ATAccess_Read,&#13; ATAccess_Write,&#13; ATAccess_ReadPAN,&#13; ATAccess_WritePAN&#13; }">ATAccess_Write</a>};
    aligned = TRUE;
    ispriv  = el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;

    fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
    fault.acctype = acctype;
    fault.write = iswrite;

    if stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> then
        regime = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    else
        regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.2" title="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</a>(el, acctype);

    ss = <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(el);
    if (el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) || (el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el)) then
        if regime == <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a> || TTBCR.EAE == '1' then
            (fault, addrdesc) = <a href="shared_pseudocode.html#AArch32.S1TranslateLD.8" title="function: (FaultRecord, AddressDescriptor) AArch32.S1TranslateLD(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateLD</a>(fault, regime, ss, address&lt;31:0&gt;, acctype,
                                                      aligned, iswrite, ispriv);
        else
            (fault, addrdesc, -) = <a href="shared_pseudocode.html#AArch32.S1TranslateSD.8" title="function: (FaultRecord, AddressDescriptor, SDFType) AArch32.S1TranslateSD(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(32) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S1TranslateSD</a>(fault, regime, ss, address&lt;31:0&gt;, acctype,
                                                         aligned, iswrite, ispriv);
    else
        (fault, addrdesc) = <a href="shared_pseudocode.html#AArch64.S1Translate.8" title="function: (FaultRecord, AddressDescriptor) AArch64.S1Translate(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(64) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch64.S1Translate</a>(fault, regime, ss, address, acctype, aligned,
                                                iswrite, ispriv);

    if stage == <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a> &amp;&amp; fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            addrdesc.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(address);
            s2fs1walk = FALSE;
            (fault, addrdesc) = <a href="shared_pseudocode.html#AArch32.S2Translate.8" title="function: (FaultRecord, AddressDescriptor) AArch32.S2Translate(FaultRecord fault, AddressDescriptor ipa,&#13; SecurityState ss, boolean s2fs1walk,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch32.S2Translate</a>(fault, addrdesc, ss, s2fs1walk, acctype,
                                                    aligned, iswrite, ispriv);
        elsif regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            s1aarch64 = TRUE;
            s2fs1walk = FALSE;
            (fault, addrdesc) = <a href="shared_pseudocode.html#AArch64.S2Translate.9" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</a>(fault, addrdesc, s1aarch64, ss, s2fs1walk,
                                                    acctype, aligned, iswrite, ispriv);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        addrdesc = <a href="shared_pseudocode.html#impl-shared.CreateFaultyAddressDescriptor.2" title="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(address, fault);
        // Take exception when synchronous external abort occurs on translation table walk or
        // a fault in the stage 2 translation of an address accessed in a stage 1 translation
        // table lookup
        // * A Granule Protection Check Exception (when RME is implemented)
        if (<a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault) ||
                (PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; fault.s2fs1walk) ||
                (<a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> &amp;&amp;
                 <a href="shared_pseudocode.html#impl-shared.ReportAsGPCException.1" title="function: boolean ReportAsGPCException(FaultRecord fault)">ReportAsGPCException</a>(fault))) then
            PAR_EL1 = bits(64) UNKNOWN;
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(address, addrdesc.fault);

    is_ATS1Ex = stage != <a href="shared_pseudocode.html#TranslationStage_12" title="enumeration TranslationStage {&#13; TranslationStage_1,&#13; TranslationStage_12&#13; }">TranslationStage_12</a>;
    <a href="shared_pseudocode.html#AArch64.EncodePAR.3" title="function: AArch64.EncodePAR(Regime regime, boolean is_ATS1Ex, AddressDescriptor addrdesc)">AArch64.EncodePAR</a>(regime, is_ATS1Ex, addrdesc);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.at.AArch64.EncodePAR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/at/AArch64.EncodePAR</h3>
      <p class="pseudocode">// AArch64.EncodePAR()
// ===================
// Encode PAR register with result of translation.

<a id="AArch64.EncodePAR.3"/>AArch64.EncodePAR(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, boolean is_ATS1Ex, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc)
    PAR_EL1 = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    paspace = addrdesc.paddress.paspace;

    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(addrdesc) then
        PAR_EL1.F = '0';
        if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
            if regime == <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a> then
                case paspace of
                    when <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>     PAR_EL1.&lt;NSE,NS&gt; = '00';
                    when <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>  PAR_EL1.&lt;NSE,NS&gt; = '01';
                    when <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>       PAR_EL1.&lt;NSE,NS&gt; = '10';
                    when <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>      PAR_EL1.&lt;NSE,NS&gt; = '11';

            elsif <a href="shared_pseudocode.html#impl-shared.SecurityStateForRegime.1" title="function: SecurityState SecurityStateForRegime(Regime regime)">SecurityStateForRegime</a>(regime) == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>  then
                PAR_EL1.NSE = bit UNKNOWN;
                PAR_EL1.NS = if paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then '0' else '1';

            elsif <a href="shared_pseudocode.html#impl-shared.SecurityStateForRegime.1" title="function: SecurityState SecurityStateForRegime(Regime regime)">SecurityStateForRegime</a>(regime) == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; !is_ATS1Ex then
                PAR_EL1.NSE = bit UNKNOWN;
                PAR_EL1.NS = if paspace == <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then '0' else '1';

            else
                PAR_EL1.NSE = bit UNKNOWN;
                PAR_EL1.NS  = '1';
        else
            PAR_EL1&lt;11&gt; = '1'; // RES1
            if <a href="shared_pseudocode.html#impl-shared.SecurityStateForRegime.1" title="function: SecurityState SecurityStateForRegime(Regime regime)">SecurityStateForRegime</a>(regime) == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
                PAR_EL1.NS = if paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then '0' else '1';
            else
                PAR_EL1.NS = bit UNKNOWN;
        PAR_EL1.SH   = ReportedPARShareability(<a href="shared_pseudocode.html#impl-shared.PAREncodeShareability.1" title="function: bits(2) PAREncodeShareability(MemoryAttributes memattrs)">PAREncodeShareability</a>(addrdesc.memattrs));
        PAR_EL1.PA   = addrdesc.paddress.address&lt;52-1:12&gt;;
        PAR_EL1.ATTR = ReportedPARAttrs(<a href="shared_pseudocode.html#impl-shared.EncodePARAttrs.1" title="function: bits(8) EncodePARAttrs(MemoryAttributes memattrs)">EncodePARAttrs</a>(addrdesc.memattrs));
        PAR_EL1&lt;10&gt; = bit IMPLEMENTATION_DEFINED "Non-Faulting PAR";
    else
        PAR_EL1.F   = '1';
        PAR_EL1.FST = <a href="shared_pseudocode.html#AArch64.PARFaultStatus.1" title="function: bits(6) AArch64.PARFaultStatus(FaultRecord fault)">AArch64.PARFaultStatus</a>(addrdesc.fault);
        PAR_EL1.PTW = if addrdesc.fault.s2fs1walk then '1' else '0';
        PAR_EL1.S   = if addrdesc.fault.secondstage then '1' else '0';
        PAR_EL1&lt;11&gt; = '1'; // RES1
        PAR_EL1&lt;63:48&gt; = bits(16) IMPLEMENTATION_DEFINED "Faulting PAR";
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.at.AArch64.PARFaultStatus"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/at/AArch64.PARFaultStatus</h3>
      <p class="pseudocode">// AArch64.PARFaultStatus()
// ========================
// Fault status field decoding of 64-bit PAR.

bits(6) <a id="AArch64.PARFaultStatus.1"/>AArch64.PARFaultStatus(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    bits(6) fst;

    if fault.statuscode == <a href="shared_pseudocode.html#Fault_Domain" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Domain</a> then
        // Report Domain fault
        assert fault.level IN {1,2};
        fst&lt;1:0&gt; = if fault.level == 1 then '01' else '10';
        fst&lt;5:2&gt; = '1111';
    else
        fst = <a href="shared_pseudocode.html#impl-shared.EncodeLDFSC.2" title="function: bits(6) EncodeLDFSC(Fault statuscode, integer level)">EncodeLDFSC</a>(fault.statuscode, fault.level);
    return fst;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.dc.AArch64.DC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/dc/AArch64.DC</h3>
      <p class="pseudocode">// AArch64.DC()
// ============
// Perform Data Cache Operation.

<a id="AArch64.DC.4"/>AArch64.DC(bits(64) regval, <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype, <a href="shared_pseudocode.html#CacheOp" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</a> cacheop, <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>;
    <a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;

    cache.acctype = acctype;
    cache.cachetype = cachetype;
    cache.cacheop = cacheop;
    cache.opscope = opscope;

    if opscope == <a href="shared_pseudocode.html#CacheOpScope_SetWay" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_SetWay</a> then
        ss = <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
        cache.cpas = <a href="shared_pseudocode.html#impl-shared.CPASAtSecurityState.1" title="function: CachePASpace CPASAtSecurityState(SecurityState ss)">CPASAtSecurityState</a>(ss);
        cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        (cache.set, cache.way, cache.level) = <a href="shared_pseudocode.html#impl-shared.DecodeSW.2" title="function: (integer, integer, integer) DecodeSW(bits(64) regval, CacheType cachetype)">DecodeSW</a>(regval, cachetype);
        if (cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
          (HCR_EL2.SWIO == '1' || HCR_EL2.&lt;DC,VM&gt; != '00')) then
            cache.cacheop = <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;

        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
        return;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            cache.is_vmid_valid = TRUE;
            cache.vmid          = <a href="shared_pseudocode.html#impl-aarch64.VMID.read.0" title="accessor: bits(16) VMID[]">VMID</a>[];
        else
            cache.is_vmid_valid = FALSE;
    else
        cache.is_vmid_valid = FALSE;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        cache.is_asid_valid = TRUE;
        cache.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];
    else
        cache.is_asid_valid = FALSE;

    if opscope == <a href="shared_pseudocode.html#CacheOpScope_PoDP" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoDP</a> &amp;&amp; boolean IMPLEMENTATION_DEFINED "Memory system does not supports PoDP" then
        opscope = <a href="shared_pseudocode.html#CacheOpScope_PoP" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoP</a>;
    if opscope == <a href="shared_pseudocode.html#CacheOpScope_PoP" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoP</a> &amp;&amp; boolean IMPLEMENTATION_DEFINED "Memory system does not supports PoP" then
        opscope = <a href="shared_pseudocode.html#CacheOpScope_PoC" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a>;
    need_translate = <a href="shared_pseudocode.html#impl-shared.DCInstNeedsTranslation.1" title="function: boolean DCInstNeedsTranslation(CacheOpScope opscope)">DCInstNeedsTranslation</a>(opscope);
    iswrite = cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a>;
    vaddress = regval;

    size = 0;        // by default no watchpoint address
    if iswrite then
        size = integer IMPLEMENTATION_DEFINED "Data Cache Invalidate Watchpoint Size";
        assert size &gt;= 4*(2^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(CTR_EL0.DminLine))) &amp;&amp; size &lt;= 2048;
        assert (size&lt;32:0&gt; AND (size-1)&lt;32:0&gt;) == 0; // size is power of 2
        vaddress = <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(regval, size);

    cache.translated = need_translate;
    cache.vaddress = vaddress;

    if need_translate then
        wasaligned = TRUE;
        memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(vaddress, acctype, iswrite, wasaligned, size);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(regval, memaddrdesc.fault);

        memattrs = memaddrdesc.memattrs;
        cache.paddress = memaddrdesc.paddress;
        cache.cpas = <a href="shared_pseudocode.html#impl-shared.CPASAtPAS.1" title="function: CachePASpace CPASAtPAS(PASpace pas)">CPASAtPAS</a>(memaddrdesc.paddress.paspace);
        if opscope IN {<a href="shared_pseudocode.html#CacheOpScope_PoC" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoC</a>, <a href="shared_pseudocode.html#CacheOpScope_PoP" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoP</a>, <a href="shared_pseudocode.html#CacheOpScope_PoDP" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoDP</a>} then
            cache.shareability = memattrs.shareability;
        else
            cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
    else
        cache.shareability = <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> UNKNOWN;
        cache.paddress = <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> UNKNOWN;

    if cacheop == <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;DC,VM&gt; != '00' then
        cache.cacheop = <a href="shared_pseudocode.html#CacheOp_CleanInvalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_CleanInvalidate</a>;

    <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.dc.AArch64.MemZero"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/dc/AArch64.MemZero</h3>
      <p class="pseudocode">// AArch64.MemZero()
// =================

<a id="AArch64.MemZero.2"/>AArch64.MemZero(bits(64) regval, <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype)

    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = <a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>;
    boolean iswrite = TRUE;
    boolean wasaligned = TRUE;

    integer size = 4*(2^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(DCZID_EL0.BS)));
    bits(64) vaddress = <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(regval, size);

    memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(vaddress, acctype, iswrite, wasaligned, size);

    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
        if <a href="shared_pseudocode.html#impl-shared.IsDebugException.1" title="function: boolean IsDebugException(FaultRecord fault)">IsDebugException</a>(memaddrdesc.fault) then
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(vaddress, memaddrdesc.fault);
        else
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(regval, memaddrdesc.fault);
    else
        if cachetype == <a href="shared_pseudocode.html#CacheType_Data" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data</a> then
            <a href="shared_pseudocode.html#AArch64.DataMemZero.4" title="function: AArch64.DataMemZero(bits(64) regval, bits(64) vaddress, AddressDescriptor memaddrdesc, integer size)">AArch64.DataMemZero</a>(regval, vaddress, memaddrdesc, size);
        elsif cachetype == <a href="shared_pseudocode.html#CacheType_Tag" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Tag</a> then
            if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then <a href="shared_pseudocode.html#AArch64.TagMemZero.2" title="function: AArch64.TagMemZero(bits(64) vaddress, integer size)">AArch64.TagMemZero</a>(vaddress, size);
        elsif cachetype == <a href="shared_pseudocode.html#CacheType_Data_Tag" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Data_Tag</a> then
            if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then <a href="shared_pseudocode.html#AArch64.TagMemZero.2" title="function: AArch64.TagMemZero(bits(64) vaddress, integer size)">AArch64.TagMemZero</a>(vaddress, size);
            <a href="shared_pseudocode.html#AArch64.DataMemZero.4" title="function: AArch64.DataMemZero(bits(64) regval, bits(64) vaddress, AddressDescriptor memaddrdesc, integer size)">AArch64.DataMemZero</a>(regval, vaddress, memaddrdesc, size);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.ic.AArch64.IC"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/ic/AArch64.IC</h3>
      <p class="pseudocode">// AArch64.IC()
// ============
// Perform Instruction Cache Operation.

<a id="AArch64.IC.1"/>AArch64.IC(<a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    regval = bits(64) UNKNOWN;
    <a href="shared_pseudocode.html#AArch64.IC.2" title="function: AArch64.IC(bits(64) regval, CacheOpScope opscope)">AArch64.IC</a>(regval, opscope);

// AArch64.IC()
// ============
// Perform Instruction Cache Operation.

<a id="AArch64.IC.2"/>AArch64.IC(bits(64) regval, <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    <a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache;
    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype = <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>;

    cache.acctype = acctype;
    cache.cachetype = <a href="shared_pseudocode.html#CacheType_Instruction" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType_Instruction</a>;
    cache.cacheop = <a href="shared_pseudocode.html#CacheOp_Invalidate" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp_Invalidate</a>;
    cache.opscope = opscope;

    if opscope IN {<a href="shared_pseudocode.html#CacheOpScope_ALLU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a>, <a href="shared_pseudocode.html#CacheOpScope_ALLUIS" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a>} then
        ss = <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
        cache.cpas = <a href="shared_pseudocode.html#impl-shared.CPASAtSecurityState.1" title="function: CachePASpace CPASAtSecurityState(SecurityState ss)">CPASAtSecurityState</a>(ss);
        if (opscope == <a href="shared_pseudocode.html#CacheOpScope_ALLUIS" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLUIS</a> || (opscope == <a href="shared_pseudocode.html#CacheOpScope_ALLU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_ALLU</a> &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.FB == '1')) then
            cache.shareability = <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
        else
            cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.regval = regval;
        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    else
        assert opscope == <a href="shared_pseudocode.html#CacheOpScope_PoU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoU</a>;

        if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
                cache.is_vmid_valid = TRUE;
                cache.vmid          = <a href="shared_pseudocode.html#impl-aarch64.VMID.read.0" title="accessor: bits(16) VMID[]">VMID</a>[];
            else
                cache.is_vmid_valid = FALSE;
        else
            cache.is_vmid_valid = FALSE;

        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            cache.is_asid_valid = TRUE;
            cache.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];
        else
            cache.is_asid_valid = FALSE;

        bits(64) vaddress = regval;
        need_translate = <a href="shared_pseudocode.html#impl-shared.ICInstNeedsTranslation.1" title="function: boolean ICInstNeedsTranslation(CacheOpScope opscope)">ICInstNeedsTranslation</a>(opscope);

        cache.vaddress = regval;
        cache.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        cache.translated = need_translate;

        if !need_translate then
            cache.paddress = <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> UNKNOWN;
            <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
            return;
        iswrite = FALSE;
        wasaligned = TRUE;
        size = 0;
        memaddrdesc = <a href="shared_pseudocode.html#AArch64.TranslateAddress.5" title="function: AddressDescriptor AArch64.TranslateAddress(bits(64) va, AccType acctype, boolean iswrite,&#13; boolean aligned, integer size)">AArch64.TranslateAddress</a>(vaddress, acctype, iswrite, wasaligned, size);

        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memaddrdesc) then
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(regval, memaddrdesc.fault);

        cache.cpas = <a href="shared_pseudocode.html#impl-shared.CPASAtPAS.1" title="function: CachePASpace CPASAtPAS(PASpace pas)">CPASAtPAS</a>(memaddrdesc.paddress.paspace);
        cache.paddress = memaddrdesc.paddress;
        <a href="shared_pseudocode.html#impl-shared.CACHE_OP.1" title="function: CACHE_OP(CacheRecord cache)">CACHE_OP</a>(cache);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.predictionrestrict.RestrictPrediction"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/predictionrestrict/RestrictPrediction</h3>
      <p class="pseudocode">// RestrictPrediction()
// ====================
// Clear all predictions in the context.

<a id="AArch64.RestrictPrediction.2"/>AArch64.RestrictPrediction(bits(64) val, <a href="shared_pseudocode.html#RestrictType" title="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch&#13; }">RestrictType</a> restriction)

    <a href="shared_pseudocode.html#ExecutionCntxt" title="type ExecutionCntxt is ( boolean is_vmid_valid, boolean all_vmid, bits(16) vmid, boolean is_asid_valid, boolean all_asid, bits(16) asid, bits(2) target_el, SecurityState security, RestrictType restriction )">ExecutionCntxt</a> c;
    target_el    = val&lt;25:24&gt;;

    // If the instruction is executed at an EL lower than the specified
    // level, it is treated as a NOP.
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target_el) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then return;

    bit ns  = val&lt;26&gt;;
    bit nse = val&lt;27&gt;;
    ss = <a href="shared_pseudocode.html#impl-shared.TargetSecurityState.2" title="function: SecurityState TargetSecurityState(bit NS, bit NSE)">TargetSecurityState</a>(ns, nse);
    if ss == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a> &amp;&amp; target_el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then return;

    c.security  = ss;
    c.target_el = target_el;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
        if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = FALSE;
            c.vmid          = <a href="shared_pseudocode.html#impl-aarch64.VMID.read.0" title="accessor: bits(16) VMID[]">VMID</a>[];

        elsif target_el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} then
            c.is_vmid_valid = TRUE;
            c.all_vmid      = val&lt;48&gt; == '1';
            c.vmid          = val&lt;47:32&gt;;           // Only valid if  val&lt;48&gt; == '0';
        else
            c.is_vmid_valid = FALSE;
    else
        c.is_vmid_valid = FALSE;

    if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = FALSE;
        c.asid          = <a href="shared_pseudocode.html#impl-shared.ASID.read.0" title="accessor: bits(16) ASID[]">ASID</a>[];

    elsif target_el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        c.is_asid_valid = TRUE;
        c.all_asid      = val&lt;16&gt; == '1';
        c.asid          = val&lt;15:0&gt;;                  // Only valid if  val&lt;16&gt; == '0';

    else
        c.is_asid_valid = FALSE;

    c.restriction = restriction;
    <a href="shared_pseudocode.html#impl-shared.RESTRICT_PREDICTIONS.1" title="function: RESTRICT_PREDICTIONS(ExecutionCntxt c)">RESTRICT_PREDICTIONS</a>(c);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.sysop.SysOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/sysop/SysOp</h3>
      <p class="pseudocode">// SysOp()
// =======

SystemOp <a id="impl-aarch64.SysOp.4"/>SysOp(bits(3) op1, bits(4) CRn, bits(4) CRm, bits(3) op2)
    case op1:CRn:CRm:op2 of
        when '000 0111 1000 000' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E1R
        when '100 0111 1000 000' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E2R
        when '110 0111 1000 000' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E3R
        when '000 0111 1000 001' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E1W
        when '100 0111 1000 001' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E2W
        when '110 0111 1000 001' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E3W
        when '000 0111 1000 010' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E0R
        when '000 0111 1000 011' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S1E0W
        when '100 0111 1000 100' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S12E1R
        when '100 0111 1000 101' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S12E1W
        when '100 0111 1000 110' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S12E0R
        when '100 0111 1000 111' return <a href="shared_pseudocode.html#Sys_AT" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_AT</a>;   // S12E0W
        when '011 0111 0100 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // ZVA
        when '000 0111 0110 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // IVAC
        when '000 0111 0110 010' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // ISW
        when '011 0111 1010 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CVAC
        when '000 0111 1010 010' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CSW
        when '011 0111 1011 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CVAU
        when '011 0111 1110 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CIVAC
        when '000 0111 1110 010' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CISW
        when '011 0111 1101 001' return <a href="shared_pseudocode.html#Sys_DC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_DC</a>;   // CVADP
        when '000 0111 0001 000' return <a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_IC</a>;   // IALLUIS
        when '000 0111 0101 000' return <a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_IC</a>;   // IALLU
        when '011 0111 0101 001' return <a href="shared_pseudocode.html#Sys_IC" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_IC</a>;   // IVAU
        when '100 1000 0000 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // IPAS2E1IS
        when '100 1000 0000 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // IPAS2LE1IS
        when '000 1000 0011 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VMALLE1IS
        when '100 1000 0011 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE2IS
        when '110 1000 0011 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE3IS
        when '000 1000 0011 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE1IS
        when '100 1000 0011 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE2IS
        when '110 1000 0011 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE3IS
        when '000 1000 0011 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ASIDE1IS
        when '000 1000 0011 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAAE1IS
        when '100 1000 0011 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE1IS
        when '000 1000 0011 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE1IS
        when '100 1000 0011 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE2IS
        when '110 1000 0011 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE3IS
        when '100 1000 0011 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VMALLS12E1IS
        when '000 1000 0011 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAALE1IS
        when '100 1000 0100 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // IPAS2E1
        when '100 1000 0100 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // IPAS2LE1
        when '000 1000 0111 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VMALLE1
        when '100 1000 0111 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE2
        when '110 1000 0111 000' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE3
        when '000 1000 0111 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE1
        when '100 1000 0111 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE2
        when '110 1000 0111 001' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAE3
        when '000 1000 0111 010' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ASIDE1
        when '000 1000 0111 011' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAAE1
        when '100 1000 0111 100' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // ALLE1
        when '000 1000 0111 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE1
        when '100 1000 0111 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE2
        when '110 1000 0111 101' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VALE3
        when '100 1000 0111 110' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VMALLS12E1
        when '000 1000 0111 111' return <a href="shared_pseudocode.html#Sys_TLBI" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_TLBI</a>; // VAALE1
    return <a href="shared_pseudocode.html#Sys_SYS" title="enumeration SystemOp {Sys_AT, Sys_DC, Sys_IC, Sys_TLBI, Sys_SYS}">Sys_SYS</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.sysop.SystemOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/sysop/SystemOp</h3>
      <p class="pseudocode">enumeration <a id="SystemOp"/>SystemOp {<a id="Sys_AT"/>Sys_AT, <a id="Sys_DC"/>Sys_DC, <a id="Sys_IC"/>Sys_IC, <a id="Sys_TLBI"/>Sys_TLBI, <a id="Sys_SYS"/>Sys_SYS};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.DTLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.DTLBI_ALL</h3>
      <p class="pseudocode">// AArch32.DTLBI_ALL()
// ===================
// Invalidate all data TLB entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.

<a id="AArch32.DTLBI_ALL.4"/>AArch32.DTLBI_ALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_DALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.DTLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.DTLBI_ASID</h3>
      <p class="pseudocode">// AArch32.DTLBI_ASID()
// ====================
// Invalidate all data TLB stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.DTLBI_ASID.6"/>AArch32.DTLBI_ASID(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                   <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_DASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.DTLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.DTLBI_VA</h3>
      <p class="pseudocode">// AArch32.DTLBI_VA()
// ==================
// Invalidate by VA all stage 1 data TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.DTLBI_VA.7"/>AArch32.DTLBI_VA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level,  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_DVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DVA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.ITLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.ITLBI_ALL</h3>
      <p class="pseudocode">// AArch32.ITLBI_ALL()
// ===================
// Invalidate all instruction TLB entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.

<a id="AArch32.ITLBI_ALL.4"/>AArch32.ITLBI_ALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.ITLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.ITLBI_ASID</h3>
      <p class="pseudocode">// AArch32.ITLBI_ASID()
// ====================
// Invalidate all instruction TLB stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.ITLBI_ASID.6"/>AArch32.ITLBI_ASID(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                   <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.ITLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.ITLBI_VA</h3>
      <p class="pseudocode">// AArch32.ITLBI_VA()
// ==================
// Invalidate by VA all stage 1 instruction TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.ITLBI_VA.7"/>AArch32.ITLBI_VA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level,  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IVA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_ALL</h3>
      <p class="pseudocode">// AArch32.TLBI_ALL()
// ==================
// Invalidate all entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.TLBI_ALL.4"/>AArch32.TLBI_ALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_ALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_ASID</h3>
      <p class="pseudocode">// AArch32.TLBI_ASID()
// ===================
// Invalidate all stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Rt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.TLBI_ASID.6"/>AArch32.TLBI_ASID(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_ASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ASID</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_IPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_IPAS2</h3>
      <p class="pseudocode">// AArch32.TLBI_IPAS2()
// ====================
// Invalidate by IPA all stage 2 only TLB entries in the indicated shareability
// domain matching the indicated VMID in the indicated regime with the indicated security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// IPA and related parameters of the are derived from Rt.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.TLBI_IPAS2.7"/>AArch32.TLBI_IPAS2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};
    assert security == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IPAS2</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.address      = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24) : Rt&lt;27:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);
    r.ipaspace     = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VA</h3>
      <p class="pseudocode">// AArch32.TLBI_VA()
// =================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.TLBI_VA.7"/>AArch32.TLBI_VA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level,  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8) : Rt&lt;7:0&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VAA</h3>
      <p class="pseudocode">// AArch32.TLBI_VAA()
// ==================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID (where regime supports VMID) and all ASID in the indicated regime
// with the indicated security state.
// VA and related parameters are derived from Rt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.TLBI_VAA.7"/>AArch32.TLBI_VAA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr,  bits(32) Rt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VAA</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.address      = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) : Rt&lt;31:12&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VMALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VMALL</h3>
      <p class="pseudocode">// AArch32.TLBI_VMALL()
// ====================
// Invalidate all stage 1 entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability
// domain that match the indicated VMID (where applicable).
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// Note: stage 2 only entries are not in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.TLBI_VMALL.5"/>AArch32.TLBI_VMALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VMALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALL</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch32.TLBI_VMALLS12"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch32.TLBI_VMALLS12</h3>
      <p class="pseudocode">// AArch32.TLBI_VMALLS12()
// =======================
// Invalidate all stage 1 and stage 2 entries for the indicated translation
// regime with the indicated security state for all TLBs within the indicated
// shareability domain that match the indicated VMID.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch32.TLBI_VMALLS12.5"/>AArch32.TLBI_VMALLS12(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                      <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VMALLS12" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALLS12</a>;
    r.from_aarch64 = FALSE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_ALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_ALL</h3>
      <p class="pseudocode">// AArch64.TLBI_ALL()
// ==================
// Invalidate all entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability domain.
// Invalidation applies to all applicable stage 1 and stage 2 entries.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch64.TLBI_ALL.4"/>AArch64.TLBI_ALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_ALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ALL</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_ASID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_ASID</h3>
      <p class="pseudocode">// AArch64.TLBI_ASID()
// ===================
// Invalidate all stage 1 entries matching the indicated VMID (where regime supports)
// and ASID in the parameter Xt in the indicated translation regime with the
// indicated security state for all TLBs within the indicated shareability domain.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch64.TLBI_ASID.6"/>AArch64.TLBI_ASID(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability,
                  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_ASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ASID</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_IPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_IPAS2</h3>
      <p class="pseudocode">// AArch64.TLBI_IPAS2()
// ====================
// Invalidate by IPA all stage 2 only TLB entries in the indicated shareability
// domain matching the indicated VMID in the indicated regime with the indicated security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// IPA and related parameters of the are derived from Xt.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch64.TLBI_IPAS2.7"/>AArch64.TLBI_IPAS2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_IPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.address      = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(Xt&lt;39:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12));

    case security of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            r.ipaspace = if Xt&lt;63&gt; == '1' then <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> else <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
        otherwise
            // Root security state does not have stage 2 translation
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_PAALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_PAALL</h3>
      <p class="pseudocode">// AArch64.TLBI_PAALL()
// ====================
// TLB Invalidate ALL GPT Information.
// Invalidates cached copies of GPT entries from TLBs in the indicated
// Shareabilty domain.
// The invalidation applies to all TLB entries containing GPT information.

<a id="AArch64.TLBI_PAALL.1"/>AArch64.TLBI_PAALL(<a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability)
    assert <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;

    // r.security and r.regime do not apply for TLBI by PA operations
    r.op    = <a href="shared_pseudocode.html#TLBIOp_PAALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_PAALL</a>;
    r.level = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.attr  = <a href="shared_pseudocode.html#TLBI_AllAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBI_AllAttr</a>;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);

    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RIPAS2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RIPAS2</h3>
      <p class="pseudocode">// AArch64.TLBI_RIPAS2()
// =====================
// Range invalidate by IPA all stage 2 only TLB entries in the indicated
// shareability domain matching the indicated VMID in the indicated regime with the indicated
// security state.
// Note: stage 1 and stage 2 combined entries are not in the scope of this operation.
// The range of IPA and related parameters of the are derived from Xt.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch64.TLBI_RIPAS2.7"/>AArch64.TLBI_RIPAS2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                    <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_RIPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RIPAS2</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer baseaddr  = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(Xt&lt;36:0&gt;);

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#impl-aarch64.TLBIRange.2" title="function: (boolean, bits(2), bits(64), bits(64)) TLBIRange(Regime regime, bits(64) Xt)">TLBIRange</a>(regime, Xt);

    if !valid then return;

    case security of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            r.ipaspace = if Xt&lt;63&gt; == '1' then <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> else <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            r.ipaspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
        otherwise
            // Root security state does not have stage 2 translation
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RPA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RPA</h3>
      <p class="pseudocode">// AArch64.TLBI_RPA()
// ==================
// TLB Range Invalidate GPT Information by PA.
// Invalidates cached copies of GPT entries from TLBs in the indicated
// Shareabilty domain.
// The invalidation applies to TLB entries containing GPT information relating
// to the indicated physical address range.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries containing GPT information
//                      from all levels of the GPT walk
//     TLBILevel_Last : this applies to TLB entries containing GPT information
//                      from the last level of the GPT walk

<a id="AArch64.TLBI_RPA.3"/>AArch64.TLBI_RPA(<a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, bits(64) Xt, <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability)
    assert <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;

    // r.security and r.regime do not apply for TLBI by PA operations
    r.op    = <a href="shared_pseudocode.html#TLBIOp_RPA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RPA</a>;
    r.level = level;
    r.attr  = <a href="shared_pseudocode.html#TLBI_AllAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBI_AllAttr</a>;

    // SIZE field
    case Xt&lt;47:44&gt; of
        when '0000' range_bits = 12; // 4KB
        when '0001' range_bits = 14; // 16KB
        when '0010' range_bits = 16; // 64KB
        when '0011' range_bits = 21; // 2MB
        when '0100' range_bits = 25; // 32MB
        when '0101' range_bits = 29; // 512MB
        when '0110' range_bits = 30; // 1GB
        when '0111' range_bits = 34; // 16GB
        when '1000' range_bits = 36; // 64GB
        when '1001' range_bits = 39; // 512GB
        otherwise   range_bits = 0;  // Reserved encoding

    // If SIZE selects a range smaller than PGS, then PGS is used instead
    case <a href="shared_pseudocode.html#impl-shared.DecodePGS.1" title="function: PGSe DecodePGS(bits(2) pgs)">DecodePGS</a>(GPCCR_EL3.PGS) of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  p = 12;
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> p = 14;
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> p = 16;

    if range_bits &lt; p then
        range_bits = p;

    bits(52) BaseADDR = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(52);
    case GPCCR_EL3.PGS of
        when '00' BaseADDR&lt;51:12&gt; = Xt&lt;39:0&gt;;   // 4KB
        when '10' BaseADDR&lt;51:14&gt; = Xt&lt;39:2&gt;;   // 16KB
        when '01' BaseADDR&lt;51:16&gt; = Xt&lt;39:4&gt;;   // 64KB

    // The calculation here automatically aligns BaseADDR to the size of
    // the region specififed in SIZE. However, the architecture does not
    // require this alignment and if BaseADDR is not aligned to the region
    // specified by SIZE then no entries are required to be invalidated.
    bits(52) start_addr = BaseADDR AND NOT <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(range_bits), 52);
    bits(52) end_addr   = start_addr + <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(range_bits), 52);

    // PASpace is not considered in TLBI by PA operations
    r.address     = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(start_addr, 64);
    r.end_address = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(end_addr, 64);

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RVA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RVA</h3>
      <p class="pseudocode">// AArch64.TLBI_RVA()
// ==================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// shareability domain matching the indicated VMID and ASID (where regime
// supports VMID, ASID) in the indicated regime with the indicated security state.
// ASID, and range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch64.TLBI_RVA.7"/>AArch64.TLBI_RVA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64)  Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_RVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RVA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#impl-aarch64.TLBIRange.2" title="function: (boolean, bits(2), bits(64), bits(64)) TLBIRange(Regime regime, bits(64) Xt)">TLBIRange</a>(regime, Xt);

    if !valid then return;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_RVAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_RVAA</h3>
      <p class="pseudocode">// AArch64.TLBI_RVAA()
// ===================
// Range invalidate by VA range all stage 1 TLB entries in the indicated
// shareability domain matching the indicated VMID (where regimesupports VMID)
// and all ASID in the indicated regime with the indicated security state.
// VA range related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch64.TLBI_RVAA.7"/>AArch64.TLBI_RVAA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a>  regime, bits(16) vmid,
                  <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_RVAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RVAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer baseaddr  = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(Xt&lt;36:0&gt;);

    boolean valid;

    (valid, r.tg, r.address, r.end_address) = <a href="shared_pseudocode.html#impl-aarch64.TLBIRange.2" title="function: (boolean, bits(2), bits(64), bits(64)) TLBIRange(Regime regime, bits(64) Xt)">TLBIRange</a>(regime, Xt);

    if !valid then return;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VA</h3>
      <p class="pseudocode">// AArch64.TLBI_VA()
// =================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID and ASID (where regime supports VMID, ASID) in the indicated regime
// with the indicated security state.
// ASID, VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch64.TLBI_VA.7"/>AArch64.TLBI_VA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level,  <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr, bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.asid         = Xt&lt;63:48&gt;;
    r.address      = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(Xt&lt;43:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12));

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VAA"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VAA</h3>
      <p class="pseudocode">// AArch64.TLBI_VAA()
// ==================
// Invalidate by VA all stage 1 TLB entries in the indicated shareability domain
// matching the indicated VMID (where regime supports VMID) and all ASID in the indicated regime
// with the indicated security state.
// VA and related parameters are derived from Xt.
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// When the indicated level is
//     TLBILevel_Any  : this applies to TLB entries at all levels
//     TLBILevel_Last : this applies to TLB entries at last level only
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch64.TLBI_VAA.7"/>AArch64.TLBI_VAA(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                 <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a> level, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr,  bits(64) Xt)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VAA</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.vmid         = vmid;
    r.level        = level;
    r.attr         = attr;
    r.address      = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(Xt&lt;43:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12));

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VMALL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VMALL</h3>
      <p class="pseudocode">// AArch64.TLBI_VMALL()
// ====================
// Invalidate all stage 1 entries for the indicated translation regime with the
// the indicated security state for all TLBs within the indicated shareability
// domain that match the indicated VMID (where applicable).
// Note: stage 1 and stage 2 combined entries are in the scope of this operation.
// Note: stage 2 only entries are not in the scope of this operation.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch64.TLBI_VMALL.5"/>AArch64.TLBI_VMALL(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                   <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VMALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALL</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.AArch64.TLBI_VMALLS12"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/AArch64.TLBI_VMALLS12</h3>
      <p class="pseudocode">// AArch64.TLBI_VMALLS12()
// =======================
// Invalidate all stage 1 and stage 2 entries for the indicated translation
// regime with the indicated security state for all TLBs within the indicated
// shareability domain that match the indicated VMID.
// The indicated attr defines the attributes of the memory operations that must be completed in
// order to deem this operation to be completed.
// When attr is TLBI_ExcludeXS, only operations with XS=0 within the scope of this TLB operation
// are required to complete.

<a id="AArch64.TLBI_VMALLS12.5"/>AArch64.TLBI_VMALLS12(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(16) vmid,
                      <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a> attr)
    assert PSTATE.EL IN {<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>};

    <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r;
    r.op           = <a href="shared_pseudocode.html#TLBIOp_VMALLS12" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALLS12</a>;
    r.from_aarch64 = TRUE;
    r.security     = security;
    r.regime       = regime;
    r.level        = <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a>;
    r.vmid         = vmid;
    r.attr         = attr;

    <a href="shared_pseudocode.html#impl-aarch64.TLBI.1" title="function: TLBI(TLBIRecord r)">TLBI</a>(r);
    if shareability != <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> then <a href="shared_pseudocode.html#impl-aarch64.Broadcast.2" title="function: Broadcast(Shareability shareability, TLBIRecord r)">Broadcast</a>(shareability, r);
    return;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.ASID_NONE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/ASID_NONE</h3>
      <p class="pseudocode">constant bits(16) <a id="ASID_NONE"/>ASID_NONE = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.Broadcast"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/Broadcast</h3>
      <p class="pseudocode">// Broadcast()
// ===========
// IMPLEMENTATION DEFINED function to broadcast TLBI operation within the indicated shareability
// domain.

<a id="impl-aarch64.Broadcast.2"/>Broadcast(<a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, <a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r)
    IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.DecodeTLBITG"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/DecodeTLBITG</h3>
      <p class="pseudocode">// DecodeTLBITG()
// ==============
// Decode translation granule size in TLBI range instructions

TGx <a id="impl-aarch64.DecodeTLBITG.1"/>DecodeTLBITG(bits(2) tg)
    case tg of
        when '01'   return <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
        when '10'   return <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;
        when '11'   return <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.HasLargeAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/HasLargeAddress</h3>
      <p class="pseudocode">// HasLargeAddress()
// =================
// Returns TRUE if the regime is configured for 52 bit addresses, FALSE otherwise.

boolean <a id="impl-aarch64.HasLargeAddress.1"/>HasLargeAddress(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    if !<a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        return FALSE;
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>
            return TCR_EL3&lt;32&gt; == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>
            return TCR_EL2&lt;32&gt; == '1';
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>
            return TCR_EL2&lt;59&gt; == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>
            return TCR_EL1&lt;59&gt; == '1';
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.SecurityStateAtEL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/SecurityStateAtEL</h3>
      <p class="pseudocode">// SecurityStateAtEL()
// ===================
// Returns the effective security state at the exception level based off current settings.

SecurityState <a id="impl-aarch64.SecurityStateAtEL.1"/>SecurityStateAtEL(bits(2) EL)
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        if EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then return <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>;
        case SCR_EL3.&lt;NSE, NS&gt; of
            when '00' return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
            when '01' return <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
            when '11' return <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>;
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if boolean IMPLEMENTATION_DEFINED "Secure-only implementation" then
            return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
        else
            return <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    elsif EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
    else
        // For EL2 call only when EL2 is enabled in current security state
        assert(EL != <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>());
        if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            return if SCR_EL3.NS == '1' then <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> else <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
        else
            return if SCR.NS == '1' then <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> else <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBI"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBI</h3>
      <p class="pseudocode">// TLBI()
// ======
// Performs TLB maintenance of operation on TLB to invalidate the matching transition table entries.

<a id="impl-aarch64.TLBI.1"/>TLBI(<a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> r)
    IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBILevel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBILevel</h3>
      <p class="pseudocode">enumeration <a id="TLBILevel"/>TLBILevel {
    <a id="TLBILevel_Any"/>TLBILevel_Any,
    <a id="TLBILevel_Last"/>TLBILevel_Last
};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIMatch"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIMatch</h3>
      <p class="pseudocode">// TLBIMatch()
// ===========
// Determine whether the TLB entry lies within the scope of inavlidation

boolean <a id="impl-aarch64.TLBIMatch.2"/>TLBIMatch(<a href="shared_pseudocode.html#TLBIRecord" title="type TLBIRecord is ( TLBIOp op, boolean from_aarch64, SecurityState security, Regime regime, bits(16) vmid, bits(16) asid, TLBILevel level, TLBIMemAttr attr, PASpace ipaspace, bits(64) address, bits(64) end_address, bits(2) tg, )">TLBIRecord</a> tlbi, <a href="shared_pseudocode.html#TLBRecord" title="type TLBRecord is ( TLBContext context, TTWState walkstate, integer blocksize, integer contigsize, bits(64) s1descriptor, bits(64) s2descriptor )">TLBRecord</a> entry)
    case tlbi.op of
        when <a href="shared_pseudocode.html#TLBIOp_DALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DALL</a>, <a href="shared_pseudocode.html#TLBIOp_IALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IALL</a>
            match = (tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime);
        when <a href="shared_pseudocode.html#TLBIOp_DASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DASID</a>, <a href="shared_pseudocode.html#TLBIOp_IASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IASID</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (<a href="shared_pseudocode.html#impl-shared.UseASID.1" title="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) &amp;&amp; entry.context.nG == '1' &amp;&amp;
                        tlbi.asid  == entry.context.asid));
        when <a href="shared_pseudocode.html#TLBIOp_DVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_DVA</a>, <a href="shared_pseudocode.html#TLBIOp_IVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IVA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseASID.1" title="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) || tlbi.asid == entry.context.asid ||
                        entry.context.nG == '0') &amp;&amp;
                     tlbi.address&lt;55:entry.blocksize&gt; == entry.context.ia&lt;55:entry.blocksize&gt; &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a href="shared_pseudocode.html#TLBIOp_ALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ALL</a>
            relax_regime = (tlbi.from_aarch64 &amp;&amp;
                            tlbi.regime IN {<a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>, <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>} &amp;&amp;
                            entry.context.regime IN {<a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>, <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>});
            match = (tlbi.security == entry.context.ss &amp;&amp;
                     (tlbi.regime  == entry.context.regime || relax_regime));
        when <a href="shared_pseudocode.html#TLBIOp_ASID" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_ASID</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (<a href="shared_pseudocode.html#impl-shared.UseASID.1" title="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) &amp;&amp; entry.context.nG == '1' &amp;&amp;
                        tlbi.asid  == entry.context.asid));
        when <a href="shared_pseudocode.html#TLBIOp_IPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_IPAS2</a>
            match = (!entry.context.includes_s1 &amp;&amp; entry.context.includes_s2 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     tlbi.ipaspace == entry.context.ipaspace &amp;&amp;
                     tlbi.address&lt;51:entry.blocksize&gt; == entry.context.ia&lt;51:entry.blocksize&gt; &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a href="shared_pseudocode.html#TLBIOp_VAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VAA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     tlbi.address&lt;55:entry.blocksize&gt; == entry.context.ia&lt;55:entry.blocksize&gt; &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a href="shared_pseudocode.html#TLBIOp_VA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseASID.1" title="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) || tlbi.asid == entry.context.asid ||
                        entry.context.nG == '0') &amp;&amp;
                     tlbi.address&lt;55:entry.blocksize&gt; == entry.context.ia&lt;55:entry.blocksize&gt; &amp;&amp;
                     (tlbi.level == <a href="shared_pseudocode.html#TLBILevel_Any" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel_Any</a> || !entry.walkstate.istable));
        when <a href="shared_pseudocode.html#TLBIOp_VMALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALL</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid));
        when <a href="shared_pseudocode.html#TLBIOp_VMALLS12" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_VMALLS12</a>
            match = (tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid));
        when <a href="shared_pseudocode.html#TLBIOp_RIPAS2" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RIPAS2</a>
            match = (!entry.context.includes_s1 &amp;&amp; entry.context.includes_s2 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     tlbi.ipaspace == entry.context.ipaspace &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.DecodeTLBITG.1" title="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.tg) == entry.context.tg) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia));
        when <a href="shared_pseudocode.html#TLBIOp_RVAA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RVAA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.DecodeTLBITG.1" title="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.tg) == entry.context.tg) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia));
        when <a href="shared_pseudocode.html#TLBIOp_RVA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RVA</a>
            match = (entry.context.includes_s1 &amp;&amp;
                     tlbi.security == entry.context.ss &amp;&amp;
                     tlbi.regime   == entry.context.regime &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseVMID.1" title="function: boolean UseVMID(TLBContext access)">UseVMID</a>(entry.context) || tlbi.vmid == entry.context.vmid) &amp;&amp;
                     (!<a href="shared_pseudocode.html#impl-shared.UseASID.1" title="function: boolean UseASID(TLBContext access)">UseASID</a>(entry.context) || tlbi.asid == entry.context.asid ||
                        entry.context.nG == '0') &amp;&amp;
                     (tlbi.tg != '00' &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.DecodeTLBITG.1" title="function: TGx DecodeTLBITG(bits(2) tg)">DecodeTLBITG</a>(tlbi.tg) == entry.context.tg) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.context.ia));
        when <a href="shared_pseudocode.html#TLBIOp_RPA" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_RPA</a>
            match = (entry.context.includes_gpt &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.address)     &lt;= <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.walkstate.baseaddress.address) &amp;&amp;
                     <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(tlbi.end_address) &gt;  <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(entry.walkstate.baseaddress.address));
        when <a href="shared_pseudocode.html#TLBIOp_PAALL" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp_PAALL</a>
            match = entry.context.includes_gpt;

    if tlbi.attr == <a href="shared_pseudocode.html#TLBI_ExcludeXS" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBI_ExcludeXS</a> &amp;&amp; entry.context.xs == '1' then
        match = FALSE;

    return match;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIMemAttr"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIMemAttr</h3>
      <p class="pseudocode">enumeration <a id="TLBIMemAttr"/>TLBIMemAttr {
    <a id="TLBI_AllAttr"/>TLBI_AllAttr,
    <a id="TLBI_ExcludeXS"/>TLBI_ExcludeXS
};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIOp</h3>
      <p class="pseudocode">enumeration <a id="TLBIOp"/>TLBIOp {
    <a id="TLBIOp_DALL"/>TLBIOp_DALL,          // AArch32 Data TLBI operations - deprecated
    <a id="TLBIOp_DASID"/>TLBIOp_DASID,
    <a id="TLBIOp_DVA"/>TLBIOp_DVA,
    <a id="TLBIOp_IALL"/>TLBIOp_IALL,          // AArch32 Instruction TLBI operations - deprecated
    <a id="TLBIOp_IASID"/>TLBIOp_IASID,
    <a id="TLBIOp_IVA"/>TLBIOp_IVA,
    <a id="TLBIOp_ALL"/>TLBIOp_ALL,
    <a id="TLBIOp_ASID"/>TLBIOp_ASID,
    <a id="TLBIOp_IPAS2"/>TLBIOp_IPAS2,
    <a id="TLBIOp_VAA"/>TLBIOp_VAA,
    <a id="TLBIOp_VA"/>TLBIOp_VA,
    <a id="TLBIOp_VMALL"/>TLBIOp_VMALL,
    <a id="TLBIOp_VMALLS12"/>TLBIOp_VMALLS12,
    <a id="TLBIOp_RIPAS2"/>TLBIOp_RIPAS2,
    <a id="TLBIOp_RVAA"/>TLBIOp_RVAA,
    <a id="TLBIOp_RVA"/>TLBIOp_RVA,
    <a id="TLBIOp_RPA"/>TLBIOp_RPA,
    <a id="TLBIOp_PAALL"/>TLBIOp_PAALL,
};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIRange</h3>
      <p class="pseudocode">// TLBIRange()
// ===========
// Extract the input address range information from encoded Xt.

(boolean, bits(2), bits(64), bits(64)) <a id="impl-aarch64.TLBIRange.2"/>TLBIRange(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) Xt)
    boolean  valid = TRUE;
    bits(64) start = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    bits(64) end   = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

    bits(2) tg        = Xt&lt;47:46&gt;;
    integer scale     = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;45:44&gt;);
    integer num       = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt&lt;43:39&gt;);
    integer tg_bits;

    if tg == '00' then
        return (FALSE, tg, start, end);

    case tg of
        when '01' // 4KB
            tg_bits = 12;
            if <a href="shared_pseudocode.html#impl-aarch64.HasLargeAddress.1" title="function: boolean HasLargeAddress(Regime regime)">HasLargeAddress</a>(regime) then
                start&lt;52:16&gt; = Xt&lt;36:0&gt;;
                start&lt;63:53&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 11);
            else
                start&lt;48:12&gt; = Xt&lt;36:0&gt;;
                start&lt;63:49&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 15);
        when '10' // 16KB
            tg_bits = 14;
            if <a href="shared_pseudocode.html#impl-aarch64.HasLargeAddress.1" title="function: boolean HasLargeAddress(Regime regime)">HasLargeAddress</a>(regime) then
                start&lt;52:16&gt; = Xt&lt;36:0&gt;;
                start&lt;63:53&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 11);
            else
                start&lt;50:14&gt; = Xt&lt;36:0&gt;;
                start&lt;63:51&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 13);
        when '11' // 64KB
            tg_bits = 16;
            start&lt;52:16&gt; = Xt&lt;36:0&gt;;
            start&lt;63:53&gt; = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(Xt&lt;36&gt;, 11);
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    integer range = (num+1) &lt;&lt; (5*scale + 1 + tg_bits);
    end   = start + range&lt;63:0&gt;;

    if end&lt;52&gt; != start&lt;52&gt; then
        // overflow, saturate it
        end = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(start&lt;52&gt;, 64-52) : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(52);

    return (valid, tg, start, end);</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.TLBIRecord"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/TLBIRecord</h3>
      <p class="pseudocode">type <a id="TLBIRecord"/>TLBIRecord is (
    <a href="shared_pseudocode.html#TLBIOp" title="enumeration TLBIOp {&#13; TLBIOp_DALL, TLBIOp_DASID,&#13; TLBIOp_DVA,&#13; TLBIOp_IALL, TLBIOp_IASID,&#13; TLBIOp_IVA,&#13; TLBIOp_ALL,&#13; TLBIOp_ASID,&#13; TLBIOp_IPAS2,&#13; TLBIOp_VAA,&#13; TLBIOp_VA,&#13; TLBIOp_VMALL,&#13; TLBIOp_VMALLS12,&#13; TLBIOp_RIPAS2,&#13; TLBIOp_RVAA,&#13; TLBIOp_RVA,&#13; TLBIOp_RPA,&#13; TLBIOp_PAALL,&#13; }">TLBIOp</a>          op,
    boolean         from_aarch64, // originated as an AArch64 operation
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a>   security,
    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a>          regime,
    bits(16)        vmid,
    bits(16)        asid,
    <a href="shared_pseudocode.html#TLBILevel" title="enumeration TLBILevel {&#13; TLBILevel_Any,&#13; TLBILevel_Last&#13; }">TLBILevel</a>       level,
    <a href="shared_pseudocode.html#TLBIMemAttr" title="enumeration TLBIMemAttr {&#13; TLBI_AllAttr,&#13; TLBI_ExcludeXS&#13; }">TLBIMemAttr</a>     attr,
    <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a>         ipaspace,     // For operations that take IPA as input address
    bits(64)        address,      // input address, for range operations, start address
    bits(64)        end_address,  // for range operations, end address
    bits(2)         tg,           // for range operations, translation granule
)</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.VMID"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/VMID</h3>
      <p class="pseudocode">// VMID[]
// ======
// Effective VMID.

bits(16) <a id="impl-aarch64.VMID.read.0"/>VMID[]
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            if <a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()">Have16bitVMID</a>() &amp;&amp; VTCR_EL2.VS == '1' then
                return VTTBR_EL2.VMID;
            else
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
        else
            return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() then
        return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    else
        return <a href="shared_pseudocode.html#VMID_NONE" title="constant bits(16) VMID_NONE = Zeros()">VMID_NONE</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.system.sysops.tlbi.VMID_NONE"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/system/sysops/tlbi/VMID_NONE</h3>
      <p class="pseudocode">constant bits(16) <a id="VMID_NONE"/>VMID_NONE = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.vector.arithmetic.binary.uniform.logical.bsl-eor.vbitop.VBitOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor/vbitop/VBitOp</h3>
      <p class="pseudocode">enumeration <a id="VBitOp"/>VBitOp      {<a id="VBitOp_VBIF"/>VBitOp_VBIF, <a id="VBitOp_VBIT"/>VBitOp_VBIT, <a id="VBitOp_VBSL"/>VBitOp_VBSL, <a id="VBitOp_VEOR"/>VBitOp_VEOR};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.vector.arithmetic.unary.cmp.compareop.CompareOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/vector/arithmetic/unary/cmp/compareop/CompareOp</h3>
      <p class="pseudocode">enumeration <a id="CompareOp"/>CompareOp   {<a id="CompareOp_GT"/>CompareOp_GT, <a id="CompareOp_GE"/>CompareOp_GE, <a id="CompareOp_EQ"/>CompareOp_EQ,
                         <a id="CompareOp_LE"/>CompareOp_LE, <a id="CompareOp_LT"/>CompareOp_LT};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.vector.logical.immediateop.ImmediateOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/vector/logical/immediateop/ImmediateOp</h3>
      <p class="pseudocode">enumeration <a id="ImmediateOp"/>ImmediateOp {<a id="ImmediateOp_MOVI"/>ImmediateOp_MOVI, <a id="ImmediateOp_MVNI"/>ImmediateOp_MVNI,
                         <a id="ImmediateOp_ORR"/>ImmediateOp_ORR, <a id="ImmediateOp_BIC"/>ImmediateOp_BIC};</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.vector.reduce.reduceop.Reduce"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/vector/reduce/reduceop/Reduce</h3>
      <p class="pseudocode">// Reduce()
// ========

bits(esize) <a id="impl-aarch64.Reduce.3"/>Reduce(<a href="shared_pseudocode.html#ReduceOp" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp</a> op, bits(N) input, integer esize)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; FPCR.AH == '1';
    return <a href="shared_pseudocode.html#impl-aarch64.Reduce.4" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)">Reduce</a>(op, input, esize, altfp);

// Reduce()
// ========
// Perform the operation 'op' on pairs of elements from the input vector,
// reducing the vector to a scalar result. The 'altfp' argument controls
// alternative floating-point behaviour.

bits(esize) <a id="impl-aarch64.Reduce.4"/>Reduce(<a href="shared_pseudocode.html#ReduceOp" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp</a> op, bits(N) input, integer esize, boolean altfp)
    integer half;
    bits(esize) hi;
    bits(esize) lo;
    bits(esize) result;

    if N == esize then
        return input&lt;esize-1:0&gt;;

    half = N DIV 2;
    hi = <a href="shared_pseudocode.html#impl-aarch64.Reduce.4" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)">Reduce</a>(op, input&lt;N-1:half&gt;, esize, altfp);
    lo = <a href="shared_pseudocode.html#impl-aarch64.Reduce.4" title="function: bits(esize) Reduce(ReduceOp op, bits(N) input, integer esize, boolean altfp)">Reduce</a>(op, input&lt;half-1:0&gt;, esize, altfp);

    case op of
        when <a href="shared_pseudocode.html#ReduceOp_FMINNUM" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMINNUM</a>
            result = <a href="shared_pseudocode.html#impl-shared.FPMinNum.3" title="function: bits(N) FPMinNum(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMinNum</a>(lo, hi, FPCR[]);
        when <a href="shared_pseudocode.html#ReduceOp_FMAXNUM" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMAXNUM</a>
            result = <a href="shared_pseudocode.html#impl-shared.FPMaxNum.3" title="function: bits(N) FPMaxNum(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMaxNum</a>(lo, hi, FPCR[]);
        when <a href="shared_pseudocode.html#ReduceOp_FMIN" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMIN</a>
            result = <a href="shared_pseudocode.html#impl-shared.FPMin.4" title="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean altfp)">FPMin</a>(lo, hi, FPCR[], altfp);
        when <a href="shared_pseudocode.html#ReduceOp_FMAX" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FMAX</a>
            result = <a href="shared_pseudocode.html#impl-shared.FPMax.4" title="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean altfp)">FPMax</a>(lo, hi, FPCR[], altfp);
        when <a href="shared_pseudocode.html#ReduceOp_FADD" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_FADD</a>
            result = <a href="shared_pseudocode.html#impl-shared.FPAdd.3" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPAdd</a>(lo, hi, FPCR[]);
        when <a href="shared_pseudocode.html#ReduceOp_ADD" title="enumeration ReduceOp {ReduceOp_FMINNUM, ReduceOp_FMAXNUM,&#13; ReduceOp_FMIN, ReduceOp_FMAX,&#13; ReduceOp_FADD, ReduceOp_ADD}">ReduceOp_ADD</a>
            result = lo + hi;

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.instrs.vector.reduce.reduceop.ReduceOp"/><h3 class="pseudocode">
            Library pseudocode for aarch64/instrs/vector/reduce/reduceop/ReduceOp</h3>
      <p class="pseudocode">enumeration <a id="ReduceOp"/>ReduceOp {<a id="ReduceOp_FMINNUM"/>ReduceOp_FMINNUM, <a id="ReduceOp_FMAXNUM"/>ReduceOp_FMAXNUM,
                      <a id="ReduceOp_FMIN"/>ReduceOp_FMIN, <a id="ReduceOp_FMAX"/>ReduceOp_FMAX,
                      <a id="ReduceOp_FADD"/>ReduceOp_FADD, <a id="ReduceOp_ADD"/>ReduceOp_ADD};</p>
    </div>
    <div class="ps"><a id="aarch64.translation.debug.AArch64.CheckBreakpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/debug/AArch64.CheckBreakpoint</h3>
      <p class="pseudocode">// AArch64.CheckBreakpoint()
// =========================
// Called before executing the instruction of length "size" bytes at "vaddress" in an AArch64
// translation regime, when either debug exceptions are enabled, or halting debug is enabled
// and halting is allowed.

FaultRecord <a id="AArch64.CheckBreakpoint.3"/>AArch64.CheckBreakpoint(bits(64) vaddress, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, integer size)
    assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());
    assert (<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; size IN {2,4}) || size == 4;

    match = FALSE;

    for i = 0 to <a href="shared_pseudocode.html#impl-shared.NumBreakpointsImplemented.0" title="function: integer NumBreakpointsImplemented()">NumBreakpointsImplemented</a>() - 1
        match_i = <a href="shared_pseudocode.html#AArch64.BreakpointMatch.4" title="function: boolean AArch64.BreakpointMatch(integer n, bits(64) vaddress,&#13; AccType acctype, integer size)">AArch64.BreakpointMatch</a>(i, vaddress, acctype, size);
        match = match || match_i;

    if match &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        reason = <a href="shared_pseudocode.html#DebugHalt_Breakpoint" title="constant bits(6) DebugHalt_Breakpoint = '000111'">DebugHalt_Breakpoint</a>;
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(reason);
    elsif match then
        acctype = <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>;
        iswrite = FALSE;
        return <a href="shared_pseudocode.html#AArch64.DebugFault.2" title="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)">AArch64.DebugFault</a>(acctype, iswrite);
    else
        return <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.translation.debug.AArch64.CheckDebug"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/debug/AArch64.CheckDebug</h3>
      <p class="pseudocode">// AArch64.CheckDebug()
// ====================
// Called on each access to check for a debug exception or entry to Debug state.

FaultRecord <a id="AArch64.CheckDebug.4"/>AArch64.CheckDebug(bits(64) vaddress, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, integer size)

    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();

    d_side = (acctype != <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>);
    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        mask = '0';
        generate_exception = <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>(), mask) &amp;&amp; MDSCR_EL1.MDE == '1';
    else
        generate_exception = <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()">AArch64.GenerateDebugExceptions</a>() &amp;&amp; MDSCR_EL1.MDE == '1';
    halt = <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>();

    if generate_exception || halt then
        if d_side then
            fault = <a href="shared_pseudocode.html#AArch64.CheckWatchpoint.4" title="function: FaultRecord AArch64.CheckWatchpoint(bits(64) vaddress, AccType acctype,&#13; boolean iswrite, integer size)">AArch64.CheckWatchpoint</a>(vaddress, acctype, iswrite, size);
        else
            fault = <a href="shared_pseudocode.html#AArch64.CheckBreakpoint.3" title="function: FaultRecord AArch64.CheckBreakpoint(bits(64) vaddress, AccType acctype, integer size)">AArch64.CheckBreakpoint</a>(vaddress, acctype, size);

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.debug.AArch64.CheckWatchpoint"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/debug/AArch64.CheckWatchpoint</h3>
      <p class="pseudocode">// AArch64.CheckWatchpoint()
// =========================
// Called before accessing the memory location of "size" bytes at "address",
// when either debug exceptions are enabled for the access, or halting debug
// is enabled and halting is allowed.

FaultRecord <a id="AArch64.CheckWatchpoint.4"/>AArch64.CheckWatchpoint(bits(64) vaddress, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                    boolean iswrite, integer size)
    assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.0" title="function: bits(2) S1TranslationRegime()">S1TranslationRegime</a>());

    if acctype IN {<a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>} then
        return <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
    if acctype == <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a> then
        if !iswrite then
            return <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();

    match = FALSE;
    match_on_read = FALSE;
    ispriv = <a href="shared_pseudocode.html#AArch64.AccessUsesEL.1" title="function: bits(2) AArch64.AccessUsesEL(AccType acctype)">AArch64.AccessUsesEL</a>(acctype) != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;

    for i = 0 to <a href="shared_pseudocode.html#impl-shared.NumWatchpointsImplemented.0" title="function: integer NumWatchpointsImplemented()">NumWatchpointsImplemented</a>() - 1
        if <a href="shared_pseudocode.html#AArch64.WatchpointMatch.6" title="function: boolean AArch64.WatchpointMatch(integer n, bits(64) vaddress, integer size, boolean ispriv,&#13; AccType acctype, boolean iswrite)">AArch64.WatchpointMatch</a>(i, vaddress, size, ispriv, acctype, iswrite) then
            match = TRUE;
            if DBGWCR_EL1[i].LSC&lt;0&gt; == '1' then
                match_on_read = TRUE;

    if match &amp;&amp; acctype == <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a> then
        iswrite = !match_on_read;

    if match &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltOnBreakpointOrWatchpoint.0" title="function: boolean HaltOnBreakpointOrWatchpoint()">HaltOnBreakpointOrWatchpoint</a>() then
        if acctype != <a href="shared_pseudocode.html#AccType_NONFAULT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NONFAULT</a> &amp;&amp; acctype != <a href="shared_pseudocode.html#AccType_CNOTFIRST" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_CNOTFIRST</a> then
            reason = <a href="shared_pseudocode.html#DebugHalt_Watchpoint" title="constant bits(6) DebugHalt_Watchpoint = '101011'">DebugHalt_Watchpoint</a>;
            EDWAR = vaddress;
            <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(reason);
        else
            // Fault will be reported and cancelled
            return <a href="shared_pseudocode.html#AArch64.DebugFault.2" title="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)">AArch64.DebugFault</a>(acctype, iswrite);
    elsif match then
        return <a href="shared_pseudocode.html#AArch64.DebugFault.2" title="function: FaultRecord AArch64.DebugFault(AccType acctype, boolean iswrite)">AArch64.DebugFault</a>(acctype, iswrite);
    else
        return <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.BlockBase"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.BlockBase</h3>
      <p class="pseudocode">// AArch64.BlockBase()
// ===================
// Extract the address embedded in a block descriptor pointing to the base of
// a memory block

bits(52) <a id="AArch64.BlockBase.4"/>AArch64.BlockBase(bits(64) descriptor, bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    bits(52) blockbase = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    if tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; level == 2 then
        blockbase&lt;47:21&gt; = descriptor&lt;47:21&gt;;
    elsif tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; level == 1 then
        blockbase&lt;47:30&gt; = descriptor&lt;47:30&gt;;
    elsif tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; level == 0 then
        blockbase&lt;47:39&gt; = descriptor&lt;47:39&gt;;
    elsif tgx == <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> &amp;&amp; level == 2 then
        blockbase&lt;47:25&gt; = descriptor&lt;47:25&gt;;
    elsif tgx == <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> &amp;&amp; level == 1 then
        blockbase&lt;47:36&gt; = descriptor&lt;47:36&gt;;
    elsif tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; level == 2 then
        blockbase&lt;47:29&gt; = descriptor&lt;47:29&gt;;
    elsif tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; level == 1 then
        blockbase&lt;47:42&gt; = descriptor&lt;47:42&gt;;
    else
        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    if <a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> then
        blockbase&lt;51:48&gt; = descriptor&lt;15:12&gt;;
    elsif ds == '1' then
        blockbase&lt;51:48&gt; = descriptor&lt;9:8&gt;:descriptor&lt;49:48&gt;;

    return blockbase;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.IASize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.IASize</h3>
      <p class="pseudocode">// AArch64.IASize()
// ================
// Retrieve the number of bits containing the input address

integer <a id="AArch64.IASize.1"/>AArch64.IASize(bits(6) txsz)
    return 64 - <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(txsz);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.NextTableBase"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.NextTableBase</h3>
      <p class="pseudocode">// AArch64.NextTableBase()
// =======================
// Extract the address embedded in a table descriptor pointing to the base of
// the next level table of descriptors

bits(52) <a id="AArch64.NextTableBase.3"/>AArch64.NextTableBase(bits(64) descriptor, bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    bits(52) tablebase = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    case tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  tablebase&lt;47:12&gt; = descriptor&lt;47:12&gt;;
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> tablebase&lt;47:14&gt; = descriptor&lt;47:14&gt;;
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> tablebase&lt;47:16&gt; = descriptor&lt;47:16&gt;;

    if <a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> then
        tablebase&lt;51:48&gt; = descriptor&lt;15:12&gt;;
    elsif ds == '1' then
        tablebase&lt;51:48&gt; = descriptor&lt;9:8&gt;:descriptor&lt;49:48&gt;;

    return tablebase;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.PageBase"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.PageBase</h3>
      <p class="pseudocode">// AArch64.PageBase()
// ==================
// Extract the address embedded in a page descriptor pointing to the base of
// a memory page

bits(52) <a id="AArch64.PageBase.3"/>AArch64.PageBase(bits(64) descriptor, bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    bits(52) pagebase = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    case tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  pagebase&lt;47:12&gt; = descriptor&lt;47:12&gt;;
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> pagebase&lt;47:14&gt; = descriptor&lt;47:14&gt;;
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> pagebase&lt;47:16&gt; = descriptor&lt;47:16&gt;;

    if <a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> then
        pagebase&lt;51:48&gt; = descriptor&lt;15:12&gt;;
    elsif ds == '1' then
        pagebase&lt;51:48&gt; = descriptor&lt;9:8&gt;:descriptor&lt;49:48&gt;;

    return pagebase;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.PhysicalAddressSize"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.PhysicalAddressSize</h3>
      <p class="pseudocode">// AArch64.PhysicalAddressSize()
// =============================
// Retrieve the number of bits bounding the physical address

integer <a id="AArch64.PhysicalAddressSize.2"/>AArch64.PhysicalAddressSize(bits(3) encoded_ps, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    integer ps;

    case encoded_ps of
        when '000'  ps = 32;
        when '001'  ps = 36;
        when '010'  ps = 40;
        when '011'  ps = 42;
        when '100'  ps = 44;
        when '101'  ps = 48;
        when '110'  ps = 52;
        otherwise
            ps = integer IMPLEMENTATION_DEFINED "Reserved Intermediate Physical Address size value";

    if tgx != <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        max_ps = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(48, <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>());
    else
        max_ps = <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>();

    return <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(ps, max_ps);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.S1StartLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.S1StartLevel</h3>
      <p class="pseudocode">// AArch64.S1StartLevel()
// ======================
// Compute the initial lookup level when performing a stage 1 translation
// table walk

integer <a id="AArch64.S1StartLevel.1"/>AArch64.S1StartLevel(<a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams)
    // Input Address size
    iasize   = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;

    return <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - (((iasize-1) - granulebits) DIV stride);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.S2SLTTEntryAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.S2SLTTEntryAddress</h3>
      <p class="pseudocode">// AArch64.S2SLTTEntryAddress()
// ============================
// Compute the first stage 2 translation table descriptor address within the
// table pointed to by the base at the start level

FullAddress <a id="AArch64.S2SLTTEntryAddress.3"/>AArch64.S2SLTTEntryAddress(<a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, bits(52) ipa,
                                       <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase)
    startlevel  = <a href="shared_pseudocode.html#AArch64.S2StartLevel.1" title="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</a>(walkparams);
    iasize      = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;

    bits(52) index;
    lsb   = levels*stride + granulebits;
    msb   = iasize - 1;
    index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ipa&lt;msb:lsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(3));

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> descaddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.S2StartLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.S2StartLevel</h3>
      <p class="pseudocode">// AArch64.S2StartLevel()
// ======================
// Determine the initial lookup level when performing a stage 2 translation
// table walk

integer <a id="AArch64.S2StartLevel.1"/>AArch64.S2StartLevel(<a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    case walkparams.tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>
            case walkparams.sl2:walkparams.sl0 of
                when '000' return 2;
                when '001' return 1;
                when '010' return 0;
                when '011' return 3;
                when '100' return -1;
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>
            case walkparams.sl0 of
                when '00' return 3;
                when '01' return 2;
                when '10' return 1;
                when '11' return 0;
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>
            case walkparams.sl0 of
                when '00' return 3;
                when '01' return 2;
                when '10' return 1;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.TTBaseAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.TTBaseAddress</h3>
      <p class="pseudocode">// AArch64.TTBaseAddress()
// =======================
// Retrieve the PA/IPA pointing to the base of the initial translation table

bits(52) <a id="AArch64.TTBaseAddress.6"/>AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,
                                   bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer startlevel)
    bits(52) tablebase = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    // Input Address size
    iasize      = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(txsz);
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(tgx);
    stride      = granulebits - 3;
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;

    // Base address is aligned to size of the initial translation table in bytes
    tsize = iasize - (levels*stride + granulebits) + 3;

    if (<a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; ps == '110') || (ds == '1') then
        tsize = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>(tsize, 6);
        tablebase&lt;51:6&gt; = ttb&lt;5:2&gt;:ttb&lt;47:6&gt;;
    else
        tablebase&lt;47:1&gt; = ttb&lt;47:1&gt;;

    tablebase = <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(tablebase, 1 &lt;&lt; tsize);
    return tablebase;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_addrcalc.AArch64.TTEntryAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_addrcalc/AArch64.TTEntryAddress</h3>
      <p class="pseudocode">// AArch64.TTEntryAddress()
// ========================
// Compute translation table descriptor address within the table pointed to by
// the table base

FullAddress <a id="AArch64.TTEntryAddress.5"/>AArch64.TTEntryAddress(integer level, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, bits(6) txsz,
                                   bits(64) ia, <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase)
    // Input Address size
    iasize      = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(txsz);
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(tgx);
    stride      = granulebits - 3;
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - level;

    bits(52) index;
    lsb   = levels*stride + granulebits;
    msb   = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(iasize - 1, lsb + stride - 1);
    index = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ia&lt;msb:lsb&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(3));

    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> descaddress;
    descaddress.address = tablebase.address OR index;
    descaddress.paspace = tablebase.paspace;

    return descaddress;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.AddrTop"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.AddrTop</h3>
      <p class="pseudocode">// AArch64.AddrTop()
// =================
// Get the top bit position of the virtual address.
// Bits above are not accounted as part of the translation process.

integer <a id="AArch64.AddrTop.3"/>AArch64.AddrTop(bit tbid, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, bit tbi)
    if tbid == '1' &amp;&amp; acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        return 63;

    if tbi == '1' then
        return 55;
    else
        return 63;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.ContiguousBitFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.ContiguousBitFaults</h3>
      <p class="pseudocode">// AArch64.ContiguousBitFaults()
// =============================
// If contiguous bit is set, returns whether the translation size exceeds the
// input address size and if the implementation generates a fault

boolean <a id="AArch64.ContiguousBitFaults.3"/>AArch64.ContiguousBitFaults(bits(6) txsz, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    // Input Address size
    iasize = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(txsz);
    // Translation size
    tsize  = <a href="shared_pseudocode.html#impl-shared.TranslationSize.2" title="function: integer TranslationSize(TGx tgx, integer level)">TranslationSize</a>(tgx, level) + <a href="shared_pseudocode.html#impl-shared.ContiguousSize.2" title="function: integer ContiguousSize(TGx tgx, integer level)">ContiguousSize</a>(tgx, level);

    fault = boolean IMPLEMENTATION_DEFINED "Translation fault on misprogrammed contiguous bit";

    return tsize &gt; iasize &amp;&amp; fault;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.DebugFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.DebugFault</h3>
      <p class="pseudocode">// AArch64.DebugFault()
// ====================
// Return a fault record indicating a hardware watchpoint/breakpoint

FaultRecord <a id="AArch64.DebugFault.2"/>AArch64.DebugFault(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;
    fault.acctype     = acctype;
    fault.write       = iswrite;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.ExclusiveFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.ExclusiveFault</h3>
      <p class="pseudocode">// AArch64.ExclusiveFault()
// ========================

FaultRecord <a id="AArch64.ExclusiveFault.4"/>AArch64.ExclusiveFault(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite,
                                   boolean secondstage, boolean s2fs1walk)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>;
    fault.acctype     = acctype;
    fault.write       = iswrite;
    fault.secondstage = secondstage;
    fault.s2fs1walk   = s2fs1walk;

    return fault;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.IPAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.IPAIsOutOfRange</h3>
      <p class="pseudocode">// AArch64.IPAIsOutOfRange()
// =========================
// Check bits not resolved by translation are ZERO

boolean <a id="AArch64.IPAIsOutOfRange.2"/>AArch64.IPAIsOutOfRange(bits(52) ipa, <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    //Input Address size
    iasize = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);

    if iasize &lt; 52 then
        return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(ipa&lt;51:iasize&gt;);
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.OAOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.OAOutOfRange</h3>
      <p class="pseudocode">// AArch64.OAOutOfRange()
// ======================
// Returns whether output address is expressed in the configured size number of bits

boolean <a id="AArch64.OAOutOfRange.4"/>AArch64.OAOutOfRange(<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate, bits(3) ps, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, bits(64) ia)
    // Output Address size
    oasize = <a href="shared_pseudocode.html#AArch64.PhysicalAddressSize.2" title="function: integer AArch64.PhysicalAddressSize(bits(3) encoded_ps, TGx tgx)">AArch64.PhysicalAddressSize</a>(ps, tgx);

    if oasize &lt; 52 then
        if walkstate.istable then
            baseaddress = walkstate.baseaddress.address;
            return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(baseaddress&lt;51:oasize&gt;);
        else
            // Output address
            oa = <a href="shared_pseudocode.html#impl-shared.StageOA.3" title="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</a>(ia, tgx, walkstate);
            return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(oa.address&lt;51:oasize&gt;);
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S1HasAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S1HasAlignmentFault</h3>
      <p class="pseudocode">// AArch64.S1HasAlignmentFault()
// =============================
// Returns whether stage 1 output fails alignment requirement on data accesses
// to Device memory

boolean <a id="AArch64.S1HasAlignmentFault.4"/>AArch64.S1HasAlignmentFault(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                    bit ntlsmd, <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> || memattrs.memtype != <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return FALSE;

    if acctype == <a href="shared_pseudocode.html#AccType_A32LSMD" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_A32LSMD</a> &amp;&amp; ntlsmd == '0' &amp;&amp; memattrs.device != <a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a> then
        return TRUE;

    return !aligned || acctype == <a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S1HasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S1HasPermissionsFault</h3>
      <p class="pseudocode">// AArch64.S1HasPermissionsFault()
// ===============================
// Returns whether stage 1 access violates permissions of target memory

boolean <a id="AArch64.S1HasPermissionsFault.7"/>AArch64.S1HasPermissionsFault(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate,
                                      <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, boolean ispriv, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                      boolean iswrite)
    permissions = walkstate.permissions;

    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        // Apply leaf permissions
        case permissions.ap&lt;2:1&gt; of
            when '00' (pr,pw,ur,uw) = ('1','1','0','0'); // Privileged access
            when '01' (pr,pw,ur,uw) = ('1','1','1','1'); // No effect
            when '10' (pr,pw,ur,uw) = ('1','0','0','0'); // Read-only, privileged access
            when '11' (pr,pw,ur,uw) = ('1','0','1','0'); // Read-only

        // Apply hierarchical permissions
        case permissions.ap_table of
            when '00' (pr,pw,ur,uw) = ( pr, pw, ur, uw); // No effect
            when '01' (pr,pw,ur,uw) = ( pr, pw,'0','0'); // Privileged access
            when '10' (pr,pw,ur,uw) = ( pr,'0', ur,'0'); // Read-only
            when '11' (pr,pw,ur,uw) = ( pr,'0','0','0'); // Read-only, privileged access

        // Locations writable by unprivileged cannot be executed by privileged
        px = NOT(permissions.pxn OR permissions.pxn_table OR uw);
        ux = NOT(permissions.uxn OR permissions.uxn_table);

        pan_access = !(acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a>});
        if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; pan_access &amp;&amp; !(regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; walkparams.nv1 == '1') then
            if (boolean IMPLEMENTATION_DEFINED "SCR_EL3.SIF affects EPAN" &amp;&amp;
                    <a href="shared_pseudocode.html#AArch64.CurrentSecurityState.0" title="function: SecurityState AArch64.CurrentSecurityState()">AArch64.CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp;
                    walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> &amp;&amp;
                    walkparams.sif == '1') then
                ux = '0';

            if (boolean IMPLEMENTATION_DEFINED "Realm <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>&amp;0 regime affects EPAN" &amp;&amp;
                    <a href="shared_pseudocode.html#AArch64.CurrentSecurityState.0" title="function: SecurityState AArch64.CurrentSecurityState()">AArch64.CurrentSecurityState</a>() == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; regime == <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> &amp;&amp;
                    walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>) then
                ux = '0';
            pan = PSTATE.PAN AND (ur OR uw OR (walkparams.epan AND ux));
            pr = pr AND NOT(pan);
            pw = pw AND NOT(pan);

        (r,w,x) = if ispriv then (pr,pw,px) else (ur,uw,ux);
    else
        // Apply leaf permissions
        case permissions.ap&lt;2&gt; of
            when '0' (r,w) = ('1','1'); // No effect
            when '1' (r,w) = ('1','0'); // Read-only

        // Apply hierarchical permissions
        case permissions.ap_table&lt;1&gt; of
            when '0' (r,w) = ( r , w ); // No effect
            when '1' (r,w) = ( r ,'0'); // Read-only

        x = NOT(permissions.xn OR permissions.xn_table);

    // Prevent execution from writable locations if WXN is set
    x = x AND NOT(walkparams.wxn AND w);
    // Prevent execution from Non-secure space by PE in secure state if SIF is set
    if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; walkstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        x = x AND NOT(walkparams.sif);
    // Prevent execution from non-Root space by Root
    if ss == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a> &amp;&amp; walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a> then
        x = '0';
    // Prevent execution from non-Realm space by Realm EL2 and Realm EL2&amp;0
    if (ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; regime IN {<a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>, <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>} &amp;&amp;
            walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>) then
        x = '0';

    if acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        if (<a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_INSTRDEVICE</a>) == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp;
                walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>) then
            return TRUE;

        return x == '0';
    elsif acctype == <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a> then
        if iswrite then
            return w == '0';
        else
            // DC from privileged context which do no write cannot permission fault
            return !ispriv &amp;&amp; (r == '0' ||
                (<a href="shared_pseudocode.html#impl-shared.IsCMOWControlledInstruction.0" title="function: boolean IsCMOWControlledInstruction()">IsCMOWControlledInstruction</a>() &amp;&amp; walkparams.cmow == '1' &amp;&amp; w == '0'));
    elsif acctype == <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a> then
        // IC instructions do not write
        assert !iswrite;
        impdef_ic_fault = boolean IMPLEMENTATION_DEFINED "Permission fault on <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> IC_IVAU execution";

        // IC from privileged context cannot permission fault
        return !ispriv &amp;&amp; ((r == '0' &amp;&amp; impdef_ic_fault) ||
            (<a href="shared_pseudocode.html#impl-shared.IsCMOWControlledInstruction.0" title="function: boolean IsCMOWControlledInstruction()">IsCMOWControlledInstruction</a>() &amp;&amp; walkparams.cmow == '1' &amp;&amp; w == '0'));
    elsif iswrite then
        return w == '0';
    else
        return r == '0';</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S1InvalidTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S1InvalidTxSZ</h3>
      <p class="pseudocode">// AArch64.S1InvalidTxSZ()
// =======================
// Detect erroneous configuration of stage 1 TxSZ field if the implementation
// does not constrain the value of TxSZ

boolean <a id="AArch64.S1InvalidTxSZ.1"/>AArch64.S1InvalidTxSZ(<a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams)
    mintxsz = <a href="shared_pseudocode.html#AArch64.S1MinTxSZ.2" title="function: integer AArch64.S1MinTxSZ(bit ds, TGx tgx)">AArch64.S1MinTxSZ</a>(walkparams.ds, walkparams.tgx);
    maxtxsz = <a href="shared_pseudocode.html#AArch64.MaxTxSZ.1" title="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);

    return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; mintxsz || <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; maxtxsz;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2HasAlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2HasAlignmentFault</h3>
      <p class="pseudocode">// AArch64.S2HasAlignmentFault()
// =============================
// Returns whether stage 2 output fails alignment requirement on data accesses
// to Device memory

boolean <a id="AArch64.S2HasAlignmentFault.3"/>AArch64.S2HasAlignmentFault(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned, <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> || memattrs.memtype != <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return FALSE;

    return !aligned || acctype == <a href="shared_pseudocode.html#AccType_DCZVA" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DCZVA</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2HasPermissionsFault"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2HasPermissionsFault</h3>
      <p class="pseudocode">// AArch64.S2HasPermissionsFault()
// ===============================
// Returns whether stage 2 access violates permissions of target memory

boolean <a id="AArch64.S2HasPermissionsFault.7"/>AArch64.S2HasPermissionsFault(boolean s2fs1walk, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                      <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, boolean ispriv, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                      boolean iswrite)
    permissions = walkstate.permissions;
    memtype = walkstate.memattrs.memtype;

    r = permissions.s2ap&lt;0&gt;;
    w = permissions.s2ap&lt;1&gt;;

    case (permissions.s2xn:permissions.s2xnx) of
        when '00' (px,ux) = ('1','1');
        when '01' (px,ux) = ('0','1');
        when '10' (px,ux) = ('0','0');
        when '11' (px,ux) = ('1','0');

    x = if ispriv then px else ux;

    if s2fs1walk &amp;&amp; walkparams.ptw == '1' &amp;&amp; memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        return TRUE;
    // Prevent translation table walks in Non-secure space by Realm state
    elsif s2fs1walk &amp;&amp; ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then
        return TRUE;
    elsif acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        constraint = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_INSTRDEVICE</a>);
        if constraint == <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a> &amp;&amp; memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            return TRUE;
        // Prevent execution from Non-secure space by Realm state
        if ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> &amp;&amp; walkstate.baseaddress.paspace != <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then
            return TRUE;
        return x == '0';
    elsif acctype == <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a> then
        // AArch32 DC maintenance instructions operating by VA cannot fault.
        if iswrite then
            return !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; w == '0';
        else
            return ((!ispriv &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; r == '0') ||
                (<a href="shared_pseudocode.html#impl-shared.IsCMOWControlledInstruction.0" title="function: boolean IsCMOWControlledInstruction()">IsCMOWControlledInstruction</a>() &amp;&amp; walkparams.cmow == '1' &amp;&amp; w == '0'));
    elsif acctype == <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a> then
        // IC instructions do not write
        assert !iswrite;
        impdef_ic_fault = boolean IMPLEMENTATION_DEFINED "Permission fault on <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> IC_IVAU execution";

        return ((!ispriv &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; r == '0' &amp;&amp; impdef_ic_fault) ||
            (<a href="shared_pseudocode.html#impl-shared.IsCMOWControlledInstruction.0" title="function: boolean IsCMOWControlledInstruction()">IsCMOWControlledInstruction</a>() &amp;&amp; walkparams.cmow == '1' &amp;&amp; w == '0'));
    elsif iswrite then
        return w == '0';
    else
        return r == '0';</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2InconsistentSL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2InconsistentSL</h3>
      <p class="pseudocode">// AArch64.S2InconsistentSL()
// ==========================
// Detect inconsistent configuration of stage 2 TxSZ and SL fields

boolean <a id="AArch64.S2InconsistentSL.1"/>AArch64.S2InconsistentSL(<a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    startlevel  = <a href="shared_pseudocode.html#AArch64.S2StartLevel.1" title="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</a>(walkparams);
    levels      = <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - startlevel;
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(walkparams.tgx);
    stride      = granulebits - 3;

    // Input address size must at least be large enough to be resolved from the start level
    sl_min_iasize = (
        levels * stride // Bits resolved by table walk, except initial level
        + granulebits   // Bits directly mapped to output address
        + 1);           // At least 1 more bit to be decoded by initial level

    // Can accomodate 1 more stride in the level + concatenation of up to 2^4 tables
    sl_max_iasize = sl_min_iasize + (stride-1) + 4;
    // Configured Input Address size
    iasize        = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);

    return iasize &lt; sl_min_iasize || iasize &gt; sl_max_iasize;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2InvalidSL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2InvalidSL</h3>
      <p class="pseudocode">// AArch64.S2InvalidSL()
// =====================
// Detect invalid configuration of SL field

boolean <a id="AArch64.S2InvalidSL.1"/>AArch64.S2InvalidSL(<a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    case walkparams.tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>
            case walkparams.sl2:walkparams.sl0 of
                when '1x1' return TRUE;
                when '11x' return TRUE;
                when '010' return <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>() &lt; 44;
                when '011' return !<a href="shared_pseudocode.html#impl-shared.HaveSmallTranslationTableExt.0" title="function: boolean HaveSmallTranslationTableExt()">HaveSmallTranslationTableExt</a>();
                otherwise  return FALSE;
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>
            case walkparams.ds:walkparams.sl0 of
                when '011' return TRUE;
                when '010' return <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>() &lt; 42;
                otherwise  return FALSE;
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>
            case walkparams.sl0 of
                when '11'  return TRUE;
                when '10'  return <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>() &lt; 44;
                otherwise  return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.S2InvalidTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.S2InvalidTxSZ</h3>
      <p class="pseudocode">// AArch64.S2InvalidTxSZ()
// =======================
// Detect erroneous configuration of stage 2 TxSZ field if the implementation
// does not constrain the value of TxSZ

boolean <a id="AArch64.S2InvalidTxSZ.2"/>AArch64.S2InvalidTxSZ(<a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, boolean s1aarch64)
    mintxsz = <a href="shared_pseudocode.html#AArch64.S2MinTxSZ.3" title="function: integer AArch64.S2MinTxSZ(bit ds, TGx tgx, boolean s1aarch64)">AArch64.S2MinTxSZ</a>(walkparams.ds, walkparams.tgx, s1aarch64);
    maxtxsz = <a href="shared_pseudocode.html#AArch64.MaxTxSZ.1" title="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);

    return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; mintxsz || <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; maxtxsz;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_faults.AArch64.VAIsOutOfRange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_faults/AArch64.VAIsOutOfRange</h3>
      <p class="pseudocode">// AArch64.VAIsOutOfRange()
// ========================
// Check bits not resolved by translation are identical and of accepted value

boolean <a id="AArch64.VAIsOutOfRange.4"/>AArch64.VAIsOutOfRange(bits(64) va, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams)
    addrtop = <a href="shared_pseudocode.html#AArch64.AddrTop.3" title="function: integer AArch64.AddrTop(bit tbid, AccType acctype, bit tbi)">AArch64.AddrTop</a>(walkparams.tbid, acctype, walkparams.tbi);
    // Input Address size
    iasize  = <a href="shared_pseudocode.html#AArch64.IASize.1" title="function: integer AArch64.IASize(bits(6) txsz)">AArch64.IASize</a>(walkparams.txsz);

    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        if <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va) == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;addrtop:iasize&gt;);
        else
            return !<a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(va&lt;addrtop:iasize&gt;);
    else
        return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;addrtop:iasize&gt;);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_memattr.AArch64.IsS2ResultTagged"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_memattr/AArch64.IsS2ResultTagged</h3>
      <p class="pseudocode">// AArch64.IsS2ResultTagged()
// ==========================
// Determine whether the combined output memory attributes of stage 1 and
// stage 2 indicate tagged memory

boolean <a id="AArch64.IsS2ResultTagged.2"/>AArch64.IsS2ResultTagged(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> s2_memattrs, boolean s1_tagged)
    return (
        s1_tagged                                &amp;&amp;
        (s2_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>)  &amp;&amp;
        (s2_memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>)  &amp;&amp;
        (s2_memattrs.inner.hints == <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>) &amp;&amp;
        (!s2_memattrs.inner.transient)           &amp;&amp;
        (s2_memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>)  &amp;&amp;
        (s2_memattrs.outer.hints == <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>) &amp;&amp;
        (!s2_memattrs.outer.transient)
    );</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_memattr.AArch64.S2ApplyFWBMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_memattr/AArch64.S2ApplyFWBMemAttrs</h3>
      <p class="pseudocode">// AArch64.S2ApplyFWBMemAttrs()
// ============================
// Apply stage 2 forced Write-Back on stage 1 memory attributes.

MemoryAttributes <a id="AArch64.S2ApplyFWBMemAttrs.3"/>AArch64.S2ApplyFWBMemAttrs(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> s1_memattrs,
                                            bits(4) s2_attr, bits(2) s2_sh)
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;

    if s2_attr&lt;2&gt; == '0' then          // S2 Device, S1 any
        s2_device = <a href="shared_pseudocode.html#impl-shared.DecodeDevice.1" title="function: DeviceType DecodeDevice(bits(2) device)">DecodeDevice</a>(s2_attr&lt;1:0&gt;);
        memattrs.memtype = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        if s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            memattrs.device = <a href="shared_pseudocode.html#impl-shared.S2CombineS1Device.2" title="function: DeviceType S2CombineS1Device(DeviceType s1_device, DeviceType s2_device)">S2CombineS1Device</a>(s1_memattrs.device, s2_device);
        else
            memattrs.device = s2_device;

    elsif s2_attr&lt;1:0&gt; == '11' then    // S2 attr = S1 attr
        memattrs = s1_memattrs;

    elsif s2_attr&lt;1:0&gt; == '10' then    // Force writeback
        memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.inner.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        memattrs.outer.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;

        if (s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
                s1_memattrs.inner.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>) then
            memattrs.inner.hints     = s1_memattrs.inner.hints;
            memattrs.inner.transient = s1_memattrs.inner.transient;
        else
            memattrs.inner.hints     = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.inner.transient = FALSE;

        if (s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp;
                s1_memattrs.outer.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>) then
            memattrs.outer.hints     = s1_memattrs.outer.hints;
            memattrs.outer.transient = s1_memattrs.outer.transient;
        else
            memattrs.outer.hints     = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.outer.transient = FALSE;

    else                               // Non-cacheable unless S1 is device
        if s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
            memattrs = s1_memattrs;
        else
            <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> cacheability_attr;
            cacheability_attr.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;

            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.inner   = cacheability_attr;
            memattrs.outer   = cacheability_attr;

    s2_shareability = <a href="shared_pseudocode.html#impl-shared.DecodeShareability.1" title="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(s2_sh);
    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.S2CombineS1Shareability.2" title="function: Shareability S2CombineS1Shareability(Shareability s1_shareability,&#13; Shareability s2_shareability)">S2CombineS1Shareability</a>(s1_memattrs.shareability, s2_shareability);
    memattrs.tagged       = <a href="shared_pseudocode.html#AArch64.IsS2ResultTagged.2" title="function: boolean AArch64.IsS2ResultTagged(MemoryAttributes s2_memattrs, boolean s1_tagged)">AArch64.IsS2ResultTagged</a>(memattrs, s1_memattrs.tagged);

    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);
    return memattrs;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.GetS1TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.GetS1TLBContext</h3>
      <p class="pseudocode">// AArch64.GetS1TLBContext()
// =========================
// Gather translation context for accesses with VA to match against TLB entries

TLBContext <a id="AArch64.GetS1TLBContext.4"/>AArch64.GetS1TLBContext(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  tlbcontext = <a href="shared_pseudocode.html#AArch64.TLBContextEL3.3" title="function: TLBContext AArch64.TLBContextEL3(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL3</a>(ss, va, tg);
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  tlbcontext = <a href="shared_pseudocode.html#AArch64.TLBContextEL2.3" title="function: TLBContext AArch64.TLBContextEL2(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL2</a>(ss, va, tg);
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> tlbcontext = <a href="shared_pseudocode.html#AArch64.TLBContextEL20.3" title="function: TLBContext AArch64.TLBContextEL20(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL20</a>(ss, va, tg);
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> tlbcontext = <a href="shared_pseudocode.html#AArch64.TLBContextEL10.3" title="function: TLBContext AArch64.TLBContextEL10(SecurityState ss, bits(64) va, TGx tg)">AArch64.TLBContextEL10</a>(ss, va, tg);

    tlbcontext.includes_s1  = TRUE;
    // The following may be amended for EL1&amp;0 Regime if caching of stage 2 is successful
    tlbcontext.includes_s2  = FALSE;
    // The following may be amended if Granule Protection Check passes
    tlbcontext.includes_gpt = FALSE;
    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.GetS2TLBContext"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.GetS2TLBContext</h3>
      <p class="pseudocode">// AArch64.GetS2TLBContext()
// =========================
// Gather translation context for accesses with IPA to match against TLB entries

TLBContext <a id="AArch64.GetS2TLBContext.3"/>AArch64.GetS2TLBContext(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> ipa, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    assert <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss       = ss;
    tlbcontext.regime   = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    tlbcontext.ipaspace = ipa.paspace;
    tlbcontext.vmid     = <a href="shared_pseudocode.html#impl-aarch64.VMID.read.0" title="accessor: bits(16) VMID[]">VMID</a>[];
    tlbcontext.tg       = tg;
    tlbcontext.ia       = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(ipa.address);
    if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then
        tlbcontext.cnp = if ipa.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then VSTTBR_EL2.CnP else VTTBR_EL2.CnP;
    else
        tlbcontext.cnp = '0';

    tlbcontext.includes_s1  = FALSE;
    tlbcontext.includes_s2  = TRUE;
    // This amy be amended if Granule Protection Check passes
    tlbcontext.includes_gpt = FALSE;
    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL10</h3>
      <p class="pseudocode">// AArch64.TLBContextEL10()
// ========================
// Gather translation context for accesses under EL10 regime to match against TLB entries

TLBContext <a id="AArch64.TLBContextEL10.3"/>AArch64.TLBContextEL10(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    tlbcontext.vmid   = <a href="shared_pseudocode.html#impl-aarch64.VMID.read.0" title="accessor: bits(16) VMID[]">VMID</a>[];
    tlbcontext.asid   = if TCR_EL1.A1 == '0' then TTBR0_EL1.ASID else TTBR1_EL1.ASID;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;

    if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then
        if <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va) == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_EL1.CnP;
        else
            tlbcontext.cnp = TTBR1_EL1.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL2</h3>
      <p class="pseudocode">// AArch64.TLBContextEL2()
// =======================
// Gather translation context for accesses under EL2 regime to match against TLB entries

TLBContext <a id="AArch64.TLBContextEL2.3"/>AArch64.TLBContextEL2(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;
    tlbcontext.cnp    = if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then TTBR0_EL2.CnP else '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL20"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL20</h3>
      <p class="pseudocode">// AArch64.TLBContextEL20()
// ========================
// Gather translation context for accesses under EL20 regime to match against TLB entries

TLBContext <a id="AArch64.TLBContextEL20.3"/>AArch64.TLBContextEL20(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>;
    tlbcontext.asid   = if TCR_EL2.A1 == '0' then TTBR0_EL2.ASID else TTBR1_EL2.ASID;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;

    if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then
        if <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va) == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
            tlbcontext.cnp = TTBR0_EL2.CnP;
        else
            tlbcontext.cnp = TTBR1_EL2.CnP;
    else
        tlbcontext.cnp = '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_tlbcontext.AArch64.TLBContextEL3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_tlbcontext/AArch64.TLBContextEL3</h3>
      <p class="pseudocode">// AArch64.TLBContextEL3()
// =======================
// Gather translation context for accesses under EL3 regime to match against TLB entries

TLBContext <a id="AArch64.TLBContextEL3.3"/>AArch64.TLBContextEL3(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tg)
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> tlbcontext;

    tlbcontext.ss     = ss;
    tlbcontext.regime = <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>;
    tlbcontext.tg     = tg;
    tlbcontext.ia     = va;
    tlbcontext.cnp    = if <a href="shared_pseudocode.html#impl-shared.HaveCommonNotPrivateTransExt.0" title="function: boolean HaveCommonNotPrivateTransExt()">HaveCommonNotPrivateTransExt</a>() then TTBR0_EL3.CnP else '0';

    return tlbcontext;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.AccessUsesEL"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.AccessUsesEL</h3>
      <p class="pseudocode">// AArch64.AccessUsesEL()
// ======================
// Returns the Exception Level of the regime that will manage the translation for a given access type.

bits(2) <a id="AArch64.AccessUsesEL.1"/>AArch64.AccessUsesEL(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    if acctype IN {<a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a>, <a href="shared_pseudocode.html#AccType_UNPRIVSTREAM" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIVSTREAM</a>} then
        return <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
    elsif acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        return <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        return PSTATE.EL;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.FaultAllowsSetAccessFlag"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.FaultAllowsSetAccessFlag</h3>
      <p class="pseudocode">// AArch64.FaultAllowsSetAccessFlag()
// ==================================
// Determine whether the access flag could be set by HW given the fault status

boolean <a id="AArch64.FaultAllowsSetAccessFlag.1"/>AArch64.FaultAllowsSetAccessFlag(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    if fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return TRUE;
    elsif fault.statuscode IN {<a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>, <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>} then
        return <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_AFUPDATE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_AFUPDATE</a>) == <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.FullTranslate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.FullTranslate</h3>
      <p class="pseudocode">// AArch64.FullTranslate()
// =======================
// Address translation as specified by VMSA
// Alignment check NOT due to memory type is expected to be done before translation

AddressDescriptor <a id="AArch64.FullTranslate.4"/>AArch64.FullTranslate(bits(64) va, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                        boolean iswrite, boolean aligned)

    fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
    fault.acctype = acctype;
    fault.write   = iswrite;

    ispriv = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; acctype != <a href="shared_pseudocode.html#AccType_UNPRIV" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_UNPRIV</a>;
    regime = <a href="shared_pseudocode.html#impl-shared.TranslationRegime.2" title="function: Regime TranslationRegime(bits(2) el, AccType acctype)">TranslationRegime</a>(PSTATE.EL, acctype);
    ss = <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);

    (fault, ipa) = <a href="shared_pseudocode.html#AArch64.S1Translate.8" title="function: (FaultRecord, AddressDescriptor) AArch64.S1Translate(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(64) va,&#13; AccType acctype, boolean aligned,&#13; boolean iswrite, boolean ispriv)">AArch64.S1Translate</a>(fault, regime, ss, va, acctype, aligned, iswrite, ispriv);

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return <a href="shared_pseudocode.html#impl-shared.CreateFaultyAddressDescriptor.2" title="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(va, fault);

    assert (ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>) IMPLIES <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        s1aarch64 = TRUE;
        s2fs1walk = FALSE;
        (fault, pa) = <a href="shared_pseudocode.html#AArch64.S2Translate.9" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</a>(fault, ipa, s1aarch64, ss, s2fs1walk,
                                          acctype, aligned, iswrite, ispriv);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return <a href="shared_pseudocode.html#impl-shared.CreateFaultyAddressDescriptor.2" title="function: AddressDescriptor CreateFaultyAddressDescriptor(bits(64) va, FaultRecord fault)">CreateFaultyAddressDescriptor</a>(va, fault);
        else
            return pa;
    else
        return ipa;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.MemSwapTableDesc"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.MemSwapTableDesc</h3>
      <p class="pseudocode">// AArch64.MemSwapTableDesc()
// ==========================
// Perform HW update of table descriptor as an atomic operation

(FaultRecord, bits(64)) <a id="AArch64.MemSwapTableDesc.5"/>AArch64.MemSwapTableDesc(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, bits(64) prev_desc,
                                                 bits(64) new_desc, bit ee,
                                                 <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> descupdateaddress)
    descupdateaccess = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(<a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>);

    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(descupdateaddress, descupdateaccess);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>;
            fault.paddress   = descupdateaddress.paddress;
            fault.gpcfs2walk = fault.secondstage;
            return (fault, bits(64) UNKNOWN);

    // All observers in the shareability domain observe the
    // following memory read and write accesses atomically.
    (memstatus, mem_desc) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(descupdateaddress, 8, descupdateaccess);
    if ee == '1' then
        mem_desc = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(mem_desc);

    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        iswrite = FALSE;
        fault = <a href="shared_pseudocode.html#impl-shared.HandleExternalTTWAbort.6" title="function: FaultRecord HandleExternalTTWAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc,&#13; AccessDescriptor accdesc, integer size,&#13; FaultRecord input_fault)">HandleExternalTTWAbort</a>(memstatus, iswrite, descupdateaddress, descupdateaccess,
                                       8, fault);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(fault.statuscode) then
            fault.acctype = <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>;
            return (fault, bits(64) UNKNOWN);

    if mem_desc == prev_desc  then
        ordered_new_desc = if ee == '1' then <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(new_desc) else new_desc;
        memstatus = <a href="shared_pseudocode.html#impl-shared.PhysMemWrite.4" title="function: PhysMemRetStatus PhysMemWrite(AddressDescriptor desc, integer size, AccessDescriptor accdesc,&#13; bits(8*size) value)">PhysMemWrite</a>(descupdateaddress, 8, descupdateaccess, ordered_new_desc);

        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
            iswrite = TRUE;
            fault = <a href="shared_pseudocode.html#impl-shared.HandleExternalTTWAbort.6" title="function: FaultRecord HandleExternalTTWAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc,&#13; AccessDescriptor accdesc, integer size,&#13; FaultRecord input_fault)">HandleExternalTTWAbort</a>(memstatus, iswrite, descupdateaddress, descupdateaccess,
                                           8, fault);
            fault.acctype = memstatus.acctype;
            if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(fault.statuscode) then
                fault.acctype = <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>;
                return (fault, bits(64) UNKNOWN);

        // Reflect what is now in memory (in little endian format)
        mem_desc = new_desc;

    return (fault, mem_desc);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.S1DisabledOutput"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.S1DisabledOutput</h3>
      <p class="pseudocode">// AArch64.S1DisabledOutput()
// ==========================
// Map the the VA to IPA/PA and assign default memory attributes

(FaultRecord, AddressDescriptor) <a id="AArch64.S1DisabledOutput.6"/>AArch64.S1DisabledOutput(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                          <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va,
                                                          <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned)

    walkparams = <a href="shared_pseudocode.html#AArch64.GetS1TTWParams.2" title="function: S1TTWParams AArch64.GetS1TTWParams(Regime regime, bits(64) va)">AArch64.GetS1TTWParams</a>(regime, va);

    // No memory page is guarded when stage 1 address translation is disabled
    <a href="shared_pseudocode.html#impl-aarch64.SetInGuardedPage.1" title="function: SetInGuardedPage(boolean guardedpage)">SetInGuardedPage</a>(FALSE);

    // Output Address
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> oa;
    oa.address = va&lt;51:0&gt;;
    case ss of
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    oa.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> oa.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>      oa.paspace = <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     oa.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; walkparams.dc == '1' then
        <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> default_cacheability;
        default_cacheability.attrs     = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
        default_cacheability.hints     = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        default_cacheability.transient = FALSE;

        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.outer        = default_cacheability;
        memattrs.inner        = default_cacheability;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        memattrs.tagged       = walkparams.dct == '1';
        memattrs.xs           = '0';
    elsif acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
        <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> i_cache_attr;
        if <a href="shared_pseudocode.html#AArch64.S1ICacheEnabled.1" title="function: boolean AArch64.S1ICacheEnabled(Regime regime)">AArch64.S1ICacheEnabled</a>(regime) then
            i_cache_attr.attrs     = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            i_cache_attr.hints     = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            i_cache_attr.transient = FALSE;
        else
            i_cache_attr.attrs     = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;

        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.outer        = i_cache_attr;
        memattrs.inner        = i_cache_attr;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        memattrs.tagged       = FALSE;
        memattrs.xs           = '1';
    else
        memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        memattrs.device       = <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
        memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        memattrs.xs           = '1';

    fault.level = 0;
    addrtop     = <a href="shared_pseudocode.html#AArch64.AddrTop.3" title="function: integer AArch64.AddrTop(bit tbid, AccType acctype, bit tbi)">AArch64.AddrTop</a>(walkparams.tbid, acctype, walkparams.tbi);
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(va&lt;addrtop:<a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>()&gt;) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
    elsif <a href="shared_pseudocode.html#AArch64.S1HasAlignmentFault.4" title="function: boolean AArch64.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch64.S1HasAlignmentFault</a>(acctype, aligned, walkparams.ntlsmd, memattrs) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);
    else
        ipa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(va, oa, memattrs);
        return (fault, ipa);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.S1Translate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.S1Translate</h3>
      <p class="pseudocode">// AArch64.S1Translate()
// =====================
// Translate VA to IPA/PA depending on the regime

(FaultRecord, AddressDescriptor) <a id="AArch64.S1Translate.8"/>AArch64.S1Translate(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                                     <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, bits(64) va,
                                                     <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean aligned,
                                                     boolean iswrite, boolean ispriv)
    // Prepare fault fields in case a fault is detected
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    if !<a href="shared_pseudocode.html#AArch64.S1Enabled.1" title="function: boolean AArch64.S1Enabled(Regime regime)">AArch64.S1Enabled</a>(regime) then
        return <a href="shared_pseudocode.html#AArch64.S1DisabledOutput.6" title="function: (FaultRecord, AddressDescriptor) AArch64.S1DisabledOutput(FaultRecord fault, Regime regime,&#13; SecurityState ss, bits(64) va,&#13; AccType acctype, boolean aligned)">AArch64.S1DisabledOutput</a>(fault, regime, ss, va, acctype, aligned);

    walkparams = <a href="shared_pseudocode.html#AArch64.GetS1TTWParams.2" title="function: S1TTWParams AArch64.GetS1TTWParams(Regime regime, bits(64) va)">AArch64.GetS1TTWParams</a>(regime, va);

    if (<a href="shared_pseudocode.html#AArch64.VAIsOutOfRange.4" title="function: boolean AArch64.VAIsOutOfRange(bits(64) va, AccType acctype, Regime regime, S1TTWParams walkparams)">AArch64.VAIsOutOfRange</a>(va, acctype, regime, walkparams) ||
            (!ispriv &amp;&amp; walkparams.e0pd == '1')) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    repeat
        (fault, descaddress, walkstate, descriptor) = <a href="shared_pseudocode.html#AArch64.S1Walk.8" title="function: (FaultRecord, AddressDescriptor, TTWState, bits(64)) AArch64.S1Walk(&#13; FaultRecord fault, S1TTWParams walkparams, bits(64) va, Regime regime, SecurityState ss,&#13; AccType acctype, boolean iswrite, boolean ispriv)">AArch64.S1Walk</a>(fault, walkparams, va, regime,
                                                                     ss, acctype, iswrite, ispriv);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

        if acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> then
            // Flag the fetched instruction is from a guarded page
            <a href="shared_pseudocode.html#impl-aarch64.SetInGuardedPage.1" title="function: SetInGuardedPage(boolean guardedpage)">SetInGuardedPage</a>(walkstate.guardedpage == '1');

        if <a href="shared_pseudocode.html#AArch64.S1HasAlignmentFault.4" title="function: boolean AArch64.S1HasAlignmentFault(AccType acctype, boolean aligned,&#13; bit ntlsmd, MemoryAttributes memattrs)">AArch64.S1HasAlignmentFault</a>(acctype, aligned, walkparams.ntlsmd,
                                       walkstate.memattrs) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
        elsif <a href="shared_pseudocode.html#impl-shared.IsAtomicRW.1" title="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) then
            if <a href="shared_pseudocode.html#AArch64.S1HasPermissionsFault.7" title="function: boolean AArch64.S1HasPermissionsFault(Regime regime, SecurityState ss, TTWState walkstate,&#13; S1TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S1HasPermissionsFault</a>(regime, ss, walkstate, walkparams,
                                             ispriv, acctype, FALSE) then
                // The permission fault was not caused by lack of write permissions
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.write      = FALSE;
            elsif <a href="shared_pseudocode.html#AArch64.S1HasPermissionsFault.7" title="function: boolean AArch64.S1HasPermissionsFault(Regime regime, SecurityState ss, TTWState walkstate,&#13; S1TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S1HasPermissionsFault</a>(regime, ss, walkstate, walkparams,
                                                ispriv, acctype, TRUE) then
                // The permission fault _was_ caused by lack of write permissions
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.write      = TRUE;
        elsif <a href="shared_pseudocode.html#AArch64.S1HasPermissionsFault.7" title="function: boolean AArch64.S1HasPermissionsFault(Regime regime, SecurityState ss, TTWState walkstate,&#13; S1TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S1HasPermissionsFault</a>(regime, ss, walkstate, walkparams,
                                            ispriv, acctype, iswrite) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

        new_desc = descriptor;
        if walkparams.ha == '1' &amp;&amp; <a href="shared_pseudocode.html#AArch64.FaultAllowsSetAccessFlag.1" title="function: boolean AArch64.FaultAllowsSetAccessFlag(FaultRecord fault)">AArch64.FaultAllowsSetAccessFlag</a>(fault) then
            // Set descriptor AF bit
            new_desc&lt;10&gt; = '1';

        // If HW update of dirty bit is enabled, the walk state permissions
        // will already reflect a configuration permitting writes.
        // The update of the descriptor occurs only if the descriptor bits in
        // memory do not reflect that and the access instigates a write.
        if (fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> &amp;&amp;
                walkparams.ha  == '1' &amp;&amp;
                walkparams.hd  == '1' &amp;&amp;
                descriptor&lt;51&gt; == '1' &amp;&amp; // Descriptor DBM bit
                (<a href="shared_pseudocode.html#impl-shared.IsAtomicRW.1" title="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) || iswrite) &amp;&amp;
                !(acctype IN {<a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>})) then
            // Clear descriptor AP[2] bit permitting stage 1 writes
            new_desc&lt;7&gt; = '0';

        // Either the access flag was clear or AP&lt;2&gt; is set
        if new_desc != descriptor then
            if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
                s1aarch64 = TRUE;
                s2fs1walk = TRUE;
                aligned   = TRUE;
                iswrite   = TRUE;
                (s2fault, descupdateaddress) = <a href="shared_pseudocode.html#AArch64.S2Translate.9" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</a>(fault, descaddress, s1aarch64,
                                                                   ss, s2fs1walk, <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>,
                                                                   aligned, iswrite, ispriv);

                if s2fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                    return (s2fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);
            else
                descupdateaddress = descaddress;

            (fault, mem_desc) = <a href="shared_pseudocode.html#AArch64.MemSwapTableDesc.5" title="function: (FaultRecord, bits(64)) AArch64.MemSwapTableDesc(FaultRecord fault, bits(64) prev_desc,&#13; bits(64) new_desc, bit ee,&#13; AddressDescriptor descupdateaddress)">AArch64.MemSwapTableDesc</a>(fault, descriptor, new_desc,
                                                         walkparams.ee, descupdateaddress);

    until new_desc == descriptor || mem_desc == new_desc;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    // Output Address
    oa = <a href="shared_pseudocode.html#impl-shared.StageOA.3" title="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</a>(va, walkparams.tgx, walkstate);

    if (acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
        (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || !<a href="shared_pseudocode.html#AArch64.S1ICacheEnabled.1" title="function: boolean AArch64.S1ICacheEnabled(Regime regime)">AArch64.S1ICacheEnabled</a>(regime))) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;
    elsif (acctype != <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp; !<a href="shared_pseudocode.html#AArch64.S1DCacheEnabled.1" title="function: boolean AArch64.S1DCacheEnabled(Regime regime)">AArch64.S1DCacheEnabled</a>(regime) &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>) then
        // Treat memory attributes as Normal Non-Cacheable
        memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        memattrs.xs = walkstate.memattrs.xs;

        // The effect of SCTLR_ELx.C when '0' is Constrained UNPREDICTABLE
        // on the Tagged attribute
        if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() &amp;&amp; walkstate.memattrs.tagged then
            memattrs.tagged = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_S1CTAGGED" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_S1CTAGGED</a>);
    else
        memattrs = walkstate.memattrs;

    // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
    // to be either effective value or descriptor value
    if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.VM == '1' &amp;&amp;
            !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
        memattrs.shareability = walkstate.memattrs.shareability;
    else
        memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);

    if acctype == <a href="shared_pseudocode.html#AccType_ATOMICLS64" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a> &amp;&amp; memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> then
        if memattrs.inner.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> || memattrs.outer.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>;
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    ipa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(va, oa, memattrs);
    return (fault, ipa);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.S2Translate"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.S2Translate</h3>
      <p class="pseudocode">// AArch64.S2Translate()
// =====================
// Translate stage 1 IPA to PA and combine memory attributes

(FaultRecord, AddressDescriptor) <a id="AArch64.S2Translate.9"/>AArch64.S2Translate(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                                     boolean s1aarch64, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                                     boolean s2fs1walk, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype,
                                                     boolean aligned, boolean iswrite,
                                                     boolean ispriv)
    walkparams = <a href="shared_pseudocode.html#AArch64.GetS2TTWParams.3" title="function: S2TTWParams AArch64.GetS2TTWParams(SecurityState ss, PASpace ipaspace, boolean s1aarch64)">AArch64.GetS2TTWParams</a>(ss, ipa.paddress.paspace, s1aarch64);

    // Prepare fault fields in case a fault is detected
    fault.statuscode  = <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>; // Ignore any faults from stage 1
    fault.secondstage = TRUE;
    fault.s2fs1walk   = s2fs1walk;
    fault.ipaddress   = ipa.paddress;

    if walkparams.vm != '1' then
        // Stage 2 translation is disabled
        return (fault, ipa);

    if <a href="shared_pseudocode.html#AArch64.IPAIsOutOfRange.2" title="function: boolean AArch64.IPAIsOutOfRange(bits(52) ipa, S2TTWParams walkparams)">AArch64.IPAIsOutOfRange</a>(ipa.paddress.address, walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    repeat
        (fault, descaddress, walkstate, descriptor) = <a href="shared_pseudocode.html#AArch64.S2Walk.7" title="function: (FaultRecord, AddressDescriptor, TTWState, bits(64)) AArch64.S2Walk(&#13; FaultRecord fault, AddressDescriptor ipa, S2TTWParams walkparams, SecurityState ss,&#13; AccType acctype, boolean iswrite, boolean s1aarch64)">AArch64.S2Walk</a>(fault, ipa, walkparams, ss,
                                                                     acctype, iswrite, s1aarch64);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

        if <a href="shared_pseudocode.html#AArch64.S2HasAlignmentFault.3" title="function: boolean AArch64.S2HasAlignmentFault(AccType acctype, boolean aligned, MemoryAttributes memattrs)">AArch64.S2HasAlignmentFault</a>(acctype, aligned, walkstate.memattrs) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
        elsif <a href="shared_pseudocode.html#impl-shared.IsAtomicRW.1" title="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) then
            if <a href="shared_pseudocode.html#AArch64.S2HasPermissionsFault.7" title="function: boolean AArch64.S2HasPermissionsFault(boolean s2fs1walk, TTWState walkstate, SecurityState ss,&#13; S2TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S2HasPermissionsFault</a>(s2fs1walk, walkstate, ss, walkparams,
                                             ispriv, acctype, FALSE) then
                // The permission fault was not caused by lack of write permissions
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                fault.write      = FALSE;
            elsif <a href="shared_pseudocode.html#AArch64.S2HasPermissionsFault.7" title="function: boolean AArch64.S2HasPermissionsFault(boolean s2fs1walk, TTWState walkstate, SecurityState ss,&#13; S2TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S2HasPermissionsFault</a>(s2fs1walk, walkstate, ss, walkparams,
                                                ispriv, acctype, TRUE) then
                // The permission fault _was_ caused by lack of write permissions.
                // However, HW updates, which are atomic writes for stage 1
                // descriptors, permissions fault reflect the original access.
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;
                if !fault.s2fs1walk then
                    fault.write  = TRUE;
        elsif <a href="shared_pseudocode.html#AArch64.S2HasPermissionsFault.7" title="function: boolean AArch64.S2HasPermissionsFault(boolean s2fs1walk, TTWState walkstate, SecurityState ss,&#13; S2TTWParams walkparams, boolean ispriv, AccType acctype,&#13; boolean iswrite)">AArch64.S2HasPermissionsFault</a>(s2fs1walk, walkstate, ss, walkparams,
                                            ispriv, acctype, iswrite) then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>;

        new_desc = descriptor;
        if walkparams.ha == '1' &amp;&amp; <a href="shared_pseudocode.html#AArch64.FaultAllowsSetAccessFlag.1" title="function: boolean AArch64.FaultAllowsSetAccessFlag(FaultRecord fault)">AArch64.FaultAllowsSetAccessFlag</a>(fault) then
            // Set descriptor AF bit
            new_desc&lt;10&gt; = '1';

        // If HW update of dirty bit is enabled, the walk state permissions
        // will already reflect a configuration permitting writes.
        // The update of the descriptor occurs only if the descriptor bits in
        // memory do not reflect that and the access instigates a write.
        if (fault.statuscode == <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> &amp;&amp;
                walkparams.ha  == '1' &amp;&amp;
                walkparams.hd  == '1' &amp;&amp;
                descriptor&lt;51&gt; == '1' &amp;&amp; // Descriptor DBM bit
                (<a href="shared_pseudocode.html#impl-shared.IsAtomicRW.1" title="function: boolean IsAtomicRW(AccType acctype)">IsAtomicRW</a>(acctype) || iswrite) &amp;&amp;
                !(acctype IN {<a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>, <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>})) then
            // Set descriptor S2AP[1] bit permitting stage 2 writes
            new_desc&lt;7&gt; = '1';

        // Either the access flag was clear or S2AP&lt;1&gt; is clear
        if new_desc != descriptor then
            (fault, mem_desc) = <a href="shared_pseudocode.html#AArch64.MemSwapTableDesc.5" title="function: (FaultRecord, bits(64)) AArch64.MemSwapTableDesc(FaultRecord fault, bits(64) prev_desc,&#13; bits(64) new_desc, bit ee,&#13; AddressDescriptor descupdateaddress)">AArch64.MemSwapTableDesc</a>(fault, descriptor, new_desc,
                                                         walkparams.ee, descaddress);

    until new_desc == descriptor || mem_desc == new_desc;

    if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    ipa_64 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address, 64);
    // Output Address
    oa = <a href="shared_pseudocode.html#impl-shared.StageOA.3" title="function: FullAddress StageOA(bits(64) ia, TGx tgx, TTWState walkstate)">StageOA</a>(ipa_64, walkparams.tgx, walkstate);

    if ((s2fs1walk &amp;&amp;
            walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp; walkparams.ptw == '0') ||
        (acctype == <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
            (walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> || HCR_EL2.ID == '1')) ||
        (acctype != <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a> &amp;&amp;
             walkstate.memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> &amp;&amp; HCR_EL2.CD == '1')) then
        // Treat memory attributes as Normal Non-Cacheable
        s2_memattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
        s2_memattrs.xs = walkstate.memattrs.xs;
    else
        s2_memattrs = walkstate.memattrs;

    if !s2fs1walk &amp;&amp; acctype == <a href="shared_pseudocode.html#AccType_ATOMICLS64" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICLS64</a> &amp;&amp; s2_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a> then
        if s2_memattrs.inner.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> || s2_memattrs.outer.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>;
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN);

    if walkparams.fwb == '0' then
        memattrs = <a href="shared_pseudocode.html#impl-shared.S2CombineS1MemAttrs.2" title="function: MemoryAttributes S2CombineS1MemAttrs(MemoryAttributes s1_memattrs,&#13; MemoryAttributes s2_memattrs)">S2CombineS1MemAttrs</a>(ipa.memattrs, s2_memattrs);
    else
        memattrs = s2_memattrs;

    pa = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(ipa.vaddress, oa, memattrs);
    return (fault, pa);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_translation.AArch64.TranslateAddress"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_translation/AArch64.TranslateAddress</h3>
      <p class="pseudocode">// AArch64.TranslateAddress()
// ==========================
// Main entry point for translating an address

AddressDescriptor <a id="AArch64.TranslateAddress.5"/>AArch64.TranslateAddress(bits(64) va, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite,
                                           boolean aligned, integer size)

    result = <a href="shared_pseudocode.html#AArch64.FullTranslate.4" title="function: AddressDescriptor AArch64.FullTranslate(bits(64) va, AccType acctype,&#13; boolean iswrite, boolean aligned)">AArch64.FullTranslate</a>(va, acctype, iswrite, aligned);

    if !<a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(result) then
        result.fault = <a href="shared_pseudocode.html#AArch64.CheckDebug.4" title="function: FaultRecord AArch64.CheckDebug(bits(64) vaddress, AccType acctype, boolean iswrite, integer size)">AArch64.CheckDebug</a>(va, acctype, iswrite, size);

    // Update virtual address for abort functions
    result.vaddress = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(va);

    return result;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.BlockDescSupported"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.BlockDescSupported</h3>
      <p class="pseudocode">// AArch64.BlockDescSupported()
// ============================
// Determine whether a block descriptor is valid for the given granule size
// and level

boolean <a id="AArch64.BlockDescSupported.3"/>AArch64.BlockDescSupported(bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    case tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  return level == 2 || level == 1 || (level == 0 &amp;&amp; ds == '1');
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> return level == 2 || (level == 1 &amp;&amp; ds == '1');
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> return level == 2 || (level == 1 &amp;&amp; <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>() == 52);

    return FALSE;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.BlocknTFaults"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.BlocknTFaults</h3>
      <p class="pseudocode">// AArch64.BlocknTFaults()
// =======================
// Identify whether the nT bit in a block descriptor is effectively set
// causing a translation fault

boolean <a id="AArch64.BlocknTFaults.1"/>AArch64.BlocknTFaults(bits(64) descriptor)
    if !<a href="shared_pseudocode.html#impl-shared.HaveBlockBBM.0" title="function: boolean HaveBlockBBM()">HaveBlockBBM</a>() then
        return FALSE;

    bbm_level = <a href="shared_pseudocode.html#AArch64.BlockBBMSupportLevel.0" title="function: integer AArch64.BlockBBMSupportLevel()">AArch64.BlockBBMSupportLevel</a>();
    nT_faults = boolean IMPLEMENTATION_DEFINED "BBM level 1 or 2 support nT bit causes Translation <a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a>";

    return bbm_level IN {1, 2} &amp;&amp; descriptor&lt;16&gt; == '1' &amp;&amp; nT_faults;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.ContiguousBit"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.ContiguousBit</h3>
      <p class="pseudocode">// AArch64.ContiguousBit()
// =======================
// Get the value of the contiguous bit

bit <a id="AArch64.ContiguousBit.3"/>AArch64.ContiguousBit(<a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level, bits(64) descriptor)
    if tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; level == 1 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()">Have52BitVAExt</a>() then
        return '0'; // RES0
    if tgx == <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> &amp;&amp; level == 1 then
        return '0'; // RES0
    if tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  &amp;&amp; level == 0 then
        return '0'; // RES0

    return descriptor&lt;52&gt;;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.DecodeDescriptorType"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.DecodeDescriptorType</h3>
      <p class="pseudocode">// AArch64.DecodeDescriptorType()
// ==============================
// Determine whether the descriptor is a page, block or table

DescriptorType <a id="AArch64.DecodeDescriptorType.4"/>AArch64.DecodeDescriptorType(bits(64) descriptor, bit ds,
                                            <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    if descriptor&lt;1:0&gt; == '11' &amp;&amp; level == <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        return <a href="shared_pseudocode.html#DescriptorType_Page" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>;
    elsif descriptor&lt;1:0&gt; == '11' then
        return <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>;
    elsif descriptor&lt;1:0&gt; == '01' then
        if <a href="shared_pseudocode.html#AArch64.BlockDescSupported.3" title="function: boolean AArch64.BlockDescSupported(bit ds, TGx tgx, integer level)">AArch64.BlockDescSupported</a>(ds, tgx, level) then
            return <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>;
        else
            return <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;
    else
        return <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.S1ApplyOutputPerms"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.S1ApplyOutputPerms</h3>
      <p class="pseudocode">// AArch64.S1ApplyOutputPerms()
// ============================
// Apply output permissions encoded in stage 1 page/block descriptors

Permissions <a id="AArch64.S1ApplyOutputPerms.4"/>AArch64.S1ApplyOutputPerms(<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> permissions, bits(64) descriptor,
                                       <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams)
    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; walkparams.nv1 == '1' then
        permissions.ap&lt;2:1&gt; = descriptor&lt;7&gt;:'0';
        permissions.pxn     = descriptor&lt;54&gt;;
    elsif <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        permissions.ap&lt;2:1&gt; = descriptor&lt;7:6&gt;;
        permissions.uxn     = descriptor&lt;54&gt;;
        permissions.pxn     = descriptor&lt;53&gt;;
    else
        permissions.ap&lt;2:1&gt; = descriptor&lt;7&gt;:'1';
        permissions.xn      = descriptor&lt;54&gt;;

    // Descriptors marked with DBM set have the effective value of AP[2] cleared.
    // This implies no permission faults caused by lack of write permissions are
    // reported, and the Dirty bit can be set.
    if walkparams.ha == '1' &amp;&amp; walkparams.hd == '1' &amp;&amp; descriptor&lt;51&gt; == '1' then
        permissions.ap&lt;2&gt; = '0';

    return permissions;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.S1ApplyTablePerms"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.S1ApplyTablePerms</h3>
      <p class="pseudocode">// AArch64.S1ApplyTablePerms()
// ===========================
// Apply hierarchical permissions encoded in stage 1 table descriptors

Permissions <a id="AArch64.S1ApplyTablePerms.4"/>AArch64.S1ApplyTablePerms(<a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> permissions, bits(64) descriptor,
                                      <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams)
    if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; walkparams.nv1 == '1' then
        ap_table  = descriptor&lt;62&gt;:'0';
        pxn_table = descriptor&lt;60&gt;;
        permissions.ap_table  = permissions.ap_table  OR ap_table;
        permissions.pxn_table = permissions.pxn_table OR pxn_table;

    elsif <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        ap_table  = descriptor&lt;62:61&gt;;
        uxn_table = descriptor&lt;60&gt;;
        pxn_table = descriptor&lt;59&gt;;
        permissions.ap_table  = permissions.ap_table  OR ap_table;
        permissions.uxn_table = permissions.uxn_table OR uxn_table;
        permissions.pxn_table = permissions.pxn_table OR pxn_table;
    else
        ap_table = descriptor&lt;62&gt;:'0';
        xn_table = descriptor&lt;60&gt;;
        permissions.ap_table = permissions.ap_table OR ap_table;
        permissions.xn_table = permissions.xn_table OR xn_table;

    return permissions;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_ttentry.AArch64.S2ApplyOutputPerms"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_ttentry/AArch64.S2ApplyOutputPerms</h3>
      <p class="pseudocode">// AArch64.S2ApplyOutputPerms()
// ============================
// Apply output permissions encoded in stage 2 page/block descriptors

Permissions <a id="AArch64.S2ApplyOutputPerms.2"/>AArch64.S2ApplyOutputPerms(bits(64) descriptor, <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> permissions;

    permissions.s2ap = descriptor&lt;7:6&gt;;
    permissions.s2xn = descriptor&lt;54&gt;;

    if <a href="shared_pseudocode.html#impl-shared.HaveExtendedExecuteNeverExt.0" title="function: boolean HaveExtendedExecuteNeverExt()">HaveExtendedExecuteNeverExt</a>() then
        permissions.s2xnx = descriptor&lt;53&gt;;
    else
        permissions.s2xnx = '0';

    // Descriptors marked with DBM set have the effective value of S2AP[1] set.
    // This implies no permission faults caused by lack of write permissions are
    // reported, and the Dirty bit can be set.
    if walkparams.ha == '1' &amp;&amp; walkparams.hd == '1' &amp;&amp; descriptor&lt;51&gt; == '1' then
        permissions.s2ap&lt;1&gt; = '1';

    return permissions;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S1InitialTTWState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S1InitialTTWState</h3>
      <p class="pseudocode">// AArch64.S1InitialTTWState()
// ===========================
// Set properties of first access to translation tables in stage 1

TTWState <a id="AArch64.S1InitialTTWState.4"/>AArch64.S1InitialTTWState(<a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, bits(64) va, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime,
                                   <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase;
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a> permissions;

    startlevel  = <a href="shared_pseudocode.html#AArch64.S1StartLevel.1" title="function: integer AArch64.S1StartLevel(S1TTWParams walkparams)">AArch64.S1StartLevel</a>(walkparams);
    ttbr        = <a href="shared_pseudocode.html#AArch64.S1TTBR.2" title="function: bits(64) AArch64.S1TTBR(Regime regime, bits(64) va)">AArch64.S1TTBR</a>(regime, va);
    case ss of
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>    tablebase.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> tablebase.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>      tablebase.paspace = <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     tablebase.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;

    tablebase.address = <a href="shared_pseudocode.html#AArch64.TTBaseAddress.6" title="function: bits(52) AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,&#13; bit ds, TGx tgx, integer startlevel)">AArch64.TTBaseAddress</a>(ttbr, walkparams.txsz, walkparams.ps, walkparams.ds,
                                              walkparams.tgx, startlevel);

    permissions.ap_table = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        permissions.uxn_table = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
        permissions.pxn_table = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    else
        permissions.xn_table  = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    walkstate.baseaddress = tablebase;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    // In regimes that support global and non-global translations, translation
    // table entries from lookup levels other than the final level of lookup
    // are treated as being non-global
    walkstate.nG          = if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then '1' else '0';
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);
    walkstate.permissions = permissions;

    return walkstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S1NextWalkStateLast"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S1NextWalkStateLast</h3>
      <p class="pseudocode">// AArch64.S1NextWalkStateLast()
// =============================
// Decode stage 1 page or block descriptor as output to this stage of translation

TTWState <a id="AArch64.S1NextWalkStateLast.5"/>AArch64.S1NextWalkStateLast(<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                     <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, bits(64) descriptor)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress;

    if currentstate.level == <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        baseaddress.address = <a href="shared_pseudocode.html#AArch64.PageBase.3" title="function: bits(52) AArch64.PageBase(bits(64) descriptor, bit ds, TGx tgx)">AArch64.PageBase</a>(descriptor, walkparams.ds, walkparams.tgx);
    else
        baseaddress.address = <a href="shared_pseudocode.html#AArch64.BlockBase.4" title="function: bits(52) AArch64.BlockBase(bits(64) descriptor, bit ds, TGx tgx, integer level)">AArch64.BlockBase</a>(descriptor, walkparams.ds, walkparams.tgx,
                                                currentstate.level);

    if currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        // Determine PA space of the block from NS bit
        baseaddress.paspace = if descriptor&lt;5&gt; == '0' then <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    elsif currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a> then
        // Determine PA space of the block from NSE and NS bits
        case descriptor&lt;11,5&gt; of
            when '00' baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
            when '01' baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
            when '10' baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>;
            when '11' baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
    elsif (currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> &amp;&amp;
            regime IN {<a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>, <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>}) then
        // Realm EL2 and EL2&amp;0 regimes have a stage 1 NS bit
        baseaddress.paspace = if descriptor&lt;5&gt; == '0' then <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    elsif currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a> then
        // Realm EL1&amp;0 regime does not have a stage 1 NS bit
        baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
    else
        baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    nextstate.istable     = FALSE;
    nextstate.level       = currentstate.level;
    nextstate.baseaddress = baseaddress;

    attrindx = descriptor&lt;4:2&gt;;
    sh = if walkparams.ds == '1' then walkparams.sh else descriptor&lt;9:8&gt;;
    attr = <a href="shared_pseudocode.html#impl-shared.MAIRAttr.2" title="function: bits(8) MAIRAttr(integer index, MAIRType mair)">MAIRAttr</a>(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(attrindx), walkparams.mair);
    s1aarch64 = TRUE;

    nextstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.S1DecodeMemAttrs.3" title="function: MemoryAttributes S1DecodeMemAttrs(bits(8) attr, bits(2) sh, boolean s1aarch64)">S1DecodeMemAttrs</a>(attr, sh, s1aarch64);
    nextstate.permissions = <a href="shared_pseudocode.html#AArch64.S1ApplyOutputPerms.4" title="function: Permissions AArch64.S1ApplyOutputPerms(Permissions permissions, bits(64) descriptor,&#13; Regime regime, S1TTWParams walkparams)">AArch64.S1ApplyOutputPerms</a>(currentstate.permissions, descriptor,
                                                       regime, walkparams);
    nextstate.contiguous  = <a href="shared_pseudocode.html#AArch64.ContiguousBit.3" title="function: bit AArch64.ContiguousBit(TGx tgx, integer level, bits(64) descriptor)">AArch64.ContiguousBit</a>(walkparams.tgx, currentstate.level, descriptor);

    if !<a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) then
        nextstate.nG = '0';
    elsif ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> &amp;&amp; currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        // In Secure state, a translation must be treated as non-global,
        // regardless of the value of the nG bit,
        // if NSTable is set to 1 at any level of the translation table walk
        nextstate.nG = '1';
    else
        nextstate.nG = descriptor&lt;11&gt;;

    nextstate.guardedpage = descriptor&lt;50&gt;;

    return nextstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S1NextWalkStateTable"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S1NextWalkStateTable</h3>
      <p class="pseudocode">// AArch64.S1NextWalkStateTable()
// ==============================
// Decode stage 1 table descriptor to transition to the next level

TTWState <a id="AArch64.S1NextWalkStateTable.4"/>AArch64.S1NextWalkStateTable(<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams,
                                      bits(64) descriptor)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase;

    tablebase.address = <a href="shared_pseudocode.html#AArch64.NextTableBase.3" title="function: bits(52) AArch64.NextTableBase(bits(64) descriptor, bit ds, TGx tgx)">AArch64.NextTableBase</a>(descriptor, walkparams.ds, walkparams.tgx);
    if currentstate.baseaddress.paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        // Determine PA space of the next table from NSTable bit
        tablebase.paspace = if descriptor&lt;63&gt; == '0' then <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> else <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    else
        // Otherwise bit 63 is RES0 and there is no NSTable bit
        tablebase.paspace = currentstate.baseaddress.paspace;

    nextstate.istable     = TRUE;
    nextstate.nG          = currentstate.nG;
    nextstate.level       = currentstate.level + 1;
    nextstate.baseaddress = tablebase;
    nextstate.memattrs    = currentstate.memattrs;

    if walkparams.hpd == '0' then
        nextstate.permissions = <a href="shared_pseudocode.html#AArch64.S1ApplyTablePerms.4" title="function: Permissions AArch64.S1ApplyTablePerms(Permissions permissions, bits(64) descriptor,&#13; Regime regime, S1TTWParams walkparams)">AArch64.S1ApplyTablePerms</a>(currentstate.permissions, descriptor,
                                                          regime, walkparams);
    else
        nextstate.permissions = currentstate.permissions;

    return nextstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S1Walk"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S1Walk</h3>
      <p class="pseudocode">// AArch64.S1Walk()
// ================
// Traverse stage 1 translation tables obtaining the final descriptor
// as well as the address leading to that descriptor

(FaultRecord, AddressDescriptor, TTWState, bits(64)) <a id="AArch64.S1Walk.8"/>AArch64.S1Walk(
        <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams, bits(64) va, <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
        <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, boolean ispriv)
    if <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime) &amp;&amp; <a href="shared_pseudocode.html#AArch64.S1EPD.2" title="function: bit AArch64.S1EPD(Regime regime, bits(64) va)">AArch64.S1EPD</a>(regime, va) == '1' then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

    if !ispriv &amp;&amp; walkparams.nfd == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsDataAccess.1" title="function: boolean IsDataAccess(AccType acctype)">IsDataAccess</a>(acctype) &amp;&amp; TSTATE.depth &gt; 0 then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

    if !ispriv &amp;&amp; walkparams.nfd == '1' &amp;&amp; acctype == <a href="shared_pseudocode.html#AccType_NONFAULT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NONFAULT</a> then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

    if <a href="shared_pseudocode.html#AArch64.S1InvalidTxSZ.1" title="function: boolean AArch64.S1InvalidTxSZ(S1TTWParams walkparams)">AArch64.S1InvalidTxSZ</a>(walkparams) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

    walkstate = <a href="shared_pseudocode.html#AArch64.S1InitialTTWState.4" title="function: TTWState AArch64.S1InitialTTWState(S1TTWParams walkparams, bits(64) va, Regime regime,&#13; SecurityState ss)">AArch64.S1InitialTTWState</a>(walkparams, va, regime, ss);

    // Detect Address Size Fault by TTB
    if <a href="shared_pseudocode.html#AArch64.OAOutOfRange.4" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, va) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

    bits(64) descriptor;
    repeat
        fault.level = walkstate.level;
        <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> descaddress = <a href="shared_pseudocode.html#AArch64.TTEntryAddress.5" title="function: FullAddress AArch64.TTEntryAddress(integer level, TGx tgx, bits(6) txsz,&#13; bits(64) ia, FullAddress tablebase)">AArch64.TTEntryAddress</a>(walkstate.level, walkparams.tgx,
                                                         walkparams.txsz, va,
                                                         walkstate.baseaddress);

        if !<a href="shared_pseudocode.html#AArch64.S1DCacheEnabled.1" title="function: boolean AArch64.S1DCacheEnabled(Regime regime)">AArch64.S1DCacheEnabled</a>(regime) then
            walkmemattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
            walkmemattrs.xs = walkstate.memattrs.xs;
        else
            walkmemattrs = walkstate.memattrs;

        // Shareability value of stage 1 translation subject to stage 2 is IMPLEMENTATION DEFINED
        // to be either effective value or descriptor value
        if (regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.VM == '1' &amp;&amp;
                !(boolean IMPLEMENTATION_DEFINED "Apply effective shareability at stage 1")) then
            walkmemattrs.shareability = walkstate.memattrs.shareability;
        else
            walkmemattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkmemattrs);

        walkaddress = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(va, descaddress, walkmemattrs);

        if regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
            s1aarch64 = TRUE;
            s2fs1walk = TRUE;
            aligned   = TRUE;
            iswrite   = FALSE;
            (s2fault, s2walkaddress) = <a href="shared_pseudocode.html#AArch64.S2Translate.9" title="function: (FaultRecord, AddressDescriptor) AArch64.S2Translate(FaultRecord fault, AddressDescriptor ipa,&#13; boolean s1aarch64, SecurityState ss,&#13; boolean s2fs1walk, AccType acctype,&#13; boolean aligned, boolean iswrite,&#13; boolean ispriv)">AArch64.S2Translate</a>(fault, walkaddress, s1aarch64, ss,
                                                           s2fs1walk, <a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>, aligned,
                                                           iswrite, ispriv);

            if s2fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
                return (s2fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.3" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; FaultRecord fault)">FetchDescriptor</a>(walkparams.ee, s2walkaddress, fault);
        else
            (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.3" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; FaultRecord fault)">FetchDescriptor</a>(walkparams.ee, walkaddress, fault);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

        desctype = <a href="shared_pseudocode.html#AArch64.DecodeDescriptorType.4" title="function: DescriptorType AArch64.DecodeDescriptorType(bits(64) descriptor, bit ds,&#13; TGx tgx, integer level)">AArch64.DecodeDescriptorType</a>(descriptor, walkparams.ds, walkparams.tgx,
                                                walkstate.level);

        case desctype of
            when <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                walkstate = <a href="shared_pseudocode.html#AArch64.S1NextWalkStateTable.4" title="function: TTWState AArch64.S1NextWalkStateTable(TTWState currentstate, Regime regime, S1TTWParams walkparams,&#13; bits(64) descriptor)">AArch64.S1NextWalkStateTable</a>(walkstate, regime, walkparams,
                                                         descriptor);

                // Detect Address Size Fault by table descriptor
                if <a href="shared_pseudocode.html#AArch64.OAOutOfRange.4" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, va) then
                    fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                    return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

            when <a href="shared_pseudocode.html#DescriptorType_Page" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>
                walkstate = <a href="shared_pseudocode.html#AArch64.S1NextWalkStateLast.5" title="function: TTWState AArch64.S1NextWalkStateLast(TTWState currentstate, Regime regime, SecurityState ss,&#13; S1TTWParams walkparams, bits(64) descriptor)">AArch64.S1NextWalkStateLast</a>(walkstate, regime, ss,
                                                        walkparams, descriptor);

            when <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

            otherwise
                <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    until desctype IN {<a href="shared_pseudocode.html#DescriptorType_Page" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>};

    if (walkstate.contiguous == '1' &amp;&amp;
            <a href="shared_pseudocode.html#AArch64.ContiguousBitFaults.3" title="function: boolean AArch64.ContiguousBitFaults(bits(6) txsz, TGx tgx, integer level)">AArch64.ContiguousBitFaults</a>(walkparams.txsz, walkparams.tgx, walkstate.level)) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    elsif desctype == <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a> &amp;&amp; <a href="shared_pseudocode.html#AArch64.BlocknTFaults.1" title="function: boolean AArch64.BlocknTFaults(bits(64) descriptor)">AArch64.BlocknTFaults</a>(descriptor) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    // Detect Address Size Fault by final output
    elsif <a href="shared_pseudocode.html#AArch64.OAOutOfRange.4" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, va) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
    // Check descriptor AF bit
    elsif (descriptor&lt;10&gt; == '0' &amp;&amp; walkparams.ha == '0' &amp;&amp;
            !(acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>} &amp;&amp;
            !boolean IMPLEMENTATION_DEFINED "Generate access flag fault on IC/DC operations")) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;

    return (fault, walkaddress, walkstate, descriptor);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S2InitialTTWState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S2InitialTTWState</h3>
      <p class="pseudocode">// AArch64.S2InitialTTWState()
// ===========================
// Set properties of first access to translation tables in stage 2

TTWState <a id="AArch64.S2InitialTTWState.2"/>AArch64.S2InitialTTWState(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase;

    ttbr              = VTTBR_EL2;
    startlevel        = <a href="shared_pseudocode.html#AArch64.S2StartLevel.1" title="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</a>(walkparams);
    case ss of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> tablebase.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>     tablebase.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
    tablebase.address = <a href="shared_pseudocode.html#AArch64.TTBaseAddress.6" title="function: bits(52) AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,&#13; bit ds, TGx tgx, integer startlevel)">AArch64.TTBaseAddress</a>(ttbr, walkparams.txsz, walkparams.ps, walkparams.ds,
                                              walkparams.tgx, startlevel);

    walkstate.baseaddress = tablebase;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);

    return walkstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S2NextWalkStateLast"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S2NextWalkStateLast</h3>
      <p class="pseudocode">// AArch64.S2NextWalkStateLast()
// =============================
// Decode stage 2 page or block descriptor as output to this stage of translation

TTWState <a id="AArch64.S2NextWalkStateLast.5"/>AArch64.S2NextWalkStateLast(<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
                                     <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa,
                                     bits(64) descriptor)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> baseaddress;

    if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        baseaddress.paspace = <a href="shared_pseudocode.html#AArch64.SS2OutputPASpace.2" title="function: PASpace AArch64.SS2OutputPASpace(S2TTWParams walkparams, PASpace ipaspace)">AArch64.SS2OutputPASpace</a>(walkparams, ipa.paddress.paspace);
    elsif ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> then
        if descriptor&lt;55&gt; == '1' then
            baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        else
            baseaddress.paspace = <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
    else
        baseaddress.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    if currentstate.level == <a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> then
        baseaddress.address = <a href="shared_pseudocode.html#AArch64.PageBase.3" title="function: bits(52) AArch64.PageBase(bits(64) descriptor, bit ds, TGx tgx)">AArch64.PageBase</a>(descriptor, walkparams.ds, walkparams.tgx);
    else
        baseaddress.address = <a href="shared_pseudocode.html#AArch64.BlockBase.4" title="function: bits(52) AArch64.BlockBase(bits(64) descriptor, bit ds, TGx tgx, integer level)">AArch64.BlockBase</a>(descriptor, walkparams.ds, walkparams.tgx,
                                                currentstate.level);

    nextstate.istable     = FALSE;
    nextstate.level       = currentstate.level;
    nextstate.baseaddress = baseaddress;
    nextstate.permissions = <a href="shared_pseudocode.html#AArch64.S2ApplyOutputPerms.2" title="function: Permissions AArch64.S2ApplyOutputPerms(bits(64) descriptor, S2TTWParams walkparams)">AArch64.S2ApplyOutputPerms</a>(descriptor, walkparams);

    s2_attr = descriptor&lt;5:2&gt;;
    s2_sh   = if walkparams.ds == '1' then walkparams.sh else descriptor&lt;9:8&gt;;
    s2_fnxs = descriptor&lt;11&gt;;
    if walkparams.fwb == '1' then
        nextstate.memattrs = <a href="shared_pseudocode.html#AArch64.S2ApplyFWBMemAttrs.3" title="function: MemoryAttributes AArch64.S2ApplyFWBMemAttrs(MemoryAttributes s1_memattrs,&#13; bits(4) s2_attr, bits(2) s2_sh)">AArch64.S2ApplyFWBMemAttrs</a>(ipa.memattrs, s2_attr, s2_sh);
        if s2_attr&lt;1:0&gt; == '10' then    // Force writeback
            nextstate.memattrs.xs = '0';
        else
            nextstate.memattrs.xs = if s2_fnxs == '1' then '0' else ipa.memattrs.xs;
    else
        nextstate.memattrs = <a href="shared_pseudocode.html#impl-shared.S2DecodeMemAttrs.2" title="function: MemoryAttributes S2DecodeMemAttrs(bits(4) attr, bits(2) sh)">S2DecodeMemAttrs</a>(s2_attr, s2_sh);
        nextstate.memattrs.xs = if s2_fnxs == '1' then '0' else ipa.memattrs.xs;
    nextstate.contiguous = <a href="shared_pseudocode.html#AArch64.ContiguousBit.3" title="function: bit AArch64.ContiguousBit(TGx tgx, integer level, bits(64) descriptor)">AArch64.ContiguousBit</a>(walkparams.tgx, currentstate.level, descriptor);

    return nextstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S2NextWalkStateTable"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S2NextWalkStateTable</h3>
      <p class="pseudocode">// AArch64.S2NextWalkStateTable()
// ==============================
// Decode stage 2 table descriptor to transition to the next level

TTWState <a id="AArch64.S2NextWalkStateTable.3"/>AArch64.S2NextWalkStateTable(<a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> currentstate, <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams,
                                      bits(64) descriptor)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    nextstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase;

    tablebase.address = <a href="shared_pseudocode.html#AArch64.NextTableBase.3" title="function: bits(52) AArch64.NextTableBase(bits(64) descriptor, bit ds, TGx tgx)">AArch64.NextTableBase</a>(descriptor, walkparams.ds, walkparams.tgx);
    tablebase.paspace = currentstate.baseaddress.paspace;

    nextstate.istable     = TRUE;
    nextstate.level       = currentstate.level + 1;
    nextstate.baseaddress = tablebase;
    nextstate.memattrs    = currentstate.memattrs;

    return nextstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.S2Walk"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.S2Walk</h3>
      <p class="pseudocode">// AArch64.S2Walk()
// ================
// Traverse stage 2 translation tables obtaining the final descriptor
// as well as the address leading to that descriptor

(FaultRecord, AddressDescriptor, TTWState, bits(64)) <a id="AArch64.S2Walk.7"/>AArch64.S2Walk(
        <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> ipa, <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
        <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, boolean s1aarch64)

    ipa_64 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address, 64);

    if (<a href="shared_pseudocode.html#AArch64.S2InvalidTxSZ.2" title="function: boolean AArch64.S2InvalidTxSZ(S2TTWParams walkparams, boolean s1aarch64)">AArch64.S2InvalidTxSZ</a>(walkparams, s1aarch64) ||
            <a href="shared_pseudocode.html#AArch64.S2InvalidSL.1" title="function: boolean AArch64.S2InvalidSL(S2TTWParams walkparams)">AArch64.S2InvalidSL</a>(walkparams) ||
            <a href="shared_pseudocode.html#AArch64.S2InconsistentSL.1" title="function: boolean AArch64.S2InconsistentSL(S2TTWParams walkparams)">AArch64.S2InconsistentSL</a>(walkparams)) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

    if ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        walkstate = <a href="shared_pseudocode.html#AArch64.SS2InitialTTWState.2" title="function: TTWState AArch64.SS2InitialTTWState(S2TTWParams walkparams, PASpace ipaspace)">AArch64.SS2InitialTTWState</a>(walkparams, ipa.paddress.paspace);
    else
        walkstate = <a href="shared_pseudocode.html#AArch64.S2InitialTTWState.2" title="function: TTWState AArch64.S2InitialTTWState(SecurityState ss, S2TTWParams walkparams)">AArch64.S2InitialTTWState</a>(ss, walkparams);

    // Detect Address Size Fault by TTB
    if <a href="shared_pseudocode.html#AArch64.OAOutOfRange.4" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, ipa_64) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
        fault.level      = 0;
        return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

    bits(64) descriptor;
    repeat
        fault.level = walkstate.level;

        <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> descaddress;
        if walkstate.level == <a href="shared_pseudocode.html#AArch64.S2StartLevel.1" title="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</a>(walkparams) then
            // Initial lookup might index into concatenated tables
            descaddress = <a href="shared_pseudocode.html#AArch64.S2SLTTEntryAddress.3" title="function: FullAddress AArch64.S2SLTTEntryAddress(S2TTWParams walkparams, bits(52) ipa,&#13; FullAddress tablebase)">AArch64.S2SLTTEntryAddress</a>(walkparams, ipa.paddress.address,
                                                     walkstate.baseaddress);
        else
            ipa_64 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(ipa.paddress.address, 64);
            descaddress = <a href="shared_pseudocode.html#AArch64.TTEntryAddress.5" title="function: FullAddress AArch64.TTEntryAddress(integer level, TGx tgx, bits(6) txsz,&#13; bits(64) ia, FullAddress tablebase)">AArch64.TTEntryAddress</a>(walkstate.level, walkparams.tgx, walkparams.txsz,
                                                 ipa_64, walkstate.baseaddress);

        if HCR_EL2.CD == '1' then
            walkmemattrs = <a href="shared_pseudocode.html#impl-shared.NormalNCMemAttr.0" title="function: MemoryAttributes NormalNCMemAttr()">NormalNCMemAttr</a>();
            walkmemattrs.xs = walkstate.memattrs.xs;
        else
            walkmemattrs = walkstate.memattrs;

        // VA parameter is for the Abort() call on the other side of _Mem
        walkaddress = <a href="shared_pseudocode.html#impl-shared.CreateAddressDescriptor.3" title="function: AddressDescriptor CreateAddressDescriptor(bits(64) va, FullAddress pa,&#13; MemoryAttributes memattrs)">CreateAddressDescriptor</a>(ipa.vaddress, descaddress, walkmemattrs);

        walkaddress.memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(walkaddress.memattrs);
        (fault, descriptor) = <a href="shared_pseudocode.html#impl-shared.FetchDescriptor.3" title="function: (FaultRecord, bits(N)) FetchDescriptor(bit ee, AddressDescriptor walkaddress,&#13; FaultRecord fault)">FetchDescriptor</a>(walkparams.ee, walkaddress, fault);

        if fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a> then
            return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

        desctype = <a href="shared_pseudocode.html#AArch64.DecodeDescriptorType.4" title="function: DescriptorType AArch64.DecodeDescriptorType(bits(64) descriptor, bit ds,&#13; TGx tgx, integer level)">AArch64.DecodeDescriptorType</a>(descriptor, walkparams.ds, walkparams.tgx,
                                                walkstate.level);

        case desctype of
            when <a href="shared_pseudocode.html#DescriptorType_Table" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Table</a>
                walkstate = <a href="shared_pseudocode.html#AArch64.S2NextWalkStateTable.3" title="function: TTWState AArch64.S2NextWalkStateTable(TTWState currentstate, S2TTWParams walkparams,&#13; bits(64) descriptor)">AArch64.S2NextWalkStateTable</a>(walkstate, walkparams, descriptor);

                // Detect Address Size Fault by table descriptor
                if <a href="shared_pseudocode.html#AArch64.OAOutOfRange.4" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, ipa_64) then
                    fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
                    return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

            when <a href="shared_pseudocode.html#DescriptorType_Page" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>
                walkstate = <a href="shared_pseudocode.html#AArch64.S2NextWalkStateLast.5" title="function: TTWState AArch64.S2NextWalkStateLast(TTWState currentstate, SecurityState ss,&#13; S2TTWParams walkparams, AddressDescriptor ipa,&#13; bits(64) descriptor)">AArch64.S2NextWalkStateLast</a>(walkstate, ss, walkparams, ipa,
                                                        descriptor);

            when <a href="shared_pseudocode.html#DescriptorType_Invalid" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Invalid</a>
                fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
                return (fault, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> UNKNOWN, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> UNKNOWN, bits(64) UNKNOWN);

            otherwise
                <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    until desctype IN {<a href="shared_pseudocode.html#DescriptorType_Page" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Page</a>, <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a>};

    if (walkstate.contiguous == '1' &amp;&amp;
            <a href="shared_pseudocode.html#AArch64.ContiguousBitFaults.3" title="function: boolean AArch64.ContiguousBitFaults(bits(6) txsz, TGx tgx, integer level)">AArch64.ContiguousBitFaults</a>(walkparams.txsz, walkparams.tgx, walkstate.level)) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    elsif desctype == <a href="shared_pseudocode.html#DescriptorType_Block" title="enumeration DescriptorType {&#13; DescriptorType_Table,&#13; DescriptorType_Block,&#13; DescriptorType_Page,&#13; DescriptorType_Invalid&#13; }">DescriptorType_Block</a> &amp;&amp; <a href="shared_pseudocode.html#AArch64.BlocknTFaults.1" title="function: boolean AArch64.BlocknTFaults(bits(64) descriptor)">AArch64.BlocknTFaults</a>(descriptor) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>;
    // Detect Address Size Fault by final output
    elsif <a href="shared_pseudocode.html#AArch64.OAOutOfRange.4" title="function: boolean AArch64.OAOutOfRange(TTWState walkstate, bits(3) ps, TGx tgx, bits(64) ia)">AArch64.OAOutOfRange</a>(walkstate, walkparams.ps, walkparams.tgx, ipa_64) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>;
    // Check descriptor AF bit
    elsif (descriptor&lt;10&gt; == '0' &amp;&amp; walkparams.ha == '0' &amp;&amp;
            !(acctype IN {<a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>} &amp;&amp;
            !boolean IMPLEMENTATION_DEFINED "Generate access flag fault on IC/DC operations")) then
        fault.statuscode = <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>;

    return (fault, walkaddress, walkstate, descriptor);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.SS2InitialTTWState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.SS2InitialTTWState</h3>
      <p class="pseudocode">// AArch64.SS2InitialTTWState()
// ============================
// Set properties of first access to translation tables in Secure stage 2

TTWState <a id="AArch64.SS2InitialTTWState.2"/>AArch64.SS2InitialTTWState(<a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> ipaspace)
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate;
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> tablebase;

    if ipaspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        ttbr = VSTTBR_EL2;
    else
        ttbr = VTTBR_EL2;

    if ipaspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        if walkparams.sw == '0' then
            tablebase.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        else
            tablebase.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    else
        if walkparams.nsw == '0' then
            tablebase.paspace = <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        else
            tablebase.paspace = <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;

    startlevel        = <a href="shared_pseudocode.html#AArch64.S2StartLevel.1" title="function: integer AArch64.S2StartLevel(S2TTWParams walkparams)">AArch64.S2StartLevel</a>(walkparams);
    tablebase.address = <a href="shared_pseudocode.html#AArch64.TTBaseAddress.6" title="function: bits(52) AArch64.TTBaseAddress(bits(64) ttb, bits(6) txsz, bits(3) ps,&#13; bit ds, TGx tgx, integer startlevel)">AArch64.TTBaseAddress</a>(ttbr, walkparams.txsz, walkparams.ps, walkparams.ds,
                                              walkparams.tgx, startlevel);

    walkstate.baseaddress = tablebase;
    walkstate.level       = startlevel;
    walkstate.istable     = TRUE;
    walkstate.memattrs    = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(walkparams.sh, walkparams.irgn, walkparams.orgn);

    return walkstate;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walk.AArch64.SS2OutputPASpace"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walk/AArch64.SS2OutputPASpace</h3>
      <p class="pseudocode">// AArch64.SS2OutputPASpace()
// ==========================
// Assign PA Space to output of Secure stage 2 translation

PASpace <a id="AArch64.SS2OutputPASpace.2"/>AArch64.SS2OutputPASpace(<a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> ipaspace)
    if ipaspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        if walkparams.&lt;sw,sa&gt; == '00' then
            return <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        else
            return <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
    else
        if walkparams.&lt;sw,sa,nsw,nsa&gt; == '0000' then
            return <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        else
            return <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.BBMSupportLevel"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.BBMSupportLevel</h3>
      <p class="pseudocode">// AArch64.BBMSupportLevel()
// =========================
// Returns the level of FEAT_BBM supported

integer <a id="AArch64.BlockBBMSupportLevel.0"/>AArch64.BlockBBMSupportLevel()
    if !<a href="shared_pseudocode.html#impl-shared.HaveBlockBBM.0" title="function: boolean HaveBlockBBM()">HaveBlockBBM</a>() then
        return integer UNKNOWN;
    else
        return integer IMPLEMENTATION_DEFINED "Block BBM support level";</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.CurrentSecurityState"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.CurrentSecurityState</h3>
      <p class="pseudocode">// AArch64.CurrentSecurityState()
// ==============================
// Return secutity state of current EL

SecurityState <a id="AArch64.CurrentSecurityState.0"/>AArch64.CurrentSecurityState()
    return <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.DecodeTG0"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.DecodeTG0</h3>
      <p class="pseudocode">// AArch64.DecodeTG0()
// ===================
// Decode granule size configuration bits TG0

TGx <a id="AArch64.DecodeTG0.1"/>AArch64.DecodeTG0(bits(2) tg0)
    if tg0 == '11' then
        tg0 = bits(2) IMPLEMENTATION_DEFINED "Reserved TG0 encoding granule size";

    case tg0 of
        when '00'   return <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
        when '01'   return <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;
        when '10'   return <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.DecodeTG1"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.DecodeTG1</h3>
      <p class="pseudocode">// AArch64.DecodeTG1()
// ===================
// Decode granule size configuration bits TG1

TGx <a id="AArch64.DecodeTG1.1"/>AArch64.DecodeTG1(bits(2) tg1)
    if tg1 == '00' then
        tg1 = bits(2) IMPLEMENTATION_DEFINED "Reserved TG1 encoding granule size";

    case tg1 of
        when '10'   return <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>;
        when '11'   return <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>;
        when '01'   return <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.GetS1TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.GetS1TTWParams</h3>
      <p class="pseudocode">// AArch64.GetS1TTWParams()
// ========================
// Returns stage 1 translation table walk parameters from respective controlling
// system registers.

S1TTWParams <a id="AArch64.GetS1TTWParams.2"/>AArch64.GetS1TTWParams(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) va)
    <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    varange = <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  walkparams = <a href="shared_pseudocode.html#AArch64.S1TTWParamsEL3.0" title="function: S1TTWParams AArch64.S1TTWParamsEL3()">AArch64.S1TTWParamsEL3</a>();
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  walkparams = <a href="shared_pseudocode.html#AArch64.S1TTWParamsEL2.0" title="function: S1TTWParams AArch64.S1TTWParamsEL2()">AArch64.S1TTWParamsEL2</a>();
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> walkparams = <a href="shared_pseudocode.html#AArch64.S1TTWParamsEL20.1" title="function: S1TTWParams AArch64.S1TTWParamsEL20(VARange varange)">AArch64.S1TTWParamsEL20</a>(varange);
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> walkparams = <a href="shared_pseudocode.html#AArch64.S1TTWParamsEL10.1" title="function: S1TTWParams AArch64.S1TTWParamsEL10(VARange varange)">AArch64.S1TTWParamsEL10</a>(varange);

    maxtxsz = <a href="shared_pseudocode.html#AArch64.MaxTxSZ.1" title="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);
    mintxsz = <a href="shared_pseudocode.html#AArch64.S1MinTxSZ.2" title="function: integer AArch64.S1MinTxSZ(bit ds, TGx tgx)">AArch64.S1MinTxSZ</a>(walkparams.ds, walkparams.tgx);
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; maxtxsz then
        if !(boolean IMPLEMENTATION_DEFINED "<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value above maximum") then
            walkparams.txsz = maxtxsz&lt;5:0&gt;;
    elsif !<a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()">Have52BitVAExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; mintxsz then
        if !(boolean IMPLEMENTATION_DEFINED "<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value below minimum") then
            walkparams.txsz = mintxsz&lt;5:0&gt;;

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.GetS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.GetS2TTWParams</h3>
      <p class="pseudocode">// AArch64.GetS2TTWParams()
// ========================
// Gather walk parameters for stage 2 translation

S2TTWParams <a id="AArch64.GetS2TTWParams.3"/>AArch64.GetS2TTWParams(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss, <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> ipaspace, boolean s1aarch64)
    <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams;

    if ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
        walkparams = <a href="shared_pseudocode.html#AArch64.NSS2TTWParams.1" title="function: S2TTWParams AArch64.NSS2TTWParams(boolean s1aarch64)">AArch64.NSS2TTWParams</a>(s1aarch64);
    elsif <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        walkparams = <a href="shared_pseudocode.html#AArch64.SS2TTWParams.2" title="function: S2TTWParams AArch64.SS2TTWParams(PASpace ipaspace, boolean s1aarch64)">AArch64.SS2TTWParams</a>(ipaspace, s1aarch64);
    elsif ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> then
        // Realm stage 2 walk parameters are the same as for Non-secure
        walkparams = <a href="shared_pseudocode.html#AArch64.NSS2TTWParams.1" title="function: S2TTWParams AArch64.NSS2TTWParams(boolean s1aarch64)">AArch64.NSS2TTWParams</a>(s1aarch64);
    else
        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    maxtxsz = <a href="shared_pseudocode.html#AArch64.MaxTxSZ.1" title="function: integer AArch64.MaxTxSZ(TGx tgx)">AArch64.MaxTxSZ</a>(walkparams.tgx);
    mintxsz = <a href="shared_pseudocode.html#AArch64.S2MinTxSZ.3" title="function: integer AArch64.S2MinTxSZ(bit ds, TGx tgx, boolean s1aarch64)">AArch64.S2MinTxSZ</a>(walkparams.ds, walkparams.tgx, s1aarch64);
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &gt; maxtxsz then
        if !(boolean IMPLEMENTATION_DEFINED "<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value above maximum") then
            walkparams.txsz = maxtxsz&lt;5:0&gt;;
    elsif !<a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(walkparams.txsz) &lt; mintxsz then
        if !(boolean IMPLEMENTATION_DEFINED "<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> on TxSZ value below minimum") then
            walkparams.txsz = mintxsz&lt;5:0&gt;;

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.GetVARange"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.GetVARange</h3>
      <p class="pseudocode">// AArch64.GetVARange()
// ====================
// Determines if the VA that is to be translated lies in LOWER or UPPER address range.

VARange <a id="AArch64.GetVARange.1"/>AArch64.GetVARange(bits(64) va)
    if va&lt;55&gt; == '0' then
        return <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a>;
    else
        return <a href="shared_pseudocode.html#VARange_UPPER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_UPPER</a>;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.MaxTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.MaxTxSZ</h3>
      <p class="pseudocode">// AArch64.MaxTxSZ()
// =================
// Retrieve the maximum value of TxSZ indicating minimum input address size for both
// stages of translation

integer <a id="AArch64.MaxTxSZ.1"/>AArch64.MaxTxSZ(<a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    if <a href="shared_pseudocode.html#impl-shared.HaveSmallTranslationTableExt.0" title="function: boolean HaveSmallTranslationTableExt()">HaveSmallTranslationTableExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        case tgx of
            when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>   return 48;
            when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>  return 48;
            when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>  return 47;
    return 39;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.NSS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.NSS2TTWParams</h3>
      <p class="pseudocode">// AArch64.NSS2TTWParams()
// =======================
// Gather walk parameters specific for Non-secure stage 2 translation

S2TTWParams <a id="AArch64.NSS2TTWParams.1"/>AArch64.NSS2TTWParams(boolean s1aarch64)
    <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams;

    walkparams.vm   = HCR_EL2.VM OR HCR_EL2.DC;
    walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.DecodeTG0.1" title="function: TGx AArch64.DecodeTG0(bits(2) tg0)">AArch64.DecodeTG0</a>(VTCR_EL2.TG0);
    walkparams.txsz = VTCR_EL2.T0SZ;
    walkparams.sl0  = VTCR_EL2.SL0;
    walkparams.ps   = VTCR_EL2.PS;
    walkparams.irgn = VTCR_EL2.IRGN0;
    walkparams.orgn = VTCR_EL2.ORGN0;
    walkparams.sh   = VTCR_EL2.SH0;
    walkparams.ee   = SCTLR_EL2.EE;

    walkparams.ptw = if HCR_EL2.TGE == '0'         then HCR_EL2.PTW else '0';
    walkparams.fwb = if <a href="shared_pseudocode.html#impl-shared.HaveStage2MemAttrControl.0" title="function: boolean HaveStage2MemAttrControl()">HaveStage2MemAttrControl</a>() then HCR_EL2.FWB else '0';
    walkparams.ha  = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>()  then VTCR_EL2.HA else '0';
    walkparams.hd  = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>()  then VTCR_EL2.HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = VTCR_EL2.DS;
    else
        walkparams.ds = '0';
    if walkparams.tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.sl2 = VTCR_EL2.SL2 AND VTCR_EL2.DS;
    else
        walkparams.sl2 = '0';
    walkparams.cmow = if <a href="shared_pseudocode.html#impl-shared.HaveFeatCMOW.0" title="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() then HCRX_EL2.CMOW else '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.PAMax"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.PAMax</h3>
      <p class="pseudocode">// AArch64.PAMax()
// ===============
// Returns the IMPLEMENTATION DEFINED maximum number of bits capable of representing
// physical address for this processor

integer <a id="AArch64.PAMax.0"/>AArch64.PAMax()
    return integer IMPLEMENTATION_DEFINED "Maximum Physical Address Size";</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1DCacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1DCacheEnabled</h3>
      <p class="pseudocode">// AArch64.S1DCacheEnabled()
// =========================
// Determine cacheability of stage 1 data accesses

boolean <a id="AArch64.S1DCacheEnabled.1"/>AArch64.S1DCacheEnabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return SCTLR_EL3.C == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return SCTLR_EL2.C == '1';
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return SCTLR_EL2.C == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return SCTLR_EL1.C == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1EPD"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1EPD</h3>
      <p class="pseudocode">// AArch64.S1EPD()
// ===============
// Determine whether stage 1 translation table walk is allowed for the VA range

bit <a id="AArch64.S1EPD.2"/>AArch64.S1EPD(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) va)
    assert <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(regime);
    varange = <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TCR_EL2.EPD0 else TCR_EL2.EPD1;
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TCR_EL1.EPD0 else TCR_EL1.EPD1;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1Enabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1Enabled</h3>
      <p class="pseudocode">// AArch64.S1Enabled()
// ===================
// Determine if stage 1 for the acting translation regime is enabled

boolean <a id="AArch64.S1Enabled.1"/>AArch64.S1Enabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return SCTLR_EL3.M == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return SCTLR_EL2.M == '1';
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return SCTLR_EL2.M == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return (!<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() || HCR_EL2.&lt;DC,TGE&gt; == '00') &amp;&amp; SCTLR_EL1.M == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1ICacheEnabled"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1ICacheEnabled</h3>
      <p class="pseudocode">// AArch64.S1ICacheEnabled()
// =========================
// Determine cacheability of stage 1 instruction fetches

boolean <a id="AArch64.S1ICacheEnabled.1"/>AArch64.S1ICacheEnabled(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return SCTLR_EL3.I == '1';
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return SCTLR_EL2.I == '1';
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return SCTLR_EL2.I == '1';
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return SCTLR_EL1.I == '1';</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1MinTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1MinTxSZ</h3>
      <p class="pseudocode">// AArch64.S1MinTxSZ()
// ===================
// Retrieve the minimum value of TxSZ indicating maximum input address size for stage 1

integer <a id="AArch64.S1MinTxSZ.2"/>AArch64.S1MinTxSZ(bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    if (<a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()">Have52BitVAExt</a>() &amp;&amp; tgx == <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>) || ds == '1' then
        return 12;

    return 16;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1TTBR"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1TTBR</h3>
      <p class="pseudocode">// AArch64.S1TTBR()
// ================
// Identify stage 1 table base register for the acting translation regime

bits(64) <a id="AArch64.S1TTBR.2"/>AArch64.S1TTBR(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime, bits(64) va)
    varange = <a href="shared_pseudocode.html#AArch64.GetVARange.1" title="function: VARange AArch64.GetVARange(bits(64) va)">AArch64.GetVARange</a>(va);

    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return TTBR0_EL3;
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return TTBR0_EL2;
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TTBR0_EL2 else TTBR1_EL2;
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then TTBR0_EL1 else TTBR1_EL1;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL10"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL10</h3>
      <p class="pseudocode">// AArch64.S1TTWParamsEL10()
// =========================
// Gather stage 1 translation table walk parameters for EL1&amp;0 regime
// (with EL2 enabled or disabled)

S1TTWParams <a id="AArch64.S1TTWParamsEL10.1"/>AArch64.S1TTWParamsEL10(<a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange)
    <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.DecodeTG0.1" title="function: TGx AArch64.DecodeTG0(bits(2) tg0)">AArch64.DecodeTG0</a>(TCR_EL1.TG0);
        walkparams.txsz = TCR_EL1.T0SZ;
        walkparams.irgn = TCR_EL1.IRGN0;
        walkparams.orgn = TCR_EL1.ORGN0;
        walkparams.sh   = TCR_EL1.SH0;
        walkparams.tbi  = TCR_EL1.TBI0;

        walkparams.nfd  = if <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() || <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then TCR_EL1.NFD0  else '0';
        walkparams.tbid = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL1.TBID0 else '0';
        walkparams.e0pd = if <a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL1.E0PD0 else '0';
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL1.HPD0  else '0';
    else
        walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.DecodeTG1.1" title="function: TGx AArch64.DecodeTG1(bits(2) tg1)">AArch64.DecodeTG1</a>(TCR_EL1.TG1);
        walkparams.txsz = TCR_EL1.T1SZ;
        walkparams.irgn = TCR_EL1.IRGN1;
        walkparams.orgn = TCR_EL1.ORGN1;
        walkparams.sh   = TCR_EL1.SH1;
        walkparams.tbi  = TCR_EL1.TBI1;

        walkparams.nfd  = if <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() || <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then TCR_EL1.NFD1  else '0';
        walkparams.tbid = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL1.TBID1 else '0';
        walkparams.e0pd = if <a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL1.E0PD1 else '0';
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL1.HPD1  else '0';

    walkparams.mair = MAIR_EL1;
    walkparams.wxn  = SCTLR_EL1.WXN;
    walkparams.ps   = TCR_EL1.IPS;
    walkparams.ee   = SCTLR_EL1.EE;
    walkparams.sif  = SCR_EL3.SIF;

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        walkparams.dc  = HCR_EL2.DC;
        walkparams.dct = if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then HCR_EL2.DCT else '0';

    if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        walkparams.ntlsmd = SCTLR_EL1.nTLSMD;
    else
        walkparams.ntlsmd = '1';

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then
        if HCR_EL2.&lt;NV,NV1&gt; == '01' then
            case <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_NVNV1" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_NVNV1</a>) of
                when <a href="shared_pseudocode.html#Constraint_NVNV1_00" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_00</a> walkparams.nv1 = '0';
                when <a href="shared_pseudocode.html#Constraint_NVNV1_01" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_01</a> walkparams.nv1 = '1';
                when <a href="shared_pseudocode.html#Constraint_NVNV1_11" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_11</a> walkparams.nv1 = '1';
        else
            walkparams.nv1 = HCR_EL2.NV1;
    else
        walkparams.nv1 = '0';

    walkparams.epan = if <a href="shared_pseudocode.html#impl-shared.HavePAN3Ext.0" title="function: boolean HavePAN3Ext()">HavePAN3Ext</a>()             then SCTLR_EL1.EPAN else '0';
    walkparams.cmow = if <a href="shared_pseudocode.html#impl-shared.HaveFeatCMOW.0" title="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>()            then SCTLR_EL1.CMOW else '0';
    walkparams.ha   = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL1.HA else '0';
    walkparams.hd   = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL1.HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL1.DS;
    else
        walkparams.ds = '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL2"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL2</h3>
      <p class="pseudocode">// AArch64.S1TTWParamsEL2()
// ========================
// Gather stage 1 translation table walk parameters for EL2 regime

S1TTWParams <a id="AArch64.S1TTWParamsEL2.0"/>AArch64.S1TTWParamsEL2()
    <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.DecodeTG0.1" title="function: TGx AArch64.DecodeTG0(bits(2) tg0)">AArch64.DecodeTG0</a>(TCR_EL2.TG0);
    walkparams.txsz = TCR_EL2.T0SZ;
    walkparams.ps   = TCR_EL2.PS;
    walkparams.irgn = TCR_EL2.IRGN0;
    walkparams.orgn = TCR_EL2.ORGN0;
    walkparams.sh   = TCR_EL2.SH0;
    walkparams.tbi  = TCR_EL2.TBI;
    walkparams.mair = MAIR_EL2;
    walkparams.wxn  = SCTLR_EL2.WXN;
    walkparams.ee   = SCTLR_EL2.EE;
    walkparams.sif  = SCR_EL3.SIF;

    walkparams.tbid = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()              then TCR_EL2.TBID else '0';
    walkparams.hpd  = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()      then TCR_EL2.HPD  else '0';
    walkparams.ha   = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL2.HA   else '0';
    walkparams.hd   = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL2.HD   else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL2.DS;
    else
        walkparams.ds = '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL20"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL20</h3>
      <p class="pseudocode">// AArch64.S1TTWParamsEL20()
// =========================
// Gather stage 1 translation table walk parameters for EL2&amp;0 regime

S1TTWParams <a id="AArch64.S1TTWParamsEL20.1"/>AArch64.S1TTWParamsEL20(<a href="shared_pseudocode.html#VARange" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange</a> varange)
    <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    if varange == <a href="shared_pseudocode.html#VARange_LOWER" title="enumeration VARange {&#13; VARange_LOWER,&#13; VARange_UPPER&#13; }">VARange_LOWER</a> then
        walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.DecodeTG0.1" title="function: TGx AArch64.DecodeTG0(bits(2) tg0)">AArch64.DecodeTG0</a>(TCR_EL2.TG0);
        walkparams.txsz = TCR_EL2.T0SZ;
        walkparams.irgn = TCR_EL2.IRGN0;
        walkparams.orgn = TCR_EL2.ORGN0;
        walkparams.sh   = TCR_EL2.SH0;
        walkparams.tbi  = TCR_EL2.TBI0;

        walkparams.nfd  = if <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() || <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then TCR_EL2.NFD0  else '0';
        walkparams.tbid = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL2.TBID0 else '0';
        walkparams.e0pd = if <a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL2.E0PD0 else '0';
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL2.HPD0  else '0';
    else
        walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.DecodeTG1.1" title="function: TGx AArch64.DecodeTG1(bits(2) tg1)">AArch64.DecodeTG1</a>(TCR_EL2.TG1);
        walkparams.txsz = TCR_EL2.T1SZ;
        walkparams.irgn = TCR_EL2.IRGN1;
        walkparams.orgn = TCR_EL2.ORGN1;
        walkparams.sh   = TCR_EL2.SH1;
        walkparams.tbi  = TCR_EL2.TBI1;

        walkparams.nfd  = if <a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() || <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() then TCR_EL2.NFD1  else '0';
        walkparams.tbid = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()           then TCR_EL2.TBID1 else '0';
        walkparams.e0pd = if <a href="shared_pseudocode.html#impl-shared.HaveE0PDExt.0" title="function: boolean HaveE0PDExt()">HaveE0PDExt</a>()          then TCR_EL2.E0PD1 else '0';
        walkparams.hpd  = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()   then TCR_EL2.HPD1  else '0';

    walkparams.mair = MAIR_EL2;
    walkparams.wxn  = SCTLR_EL2.WXN;
    walkparams.ps   = TCR_EL2.IPS;
    walkparams.ee   = SCTLR_EL2.EE;
    walkparams.sif  = SCR_EL3.SIF;

    if <a href="shared_pseudocode.html#impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0" title="function: boolean HaveTrapLoadStoreMultipleDeviceExt()">HaveTrapLoadStoreMultipleDeviceExt</a>() then
        walkparams.ntlsmd = SCTLR_EL2.nTLSMD;
    else
        walkparams.ntlsmd = '1';

    walkparams.epan = if <a href="shared_pseudocode.html#impl-shared.HavePAN3Ext.0" title="function: boolean HavePAN3Ext()">HavePAN3Ext</a>()             then SCTLR_EL2.EPAN else '0';
    walkparams.cmow = if <a href="shared_pseudocode.html#impl-shared.HaveFeatCMOW.0" title="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>()            then SCTLR_EL2.CMOW else '0';
    walkparams.ha   = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL2.HA else '0';
    walkparams.hd   = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL2.HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL2.DS;
    else
        walkparams.ds = '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S1TTWParamsEL3"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S1TTWParamsEL3</h3>
      <p class="pseudocode">// AArch64.S1TTWParamsEL3()
// ========================
// Gather stage 1 translation table walk parameters for EL3 regime

S1TTWParams <a id="AArch64.S1TTWParamsEL3.0"/>AArch64.S1TTWParamsEL3()
    <a href="shared_pseudocode.html#S1TTWParams" title="type S1TTWParams is ( bit ha, bit hd, bit tbi, bit tbid, bit nfd, bit e0pd, bit ds, bits(3) ps, bits(6) txsz, bit epan, bit dct, bit nv1, bit cmow, bits(3) t0sz, bits(3) t1sz, bit uwxn, TGx tgx, bits(2) irgn, bits(2) orgn, bits(2) sh, bit hpd, bit ee, bit wxn, bit ntlsmd, bit dc, bit sif, MAIRType mair )">S1TTWParams</a> walkparams;

    walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.DecodeTG0.1" title="function: TGx AArch64.DecodeTG0(bits(2) tg0)">AArch64.DecodeTG0</a>(TCR_EL3.TG0);
    walkparams.txsz = TCR_EL3.T0SZ;
    walkparams.ps   = TCR_EL3.PS;
    walkparams.irgn = TCR_EL3.IRGN0;
    walkparams.orgn = TCR_EL3.ORGN0;
    walkparams.sh   = TCR_EL3.SH0;
    walkparams.tbi  = TCR_EL3.TBI;
    walkparams.mair = MAIR_EL3;
    walkparams.wxn  = SCTLR_EL3.WXN;
    walkparams.ee   = SCTLR_EL3.EE;
    walkparams.sif  = SCR_EL3.SIF;

    walkparams.tbid = if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>()              then TCR_EL3.TBID else '0';
    walkparams.hpd  = if <a href="shared_pseudocode.html#AArch64.HaveHPDExt.0" title="function: boolean AArch64.HaveHPDExt()">AArch64.HaveHPDExt</a>()      then TCR_EL3.HPD  else '0';
    walkparams.ha   = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>() then TCR_EL3.HA   else '0';
    walkparams.hd   = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>() then TCR_EL3.HD   else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = TCR_EL3.DS;
    else
        walkparams.ds = '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.S2MinTxSZ"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.S2MinTxSZ</h3>
      <p class="pseudocode">// AArch64.S2MinTxSZ()
// ===================
// Retrieve the minimum value of TxSZ indicating maximum input address size for stage 2

integer <a id="AArch64.S2MinTxSZ.3"/>AArch64.S2MinTxSZ(bit ds, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, boolean s1aarch64)
    ips = <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>();

    if <a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>() &amp;&amp; tgx != <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> &amp;&amp; ds == '0' then
        ips = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(48, <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>());

    min_txsz = 64 - ips;
    if !s1aarch64 then
        // EL1 is AArch32
        min_txsz = <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(min_txsz, 24);

    return min_txsz;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.SS2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.SS2TTWParams</h3>
      <p class="pseudocode">// AArch64.SS2TTWParams()
// ======================
// Gather walk parameters specific for secure stage 2 translation

S2TTWParams <a id="AArch64.SS2TTWParams.2"/>AArch64.SS2TTWParams(<a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> ipaspace, boolean s1aarch64)
    <a href="shared_pseudocode.html#S2TTWParams" title="type S2TTWParams is ( bit ha, bit hd, bit sl2, bit ds, bit sw, bit nsw, bit sa, bit nsa, bits(3) ps, bits(6) txsz, bit fwb, bit cmow, bit s, bits(4) t0sz, TGx tgx, bits(2) sl0, bits(2) irgn, bits(2) orgn, bits(2) sh, bit ee, bit ptw, bit vm )">S2TTWParams</a> walkparams;

    if ipaspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a> then
        walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.DecodeTG0.1" title="function: TGx AArch64.DecodeTG0(bits(2) tg0)">AArch64.DecodeTG0</a>(VSTCR_EL2.TG0);
        walkparams.txsz = VSTCR_EL2.T0SZ;
        walkparams.sl0  = VSTCR_EL2.SL0;
        if walkparams.tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
            walkparams.sl2 = VSTCR_EL2.SL2 AND VTCR_EL2.DS;
        else
            walkparams.sl2 = '0';
    elsif ipaspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
        walkparams.tgx  = <a href="shared_pseudocode.html#AArch64.DecodeTG0.1" title="function: TGx AArch64.DecodeTG0(bits(2) tg0)">AArch64.DecodeTG0</a>(VTCR_EL2.TG0);
        walkparams.txsz = VTCR_EL2.T0SZ;
        walkparams.sl0  = VTCR_EL2.SL0;
        if walkparams.tgx == <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
            walkparams.sl2 = VTCR_EL2.SL2 AND VTCR_EL2.DS;
        else
            walkparams.sl2 = '0';
    else
        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    walkparams.sw   = VSTCR_EL2.SW;
    walkparams.nsw  = VTCR_EL2.NSW;
    walkparams.sa   = VSTCR_EL2.SA;
    walkparams.nsa  = VTCR_EL2.NSA;
    walkparams.vm   = HCR_EL2.VM OR HCR_EL2.DC;
    walkparams.ps   = VTCR_EL2.PS;
    walkparams.irgn = VTCR_EL2.IRGN0;
    walkparams.orgn = VTCR_EL2.ORGN0;
    walkparams.sh   = VTCR_EL2.SH0;
    walkparams.ee   = SCTLR_EL2.EE;

    walkparams.ptw = if HCR_EL2.TGE == '0'         then HCR_EL2.PTW else '0';
    walkparams.fwb = if <a href="shared_pseudocode.html#impl-shared.HaveStage2MemAttrControl.0" title="function: boolean HaveStage2MemAttrControl()">HaveStage2MemAttrControl</a>() then HCR_EL2.FWB else '0';
    walkparams.ha  = if <a href="shared_pseudocode.html#impl-shared.HaveAccessFlagUpdateExt.0" title="function: boolean HaveAccessFlagUpdateExt()">HaveAccessFlagUpdateExt</a>()  then VTCR_EL2.HA else '0';
    walkparams.hd  = if <a href="shared_pseudocode.html#impl-shared.HaveDirtyBitModifierExt.0" title="function: boolean HaveDirtyBitModifierExt()">HaveDirtyBitModifierExt</a>()  then VTCR_EL2.HD else '0';
    if walkparams.tgx IN {<a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>, <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>() then
        walkparams.ds = VTCR_EL2.DS;
    else
        walkparams.ds = '0';
    walkparams.cmow = if <a href="shared_pseudocode.html#impl-shared.HaveFeatCMOW.0" title="function: boolean HaveFeatCMOW()">HaveFeatCMOW</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.IsHCRXEL2Enabled.0" title="function: boolean IsHCRXEL2Enabled()">IsHCRXEL2Enabled</a>() then HCRX_EL2.CMOW else '0';

    return walkparams;</p>
    </div>
    <div class="ps"><a id="aarch64.translation.vmsa_walkparams.AArch64.VAMax"/><h3 class="pseudocode">
            Library pseudocode for aarch64/translation/vmsa_walkparams/AArch64.VAMax</h3>
      <p class="pseudocode">// AArch64.VAMax()
// ===============
// Returns the IMPLEMENTATION DEFINED maximum number of bits capable of representing
// the virtual address for this processor

integer <a id="AArch64.VAMax.0"/>AArch64.VAMax()
    return integer IMPLEMENTATION_DEFINED "Maximum Virtual Address Size";</p>
    </div>
    <div class="ps"><a id="shared.debug.ClearStickyErrors.ClearStickyErrors"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/ClearStickyErrors/ClearStickyErrors</h3>
      <p class="pseudocode">// ClearStickyErrors()
// ===================

<a id="impl-shared.ClearStickyErrors.0"/>ClearStickyErrors()
    EDSCR.TXU = '0';            // Clear TX underrun flag
    EDSCR.RXO = '0';            // Clear RX overrun flag

    if <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then            // in Debug state
        EDSCR.ITO = '0';        // Clear ITR overrun flag

    // If halted and the ITR is not empty then it is UNPREDICTABLE whether the EDSCR.ERR is cleared.
    // The UNPREDICTABLE behavior also affects the instructions in flight, but this is not described
    // in the pseudocode.
    if <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.ITE == '0' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_CLEARERRITEZERO" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_CLEARERRITEZERO</a>) then
        return;
    EDSCR.ERR = '0';            // Clear cumulative error flag

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.DebugTarget.DebugTarget"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/DebugTarget/DebugTarget</h3>
      <p class="pseudocode">// DebugTarget()
// =============
// Returns the debug exception target Exception level

bits(2) <a id="impl-shared.DebugTarget.0"/>DebugTarget()
    secure = <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    return <a href="shared_pseudocode.html#impl-shared.DebugTargetFrom.1" title="function: bits(2) DebugTargetFrom(boolean secure)">DebugTargetFrom</a>(secure);</p>
    </div>
    <div class="ps"><a id="shared.debug.DebugTarget.DebugTargetFrom"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/DebugTarget/DebugTargetFrom</h3>
      <p class="pseudocode">// DebugTargetFrom()
// =================

bits(2) <a id="impl-shared.DebugTargetFrom.1"/>DebugTargetFrom(boolean secure)
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!secure || (<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp;
            (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) ||SCR_EL3.EEL2 == '1'))) then
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            route_to_el2 = (HDCR.TDE == '1' || HCR.TGE == '1');
        else
            route_to_el2 = (MDCR_EL2.TDE == '1' || HCR_EL2.TGE == '1');
    else
        route_to_el2 = FALSE;

    if route_to_el2 then
        target = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() &amp;&amp; secure then
        target = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    else
        target = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

    return target;</p>
    </div>
    <div class="ps"><a id="shared.debug.DoubleLockStatus.DoubleLockStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/DoubleLockStatus/DoubleLockStatus</h3>
      <p class="pseudocode">// DoubleLockStatus()
// ==================
// Returns the state of the OS Double Lock.
//    FALSE if OSDLR_EL1.DLK == 0 or DBGPRCR_EL1.CORENPDRQ == 1 or the PE is in Debug state.
//    TRUE if OSDLR_EL1.DLK == 1 and DBGPRCR_EL1.CORENPDRQ == 0 and the PE is in Non-debug state.

boolean <a id="impl-shared.DoubleLockStatus.0"/>DoubleLockStatus()
    if !<a href="shared_pseudocode.html#impl-shared.HaveDoubleLock.0" title="function: boolean HaveDoubleLock()">HaveDoubleLock</a>() then
        return FALSE;
    elsif <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        return DBGOSDLR.DLK == '1' &amp;&amp; DBGPRCR.CORENPDRQ == '0' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();
    else
        return OSDLR_EL1.DLK == '1' &amp;&amp; DBGPRCR_EL1.CORENPDRQ == '0' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.OSLockStatus.OSLockStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/OSLockStatus/OSLockStatus</h3>
      <p class="pseudocode">// OSLockStatus()
// ==============
// Returns the state of the OS Lock.

boolean <a id="impl-shared.OSLockStatus.0"/>OSLockStatus()
    return (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then DBGOSLSR.OSLK else OSLSR_EL1.OSLK) == '1';</p>
    </div>
    <div class="ps"><a id="shared.debug.SoftwareLockStatus.Component"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/SoftwareLockStatus/Component</h3>
      <p class="pseudocode">enumeration <a id="Component"/>Component {
        <a id="Component_PMU"/>Component_PMU,
        <a id="Component_Debug"/>Component_Debug,
        <a id="Component_CTI"/>Component_CTI
};</p>
    </div>
    <div class="ps"><a id="shared.debug.SoftwareLockStatus.GetAccessComponent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/SoftwareLockStatus/GetAccessComponent</h3>
      <p class="pseudocode">// Returns the accessed component.
Component <a id="impl-shared.GetAccessComponent.0"/>GetAccessComponent();</p>
    </div>
    <div class="ps"><a id="shared.debug.SoftwareLockStatus.SoftwareLockStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/SoftwareLockStatus/SoftwareLockStatus</h3>
      <p class="pseudocode">// SoftwareLockStatus()
// ====================
// Returns the state of the Software Lock.

boolean <a id="impl-shared.SoftwareLockStatus.0"/>SoftwareLockStatus()
    <a href="shared_pseudocode.html#Component" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component</a> component = <a href="shared_pseudocode.html#impl-shared.GetAccessComponent.0" title="function: Component GetAccessComponent()">GetAccessComponent</a>();
    if !<a href="shared_pseudocode.html#impl-shared.HaveSoftwareLock.1" title="function: boolean HaveSoftwareLock(Component component)">HaveSoftwareLock</a>(component) then
        return FALSE;
    case component of
        when <a href="shared_pseudocode.html#Component_Debug" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_Debug</a>
            return EDLSR.SLK == '1';
        when <a href="shared_pseudocode.html#Component_PMU" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_PMU</a>
            return PMLSR.SLK == '1';
        when <a href="shared_pseudocode.html#Component_CTI" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_CTI</a>
            return CTILSR.SLK == '1';
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AllowExternalDebugAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AllowExternalDebugAccess</h3>
      <p class="pseudocode">// AllowExternalDebugAccess()
// ==========================
// Returns TRUE if an external debug interface access to the External debug registers
// is allowed, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalDebugAccess.0"/>AllowExternalDebugAccess()
    // The access may also be subject to OS Lock, power-down, etc.
    if <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</a>() then
        return <a href="shared_pseudocode.html#impl-shared.AllowExternalDebugAccess.1" title="function: boolean AllowExternalDebugAccess(boolean allow_secure)">AllowExternalDebugAccess</a>(<a href="shared_pseudocode.html#impl-shared.IsAccessSecure.0" title="function: boolean IsAccessSecure()">IsAccessSecure</a>());
    else
        return <a href="shared_pseudocode.html#impl-shared.AllowExternalDebugAccess.1" title="function: boolean AllowExternalDebugAccess(boolean allow_secure)">AllowExternalDebugAccess</a>(<a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>());

// AllowExternalDebugAccess()
// ==========================
// Returns TRUE if an external debug interface access to the External debug registers
// is allowed for the given Security state, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalDebugAccess.1"/>AllowExternalDebugAccess(boolean allow_secure)
    // The access may also be subject to OS Lock, power-down, etc.
    if <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() then
        if allow_secure then
            return TRUE;
        elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
                return SDCR.EDAD == '0';
            else
                return MDCR_EL3.EDAD == '0';
        else
            return !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AllowExternalPMUAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AllowExternalPMUAccess</h3>
      <p class="pseudocode">// AllowExternalPMUAccess()
// ========================
// Returns TRUE if an external debug interface access to the PMU registers is
// allowed, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalPMUAccess.0"/>AllowExternalPMUAccess()
    // The access may also be subject to OS Lock, power-down, etc.
    if <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</a>() then
        return <a href="shared_pseudocode.html#impl-shared.AllowExternalPMUAccess.1" title="function: boolean AllowExternalPMUAccess(boolean allow_secure)">AllowExternalPMUAccess</a>(<a href="shared_pseudocode.html#impl-shared.IsAccessSecure.0" title="function: boolean IsAccessSecure()">IsAccessSecure</a>());
    else
        return <a href="shared_pseudocode.html#impl-shared.AllowExternalPMUAccess.1" title="function: boolean AllowExternalPMUAccess(boolean allow_secure)">AllowExternalPMUAccess</a>(<a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>());

// AllowExternalPMUAccess()
// ========================
// Returns TRUE if an external debug interface access to the PMU registers is
// allowed for the given Security state, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalPMUAccess.1"/>AllowExternalPMUAccess(boolean allow_secure)
    // The access may also be subject to OS Lock, power-down, etc.
    if <a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()">ExternalNoninvasiveDebugEnabled</a>() then
        if allow_secure then
            return TRUE;
        elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
                return SDCR.EPMAD == '0';
            else
                return MDCR_EL3.EPMAD == '0';
        else
            return !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.AllowExternalTraceAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/AllowExternalTraceAccess</h3>
      <p class="pseudocode">// AllowExternalTraceAccess()
// ==========================
// Returns TRUE if an external Trace access to the Trace registers is allowed, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalTraceAccess.0"/>AllowExternalTraceAccess()
    if !<a href="shared_pseudocode.html#impl-shared.HaveTraceBufferExtension.0" title="function: boolean HaveTraceBufferExtension()">HaveTraceBufferExtension</a>() then
        return TRUE;
    else
        return <a href="shared_pseudocode.html#impl-shared.AllowExternalTraceAccess.1" title="function: boolean AllowExternalTraceAccess(boolean access_is_secure)">AllowExternalTraceAccess</a>(<a href="shared_pseudocode.html#impl-shared.IsAccessSecure.0" title="function: boolean IsAccessSecure()">IsAccessSecure</a>());

// AllowExternalTraceAccess()
// ==========================
// Returns TRUE if an external Trace access to the Trace registers is allowed for the
// given Security state, FALSE otherwise.

boolean <a id="impl-shared.AllowExternalTraceAccess.1"/>AllowExternalTraceAccess(boolean access_is_secure)
    // The access may also be subject to OS lock, power-down, etc.
    if !<a href="shared_pseudocode.html#impl-shared.HaveTraceBufferExtension.0" title="function: boolean HaveTraceBufferExtension()">HaveTraceBufferExtension</a>() || access_is_secure then
        return TRUE;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        // External Trace access is not supported for EL3 using AArch32
        assert !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);

        return MDCR_EL3.ETAD == '0';
    else
        return !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.Debug_authentication"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/Debug_authentication</h3>
      <p class="pseudocode">signal DBGEN;
signal NIDEN;
signal SPIDEN;
signal SPNIDEN;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalInvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalInvasiveDebugEnabled()
// ==============================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the DBGEN signal.

boolean <a id="impl-shared.ExternalInvasiveDebugEnabled.0"/>ExternalInvasiveDebugEnabled()
    return DBGEN == HIGH;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalNoninvasiveDebugAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalNoninvasiveDebugAllowed</h3>
      <p class="pseudocode">// ExternalNoninvasiveDebugAllowed()
// =================================
// Returns TRUE if Trace and PC Sample-based Profiling are allowed

boolean <a id="impl-shared.ExternalNoninvasiveDebugAllowed.0"/>ExternalNoninvasiveDebugAllowed()
    return (<a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()">ExternalNoninvasiveDebugEnabled</a>() &amp;&amp;
            (!<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>() ||
             (<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; SDER.SUNIDEN == '1')));</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalNoninvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalNoninvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalNoninvasiveDebugEnabled()
// =================================
// This function returns TRUE if the FEAT_Debugv8p4 is implemented.
// Otherwise, this function is IMPLEMENTATION DEFINED, and, in the
// recommended interface, ExternalNoninvasiveDebugEnabled returns
// the state of the (DBGEN OR NIDEN) signal.

boolean <a id="impl-shared.ExternalNoninvasiveDebugEnabled.0"/>ExternalNoninvasiveDebugEnabled()
    return !<a href="shared_pseudocode.html#impl-shared.HaveNoninvasiveDebugAuth.0" title="function: boolean HaveNoninvasiveDebugAuth()">HaveNoninvasiveDebugAuth</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() || NIDEN == HIGH;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalSecureInvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalSecureInvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalSecureInvasiveDebugEnabled()
// ====================================
// The definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the (DBGEN AND SPIDEN) signal.
// CoreSight allows asserting SPIDEN without also asserting DBGEN, but this is not recommended.

boolean <a id="impl-shared.ExternalSecureInvasiveDebugEnabled.0"/>ExternalSecureInvasiveDebugEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then return FALSE;
    return <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>() &amp;&amp; SPIDEN == HIGH;</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.ExternalSecureNoninvasiveDebugEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/ExternalSecureNoninvasiveDebugEnabled</h3>
      <p class="pseudocode">// ExternalSecureNoninvasiveDebugEnabled()
// =======================================
// This function returns the value of ExternalSecureInvasiveDebugEnabled() when FEAT_Debugv8p4
// is implemented. Otherwise, the definition of this function is IMPLEMENTATION DEFINED.
// In the recommended interface, this function returns the state of the (DBGEN OR NIDEN) AND
// (SPIDEN OR SPNIDEN) signal.

boolean <a id="impl-shared.ExternalSecureNoninvasiveDebugEnabled.0"/>ExternalSecureNoninvasiveDebugEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveNoninvasiveDebugAuth.0" title="function: boolean HaveNoninvasiveDebugAuth()">HaveNoninvasiveDebugAuth</a>() then
        return <a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugEnabled.0" title="function: boolean ExternalNoninvasiveDebugEnabled()">ExternalNoninvasiveDebugEnabled</a>() &amp;&amp; (SPIDEN == HIGH || SPNIDEN == HIGH);
    else
        return <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.IsAccessSecure"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/IsAccessSecure</h3>
      <p class="pseudocode">// Returns TRUE when an access is Secure
boolean <a id="impl-shared.IsAccessSecure.0"/>IsAccessSecure();</p>
    </div>
    <div class="ps"><a id="shared.debug.authentication.IsCorePowered"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/authentication/IsCorePowered</h3>
      <p class="pseudocode">// Returns TRUE if the Core power domain is powered on, FALSE otherwise.
boolean <a id="impl-shared.IsCorePowered.0"/>IsCorePowered();</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.CheckValidStateMatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/CheckValidStateMatch</h3>
      <p class="pseudocode">// CheckValidStateMatch()
// ======================
// Checks for an invalid state match that will generate Constrained
// Unpredictable behaviour, otherwise returns Constraint_NONE.

(Constraint, bits(2), bit, bits(2)) <a id="impl-shared.CheckValidStateMatch.4"/>CheckValidStateMatch(bits(2) SSC, bit HMC, bits(2) PxC,
                                                         boolean isbreakpnt)
    boolean reserved = FALSE;

    // Match 'Usr/Sys/Svc' only valid for AArch32 breakpoints
    if (!isbreakpnt || !<a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>)) &amp;&amp; HMC:PxC == '000' &amp;&amp; SSC != '11' then
        reserved = TRUE;

    // Both EL3 and EL2 are not implemented
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (HMC != '0' || SSC != '00') then
        reserved = TRUE;

    // EL3 is not implemented
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SSC IN {'01','10'} &amp;&amp; HMC:SSC:PxC != '10100' then
        reserved = TRUE;

    // EL3 using AArch64 only
    if (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>()) &amp;&amp; HMC:SSC:PxC == '11000' then
        reserved = TRUE;

    // EL2 is not implemented
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HMC:SSC:PxC == '11100' then
        reserved = TRUE;

    // Secure EL2 is not implemented
    if !<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; (HMC:SSC:PxC)  IN {'01100','10100','x11x1'} then
        reserved = TRUE;

    // Values that are not allocated in any architecture version
    if (HMC:SSC:PxC) IN {'01110','100x0','10110','11x10'} then
        reserved = TRUE;

    if reserved then
        // If parameters are set to a reserved type, behaves as either disabled or a defined type
        (c, &lt;HMC,SSC,PxC&gt;) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESBPWPCTRL" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESBPWPCTRL</a>);
        assert c IN {<a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>, <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>};
        if c == <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a> then
            return (c, bits(2) UNKNOWN, bit UNKNOWN, bits(2) UNKNOWN);
        // Otherwise the value returned by ConstrainUnpredictableBits must be a not-reserved value

    return (<a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>, SSC, HMC, PxC);</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.NumBreakpointsImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/NumBreakpointsImplemented</h3>
      <p class="pseudocode">// NumBreakpointsImplemented()
// ===========================
// Returns the number of breakpoints implemented. This is indicated to software by
// DBGDIDR.BRPs in AArch32 state, and ID_AA64DFR0_EL1.BRPs in AArch64 state.

integer <a id="impl-shared.NumBreakpointsImplemented.0"/>NumBreakpointsImplemented()
    return integer IMPLEMENTATION_DEFINED "Number of breakpoints";</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.NumContextAwareBreakpointsImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/NumContextAwareBreakpointsImplemented</h3>
      <p class="pseudocode">// NumContextAwareBreakpointsImplemented()
// =======================================
// Returns the number of context-aware breakpoints implemented. This is indicated to software by
// DBGDIDR.CTX_CMPs in AArch32 state, and ID_AA64DFR0_EL1.CTX_CMPs in AArch64 state.

integer <a id="impl-shared.NumContextAwareBreakpointsImplemented.0"/>NumContextAwareBreakpointsImplemented()
    return integer IMPLEMENTATION_DEFINED "Number of context-aware breakpoints";</p>
    </div>
    <div class="ps"><a id="shared.debug.breakpoint.NumWatchpointsImplemented"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/breakpoint/NumWatchpointsImplemented</h3>
      <p class="pseudocode">// NumWatchpointsImplemented()
// ===========================
// Returns the number of watchpoints implemented. This is indicated to software by
// DBGDIDR.WRPs in AArch32 state, and ID_AA64DFR0_EL1.WRPs in AArch64 state.

integer <a id="impl-shared.NumWatchpointsImplemented.0"/>NumWatchpointsImplemented()
    return integer IMPLEMENTATION_DEFINED "Number of watchpoints";</p>
    </div>
    <div class="ps"><a id="shared.debug.cti.CTI_SetEventLevel"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/cti/CTI_SetEventLevel</h3>
      <p class="pseudocode">// Set a Cross Trigger multi-cycle input event trigger to the specified level.
CTI_SetEventLevel(<a href="shared_pseudocode.html#CrossTriggerIn" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn</a> id, signal level);</p>
    </div>
    <div class="ps"><a id="shared.debug.cti.CTI_SignalEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/cti/CTI_SignalEvent</h3>
      <p class="pseudocode">// Signal a discrete event on a Cross Trigger input event trigger.
<a id="impl-shared.CTI_SignalEvent.1"/>CTI_SignalEvent(<a href="shared_pseudocode.html#CrossTriggerIn" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn</a> id);</p>
    </div>
    <div class="ps"><a id="shared.debug.cti.CrossTrigger"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/cti/CrossTrigger</h3>
      <p class="pseudocode">enumeration <a id="CrossTriggerOut"/>CrossTriggerOut {<a id="CrossTriggerOut_DebugRequest"/>CrossTriggerOut_DebugRequest, <a id="CrossTriggerOut_RestartRequest"/>CrossTriggerOut_RestartRequest,
                             <a id="CrossTriggerOut_IRQ"/>CrossTriggerOut_IRQ,          <a id="CrossTriggerOut_RSVD3"/>CrossTriggerOut_RSVD3,
                             <a id="CrossTriggerOut_TraceExtIn0"/>CrossTriggerOut_TraceExtIn0,  <a id="CrossTriggerOut_TraceExtIn1"/>CrossTriggerOut_TraceExtIn1,
                             <a id="CrossTriggerOut_TraceExtIn2"/>CrossTriggerOut_TraceExtIn2,  <a id="CrossTriggerOut_TraceExtIn3"/>CrossTriggerOut_TraceExtIn3};

enumeration <a id="CrossTriggerIn"/>CrossTriggerIn  {<a id="CrossTriggerIn_CrossHalt"/>CrossTriggerIn_CrossHalt,     <a id="CrossTriggerIn_PMUOverflow"/>CrossTriggerIn_PMUOverflow,
                             <a id="CrossTriggerIn_RSVD2"/>CrossTriggerIn_RSVD2,         <a id="CrossTriggerIn_RSVD3"/>CrossTriggerIn_RSVD3,
                             <a id="CrossTriggerIn_TraceExtOut0"/>CrossTriggerIn_TraceExtOut0,  <a id="CrossTriggerIn_TraceExtOut1"/>CrossTriggerIn_TraceExtOut1,
                             <a id="CrossTriggerIn_TraceExtOut2"/>CrossTriggerIn_TraceExtOut2,  <a id="CrossTriggerIn_TraceExtOut3"/>CrossTriggerIn_TraceExtOut3};</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.CheckForDCCInterrupts"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/CheckForDCCInterrupts</h3>
      <p class="pseudocode">// CheckForDCCInterrupts()
// =======================

<a id="impl-shared.CheckForDCCInterrupts.0"/>CheckForDCCInterrupts()
    commrx = (EDSCR.RXfull == '1');
    commtx = (EDSCR.TXfull == '0');

    // COMMRX and COMMTX support is optional and not recommended for new designs.
    // SetInterruptRequestLevel(InterruptID_COMMRX, if commrx then HIGH else LOW);
    // SetInterruptRequestLevel(InterruptID_COMMTX, if commtx then HIGH else LOW);

    // The value to be driven onto the common COMMIRQ signal.
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        commirq = ((commrx &amp;&amp; DBGDCCINT.RX == '1') ||
                   (commtx &amp;&amp; DBGDCCINT.TX == '1'));
    else
        commirq = ((commrx &amp;&amp; MDCCINT_EL1.RX == '1') ||
                   (commtx &amp;&amp; MDCCINT_EL1.TX == '1'));
    SetInterruptRequestLevel(<a href="shared_pseudocode.html#InterruptID_COMMIRQ" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_COMMIRQ</a>, if commirq then HIGH else LOW);

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.DBGDTRRX_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/DBGDTRRX_EL0</h3>
      <p class="pseudocode">// DBGDTRRX_EL0[] (external write)
// ===============================
// Called on writes to debug register 0x08C.

<a id="impl-shared.DBGDTRRX_EL0.write.1"/>DBGDTRRX_EL0[boolean memory_mapped] = bits(32) value

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return;

    if EDSCR.ERR == '1' then return;                    // Error flag set: ignore write

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write

    if EDSCR.RXfull == '1' || (<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' &amp;&amp; EDSCR.ITE == '0') then
        EDSCR.RXO = '1';  EDSCR.ERR = '1';              // Overrun condition: ignore write
        return;

    EDSCR.RXfull = '1';
    DTRRX = value;

    if <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' then
        EDSCR.ITE = '0';                            // See comments in EDITR[] (external write)
        if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xD5330501&lt;31:0&gt;);               // A64 "MRS X1,DBGDTRRX_EL0"
            <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xB8004401&lt;31:0&gt;);               // A64 "STR W1,[X0],#4"
            <a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value">X</a>[1] = bits(64) UNKNOWN;
        else
            <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xEE10&lt;15:0&gt; /*hw1*/, 0x1E15&lt;15:0&gt; /*hw2*/);  // T32 "MRS R1,DBGDTRRXint"
            <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xF840&lt;15:0&gt; /*hw1*/, 0x1B04&lt;15:0&gt; /*hw2*/);  // T32 "STR R1,[R0],#4"
            <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[1] = bits(32) UNKNOWN;
        // If the store aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR.ERR == '1' then
            EDSCR.RXfull = bit UNKNOWN;
            DBGDTRRX_EL0 = bits(64) UNKNOWN;
        else
            // "MRS X1,DBGDTRRX_EL0" calls DBGDTR_EL0[] (read) which clears RXfull.
            assert EDSCR.RXfull == '0';

        EDSCR.ITE = '1';                                // See comments in EDITR[] (external write)
    return;

// DBGDTRRX_EL0[] (external read)
// ==============================

bits(32) <a id="impl-shared.DBGDTRRX_EL0.read.1"/>DBGDTRRX_EL0[boolean memory_mapped]
    return DTRRX;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.DBGDTRTX_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/DBGDTRTX_EL0</h3>
      <p class="pseudocode">// DBGDTRTX_EL0[] (external read)
// ==============================
// Called on reads of debug register 0x080.

bits(32) <a id="impl-shared.DBGDTRTX_EL0.read.1"/>DBGDTRTX_EL0[boolean memory_mapped]

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return bits(32) UNKNOWN;

    underrun = EDSCR.TXfull == '0' || (<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' &amp;&amp; EDSCR.ITE == '0');
    value = if underrun then bits(32) UNKNOWN else DTRTX;

    if EDSCR.ERR == '1' then return value;              // Error flag set: no side-effects

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then           // Software lock locked: no side-effects
        return value;

    if underrun then
        EDSCR.TXU = '1';  EDSCR.ERR = '1';              // Underrun condition: block side-effects
        return value;                                   // Return UNKNOWN

    EDSCR.TXfull = '0';
    if <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() &amp;&amp; EDSCR.MA == '1' then
        EDSCR.ITE = '0';                                // See comments in EDITR[] (external write)

        if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xB8404401&lt;31:0&gt;);               // A64 "LDR W1,[X0],#4"
        else
            <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xF850&lt;15:0&gt; /*hw1*/, 0x1B04&lt;15:0&gt; /*hw2*/);      // T32 "LDR R1,[R0],#4"
        // If the load aborts, the Data Abort exception is taken and EDSCR.ERR is set to 1
        if EDSCR.ERR == '1' then
            EDSCR.TXfull = bit UNKNOWN;
            DBGDTRTX_EL0 = bits(64) UNKNOWN;
        else
            if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
                <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(0xD5130501&lt;31:0&gt;);           // A64 "MSR DBGDTRTX_EL0,X1"
            else
                <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(0xEE00&lt;15:0&gt; /*hw1*/, 0x1E15&lt;15:0&gt; /*hw2*/);  // T32 "MSR DBGDTRTXint,R1"
            // "MSR DBGDTRTX_EL0,X1" calls DBGDTR_EL0[] (write) which sets TXfull.
            assert EDSCR.TXfull == '1';
        if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value">X</a>[1] = bits(64) UNKNOWN;
        else
            <a href="shared_pseudocode.html#impl-aarch32.R.write.1" title="accessor: R[integer n] = bits(32) value">R</a>[1] = bits(32) UNKNOWN;
        EDSCR.ITE = '1';                                // See comments in EDITR[] (external write)

    return value;

// DBGDTRTX_EL0[] (external write)
// ===============================

<a id="impl-shared.DBGDTRTX_EL0.write.1"/>DBGDTRTX_EL0[boolean memory_mapped] = bits(32) value
    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write
    DTRTX = value;
    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.DBGDTR_EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/DBGDTR_EL0</h3>
      <p class="pseudocode">// DBGDTR_EL0[] (write)
// ====================
// System register writes to DBGDTR_EL0, DBGDTRTX_EL0 (AArch64) and DBGDTRTXint (AArch32)

<a id="impl-shared.DBGDTR_EL0.write.0"/>DBGDTR_EL0[] = bits(N) value
    // For MSR DBGDTRTX_EL0,&lt;Rt&gt;  N=32, value=X[t]&lt;31:0&gt;, X[t]&lt;63:32&gt; is ignored
    // For MSR DBGDTR_EL0,&lt;Xt&gt;    N=64, value=X[t]&lt;63:0&gt;
    assert N IN {32,64};
    if EDSCR.TXfull == '1' then
        value = bits(N) UNKNOWN;
    // On a 64-bit write, implement a half-duplex channel
    if N == 64 then DTRRX = value&lt;63:32&gt;;
    DTRTX = value&lt;31:0&gt;;        // 32-bit or 64-bit write
    EDSCR.TXfull = '1';
    return;

// DBGDTR_EL0[] (read)
// ===================
// System register reads of DBGDTR_EL0, DBGDTRRX_EL0 (AArch64) and DBGDTRRXint (AArch32)

bits(N) <a id="impl-shared.DBGDTR_EL0.read.0"/>DBGDTR_EL0[]
    // For MRS &lt;Rt&gt;,DBGDTRTX_EL0  N=32, X[t]=Zeros(32):result
    // For MRS &lt;Xt&gt;,DBGDTR_EL0    N=64, X[t]=result
    assert N IN {32,64};
    bits(N) result;
    if EDSCR.RXfull == '0' then
        result = bits(N) UNKNOWN;
    else
        // On a 64-bit read, implement a half-duplex channel
        // NOTE: the word order is reversed on reads with regards to writes
        if N == 64 then result&lt;63:32&gt; = DTRTX;
        result&lt;31:0&gt; = DTRRX;
    EDSCR.RXfull = '0';
    return result;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.DTR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/DTR</h3>
      <p class="pseudocode">bits(32) DTRRX;
bits(32) DTRTX;</p>
    </div>
    <div class="ps"><a id="shared.debug.dccanditr.EDITR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/dccanditr/EDITR</h3>
      <p class="pseudocode">// EDITR[] (external write)
// ========================
// Called on writes to debug register 0x084.

<a id="impl-shared.EDITR.write.1"/>EDITR[boolean memory_mapped] = bits(32) value
    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return;

    if EDSCR.ERR == '1' then return;                    // Error flag set: ignore write

    // The Software lock is OPTIONAL.
    if memory_mapped &amp;&amp; EDLSR.SLK == '1' then return;   // Software lock locked: ignore write

    if !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then return;                           // Non-debug state: ignore write

    if EDSCR.ITE == '0' || EDSCR.MA == '1' then
        EDSCR.ITO = '1';  EDSCR.ERR = '1';              // Overrun condition: block write
        return;

    // ITE indicates whether the processor is ready to accept another instruction; the processor
    // may support multiple outstanding instructions. Unlike the "InstrCompl" flag in [v7A] there
    // is no indication that the pipeline is empty (all instructions have completed). In this
    // pseudocode, the assumption is that only one instruction can be executed at a time,
    // meaning ITE acts like "InstrCompl".
    EDSCR.ITE = '0';

    if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        <a href="shared_pseudocode.html#impl-shared.ExecuteA64.1" title="function: ExecuteA64(bits(32) instr)">ExecuteA64</a>(value);
    else
        <a href="shared_pseudocode.html#impl-shared.ExecuteT32.2" title="function: ExecuteT32(bits(16) hw1, bits(16) hw2)">ExecuteT32</a>(value&lt;15:0&gt;/*hw1*/, value&lt;31:16&gt; /*hw2*/);

    EDSCR.ITE = '1';

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DCPSInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DCPSInstruction</h3>
      <p class="pseudocode">// DCPSInstruction()
// =================
// Operation of the DCPS instruction in Debug state

<a id="impl-shared.DCPSInstruction.1"/>DCPSInstruction(bits(2) target_el)

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    case target_el of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> || (PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>()) then handle_el = PSTATE.EL;
            elsif <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.TGE == '1' then UNDEFINED;
            else handle_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then UNDEFINED;
            elsif PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then handle_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            elsif !<a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then UNDEFINED;
            else handle_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            if EDSCR.SDD == '1' || !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then UNDEFINED;
            handle_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    from_secure = <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(handle_el) then
        if PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then SCR.NS = '0';
        assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();                  // Cannot move from AArch64 to AArch32
        case handle_el of
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
                <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>);
                if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; SCTLR.SPAN == '0' then
                    PSTATE.PAN = '1';
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>);
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
                <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(<a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>);
                if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then
                    if !from_secure then
                        PSTATE.PAN = '0';
                    elsif SCTLR.SPAN == '0' then
                        PSTATE.PAN = '1';
        if handle_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
            ELR_hyp = bits(32) UNKNOWN;  HSR = bits(32) UNKNOWN;
        else
            <a href="shared_pseudocode.html#impl-aarch32.LR.write.none" title="accessor: LR = bits(32) value">LR</a> = bits(32) UNKNOWN;
        <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(32) UNKNOWN;
        PSTATE.E = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].EE;
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;

    else                                        // Targeting AArch64
        if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a href="shared_pseudocode.html#AArch64.MaybeZeroRegisterUppers.0" title="function: AArch64.MaybeZeroRegisterUppers()">AArch64.MaybeZeroRegisterUppers</a>();
        <a href="shared_pseudocode.html#impl-aarch64.MaybeZeroSVEUppers.1" title="function: MaybeZeroSVEUppers(bits(2) target_el)">MaybeZeroSVEUppers</a>(target_el);
        PSTATE.nRW = '0';  PSTATE.SP = '1';  PSTATE.EL = handle_el;
        if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() &amp;&amp; ((handle_el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; SCTLR_EL1.SPAN == '0') ||
                            (handle_el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp;
                             HCR_EL2.TGE == '1' &amp;&amp; SCTLR_EL2.SPAN == '0')) then
            PSTATE.PAN = '1';
        <a href="shared_pseudocode.html#impl-aarch64.ELR.write.0" title="accessor: ELR[] = bits(64) value">ELR</a>[] = bits(64) UNKNOWN;  <a href="shared_pseudocode.html#impl-shared.SPSR.write.0" title="accessor: SPSR[] = bits(N) value">SPSR</a>[] = bits(64) UNKNOWN;  <a href="shared_pseudocode.html#impl-aarch64.ESR.write.0" title="accessor: ESR[] = ESRType value">ESR</a>[] = bits(64) UNKNOWN;
        DLR_EL0 = bits(64) UNKNOWN;  DSPSR_EL0 = bits(64) UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = '0';
        if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = '1';

    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR PE state flags
    sync_errors = <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].IESB == '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !<a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_IESBinDebug</a>) then
        sync_errors = FALSE;
    if sync_errors then
        <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DRPSInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DRPSInstruction</h3>
      <p class="pseudocode">// DRPSInstruction()
// =================
// Operation of the A64 DRPS and T32 ERET instructions in Debug state

<a id="impl-shared.DRPSInstruction.0"/>DRPSInstruction()

    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    sync_errors = <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].IESB == '1';
    if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        sync_errors = sync_errors || (SCR_EL3.EA == '1' &amp;&amp; SCR_EL3.NMEA == '1' &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    // SCTLR[].IESB might be ignored in Debug state.
    if !<a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_IESBinDebug</a>) then
        sync_errors = FALSE;
    if sync_errors then
        <a href="shared_pseudocode.html#impl-shared.SynchronizeErrors.0" title="function: SynchronizeErrors()">SynchronizeErrors</a>();

    bits(64) spsr = <a href="shared_pseudocode.html#impl-shared.SPSR.read.0" title="accessor: bits(N) SPSR[]">SPSR</a>[];
    <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);

    // PSTATE.{N,Z,C,V,Q,GE,SS,D,A,I,F} are not observable and ignored in Debug state, so
    // behave as if UNKNOWN.
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        PSTATE.&lt;N,Z,C,V,Q,GE,SS,A,I,F&gt; = bits(13) UNKNOWN;
        //  In AArch32, all instructions are T32 and unconditional.
        PSTATE.IT = '00000000';  PSTATE.T = '1';        // PSTATE.J is RES0
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;
    else
        PSTATE.&lt;N,Z,C,V,SS,D,A,I,F&gt; = bits(9) UNKNOWN;
        DLR_EL0 = bits(64) UNKNOWN;  DSPSR_EL0 = bits(64) UNKNOWN;

    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                                // Update EDSCR PE state flags

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DebugHalt"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DebugHalt</h3>
      <p class="pseudocode">constant bits(6) <a id="DebugHalt_Breakpoint"/>DebugHalt_Breakpoint      = '000111';
constant bits(6) <a id="DebugHalt_EDBGRQ"/>DebugHalt_EDBGRQ          = '010011';
constant bits(6) <a id="DebugHalt_Step_Normal"/>DebugHalt_Step_Normal     = '011011';
constant bits(6) <a id="DebugHalt_Step_Exclusive"/>DebugHalt_Step_Exclusive  = '011111';
constant bits(6) <a id="DebugHalt_OSUnlockCatch"/>DebugHalt_OSUnlockCatch   = '100011';
constant bits(6) <a id="DebugHalt_ResetCatch"/>DebugHalt_ResetCatch      = '100111';
constant bits(6) <a id="DebugHalt_Watchpoint"/>DebugHalt_Watchpoint      = '101011';
constant bits(6) <a id="DebugHalt_HaltInstruction"/>DebugHalt_HaltInstruction = '101111';
constant bits(6) <a id="DebugHalt_SoftwareAccess"/>DebugHalt_SoftwareAccess  = '110011';
constant bits(6) <a id="DebugHalt_ExceptionCatch"/>DebugHalt_ExceptionCatch  = '110111';
constant bits(6) <a id="DebugHalt_Step_NoSyndrome"/>DebugHalt_Step_NoSyndrome = '111011';</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.DisableITRAndResumeInstructionPrefetch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/DisableITRAndResumeInstructionPrefetch</h3>
      <p class="pseudocode"><a id="impl-shared.DisableITRAndResumeInstructionPrefetch.0"/>DisableITRAndResumeInstructionPrefetch();</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.ExecuteA64"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/ExecuteA64</h3>
      <p class="pseudocode">// Execute an A64 instruction in Debug state.
<a id="impl-shared.ExecuteA64.1"/>ExecuteA64(bits(32) instr);</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.ExecuteT32"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/ExecuteT32</h3>
      <p class="pseudocode">// Execute a T32 instruction in Debug state.
<a id="impl-shared.ExecuteT32.2"/>ExecuteT32(bits(16) hw1, bits(16) hw2);</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.ExitDebugState"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/ExitDebugState</h3>
      <p class="pseudocode">// ExitDebugState()
// ================

<a id="impl-shared.ExitDebugState.0"/>ExitDebugState()
    assert <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();
    <a href="shared_pseudocode.html#impl-shared.SynchronizeContext.0" title="function: SynchronizeContext()">SynchronizeContext</a>();

    // Although EDSCR.STATUS signals that the PE is restarting, debuggers must use EDPRSR.SDR to
    // detect that the PE has restarted.
    EDSCR.STATUS = '000001';                           // Signal restarting
    EDESR&lt;2:0&gt; = '000';                                // Clear any pending Halting debug events

    bits(64) new_pc;
    bits(64) spsr;

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        new_pc = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(DLR);
        spsr = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(DSPSR);
    else
        new_pc = DLR_EL0;
        spsr = DSPSR_EL0;
    // If this is an illegal return, SetPSTATEFromPSR() will set PSTATE.IL.
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr&lt;31:0&gt;);                  // Can update privileged bits, even at EL0
    else
        <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.1" title="function: SetPSTATEFromPSR(bits(N) spsr)">SetPSTATEFromPSR</a>(spsr);                        // Can update privileged bits, even at EL0

    boolean branch_conditional = FALSE;
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_RESTARTALIGNPC" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESTARTALIGNPC</a>) then new_pc&lt;0&gt; = '0';
        // AArch32 branch
        <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc&lt;31:0&gt;, <a href="shared_pseudocode.html#BranchType_DBGEXIT" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DBGEXIT</a>, branch_conditional);
    else
        // If targeting AArch32 then possibly zero the 32 most significant bits of the target PC
        if spsr&lt;4&gt; == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_RESTARTZEROUPPERPC" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESTARTZEROUPPERPC</a>) then
            new_pc&lt;63:32&gt; = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
        if <a href="shared_pseudocode.html#impl-shared.HaveBRBExt.0" title="function: boolean HaveBRBExt()">HaveBRBExt</a>() then
            <a href="shared_pseudocode.html#impl-aarch64.BRBEDebugStateExit.1" title="function: BRBEDebugStateExit(bits(64) target_address)">BRBEDebugStateExit</a>(new_pc);
        // A type of branch that is never predicted
        <a href="shared_pseudocode.html#impl-shared.BranchTo.3" title="function: BranchTo(bits(N) target, BranchType branch_type, boolean branch_conditional)">BranchTo</a>(new_pc, <a href="shared_pseudocode.html#BranchType_DBGEXIT" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DBGEXIT</a>, branch_conditional);

    (EDSCR.STATUS,EDPRSR.SDR) = ('000010','1');        // Atomically signal restarted
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                               // Stop signalling PE state
    <a href="shared_pseudocode.html#impl-shared.DisableITRAndResumeInstructionPrefetch.0" title="function: DisableITRAndResumeInstructionPrefetch()">DisableITRAndResumeInstructionPrefetch</a>();

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.Halt"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/Halt</h3>
      <p class="pseudocode">// Halt()
// ======

<a id="impl-shared.Halt.1"/>Halt(bits(6) reason)

    <a href="shared_pseudocode.html#impl-shared.CTI_SignalEvent.1" title="function: CTI_SignalEvent(CrossTriggerIn id)">CTI_SignalEvent</a>(<a href="shared_pseudocode.html#CrossTriggerIn_CrossHalt" title="enumeration CrossTriggerIn  {CrossTriggerIn_CrossHalt,     CrossTriggerIn_PMUOverflow,&#13; CrossTriggerIn_RSVD2,         CrossTriggerIn_RSVD3,&#13; CrossTriggerIn_TraceExtOut0,  CrossTriggerIn_TraceExtOut1,&#13; CrossTriggerIn_TraceExtOut2,  CrossTriggerIn_TraceExtOut3}">CrossTriggerIn_CrossHalt</a>);  // Trigger other cores to halt

    bits(64) preferred_restart_address = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    bits(32) spsr_32;
    bits(64) spsr_64;
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        spsr_32 = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.1" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#DebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</a>);
    else
        spsr_64 = <a href="shared_pseudocode.html#impl-shared.GetPSRFromPSTATE.1" title="function: bits(N) GetPSRFromPSTATE(ExceptionalOccurrenceTargetState targetELState)">GetPSRFromPSTATE</a>(<a href="shared_pseudocode.html#DebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</a>);

    if (<a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() &amp;&amp;
        !(reason IN {<a href="shared_pseudocode.html#DebugHalt_Step_Normal" title="constant bits(6) DebugHalt_Step_Normal = '011011'">DebugHalt_Step_Normal</a>, <a href="shared_pseudocode.html#DebugHalt_Step_Exclusive" title="constant bits(6) DebugHalt_Step_Exclusive = '011111'">DebugHalt_Step_Exclusive</a>, <a href="shared_pseudocode.html#DebugHalt_Step_NoSyndrome" title="constant bits(6) DebugHalt_Step_NoSyndrome = '111011'">DebugHalt_Step_NoSyndrome</a>,
                     <a href="shared_pseudocode.html#DebugHalt_Breakpoint" title="constant bits(6) DebugHalt_Breakpoint = '000111'">DebugHalt_Breakpoint</a>, <a href="shared_pseudocode.html#DebugHalt_HaltInstruction" title="constant bits(6) DebugHalt_HaltInstruction = '101111'">DebugHalt_HaltInstruction</a>}) &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ZEROBTYPE</a>)) then
        if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            spsr_32&lt;11:10&gt; = '00';
        else
            spsr_64&lt;11:10&gt; = '00';

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        DLR = preferred_restart_address&lt;31:0&gt;;
        DSPSR = spsr_32;
    else
        DLR_EL0 = preferred_restart_address;
        DSPSR_EL0 = spsr_64;

    EDSCR.ITE = '1';
    EDSCR.ITO = '0';
    if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        EDSCR.SDD = '0';                        // If entered in Secure state, allow debug
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        EDSCR.SDD = if <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>() then '0' else '1';
    else
        assert EDSCR.SDD == '1';                // Otherwise EDSCR.SDD is RES1
    EDSCR.MA = '0';

    // In Debug state:
    // * PSTATE.{SS,SSBS,D,A,I,F} are not observable and ignored so behave-as-if UNKNOWN.
    // * PSTATE.{N,Z,C,V,Q,GE,E,M,nRW,EL,SP,DIT} are also not observable, but since these
    //     are not changed on exception entry, this function also leaves them unchanged.
    // * PSTATE.{IT,T} are ignored.
    // * PSTATE.IL is ignored and behave-as-if 0.
    // * PSTATE.BTYPE is ignored and behave-as-if 0.
    // * PSTATE.TCO is set 1.
    // * PSTATE.{UAO,PAN} are observable and not changed on entry into Debug state.
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        PSTATE.&lt;IT,SS,SSBS,A,I,F,T&gt; = bits(14) UNKNOWN;
    else
        PSTATE.&lt;SS,SSBS,D,A,I,F&gt;    = bits(6)  UNKNOWN;
        PSTATE.TCO = '1';
        PSTATE.BTYPE = '00';
    PSTATE.IL = '0';

    <a href="shared_pseudocode.html#impl-shared.StopInstructionPrefetchAndEnableITR.0" title="function: StopInstructionPrefetchAndEnableITR()">StopInstructionPrefetchAndEnableITR</a>();
    EDSCR.STATUS = reason;                      // Signal entered Debug state
    <a href="shared_pseudocode.html#impl-shared.UpdateEDSCRFields.0" title="function: UpdateEDSCRFields()">UpdateEDSCRFields</a>();                        // Update EDSCR PE state flags.

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.HaltOnBreakpointOrWatchpoint"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/HaltOnBreakpointOrWatchpoint</h3>
      <p class="pseudocode">// HaltOnBreakpointOrWatchpoint()
// ==============================
// Returns TRUE if the Breakpoint and Watchpoint debug events should be considered for Debug
// state entry, FALSE if they should be considered for a debug exception.

boolean <a id="impl-shared.HaltOnBreakpointOrWatchpoint.0"/>HaltOnBreakpointOrWatchpoint()
    return <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDSCR.HDE == '1' &amp;&amp; OSLSR_EL1.OSLK == '0';</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.Halted"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/Halted</h3>
      <p class="pseudocode">// Halted()
// ========

boolean <a id="impl-shared.Halted.0"/>Halted()
    return !(EDSCR.STATUS IN {'000001', '000010'});                     // Halted</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.HaltingAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/HaltingAllowed</h3>
      <p class="pseudocode">// HaltingAllowed()
// ================
// Returns TRUE if halting is currently allowed, FALSE if halting is prohibited.

boolean <a id="impl-shared.HaltingAllowed.0"/>HaltingAllowed()
    if <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.DoubleLockStatus.0" title="function: boolean DoubleLockStatus()">DoubleLockStatus</a>() then
        return FALSE;
    elsif <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
        return <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();
    else
        return <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.Restarting"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/Restarting</h3>
      <p class="pseudocode">// Restarting()
// ============

boolean <a id="impl-shared.Restarting.0"/>Restarting()
    return EDSCR.STATUS == '000001';                                    // Restarting</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.StopInstructionPrefetchAndEnableITR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/StopInstructionPrefetchAndEnableITR</h3>
      <p class="pseudocode"><a id="impl-shared.StopInstructionPrefetchAndEnableITR.0"/>StopInstructionPrefetchAndEnableITR();</p>
    </div>
    <div class="ps"><a id="shared.debug.halting.UpdateEDSCRFields"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/halting/UpdateEDSCRFields</h3>
      <p class="pseudocode">// UpdateEDSCRFields()
// ===================
// Update EDSCR PE state fields

<a id="impl-shared.UpdateEDSCRFields.0"/>UpdateEDSCRFields()

    if !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then
        EDSCR.EL = '00';
        EDSCR.NS = bit UNKNOWN;
        EDSCR.RW = '1111';
    else
        EDSCR.EL = PSTATE.EL;
        EDSCR.NS = if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then '0' else '1';

        bits(4) RW;
        RW&lt;1&gt; = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then '0' else '1';
        if PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            RW&lt;0&gt; = RW&lt;1&gt;;
        else
            RW&lt;0&gt; = if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then '0' else '1';
        if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '0' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then
            RW&lt;2&gt; = RW&lt;1&gt;;
        else
            RW&lt;2&gt; = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then '0' else '1';
        if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            RW&lt;3&gt; = RW&lt;2&gt;;
        else
            RW&lt;3&gt; = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then '0' else '1';

        // The least-significant bits of EDSCR.RW are UNKNOWN if any higher EL is using AArch32.
        if RW&lt;3&gt; == '0' then RW&lt;2:0&gt; = bits(3) UNKNOWN;
        elsif RW&lt;2&gt; == '0' then RW&lt;1:0&gt; = bits(2) UNKNOWN;
        elsif RW&lt;1&gt; == '0' then RW&lt;0&gt; = bit UNKNOWN;
        EDSCR.RW = RW;
    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckExceptionCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckExceptionCatch</h3>
      <p class="pseudocode">// CheckExceptionCatch()
// =====================
// Check whether an Exception Catch debug event is set on the current Exception level

<a id="impl-shared.CheckExceptionCatch.1"/>CheckExceptionCatch(boolean exception_entry)
    // Called after an exception entry or exit, that is, such that IsSecure()
    // and PSTATE.EL are correct for the exception target. When FEAT_Debugv8p2
    // is not implemented, this function might also be called at any time.
    base = if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then 0 else 4;
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveExtendedECDebugEvents.0" title="function: boolean HaveExtendedECDebugEvents()">HaveExtendedECDebugEvents</a>() then
            exception_exit = !exception_entry;
            ctrl = EDECCR&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) + base + 8&gt;:EDECCR&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) + base&gt;;
            case ctrl of
                when '00'  halt = FALSE;
                when '01'  halt = TRUE;
                when '10'  halt = (exception_exit == TRUE);
                when '11'  halt = (exception_entry == TRUE);
        else
            halt = (EDECCR&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) + base&gt; == '1');
        if halt then <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_ExceptionCatch" title="constant bits(6) DebugHalt_ExceptionCatch = '110111'">DebugHalt_ExceptionCatch</a>);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckHaltingStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckHaltingStep</h3>
      <p class="pseudocode">// CheckHaltingStep()
// ==================
// Check whether EDESR.SS has been set by Halting Step

<a id="impl-shared.CheckHaltingStep.0"/>CheckHaltingStep()
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDESR.SS == '1' then
        // The STATUS code depends on how we arrived at the state where EDESR.SS == 1.
        if <a href="shared_pseudocode.html#impl-shared.HaltingStep_DidNotStep.0" title="function: boolean HaltingStep_DidNotStep()">HaltingStep_DidNotStep</a>() then
            <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_Step_NoSyndrome" title="constant bits(6) DebugHalt_Step_NoSyndrome = '111011'">DebugHalt_Step_NoSyndrome</a>);
        elsif <a href="shared_pseudocode.html#impl-shared.HaltingStep_SteppedEX.0" title="function: boolean HaltingStep_SteppedEX()">HaltingStep_SteppedEX</a>() then
            <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_Step_Exclusive" title="constant bits(6) DebugHalt_Step_Exclusive = '011111'">DebugHalt_Step_Exclusive</a>);
        else
            <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_Step_Normal" title="constant bits(6) DebugHalt_Step_Normal = '011011'">DebugHalt_Step_Normal</a>);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckOSUnlockCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckOSUnlockCatch</h3>
      <p class="pseudocode">// CheckOSUnlockCatch()
// ====================
// Called on unlocking the OS Lock to pend an OS Unlock Catch debug event

<a id="impl-shared.CheckOSUnlockCatch.0"/>CheckOSUnlockCatch()

    if (<a href="shared_pseudocode.html#impl-shared.HaveDoPD.0" title="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; CTIDEVCTL.OSUCE == '1')
    || (!<a href="shared_pseudocode.html#impl-shared.HaveDoPD.0" title="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; EDECR.OSUCE == '1')
    then
        if !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then EDESR.OSUC = '1';</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckPendingOSUnlockCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckPendingOSUnlockCatch</h3>
      <p class="pseudocode">// CheckPendingOSUnlockCatch()
// ===========================
// Check whether EDESR.OSUC has been set by an OS Unlock Catch debug event

<a id="impl-shared.CheckPendingOSUnlockCatch.0"/>CheckPendingOSUnlockCatch()
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDESR.OSUC == '1' then
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_OSUnlockCatch" title="constant bits(6) DebugHalt_OSUnlockCatch = '100011'">DebugHalt_OSUnlockCatch</a>);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckPendingResetCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckPendingResetCatch</h3>
      <p class="pseudocode">// CheckPendingResetCatch()
// ========================
// Check whether EDESR.RC has been set by a Reset Catch debug event

<a id="impl-shared.CheckPendingResetCatch.0"/>CheckPendingResetCatch()
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDESR.RC == '1' then
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_ResetCatch" title="constant bits(6) DebugHalt_ResetCatch = '100111'">DebugHalt_ResetCatch</a>);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckResetCatch"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckResetCatch</h3>
      <p class="pseudocode">// CheckResetCatch()
// =================
// Called after reset

<a id="impl-shared.CheckResetCatch.0"/>CheckResetCatch()
    if (<a href="shared_pseudocode.html#impl-shared.HaveDoPD.0" title="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; CTIDEVCTL.RCE == '1') || (!<a href="shared_pseudocode.html#impl-shared.HaveDoPD.0" title="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; EDECR.RCE == '1') then
        EDESR.RC = '1';
        // If halting is allowed then halt immediately
        if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() then <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_ResetCatch" title="constant bits(6) DebugHalt_ResetCatch = '100111'">DebugHalt_ResetCatch</a>);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.CheckSoftwareAccessToDebugRegisters"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/CheckSoftwareAccessToDebugRegisters</h3>
      <p class="pseudocode">// CheckSoftwareAccessToDebugRegisters()
// =====================================
// Check for access to Breakpoint and Watchpoint registers.

<a id="impl-shared.CheckSoftwareAccessToDebugRegisters.0"/>CheckSoftwareAccessToDebugRegisters()
    os_lock = (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then DBGOSLSR.OSLK else OSLSR_EL1.OSLK);
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() &amp;&amp; EDSCR.TDA == '1' &amp;&amp; os_lock == '0' then
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_SoftwareAccess" title="constant bits(6) DebugHalt_SoftwareAccess = '110011'">DebugHalt_SoftwareAccess</a>);</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.ExternalDebugRequest"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/ExternalDebugRequest</h3>
      <p class="pseudocode">// ExternalDebugRequest()
// ======================

<a id="impl-shared.ExternalDebugRequest.0"/>ExternalDebugRequest()
    if <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() then
        <a href="shared_pseudocode.html#impl-shared.Halt.1" title="function: Halt(bits(6) reason)">Halt</a>(<a href="shared_pseudocode.html#DebugHalt_EDBGRQ" title="constant bits(6) DebugHalt_EDBGRQ = '010011'">DebugHalt_EDBGRQ</a>);
    // Otherwise the CTI continues to assert the debug request until it is taken.</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.HaltingStep_DidNotStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/HaltingStep_DidNotStep</h3>
      <p class="pseudocode">// Returns TRUE if the previously executed instruction was executed in the inactive state, that is,
// if it was not itself stepped.
boolean <a id="impl-shared.HaltingStep_DidNotStep.0"/>HaltingStep_DidNotStep();</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.HaltingStep_SteppedEX"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/HaltingStep_SteppedEX</h3>
      <p class="pseudocode">// Returns TRUE if the previously executed instruction was a Load-Exclusive class instruction
// executed in the active-not-pending state.
boolean <a id="impl-shared.HaltingStep_SteppedEX.0"/>HaltingStep_SteppedEX();</p>
    </div>
    <div class="ps"><a id="shared.debug.haltingevents.RunHaltingStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/haltingevents/RunHaltingStep</h3>
      <p class="pseudocode">// RunHaltingStep()
// ================

<a id="impl-shared.RunHaltingStep.4"/>RunHaltingStep(boolean exception_generated, bits(2) exception_target, boolean syscall,
               boolean reset)
    // "exception_generated" is TRUE if the previous instruction generated a synchronous exception
    // or was cancelled by an asynchronous exception.
    //
    // if "exception_generated" is TRUE then "exception_target" is the target of the exception, and
    // "syscall" is TRUE if the exception is a synchronous exception where the preferred return
    // address is the instruction following that which generated the exception.
    //
    // "reset" is TRUE if exiting reset state into the highest EL.

    if reset then assert !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();             // Cannot come out of reset halted
    active = EDECR.SS == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();

    if active &amp;&amp; reset then                     // Coming out of reset with EDECR.SS set
        EDESR.SS = '1';
    elsif active &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaltingAllowed.0" title="function: boolean HaltingAllowed()">HaltingAllowed</a>() then
        if exception_generated &amp;&amp; exception_target == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            advance = syscall || <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>();
        else
            advance = TRUE;
        if advance then EDESR.SS = '1';

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.interrupts.ExternalDebugInterruptsDisabled"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/interrupts/ExternalDebugInterruptsDisabled</h3>
      <p class="pseudocode">// ExternalDebugInterruptsDisabled()
// =================================
// Determine whether EDSCR disables interrupts routed to 'target'.

boolean <a id="impl-shared.ExternalDebugInterruptsDisabled.1"/>ExternalDebugInterruptsDisabled(bits(2) target)
    if <a href="shared_pseudocode.html#impl-shared.Havev8p4Debug.0" title="function: boolean Havev8p4Debug()">Havev8p4Debug</a>() then
        if target == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> || <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
            int_dis = (EDSCR.INTdis[0] == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>());
        else
            int_dis = (EDSCR.INTdis[0] == '1');
    else
        case target of
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
                int_dis = (EDSCR.INTdis == '11' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>());
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
                int_dis = (EDSCR.INTdis == '1x' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>());
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
                if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then
                    int_dis = (EDSCR.INTdis == '1x' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ExternalSecureInvasiveDebugEnabled.0" title="function: boolean ExternalSecureInvasiveDebugEnabled()">ExternalSecureInvasiveDebugEnabled</a>());
                else
                    int_dis = (EDSCR.INTdis != '00' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ExternalInvasiveDebugEnabled.0" title="function: boolean ExternalInvasiveDebugEnabled()">ExternalInvasiveDebugEnabled</a>());
    return int_dis;</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.GetNumEventCounters"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/GetNumEventCounters</h3>
      <p class="pseudocode">// GetNumEventCounters()
// =====================
// Returns the number of event counters implemented. This is indicated to software at the
// highest Exception level by PMCR.N in AArch32 state, and PMCR_EL0.N in AArch64 state.

integer <a id="impl-shared.GetNumEventCounters.0"/>GetNumEventCounters()
    return integer IMPLEMENTATION_DEFINED "Number of event counters";</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.HasElapsed64Cycles"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/HasElapsed64Cycles</h3>
      <p class="pseudocode">// Returns TRUE if 64 cycles have elapsed between the last count, and FALSE otherwise.
boolean <a id="impl-shared.HasElapsed64Cycles.0"/>HasElapsed64Cycles();</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUCounterMask"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUCounterMask</h3>
      <p class="pseudocode">constant integer <a id="CYCLE_COUNTER_ID"/>CYCLE_COUNTER_ID = 31;

// PMUCounterMask()
// ================
// Return bitmask of accessible PMU counters.

bits(32) <a id="impl-shared.PMUCounterMask.0"/>PMUCounterMask()
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        n = <a href="shared_pseudocode.html#AArch32.GetNumEventCountersAccessible.0" title="function: integer AArch32.GetNumEventCountersAccessible()">AArch32.GetNumEventCountersAccessible</a>();
    else
        n = <a href="shared_pseudocode.html#AArch64.GetNumEventCountersAccessible.0" title="function: integer AArch64.GetNumEventCountersAccessible()">AArch64.GetNumEventCountersAccessible</a>();
    return '1' : <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(n), 31);</p>
    </div>
    <div class="ps"><a id="shared.debug.pmu.PMUEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/pmu/PMUEvent</h3>
      <p class="pseudocode">constant bits(16) <a id="PMU_EVENT_SW_INCR"/>PMU_EVENT_SW_INCR                    = 0x0000&lt;15:0&gt;;
constant bits(16) <a id="PMU_EVENT_INST_RETIRED"/>PMU_EVENT_INST_RETIRED               = 0x0008&lt;15:0&gt;;
constant bits(16) <a id="PMU_EVENT_EXC_TAKEN"/>PMU_EVENT_EXC_TAKEN                  = 0x0009&lt;15:0&gt;;
constant bits(16) <a id="PMU_EVENT_CPU_CYCLES"/>PMU_EVENT_CPU_CYCLES                 = 0x0011&lt;15:0&gt;;
constant bits(16) <a id="PMU_EVENT_INST_SPEC"/>PMU_EVENT_INST_SPEC                  = 0x001B&lt;15:0&gt;;
constant bits(16) <a id="PMU_EVENT_CHAIN"/>PMU_EVENT_CHAIN                      = 0x001E&lt;15:0&gt;;

// PMUEvent()
// ==========
// Generate a PMU event. By default, increment by 1.

<a id="impl-shared.PMUEvent.1"/>PMUEvent(bits(16) event)
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        <a href="shared_pseudocode.html#AArch32.PMUEvent.2" title="function: AArch32.PMUEvent(bits(16) event, integer increment)">AArch32.PMUEvent</a>(event, 1);
    else
        <a href="shared_pseudocode.html#AArch64.PMUEvent.2" title="function: AArch64.PMUEvent(bits(16) event, integer increment)">AArch64.PMUEvent</a>(event, 1);</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.CreatePCSample"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/CreatePCSample</h3>
      <p class="pseudocode">// CreatePCSample()
// ================

<a id="impl-shared.CreatePCSample.0"/>CreatePCSample()
    // In a simple sequential execution of the program, CreatePCSample is executed each time the PE
    // executes an instruction that can be sampled. An implementation is not constrained such that
    // reads of EDPCSRlo return the current values of PC, etc.

    pc_sample.valid = <a href="shared_pseudocode.html#impl-shared.ExternalNoninvasiveDebugAllowed.0" title="function: boolean ExternalNoninvasiveDebugAllowed()">ExternalNoninvasiveDebugAllowed</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>();
    pc_sample.pc = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
    pc_sample.el = PSTATE.EL;
    pc_sample.rw = if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then '0' else '1';
    pc_sample.ns = if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() then '0' else '1';
    pc_sample.contextidr = if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then CONTEXTIDR else CONTEXTIDR_EL1&lt;31:0&gt;;
    pc_sample.has_el2 = PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    if pc_sample.has_el2 then
        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            pc_sample.vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR.VMID, 16);
        elsif !<a href="shared_pseudocode.html#impl-shared.Have16bitVMID.0" title="function: boolean Have16bitVMID()">Have16bitVMID</a>() || VTCR_EL2.VS == '0' then
            pc_sample.vmid = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(VTTBR_EL2.VMID&lt;7:0&gt;, 16);
        else
            pc_sample.vmid = VTTBR_EL2.VMID;
        if (<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a href="shared_pseudocode.html#impl-shared.HaveV82Debug.0" title="function: boolean HaveV82Debug()">HaveV82Debug</a>()) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            pc_sample.contextidr_el2 = CONTEXTIDR_EL2&lt;31:0&gt;;
        else
            pc_sample.contextidr_el2 = bits(32) UNKNOWN;
        pc_sample.el0h = PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.EDPCSRlo"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/EDPCSRlo</h3>
      <p class="pseudocode">// EDPCSRlo[] (read)
// =================

bits(32) <a id="impl-shared.EDPCSRlo.read.1"/>EDPCSRlo[boolean memory_mapped]

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return bits(32) UNKNOWN;

    // The Software lock is OPTIONAL.
    update = !memory_mapped || EDLSR.SLK == '0';        // Software locked: no side-effects

    if pc_sample.valid then
        sample = pc_sample.pc&lt;31:0&gt;;
        if update then
            if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; EDSCR.SC2 == '1' then
                EDPCSRhi.PC = (if pc_sample.rw == '0' then <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24) else pc_sample.pc&lt;55:32&gt;);
                EDPCSRhi.EL = pc_sample.el;
                EDPCSRhi.NS = pc_sample.ns;
            else
                EDPCSRhi = (if pc_sample.rw == '0' then <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(32) else pc_sample.pc&lt;63:32&gt;);
            EDCIDSR = pc_sample.contextidr;
            if (<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a href="shared_pseudocode.html#impl-shared.HaveV82Debug.0" title="function: boolean HaveV82Debug()">HaveV82Debug</a>()) &amp;&amp; EDSCR.SC2 == '1' then
                EDVIDSR = (if pc_sample.has_el2 then pc_sample.contextidr_el2
                           else bits(32) UNKNOWN);
            else
                EDVIDSR.VMID = (if pc_sample.has_el2 &amp;&amp; pc_sample.el IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>,<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>}
                                then pc_sample.vmid else <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>());
                EDVIDSR.NS = pc_sample.ns;
                EDVIDSR.E2 = (if pc_sample.el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then '1' else '0');
                EDVIDSR.E3 = (if pc_sample.el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then '1' else '0') AND pc_sample.rw;
                // The conditions for setting HV are not specified if PCSRhi is zero.
                // An example implementation may be "pc_sample.rw".
                EDVIDSR.HV = (if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(EDPCSRhi) then '1' else bit IMPLEMENTATION_DEFINED "0 or 1");
    else
        sample = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(32);
        if update then
            EDPCSRhi = bits(32) UNKNOWN;
            EDCIDSR = bits(32) UNKNOWN;
            EDVIDSR = bits(32) UNKNOWN;

    return sample;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.PCSample"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/PCSample</h3>
      <p class="pseudocode">type <a id="PCSample"/>PCSample is (
    boolean valid,
    bits(64) pc,
    bits(2) el,
    bit rw,
    bit ns,
    boolean has_el2,
    bits(32) contextidr,
    bits(32) contextidr_el2,
    boolean el0h,
    bits(16) vmid
)

<a href="shared_pseudocode.html#PCSample" title="type PCSample is ( boolean valid, bits(64) pc, bits(2) el, bit rw, bit ns, boolean has_el2, bits(32) contextidr, bits(32) contextidr_el2, boolean el0h, bits(16) vmid )">PCSample</a> pc_sample;</p>
    </div>
    <div class="ps"><a id="shared.debug.samplebasedprofiling.PMPCSR"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/samplebasedprofiling/PMPCSR</h3>
      <p class="pseudocode">// PMPCSR[] (read)
// ===============

bits(32) <a id="impl-shared.PMPCSR.read.1"/>PMPCSR[boolean memory_mapped]

    if EDPRSR&lt;6:5,0&gt; != '001' then                      // Check DLK, OSLK and PU bits
        IMPLEMENTATION_DEFINED "generate error response";
        return bits(32) UNKNOWN;

    // The Software lock is OPTIONAL.
    update = !memory_mapped || PMLSR.SLK == '0';        // Software locked: no side-effects

    if pc_sample.valid then
        sample = pc_sample.pc&lt;31:0&gt;;
        if update then
            PMPCSR&lt;55:32&gt; = (if pc_sample.rw == '0' then <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24) else pc_sample.pc&lt;55:32&gt;);
            PMPCSR.EL = pc_sample.el;
            PMPCSR.NS = pc_sample.ns;

            PMCID1SR = pc_sample.contextidr;
            PMCID2SR = if pc_sample.has_el2 then pc_sample.contextidr_el2 else bits(32) UNKNOWN;

            PMVIDSR.VMID = (if pc_sample.has_el2 &amp;&amp; pc_sample.el IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>,<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>} &amp;&amp; !pc_sample.el0h
                            then pc_sample.vmid else bits(16) UNKNOWN);
    else
        sample = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(32);
        if update then
            PMPCSR&lt;55:32&gt;  = bits(24) UNKNOWN;
            PMPCSR.EL = bits(2) UNKNOWN;
            PMPCSR.NS = bit UNKNOWN;

            PMCID1SR = bits(32) UNKNOWN;
            PMCID2SR = bits(32) UNKNOWN;

            PMVIDSR.VMID = bits(16) UNKNOWN;

    return sample;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.CheckSoftwareStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/CheckSoftwareStep</h3>
      <p class="pseudocode">// CheckSoftwareStep()
// ===================
// Take a Software Step exception if in the active-pending state

<a id="impl-shared.CheckSoftwareStep.0"/>CheckSoftwareStep()

    // Other self-hosted debug functions will call AArch32.GenerateDebugExceptions() if called from
    // AArch32 state. However, because Software Step is only active when the debug target Exception
    // level is using AArch64, CheckSoftwareStep only calls AArch64.GenerateDebugExceptions().
    step_enabled = !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()">DebugTarget</a>()) &amp;&amp; <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()">AArch64.GenerateDebugExceptions</a>() &amp;&amp; MDSCR_EL1.SS == '1';
    if step_enabled &amp;&amp; PSTATE.SS == '0' then
        <a href="shared_pseudocode.html#AArch64.SoftwareStepException.0" title="function: AArch64.SoftwareStepException()">AArch64.SoftwareStepException</a>();</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.DebugExceptionReturnSS"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/DebugExceptionReturnSS</h3>
      <p class="pseudocode">// DebugExceptionReturnSS()
// ========================
// Returns value to write to PSTATE.SS on an exception return or Debug state exit.

bit <a id="impl-shared.DebugExceptionReturnSS.1"/>DebugExceptionReturnSS(bits(N) spsr)
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        assert N == 32;
    else
        assert N == 64;

    assert <a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() || <a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()">Restarting</a>() ||  PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;

    if <a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()">Restarting</a>() then
        enabled_at_source = FALSE;
    elsif <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        enabled_at_source = <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptions.0" title="function: boolean AArch32.GenerateDebugExceptions()">AArch32.GenerateDebugExceptions</a>();
    else
        enabled_at_source = <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptions.0" title="function: boolean AArch64.GenerateDebugExceptions()">AArch64.GenerateDebugExceptions</a>();

    if <a href="shared_pseudocode.html#impl-shared.IllegalExceptionReturn.1" title="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</a>(spsr) then
        dest = PSTATE.EL;
    else
        (valid, dest) = <a href="shared_pseudocode.html#impl-shared.ELFromSPSR.1" title="function: (boolean,bits(2)) ELFromSPSR(bits(N) spsr)">ELFromSPSR</a>(spsr);  assert valid;

    dest_is_secure = <a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>() || dest == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    dest_using_32 = (if dest == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then spsr&lt;4&gt; == '1' else <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(dest));
    if dest_using_32 then
        enabled_at_dest = <a href="shared_pseudocode.html#AArch32.GenerateDebugExceptionsFrom.2" title="function: boolean AArch32.GenerateDebugExceptionsFrom(bits(2) from, boolean secure)">AArch32.GenerateDebugExceptionsFrom</a>(dest, dest_is_secure);
    else
        mask = spsr&lt;9&gt;;
        enabled_at_dest = <a href="shared_pseudocode.html#AArch64.GenerateDebugExceptionsFrom.3" title="function: boolean AArch64.GenerateDebugExceptionsFrom(bits(2) from, boolean secure, bit mask)">AArch64.GenerateDebugExceptionsFrom</a>(dest, dest_is_secure, mask);

    ELd = <a href="shared_pseudocode.html#impl-shared.DebugTargetFrom.1" title="function: bits(2) DebugTargetFrom(boolean secure)">DebugTargetFrom</a>(dest_is_secure);
    if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(ELd) &amp;&amp; MDSCR_EL1.SS == '1' &amp;&amp; !enabled_at_source &amp;&amp; enabled_at_dest then
        SS_bit = spsr&lt;21&gt;;
    else
        SS_bit = '0';

    return SS_bit;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.SSAdvance"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/SSAdvance</h3>
      <p class="pseudocode">// SSAdvance()
// ===========
// Advance the Software Step state machine.

<a id="impl-shared.SSAdvance.0"/>SSAdvance()

    // A simpler implementation of this function just clears PSTATE.SS to zero regardless of the
    // current Software Step state machine. However, this check is made to illustrate that the
    // processor only needs to consider advancing the state machine from the active-not-pending
    // state.
    target = <a href="shared_pseudocode.html#impl-shared.DebugTarget.0" title="function: bits(2) DebugTarget()">DebugTarget</a>();
    step_enabled = !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target) &amp;&amp; MDSCR_EL1.SS == '1';
    active_not_pending = step_enabled &amp;&amp; PSTATE.SS == '1';

    if active_not_pending then PSTATE.SS = '0';

    return;</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.SoftwareStep_DidNotStep"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/SoftwareStep_DidNotStep</h3>
      <p class="pseudocode">// Returns TRUE if the previously executed instruction was executed in the
// inactive state, that is, if it was not itself stepped.
// Might return TRUE or FALSE if the previously executed instruction was an ISB
// or ERET executed in the active-not-pending state, or if another exception
// was taken before the Software Step exception.  Returns FALSE otherwise,
// indicating that the previously executed instruction was executed in the
// active-not-pending state, that is, the instruction was stepped.
boolean <a id="impl-shared.SoftwareStep_DidNotStep.0"/>SoftwareStep_DidNotStep();</p>
    </div>
    <div class="ps"><a id="shared.debug.softwarestep.SoftwareStep_SteppedEX"/><h3 class="pseudocode">
            Library pseudocode for shared/debug/softwarestep/SoftwareStep_SteppedEX</h3>
      <p class="pseudocode">// Returns a value that describes the previously executed instruction. The
// result is valid only if SoftwareStep_DidNotStep() returns FALSE.
// Might return TRUE or FALSE if the instruction was an AArch32 LDREX or LDAEX
// that failed its condition code test.  Otherwise returns TRUE if the
// instruction was a Load-Exclusive class instruction, and FALSE if the
// instruction was not a Load-Exclusive class instruction.
boolean <a id="impl-shared.SoftwareStep_SteppedEX.0"/>SoftwareStep_SteppedEX();</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.ConditionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/ConditionSyndrome</h3>
      <p class="pseudocode">// ConditionSyndrome()
// ===================
// Return CV and COND fields of instruction syndrome

bits(5) <a id="impl-shared.ConditionSyndrome.0"/>ConditionSyndrome()

    bits(5) syndrome;

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        cond = <a href="shared_pseudocode.html#AArch32.CurrentCond.0" title="function: bits(4) AArch32.CurrentCond()">AArch32.CurrentCond</a>();
        if PSTATE.T == '0' then             // A32
            syndrome&lt;4&gt; = '1';
            // A conditional A32 instruction that is known to pass its condition code check
            // can be presented either with COND set to 0xE, the value for unconditional, or
            // the COND value held in the instruction.
            if <a href="shared_pseudocode.html#impl-shared.ConditionHolds.1" title="function: boolean ConditionHolds(bits(4) cond)">ConditionHolds</a>(cond) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ESRCONDPASS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ESRCONDPASS</a>) then
                syndrome&lt;3:0&gt; = '1110';
            else
                syndrome&lt;3:0&gt; = cond;
        else                                // T32
            // When a T32 instruction is trapped, it is IMPLEMENTATION DEFINED whether:
            //  * CV set to 0 and COND is set to an UNKNOWN value
            //  * CV set to 1 and COND is set to the condition code for the condition that
            //    applied to the instruction.
            if boolean IMPLEMENTATION_DEFINED "Condition valid for trapped T32" then
                syndrome&lt;4&gt; = '1';
                syndrome&lt;3:0&gt; = cond;
            else
                syndrome&lt;4&gt; = '0';
                syndrome&lt;3:0&gt; = bits(4) UNKNOWN;
    else
        syndrome&lt;4&gt; = '1';
        syndrome&lt;3:0&gt; = '1110';

    return syndrome;</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.Exception"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/Exception</h3>
      <p class="pseudocode">enumeration <a id="Exception"/>Exception {<a id="Exception_Uncategorized"/>Exception_Uncategorized,       // Uncategorized or unknown reason
                       <a id="Exception_WFxTrap"/>Exception_WFxTrap,             // Trapped WFI or WFE instruction
                       <a id="Exception_CP15RTTrap"/>Exception_CP15RTTrap,          // Trapped AArch32 MCR or MRC access, coproc=0b1111
                       <a id="Exception_CP15RRTTrap"/>Exception_CP15RRTTrap,         // Trapped AArch32 MCRR or MRRC access, coproc=0b1111
                       <a id="Exception_CP14RTTrap"/>Exception_CP14RTTrap,          // Trapped AArch32 MCR or MRC access, coproc=0b1110
                       <a id="Exception_CP14DTTrap"/>Exception_CP14DTTrap,          // Trapped AArch32 LDC or STC access, coproc=0b1110
                       <a id="Exception_CP14RRTTrap"/>Exception_CP14RRTTrap,         // Trapped AArch32 MRRC access, coproc=0b1110
                       <a id="Exception_AdvSIMDFPAccessTrap"/>Exception_AdvSIMDFPAccessTrap, // HCPTR-trapped access to SIMD or FP
                       <a id="Exception_FPIDTrap"/>Exception_FPIDTrap,            // Trapped access to SIMD or FP ID register
                       <a id="Exception_LDST64BTrap"/>Exception_LDST64BTrap,         // Trapped access to ST64BV, ST64BV0, ST64B and LD64B
                       // Trapped BXJ instruction not supported in Armv8
                       <a id="Exception_PACTrap"/>Exception_PACTrap,             // Trapped invalid PAC use
                       <a id="Exception_IllegalState"/>Exception_IllegalState,        // Illegal Execution state
                       <a id="Exception_SupervisorCall"/>Exception_SupervisorCall,      // Supervisor Call
                       <a id="Exception_HypervisorCall"/>Exception_HypervisorCall,      // Hypervisor Call
                       <a id="Exception_MonitorCall"/>Exception_MonitorCall,         // Monitor Call or Trapped SMC instruction
                       <a id="Exception_SystemRegisterTrap"/>Exception_SystemRegisterTrap,  // Trapped MRS or MSR system register access
                       <a id="Exception_ERetTrap"/>Exception_ERetTrap,            // Trapped invalid ERET use
                       <a id="Exception_InstructionAbort"/>Exception_InstructionAbort,    // Instruction Abort or Prefetch Abort
                       <a id="Exception_PCAlignment"/>Exception_PCAlignment,         // PC alignment fault
                       <a id="Exception_DataAbort"/>Exception_DataAbort,           // Data Abort
                       <a id="Exception_NV2DataAbort"/>Exception_NV2DataAbort,        // Data abort at EL1 reported as being from EL2
                       <a id="Exception_PACFail"/>Exception_PACFail,             // PAC Authentication failure
                       <a id="Exception_SPAlignment"/>Exception_SPAlignment,         // SP alignment fault
                       <a id="Exception_FPTrappedException"/>Exception_FPTrappedException,  // IEEE trapped FP exception
                       <a id="Exception_SError"/>Exception_SError,              // SError interrupt
                       <a id="Exception_Breakpoint"/>Exception_Breakpoint,          // (Hardware) Breakpoint
                       <a id="Exception_SoftwareStep"/>Exception_SoftwareStep,        // Software Step
                       <a id="Exception_Watchpoint"/>Exception_Watchpoint,          // Watchpoint
                       <a id="Exception_NV2Watchpoint"/>Exception_NV2Watchpoint,       // Watchpoint at EL1 reported as being from EL2
                       <a id="Exception_SoftwareBreakpoint"/>Exception_SoftwareBreakpoint,  // Software Breakpoint Instruction
                       <a id="Exception_VectorCatch"/>Exception_VectorCatch,         // AArch32 Vector Catch
                       <a id="Exception_IRQ"/>Exception_IRQ,                 // IRQ interrupt
                       <a id="Exception_SVEAccessTrap"/>Exception_SVEAccessTrap,       // HCPTR trapped access to SVE
                       <a id="Exception_SMEAccessTrap"/>Exception_SMEAccessTrap,       // HCPTR trapped access to SME
                       <a id="Exception_TSTARTAccessTrap"/>Exception_TSTARTAccessTrap,    // Trapped TSTART access
                       <a id="Exception_GPC"/>Exception_GPC,                 // Granule protection check
                       <a id="Exception_BranchTarget"/>Exception_BranchTarget,        // Branch Target Identification
                       <a id="Exception_MemCpyMemSet"/>Exception_MemCpyMemSet,        // Exception from a CPY* or SET* instruction
                       <a id="Exception_FIQ"/>Exception_FIQ};                // FIQ interrupt</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.ExceptionRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/ExceptionRecord</h3>
      <p class="pseudocode">type <a id="ExceptionRecord"/>ExceptionRecord is (
    <a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a>   exceptype,  // Exception class
    bits(25)    syndrome,   // Syndrome record
    bits(5)     syndrome2,  // ST64BV(0) return value register specifier
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress,   // Physical fault address
    bits(64)    vaddress,   // Virtual fault address
    boolean     ipavalid,   // Validity of Intermediate Physical fault address
    bit         NS,         // Intermediate Physical fault address space
    bits(52)    ipaddress)  // Intermediate Physical fault address</p>
    </div>
    <div class="ps"><a id="shared.exceptions.exceptions.ExceptionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for shared/exceptions/exceptions/ExceptionSyndrome</h3>
      <p class="pseudocode">// ExceptionSyndrome()
// ===================
// Return a blank exception syndrome record for an exception of the given type.

ExceptionRecord <a id="impl-shared.ExceptionSyndrome.1"/>ExceptionSyndrome(<a href="shared_pseudocode.html#Exception" title="enumeration Exception {Exception_Uncategorized, Exception_WFxTrap, Exception_CP15RTTrap, Exception_CP15RRTTrap, Exception_CP14RTTrap, Exception_CP14DTTrap, Exception_CP14RRTTrap, Exception_AdvSIMDFPAccessTrap, Exception_FPIDTrap, Exception_LDST64BTrap,  Exception_PACTrap, Exception_IllegalState, Exception_SupervisorCall, Exception_HypervisorCall, Exception_MonitorCall, Exception_SystemRegisterTrap, Exception_ERetTrap, Exception_InstructionAbort, Exception_PCAlignment, Exception_DataAbort, Exception_NV2DataAbort, Exception_PACFail, Exception_SPAlignment, Exception_FPTrappedException, Exception_SError, Exception_Breakpoint, Exception_SoftwareStep, Exception_Watchpoint, Exception_NV2Watchpoint, Exception_SoftwareBreakpoint, Exception_VectorCatch, Exception_IRQ, Exception_SVEAccessTrap, Exception_SMEAccessTrap, Exception_TSTARTAccessTrap, Exception_GPC, Exception_BranchTarget, Exception_MemCpyMemSet, Exception_FIQ}">Exception</a> exceptype)

    <a href="shared_pseudocode.html#ExceptionRecord" title="type ExceptionRecord is ( Exception exceptype, bits(25) syndrome, bits(5) syndrome2, FullAddress paddress, bits(64) vaddress, boolean ipavalid, bit NS, bits(52) ipaddress)">ExceptionRecord</a> r;

    r.exceptype = exceptype;

    // Initialize all other fields
    r.syndrome  = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    r.syndrome2 = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    r.vaddress  = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    r.ipavalid  = FALSE;
    r.NS        = '0';
    r.ipaddress = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    r.paddress.paspace = <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> UNKNOWN;
    r.paddress.address = bits(52) UNKNOWN;
    return r;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.EncodeLDFSC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/EncodeLDFSC</h3>
      <p class="pseudocode">// EncodeLDFSC()
// =============
// Function that gives the Long-descriptor FSC code for types of Fault

bits(6) <a id="impl-shared.EncodeLDFSC.2"/>EncodeLDFSC(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode, integer level)
    bits(6) result;

    if level == -1 then
        assert <a href="shared_pseudocode.html#impl-shared.Have52BitIPAAndPASpaceExt.0" title="function: boolean Have52BitIPAAndPASpaceExt()">Have52BitIPAAndPASpaceExt</a>();
        case statuscode of
            when <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>          result = '101001';
            when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>          result = '101011';
            when <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>   result = '010011';
            when <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>     result = '011011'; assert !<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>();
            when <a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>           result = '100011';
            otherwise                       <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

        return result;
    case statuscode of
        when <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>         result = '0000':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>          result = '0010':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>          result = '0011':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>         result = '0001':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>        result = '010000';
        when <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>  result = '0101':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>          result = '011000';
        when <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>    result = '0111':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>         result = '011001';
        when <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>       result = '010001';
        when <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>           result = '100001';
        when <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>               result = '100010';
        when <a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>          result = '1001':level&lt;1:0&gt;; assert level IN {0,1,2,3};
        when <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>        result = '101000';
        when <a href="shared_pseudocode.html#Fault_TLBConflict" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_TLBConflict</a>         result = '110000';
        when <a href="shared_pseudocode.html#Fault_HWUpdateAccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_HWUpdateAccessFlag</a>  result = '110001';
        when <a href="shared_pseudocode.html#Fault_Lockdown" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Lockdown</a>            result = '110100';  // IMPLEMENTATION DEFINED
        when <a href="shared_pseudocode.html#Fault_Exclusive" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Exclusive</a>           result = '110101';  // IMPLEMENTATION DEFINED
        otherwise                      <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IPAValid"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IPAValid</h3>
      <p class="pseudocode">// IPAValid()
// ==========
// Return TRUE if the IPA is reported for the abort

boolean <a id="impl-shared.IPAValid.1"/>IPAValid(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
        return fault.secondstage;
    elsif fault.s2fs1walk then
        return fault.statuscode IN {
            <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>,
            <a href="shared_pseudocode.html#Fault_Permission" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Permission</a>,
            <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>,
            <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>
        };
    elsif fault.secondstage then
        return fault.statuscode IN {
            <a href="shared_pseudocode.html#Fault_AccessFlag" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AccessFlag</a>,
            <a href="shared_pseudocode.html#Fault_Translation" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Translation</a>,
            <a href="shared_pseudocode.html#Fault_AddressSize" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AddressSize</a>
        };
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsAsyncAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsAsyncAbort</h3>
      <p class="pseudocode">// IsAsyncAbort()
// ==============
// Returns TRUE if the abort currently being processed is an asynchronous abort, and FALSE
// otherwise.

boolean <a id="impl-shared.IsAsyncAbort.1"/>IsAsyncAbort(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {<a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>, <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>});

// IsAsyncAbort()
// ==============

boolean <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    return <a href="shared_pseudocode.html#impl-shared.IsAsyncAbort.1" title="function: boolean IsAsyncAbort(Fault statuscode)">IsAsyncAbort</a>(fault.statuscode);</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsDebugException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsDebugException</h3>
      <p class="pseudocode">// IsDebugException()
// ==================

boolean <a id="impl-shared.IsDebugException.1"/>IsDebugException(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    return fault.statuscode == <a href="shared_pseudocode.html#Fault_Debug" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Debug</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsExternalAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsExternalAbort</h3>
      <p class="pseudocode">// IsExternalAbort()
// =================
// Returns TRUE if the abort currently being processed is an External abort and FALSE otherwise.

boolean <a id="impl-shared.IsExternalAbort.1"/>IsExternalAbort(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {
        <a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>,
        <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>,
        <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>,
        <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>,
        <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>,
        <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>
    });

// IsExternalAbort()
// =================

boolean <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    return <a href="shared_pseudocode.html#impl-shared.IsExternalAbort.1" title="function: boolean IsExternalAbort(Fault statuscode)">IsExternalAbort</a>(fault.statuscode) || fault.gpcf.gpf == <a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsExternalSyncAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsExternalSyncAbort</h3>
      <p class="pseudocode">// IsExternalSyncAbort()
// =====================
// Returns TRUE if the abort currently being processed is an external
// synchronous abort and FALSE otherwise.

boolean <a id="impl-shared.IsExternalSyncAbort.1"/>IsExternalSyncAbort(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {
        <a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>,
        <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>,
        <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>,
        <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>
    });

// IsExternalSyncAbort()
// =====================

boolean <a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    return <a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault.statuscode) || fault.gpcf.gpf == <a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsFault"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsFault</h3>
      <p class="pseudocode">// IsFault()
// =========
// Return TRUE if a fault is associated with an address descriptor

boolean <a id="impl-shared.IsFault.1"/>IsFault(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc)
    return addrdesc.fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

// IsFault()
// =========
// Return TRUE if a fault is associated with a memory access.

boolean <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> fault)
    return fault != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

// IsFault()
// =========
// Return TRUE if a fault is associated with status returned by memory.

boolean <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> retstatus)
    return retstatus.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsSErrorInterrupt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsSErrorInterrupt</h3>
      <p class="pseudocode">// IsSErrorInterrupt()
// ===================
// Returns TRUE if the abort currently being processed is an SError interrupt, and FALSE
// otherwise.

boolean <a id="impl-shared.IsSErrorInterrupt.1"/>IsSErrorInterrupt(<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a> statuscode)
    assert statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return (statuscode IN {<a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>, <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>});

// IsSErrorInterrupt()
// ===================

boolean <a href="shared_pseudocode.html#impl-shared.IsSErrorInterrupt.1" title="function: boolean IsSErrorInterrupt(Fault statuscode)">IsSErrorInterrupt</a>(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    return <a href="shared_pseudocode.html#impl-shared.IsSErrorInterrupt.1" title="function: boolean IsSErrorInterrupt(Fault statuscode)">IsSErrorInterrupt</a>(fault.statuscode);</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.IsSecondStage"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/IsSecondStage</h3>
      <p class="pseudocode">// IsSecondStage()
// ===============

boolean <a id="impl-shared.IsSecondStage.1"/>IsSecondStage(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert fault.statuscode != <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;

    return fault.secondstage;</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.LSInstructionSyndrome"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/LSInstructionSyndrome</h3>
      <p class="pseudocode">// Returns the extended syndrome information for a second stage fault.
//  &lt;10&gt;  - Syndrome valid bit. The syndrome is only valid for certain types of access instruction.
//  &lt;9:8&gt; - Access size.
//  &lt;7&gt;   - Sign extended (for loads).
//  &lt;6:2&gt; - Transfer register.
//  &lt;1&gt;   - Transfer register is 64-bit.
//  &lt;0&gt;   - Instruction has acquire/release semantics.
bits(11) <a id="impl-shared.LSInstructionSyndrome.0"/>LSInstructionSyndrome();</p>
    </div>
    <div class="ps"><a id="shared.functions.aborts.ReportAsGPCException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/aborts/ReportAsGPCException</h3>
      <p class="pseudocode">// ReportAsGPCException()
// ======================
// Determine whether the given GPCF is reported as a Granule Protection Check Exception
// rather than a Data or Instruction Abort

boolean <a id="impl-shared.ReportAsGPCException.1"/>ReportAsGPCException(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    assert <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>();
    assert fault.statuscode IN {<a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>, <a href="shared_pseudocode.html#Fault_GPCFOnOutput" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnOutput</a>};
    assert fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>;

    case fault.gpcf.gpf of
        when <a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>        return TRUE;
        when <a href="shared_pseudocode.html#GPCF_AddressSize" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_AddressSize</a> return TRUE;
        when <a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>        return TRUE;
        when <a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a>        return SCR_EL3.GPF == '1' &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CACHE_OP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CACHE_OP</h3>
      <p class="pseudocode">// CACHE_OP()
// ==========
// Performs Cache maintenance operations as per CacheRecord.

<a id="impl-shared.CACHE_OP.1"/>CACHE_OP(<a href="shared_pseudocode.html#CacheRecord" title="type CacheRecord is ( AccType acctype, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, bits(64) regval, FullAddress paddress, bits(64) vaddress, integer set, integer way, integer level, Shareability shareability, boolean translated, boolean is_vmid_valid, bits(16) vmid, boolean is_asid_valid, bits(16) asid, SecurityState security, CachePASpace cpas )">CacheRecord</a> cache)
    IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CPASAtPAS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CPASAtPAS</h3>
      <p class="pseudocode">// CPASAtPAS()
// ===========
// Get cache PA space for given PA space.

CachePASpace <a id="impl-shared.CPASAtPAS.1"/>CPASAtPAS(<a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> pas)
    case pas of
        when <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>
            return <a href="shared_pseudocode.html#CPAS_NonSecure" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any, CPAS_RealmNonSecure, CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>
            return <a href="shared_pseudocode.html#CPAS_Secure" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any, CPAS_RealmNonSecure, CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_Secure</a>;
        when <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>
            return <a href="shared_pseudocode.html#CPAS_Root" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any, CPAS_RealmNonSecure, CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_Root</a>;
        when <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>
            return <a href="shared_pseudocode.html#CPAS_Realm" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any, CPAS_RealmNonSecure, CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_Realm</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CPASAtSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CPASAtSecurityState</h3>
      <p class="pseudocode">// CPASAtSecurityState()
// =====================
// Get cache PA space for given security state.

CachePASpace <a id="impl-shared.CPASAtSecurityState.1"/>CPASAtSecurityState(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss)
    case ss of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            return <a href="shared_pseudocode.html#CPAS_NonSecure" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any, CPAS_RealmNonSecure, CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            return <a href="shared_pseudocode.html#CPAS_SecureNonSecure" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any, CPAS_RealmNonSecure, CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_SecureNonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>
            return <a href="shared_pseudocode.html#CPAS_Any" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any, CPAS_RealmNonSecure, CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_Any</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            return <a href="shared_pseudocode.html#CPAS_RealmNonSecure" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any, CPAS_RealmNonSecure, CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CPAS_RealmNonSecure</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CacheOp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CacheOp</h3>
      <p class="pseudocode">enumeration <a id="CacheOp"/>CacheOp {
    <a id="CacheOp_Clean"/>CacheOp_Clean,
    <a id="CacheOp_Invalidate"/>CacheOp_Invalidate,
    <a id="CacheOp_CleanInvalidate"/>CacheOp_CleanInvalidate
};</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CacheOpScope"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CacheOpScope</h3>
      <p class="pseudocode">enumeration <a id="CacheOpScope"/>CacheOpScope {
    <a id="CacheOpScope_SetWay"/>CacheOpScope_SetWay,
    <a id="CacheOpScope_PoU"/>CacheOpScope_PoU,
    <a id="CacheOpScope_PoC"/>CacheOpScope_PoC,
    <a id="CacheOpScope_PoP"/>CacheOpScope_PoP,
    <a id="CacheOpScope_PoDP"/>CacheOpScope_PoDP,
    <a id="CacheOpScope_ALLU"/>CacheOpScope_ALLU,
    <a id="CacheOpScope_ALLUIS"/>CacheOpScope_ALLUIS
};</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CachePASpace"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CachePASpace</h3>
      <p class="pseudocode">enumeration <a id="CachePASpace"/>CachePASpace {
    <a id="CPAS_NonSecure"/>CPAS_NonSecure,
    <a id="CPAS_Any"/>CPAS_Any,               // match entries from any PA Space - possible from Root only
    <a id="CPAS_RealmNonSecure"/>CPAS_RealmNonSecure,    // match entries from Realm or Non-Secure PAS
    <a id="CPAS_Realm"/>CPAS_Realm,
    <a id="CPAS_Root"/>CPAS_Root,
    <a id="CPAS_SecureNonSecure"/>CPAS_SecureNonSecure,   // match entries from Secure or Non-Secure PAS
    <a id="CPAS_Secure"/>CPAS_Secure
};</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CacheRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CacheRecord</h3>
      <p class="pseudocode">type <a id="CacheRecord"/>CacheRecord is (
    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a>          acctype,           // Access type
    <a href="shared_pseudocode.html#CacheOp" title="enumeration CacheOp {&#13; CacheOp_Clean,&#13; CacheOp_Invalidate,&#13; CacheOp_CleanInvalidate&#13; }">CacheOp</a>          cacheop,           // Cache operation
    <a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a>     opscope,           // Cache operation type
    <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a>        cachetype,         // Cache type
    bits(64)         regval,
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a>      paddress,
    bits(64)         vaddress,          // For VA operations
    integer          set,               // For SW operations
    integer          way,               // For SW operations
    integer          level,             // For SW operations
    <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a>     shareability,
    boolean          translated,
    boolean          is_vmid_valid,     // is vmid valid for current context
    bits(16)         vmid,
    boolean          is_asid_valid,     // is asid valid for current context
    bits(16)         asid,
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a>    security,
    // For cache operations to full cache or by set/way
    // For operations by address, PA space in paddress
    <a href="shared_pseudocode.html#CachePASpace" title="enumeration CachePASpace {&#13; CPAS_NonSecure,&#13; CPAS_Any, CPAS_RealmNonSecure, CPAS_Realm,&#13; CPAS_Root,&#13; CPAS_SecureNonSecure, CPAS_Secure&#13; }">CachePASpace</a>     cpas
)</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.CacheType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/CacheType</h3>
      <p class="pseudocode">enumeration <a id="CacheType"/>CacheType {
    <a id="CacheType_Data"/>CacheType_Data,
    <a id="CacheType_Tag"/>CacheType_Tag,
    <a id="CacheType_Data_Tag"/>CacheType_Data_Tag,
    <a id="CacheType_Instruction"/>CacheType_Instruction
};</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.DCInstNeedsTranslation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/DCInstNeedsTranslation</h3>
      <p class="pseudocode">// DCInstNeedsTranslation()
// ========================
// Check whether Data Cache operation needs translation.

boolean <a id="impl-shared.DCInstNeedsTranslation.1"/>DCInstNeedsTranslation(<a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    if CLIDR_EL1.LoC == '000' then
        return !boolean IMPLEMENTATION_DEFINED "No fault generated for DC operations if PoC is before any level of cache";

    if CLIDR_EL1.LoUU == '000' &amp;&amp; opscope == <a href="shared_pseudocode.html#CacheOpScope_PoU" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope_PoU</a> then
        return !boolean IMPLEMENTATION_DEFINED "No fault generated for DC operations if PoU is before any level of cache";

    return TRUE;</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.DecodeSW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/DecodeSW</h3>
      <p class="pseudocode">// DecodeSW()
// ==========
// Decode input value into set, way and level for SW instructions.

(integer, integer, integer) <a id="impl-shared.DecodeSW.2"/>DecodeSW(bits(64) regval, <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype)
    level = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(regval[3:1]);
    (set, way, linesize) = <a href="shared_pseudocode.html#impl-shared.GetCacheInfo.2" title="function: (integer, integer, integer) GetCacheInfo(integer level, CacheType cachetype)">GetCacheInfo</a>(level, cachetype);
    return (set, way, level);</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.GetCacheInfo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/GetCacheInfo</h3>
      <p class="pseudocode">// Returns numsets, assosciativity &amp; linesize.
(integer, integer, integer) <a id="impl-shared.GetCacheInfo.2"/>GetCacheInfo(integer level, <a href="shared_pseudocode.html#CacheType" title="enumeration CacheType {&#13; CacheType_Data,&#13; CacheType_Tag,&#13; CacheType_Data_Tag,&#13; CacheType_Instruction&#13; }">CacheType</a> cachetype);</p>
    </div>
    <div class="ps"><a id="shared.functions.cache.ICInstNeedsTranslation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/cache/ICInstNeedsTranslation</h3>
      <p class="pseudocode">// ICInstNeedsTranslation()
// ========================
// Check whether Instruction Cache operation needs translation.

boolean <a id="impl-shared.ICInstNeedsTranslation.1"/>ICInstNeedsTranslation(<a href="shared_pseudocode.html#CacheOpScope" title="enumeration CacheOpScope {&#13; CacheOpScope_SetWay,&#13; CacheOpScope_PoU,&#13; CacheOpScope_PoC,&#13; CacheOpScope_PoP,&#13; CacheOpScope_PoDP,&#13; CacheOpScope_ALLU,&#13; CacheOpScope_ALLUIS&#13; }">CacheOpScope</a> opscope)
    return boolean IMPLEMENTATION_DEFINED "Instruction Cache needs translation";</p>
    </div>
    <div class="ps"><a id="shared.functions.common.ASR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/ASR</h3>
      <p class="pseudocode">// ASR()
// =====

bits(N) <a id="impl-shared.ASR.2"/>ASR(bits(N) x, integer shift)
    assert shift &gt;= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a href="shared_pseudocode.html#impl-shared.ASR_C.2" title="function: (bits(N), bit) ASR_C(bits(N) x, integer shift)">ASR_C</a>(x, shift);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.ASR_C"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/ASR_C</h3>
      <p class="pseudocode">// ASR_C()
// =======

(bits(N), bit) <a id="impl-shared.ASR_C.2"/>ASR_C(bits(N) x, integer shift)
    assert shift &gt; 0;
    extended_x = <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(x, shift+N);
    result = extended_x&lt;shift+N-1:shift&gt;;
    carry_out = extended_x&lt;shift-1&gt;;
    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Abs"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Abs</h3>
      <p class="pseudocode">// Abs()
// =====

integer <a id="impl-shared.Abs.1"/>Abs(integer x)
    return if x &gt;= 0 then x else -x;

// Abs()
// =====

real <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(real x)
    return if x &gt;= 0.0 then x else -x;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Align"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Align</h3>
      <p class="pseudocode">// Align()
// =======

integer <a id="impl-shared.Align.2"/>Align(integer x, integer y)
    return y * (x DIV y);

// Align()
// =======

bits(N) <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(bits(N) x, integer y)
    return <a href="shared_pseudocode.html#impl-shared.Align.2" title="function: integer Align(integer x, integer y)">Align</a>(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(x), y)&lt;N-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.BitCount"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/BitCount</h3>
      <p class="pseudocode">// BitCount()
// ==========

integer <a id="impl-shared.BitCount.1"/>BitCount(bits(N) x)
    integer result = 0;
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then
            result = result + 1;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.CountLeadingSignBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/CountLeadingSignBits</h3>
      <p class="pseudocode">// CountLeadingSignBits()
// ======================

integer <a id="impl-shared.CountLeadingSignBits.1"/>CountLeadingSignBits(bits(N) x)
    return <a href="shared_pseudocode.html#impl-shared.CountLeadingZeroBits.1" title="function: integer CountLeadingZeroBits(bits(N) x)">CountLeadingZeroBits</a>(x&lt;N-1:1&gt; EOR x&lt;N-2:0&gt;);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.CountLeadingZeroBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/CountLeadingZeroBits</h3>
      <p class="pseudocode">// CountLeadingZeroBits()
// ======================

integer <a id="impl-shared.CountLeadingZeroBits.1"/>CountLeadingZeroBits(bits(N) x)
    return N - (<a href="shared_pseudocode.html#impl-shared.HighestSetBit.1" title="function: integer HighestSetBit(bits(N) x)">HighestSetBit</a>(x) + 1);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Elem"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Elem</h3>
      <p class="pseudocode">// Elem[] - non-assignment form
// ============================

bits(size) <a id="impl-shared.Elem.read.3"/>Elem[bits(N) vector, integer e, integer size]
    assert e &gt;= 0 &amp;&amp; (e+1)*size &lt;= N;
    return vector&lt;e*size+size-1 : e*size&gt;;

// Elem[] - non-assignment form
// ============================

bits(size) <a id="impl-shared.Elem.read.2"/>Elem[bits(N) vector, integer e]
    return <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[vector, e, size];

// Elem[] - assignment form
// ========================

<a id="impl-shared.Elem.write.3"/>Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value
    assert e &gt;= 0 &amp;&amp; (e+1)*size &lt;= N;
    vector&lt;(e+1)*size-1:e*size&gt; = value;
    return;

// Elem[] - assignment form
// ========================

<a id="impl-shared.Elem.write.2"/>Elem[bits(N) &amp;vector, integer e] = bits(size) value
    <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[vector, e, size] = value;
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Extend"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Extend</h3>
      <p class="pseudocode">// Extend()
// ========

bits(N) <a id="impl-shared.Extend.3"/>Extend(bits(M) x, integer N, boolean unsigned)
    return if unsigned then <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(x, N) else <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(x, N);

// Extend()
// ========

bits(N) <a id="impl-shared.Extend.2"/>Extend(bits(M) x, boolean unsigned)
    return <a href="shared_pseudocode.html#impl-shared.Extend.3" title="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)">Extend</a>(x, N, unsigned);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.HighestSetBit"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/HighestSetBit</h3>
      <p class="pseudocode">// HighestSetBit()
// ===============

integer <a id="impl-shared.HighestSetBit.1"/>HighestSetBit(bits(N) x)
    for i = N-1 downto 0
        if x&lt;i&gt; == '1' then return i;
    return -1;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Int"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Int</h3>
      <p class="pseudocode">// Int()
// =====

integer <a id="impl-shared.Int.2"/>Int(bits(N) x, boolean unsigned)
    result = if unsigned then <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(x) else <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(x);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.IsOnes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/IsOnes</h3>
      <p class="pseudocode">// IsOnes()
// ========

boolean <a id="impl-shared.IsOnes.1"/>IsOnes(bits(N) x)
    return x == <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.IsZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/IsZero</h3>
      <p class="pseudocode">// IsZero()
// ========

boolean <a id="impl-shared.IsZero.1"/>IsZero(bits(N) x)
    return x == <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.IsZeroBit"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/IsZeroBit</h3>
      <p class="pseudocode">// IsZeroBit()
// ===========

bit <a id="impl-shared.IsZeroBit.1"/>IsZeroBit(bits(N) x)
    return if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(x) then '1' else '0';</p>
    </div>
    <div class="ps"><a id="shared.functions.common.LSL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/LSL</h3>
      <p class="pseudocode">// LSL()
// =====

bits(N) <a id="impl-shared.LSL.2"/>LSL(bits(N) x, integer shift)
    assert shift &gt;= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a href="shared_pseudocode.html#impl-shared.LSL_C.2" title="function: (bits(N), bit) LSL_C(bits(N) x, integer shift)">LSL_C</a>(x, shift);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.LSL_C"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/LSL_C</h3>
      <p class="pseudocode">// LSL_C()
// =======

(bits(N), bit) <a id="impl-shared.LSL_C.2"/>LSL_C(bits(N) x, integer shift)
    assert shift &gt; 0;
    extended_x = x : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(shift);
    result = extended_x&lt;N-1:0&gt;;
    carry_out = extended_x&lt;N&gt;;
    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.LSR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/LSR</h3>
      <p class="pseudocode">// LSR()
// =====

bits(N) <a id="impl-shared.LSR.2"/>LSR(bits(N) x, integer shift)
    assert shift &gt;= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a href="shared_pseudocode.html#impl-shared.LSR_C.2" title="function: (bits(N), bit) LSR_C(bits(N) x, integer shift)">LSR_C</a>(x, shift);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.LSR_C"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/LSR_C</h3>
      <p class="pseudocode">// LSR_C()
// =======

(bits(N), bit) <a id="impl-shared.LSR_C.2"/>LSR_C(bits(N) x, integer shift)
    assert shift &gt; 0;
    extended_x = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(x, shift+N);
    result = extended_x&lt;shift+N-1:shift&gt;;
    carry_out = extended_x&lt;shift-1&gt;;
    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.LowestSetBit"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/LowestSetBit</h3>
      <p class="pseudocode">// LowestSetBit()
// ==============

integer <a id="impl-shared.LowestSetBit.1"/>LowestSetBit(bits(N) x)
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then return i;
    return N;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Max"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Max</h3>
      <p class="pseudocode">// Max()
// =====

integer <a id="impl-shared.Max.2"/>Max(integer a, integer b)
    return if a &gt;= b then a else b;

// Max()
// =====

real <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>(real a, real b)
    return if a &gt;= b then a else b;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Min"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Min</h3>
      <p class="pseudocode">// Min()
// =====

integer <a id="impl-shared.Min.2"/>Min(integer a, integer b)
    return if a &lt;= b then a else b;

// Min()
// =====

real <a href="shared_pseudocode.html#impl-shared.Min.2" title="function: integer Min(integer a, integer b)">Min</a>(real a, real b)
    return if a &lt;= b then a else b;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Ones"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Ones</h3>
      <p class="pseudocode">// Ones()
// ======

bits(N) <a id="impl-shared.Ones.1"/>Ones(integer N)
    return <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>('1',N);

// Ones()
// ======

bits(N) <a id="impl-shared.Ones.0"/>Ones()
    return <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.ROR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/ROR</h3>
      <p class="pseudocode">// ROR()
// =====

bits(N) <a id="impl-shared.ROR.2"/>ROR(bits(N) x, integer shift)
    assert shift &gt;= 0;
    if shift == 0 then
        result = x;
    else
        (result, -) = <a href="shared_pseudocode.html#impl-shared.ROR_C.2" title="function: (bits(N), bit) ROR_C(bits(N) x, integer shift)">ROR_C</a>(x, shift);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.ROR_C"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/ROR_C</h3>
      <p class="pseudocode">// ROR_C()
// =======

(bits(N), bit) <a id="impl-shared.ROR_C.2"/>ROR_C(bits(N) x, integer shift)
    assert shift != 0;
    m = shift MOD N;
    result = <a href="shared_pseudocode.html#impl-shared.LSR.2" title="function: bits(N) LSR(bits(N) x, integer shift)">LSR</a>(x,m) OR <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(x,N-m);
    carry_out = result&lt;N-1&gt;;
    return (result, carry_out);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Replicate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Replicate</h3>
      <p class="pseudocode">// Replicate()
// ===========

bits(N) <a id="impl-shared.Replicate.1"/>Replicate(bits(M) x)
    assert N MOD M == 0;
    return <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(x, N DIV M);

bits(M*N) <a id="impl-shared.Replicate.2"/>Replicate(bits(M) x, integer N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.RoundDown"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/RoundDown</h3>
      <p class="pseudocode">integer <a id="impl-shared.RoundDown.1"/>RoundDown(real x);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.RoundTowardsZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/RoundTowardsZero</h3>
      <p class="pseudocode">// RoundTowardsZero()
// ==================

integer <a id="impl-shared.RoundTowardsZero.1"/>RoundTowardsZero(real x)
    return if x == 0.0 then 0 else if x &gt;= 0.0 then <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(x) else <a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)">RoundUp</a>(x);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.RoundUp"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/RoundUp</h3>
      <p class="pseudocode">integer <a id="impl-shared.RoundUp.1"/>RoundUp(real x);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.SInt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/SInt</h3>
      <p class="pseudocode">// SInt()
// ======

integer <a id="impl-shared.SInt.1"/>SInt(bits(N) x)
    result = 0;
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then result = result + 2^i;
    if x&lt;N-1&gt; == '1' then result = result - 2^N;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.SignExtend"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/SignExtend</h3>
      <p class="pseudocode">// SignExtend()
// ============

bits(N) <a id="impl-shared.SignExtend.2"/>SignExtend(bits(M) x, integer N)
    assert N &gt;= M;
    return <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(x&lt;M-1&gt;, N-M) : x;

// SignExtend()
// ============

bits(N) <a id="impl-shared.SignExtend.1"/>SignExtend(bits(M) x)
    return <a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(x, N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.UInt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/UInt</h3>
      <p class="pseudocode">// UInt()
// ======

integer <a id="impl-shared.UInt.1"/>UInt(bits(N) x)
    result = 0;
    for i = 0 to N-1
        if x&lt;i&gt; == '1' then result = result + 2^i;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.common.ZeroExtend"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/ZeroExtend</h3>
      <p class="pseudocode">// ZeroExtend()
// ============

bits(N) <a id="impl-shared.ZeroExtend.2"/>ZeroExtend(bits(M) x, integer N)
    assert N &gt;= M;
    return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-M) : x;

// ZeroExtend()
// ============

bits(N) <a id="impl-shared.ZeroExtend.1"/>ZeroExtend(bits(M) x)
    return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(x, N);</p>
    </div>
    <div class="ps"><a id="shared.functions.common.Zeros"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/common/Zeros</h3>
      <p class="pseudocode">// Zeros()
// =======

bits(N) <a id="impl-shared.Zeros.1"/>Zeros(integer N)
    return <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>('0',N);

// Zeros()
// =======

bits(N) <a id="impl-shared.Zeros.0"/>Zeros()
    return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N);</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.AArch32.CheckTimerConditions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/AArch32.CheckTimerConditions</h3>
      <p class="pseudocode">// AArch32.CheckTimerConditions()
// ==============================
// Checking timer conditions for all A32 timer registers

<a id="AArch32.CheckTimerConditions.0"/>AArch32.CheckTimerConditions()
    boolean status;
    bits(64) offset;
    offset = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    assert !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>();

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        if CNTP_CTL_S.ENABLE == '1' then
            status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL_S,
                                         CNTP_CTL_S.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTPS" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTPS</a>);
            CNTP_CTL_S.ISTATUS = if status then '1' else '0';

        if CNTP_CTL_NS.ENABLE == '1' then
            status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL_NS,
                                         CNTP_CTL_NS.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTP" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTP</a>);
            CNTP_CTL_NS.ISTATUS = if status then '1' else '0';
    else
        if CNTP_CTL.ENABLE == '1' then
            status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL,
                                         CNTP_CTL.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTP" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTP</a>);
            CNTP_CTL.ISTATUS = if status then '1' else '0';

    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; CNTHP_CTL.ENABLE == '1' then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTHP_CVAL,
                                     CNTHP_CTL.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTHP" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTHP</a>);
        CNTHP_CTL.ISTATUS = if status then '1' else '0';

    if CNTV_CTL_EL0.ENABLE == '1' then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(CNTVOFF_EL2, CNTV_CVAL_EL0,
                                     CNTV_CTL_EL0.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTV" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTV</a>);
        CNTV_CTL_EL0.ISTATUS = if status then '1' else '0';

    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.AArch64.CheckTimerConditions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/AArch64.CheckTimerConditions</h3>
      <p class="pseudocode">// AArch64.CheckTimerConditions()
// ==============================
// Checking timer conditions for all A64 timer registers

<a id="AArch64.CheckTimerConditions.0"/>AArch64.CheckTimerConditions()
    boolean status;
    bits(64) offset;
    boolean ecv = FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() then
        ecv = CNTHCTL_EL2.ECV == '1' &amp;&amp; SCR_EL3.ECVEn == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    if ecv then
        offset = CNTPOFF_EL2;
    else
        offset = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);

    if CNTP_CTL_EL0.ENABLE == '1' then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTP_CVAL_EL0,
                                     CNTP_CTL_EL0.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTP" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTP</a>);
        CNTP_CTL_EL0.ISTATUS = if status then '1' else '0';
    if ((<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>())) &amp;&amp;
       CNTHP_CTL_EL2.ENABLE == '1') then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHP_CVAL_EL2,
                                     CNTHP_CTL_EL2.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTHP" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTHP</a>);
        CNTHP_CTL_EL2.ISTATUS = if status then '1' else '0';
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; CNTHPS_CTL_EL2.ENABLE == '1' then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHPS_CVAL_EL2,
                                     CNTHPS_CTL_EL2.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTHPS" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTHPS</a>);
        CNTHPS_CTL_EL2.ISTATUS = if status then '1' else '0';

    if CNTPS_CTL_EL1.ENABLE == '1' then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(offset, CNTPS_CVAL_EL1,
                                     CNTPS_CTL_EL1.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTPS" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTPS</a>);
        CNTPS_CTL_EL1.ISTATUS = if status then '1' else '0';

    if CNTV_CTL_EL0.ENABLE == '1' then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(CNTVOFF_EL2, CNTV_CVAL_EL0,
                                     CNTV_CTL_EL0.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTV" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTV</a>);
        CNTV_CTL_EL0.ISTATUS = if status then '1' else '0';

    if ((<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || !<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>())) &amp;&amp;
        CNTHV_CTL_EL2.ENABLE == '1') then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHV_CVAL_EL2,
                                     CNTHV_CTL_EL2.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTHV" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTHV</a>);
        CNTHV_CTL_EL2.ISTATUS = if status then '1' else '0';

    if ((<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>()) &amp;&amp;
        CNTHVS_CTL_EL2.ENABLE == '1') then
        status = <a href="shared_pseudocode.html#impl-shared.IsTimerConditionMet.4" title="function: boolean IsTimerConditionMet(bits(64) offset, bits(64) compare_value,&#13; bits(1) imask, InterruptID intid)">IsTimerConditionMet</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64), CNTHVS_CVAL_EL2,
                                     CNTHVS_CTL_EL2.IMASK, <a href="shared_pseudocode.html#InterruptID_CNTHVS" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID_CNTHVS</a>);
        CNTHVS_CTL_EL2.ISTATUS = if status then '1' else '0';
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.GenericCounterTick"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/GenericCounterTick</h3>
      <p class="pseudocode">// GenericCounterTick()
// ====================
// Increments PhysicalCount value for every clock tick.

<a id="impl-shared.GenericCounterTick.0"/>GenericCounterTick()
    bits(64) prev_physical_count;
    if CNTCR.EN == '0' then
        if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
            <a href="shared_pseudocode.html#AArch32.CheckTimerConditions.0" title="function: AArch32.CheckTimerConditions()">AArch32.CheckTimerConditions</a>();
        else
            <a href="shared_pseudocode.html#AArch64.CheckTimerConditions.0" title="function: AArch64.CheckTimerConditions()">AArch64.CheckTimerConditions</a>();
        return;
    prev_physical_count = <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveCNTSCExt.0" title="function: boolean HaveCNTSCExt()">HaveCNTSCExt</a>() &amp;&amp; CNTCR.SCEN == '1' then
        PhysicalCount = PhysicalCount + <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(CNTSCR);
    else
        PhysicalCount&lt;87:24&gt; = PhysicalCount&lt;87:24&gt; + 1;
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        <a href="shared_pseudocode.html#AArch32.CheckTimerConditions.0" title="function: AArch32.CheckTimerConditions()">AArch32.CheckTimerConditions</a>();
    else
        <a href="shared_pseudocode.html#AArch64.CheckTimerConditions.0" title="function: AArch64.CheckTimerConditions()">AArch64.CheckTimerConditions</a>();
    <a href="shared_pseudocode.html#impl-shared.TestEventCNTP.2" title="function: TestEventCNTP(bits(64) prev_physical_count, bits(64) current_physical_count)">TestEventCNTP</a>(prev_physical_count, <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>());
    <a href="shared_pseudocode.html#impl-shared.TestEventCNTV.2" title="function: TestEventCNTV(bits(64) prev_physical_count, bits(64) current_physical_count)">TestEventCNTV</a>(prev_physical_count, <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>());
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.IsTimerConditionMet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/IsTimerConditionMet</h3>
      <p class="pseudocode">// IsTimerConditionMet()
// =====================

boolean <a id="impl-shared.IsTimerConditionMet.4"/>IsTimerConditionMet(bits(64) offset, bits(64) compare_value,
                            bits(1) imask, <a href="shared_pseudocode.html#InterruptID" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID</a> intid)
    boolean conditon_met;
    signal level;
    condition_met = (<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(<a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>() - offset) -
                                        <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(compare_value)) &gt;= 0;
    level = if condition_met &amp;&amp; imask == '0' then HIGH else LOW;
    SetInterruptRequestLevel(intid, level);
    return condition_met;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.PhysicalCount"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/PhysicalCount</h3>
      <p class="pseudocode">bits(88) PhysicalCount;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.SetEventRegister"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/SetEventRegister</h3>
      <p class="pseudocode">// SetEventRegister()
// ==================
// Sets the Event Register of this PE

<a id="impl-shared.SetEventRegister.0"/>SetEventRegister()
    EventRegister = '1';
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.TestEventCNTP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/TestEventCNTP</h3>
      <p class="pseudocode">// TestEventCNTP()
// ===============
// Generate Event stream from the physical counter

<a id="impl-shared.TestEventCNTP.2"/>TestEventCNTP(bits(64) prev_physical_count, bits(64) current_physical_count)
    bits(64) offset;
    bits(1) samplebit, previousbit;
    if CNTHCTL_EL2.EVNTEN == '1' then
        n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(CNTHCTL_EL2.EVNTI);
        if <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; CNTHCTL_EL2.EVNTIS == '1' then
            n = n + 8;
        boolean ecv = FALSE;
        if <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() then
            ecv = (<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; CNTHCTL_EL2.ECV == '1' &amp;&amp;
                   SCR_EL3.ECVEn == '1');
            offset = if ecv then CNTPOFF_EL2 else <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        samplebit   = (current_physical_count - offset)&lt;n&gt;;
        previousbit = (prev_physical_count - offset)&lt;n&gt;;
        if CNTHCTL_EL2.EVNTDIR == '0' then
            if previousbit == '0' &amp;&amp; samplebit == '1' then <a href="shared_pseudocode.html#impl-shared.SetEventRegister.0" title="function: SetEventRegister()">SetEventRegister</a>();
        else
            if previousbit == '1' &amp;&amp; samplebit == '0' then <a href="shared_pseudocode.html#impl-shared.SetEventRegister.0" title="function: SetEventRegister()">SetEventRegister</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.counters.TestEventCNTV"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/counters/TestEventCNTV</h3>
      <p class="pseudocode">// TestEventCNTV()
// ===============
// Generate Event stream from the virtual counter

<a id="impl-shared.TestEventCNTV.2"/>TestEventCNTV(bits(64) prev_physical_count, bits(64) current_physical_count)
    bits(64) offset;
    bits(1) samplebit, previousbit;
    if (!(<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11') &amp;&amp;
        CNTKCTL_EL1.EVNTEN == '1') then
        n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(CNTKCTL_EL1.EVNTI);
        if <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; CNTKCTL_EL1.EVNTIS == '1' then
            n = n + 8;
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() || HCR_EL2.&lt;E2H,TGE&gt; != '11') then
            offset = CNTVOFF_EL2;
        else
            offset = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        samplebit   = (current_physical_count - offset)&lt;n&gt;;
        previousbit = (prev_physical_count - offset)&lt;n&gt;;
        if CNTKCTL_EL1.EVNTDIR == '0' then
            if previousbit == '0' &amp;&amp; samplebit == '1' then <a href="shared_pseudocode.html#impl-shared.SetEventRegister.0" title="function: SetEventRegister()">SetEventRegister</a>();
        else
            if previousbit == '1' &amp;&amp; samplebit == '0' then <a href="shared_pseudocode.html#impl-shared.SetEventRegister.0" title="function: SetEventRegister()">SetEventRegister</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.crc.BitReverse"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crc/BitReverse</h3>
      <p class="pseudocode">// BitReverse()
// ============

bits(N) <a id="impl-shared.BitReverse.1"/>BitReverse(bits(N) data)
    bits(N) result;
    for i = 0 to N-1
        result&lt;N-i-1&gt; = data&lt;i&gt;;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.crc.HaveCRCExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crc/HaveCRCExt</h3>
      <p class="pseudocode">// HaveCRCExt()
// ============

boolean <a id="impl-shared.HaveCRCExt.0"/>HaveCRCExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>) || boolean IMPLEMENTATION_DEFINED "Have CRC extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.crc.Poly32Mod2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crc/Poly32Mod2</h3>
      <p class="pseudocode">// Poly32Mod2()
// ============

// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation

bits(32) <a id="impl-shared.Poly32Mod2.2"/>Poly32Mod2(bits(N) data, bits(32) poly)
    assert N &gt; 32;
    for i = N-1 downto 32
        if data&lt;i&gt; == '1' then
            data&lt;i-1:0&gt; = data&lt;i-1:0&gt; EOR (poly:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(i-32));
    return data&lt;31:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESInvMixColumns"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESInvMixColumns</h3>
      <p class="pseudocode">// AESInvMixColumns()
// ==================
// Transformation in the Inverse Cipher that is the inverse of AESMixColumns.

bits(128) <a id="impl-shared.AESInvMixColumns.1"/>AESInvMixColumns(bits (128) op)
    bits(4*8) in0 = op&lt; 96+:8&gt; : op&lt; 64+:8&gt; : op&lt; 32+:8&gt; : op&lt;  0+:8&gt;;
    bits(4*8) in1 = op&lt;104+:8&gt; : op&lt; 72+:8&gt; : op&lt; 40+:8&gt; : op&lt;  8+:8&gt;;
    bits(4*8) in2 = op&lt;112+:8&gt; : op&lt; 80+:8&gt; : op&lt; 48+:8&gt; : op&lt; 16+:8&gt;;
    bits(4*8) in3 = op&lt;120+:8&gt; : op&lt; 88+:8&gt; : op&lt; 56+:8&gt; : op&lt; 24+:8&gt;;

    bits(4*8) out0;
    bits(4*8) out1;
    bits(4*8) out2;
    bits(4*8) out3;

    for c = 0 to 3
        out0&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul0E.1" title="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in0&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0B.1" title="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in1&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0D.1" title="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in2&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul09.1" title="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in3&lt;c*8+:8&gt;);
        out1&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul09.1" title="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in0&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0E.1" title="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in1&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0B.1" title="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in2&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0D.1" title="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in3&lt;c*8+:8&gt;);
        out2&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul0D.1" title="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in0&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul09.1" title="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in1&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0E.1" title="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in2&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0B.1" title="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in3&lt;c*8+:8&gt;);
        out3&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul0B.1" title="function: bits(8) FFmul0B(bits(8) b)">FFmul0B</a>(in0&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0D.1" title="function: bits(8) FFmul0D(bits(8) b)">FFmul0D</a>(in1&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul09.1" title="function: bits(8) FFmul09(bits(8) b)">FFmul09</a>(in2&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul0E.1" title="function: bits(8) FFmul0E(bits(8) b)">FFmul0E</a>(in3&lt;c*8+:8&gt;);

    return (
        out3&lt;3*8+:8&gt; : out2&lt;3*8+:8&gt; : out1&lt;3*8+:8&gt; : out0&lt;3*8+:8&gt; :
        out3&lt;2*8+:8&gt; : out2&lt;2*8+:8&gt; : out1&lt;2*8+:8&gt; : out0&lt;2*8+:8&gt; :
        out3&lt;1*8+:8&gt; : out2&lt;1*8+:8&gt; : out1&lt;1*8+:8&gt; : out0&lt;1*8+:8&gt; :
        out3&lt;0*8+:8&gt; : out2&lt;0*8+:8&gt; : out1&lt;0*8+:8&gt; : out0&lt;0*8+:8&gt;
    );</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESInvShiftRows"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESInvShiftRows</h3>
      <p class="pseudocode">// AESInvShiftRows()
// =================
// Transformation in the Inverse Cipher that is inverse of AESShiftRows.

bits(128) <a id="impl-shared.AESInvShiftRows.1"/>AESInvShiftRows(bits(128) op)
    return (
        op&lt; 24+:8&gt; : op&lt; 48+:8&gt; : op&lt; 72+:8&gt; : op&lt; 96+:8&gt; :
        op&lt;120+:8&gt; : op&lt; 16+:8&gt; : op&lt; 40+:8&gt; : op&lt; 64+:8&gt; :
        op&lt; 88+:8&gt; : op&lt;112+:8&gt; : op&lt;  8+:8&gt; : op&lt; 32+:8&gt; :
        op&lt; 56+:8&gt; : op&lt; 80+:8&gt; : op&lt;104+:8&gt; : op&lt;  0+:8&gt;
    );</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESInvSubBytes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESInvSubBytes</h3>
      <p class="pseudocode">// AESInvSubBytes()
// ================
// Transformation in the Inverse Cipher that is the inverse of AESSubBytes.

bits(128) <a id="impl-shared.AESInvSubBytes.1"/>AESInvSubBytes(bits(128) op)
    // Inverse S-box values
    bits(16*16*8) GF2_inv = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x7d0c2155631469e126d677ba7e042b17&lt;127:0&gt; :
        /*E*/ 0x619953833cbbebc8b0f52aae4d3be0a0&lt;127:0&gt; :
        /*D*/ 0xef9cc9939f7ae52d0d4ab519a97f5160&lt;127:0&gt; :
        /*C*/ 0x5fec8027591012b131c7078833a8dd1f&lt;127:0&gt; :
        /*B*/ 0xf45acd78fec0db9a2079d2c64b3e56fc&lt;127:0&gt; :
        /*A*/ 0x1bbe18aa0e62b76f89c5291d711af147&lt;127:0&gt; :
        /*9*/ 0x6edf751ce837f9e28535ade72274ac96&lt;127:0&gt; :
        /*8*/ 0x73e6b4f0cecff297eadc674f4111913a&lt;127:0&gt; :
        /*7*/ 0x6b8a130103bdafc1020f3fca8f1e2cd0&lt;127:0&gt; :
        /*6*/ 0x0645b3b80558e4f70ad3bc8c00abd890&lt;127:0&gt; :
        /*5*/ 0x849d8da75746155edab9edfd5048706c&lt;127:0&gt; :
        /*4*/ 0x92b6655dcc5ca4d41698688664f6f872&lt;127:0&gt; :
        /*3*/ 0x25d18b6d49a25b76b224d92866a12e08&lt;127:0&gt; :
        /*2*/ 0x4ec3fa420b954cee3d23c2a632947b54&lt;127:0&gt; :
        /*1*/ 0xcbe9dec444438e3487ff2f9b8239e37c&lt;127:0&gt; :
        /*0*/ 0xfbd7f3819ea340bf38a53630d56a0952&lt;127:0&gt;
    );
    bits(128) out;
    for i = 0 to 15
        out&lt;i*8+:8&gt; = GF2_inv&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(op&lt;i*8+:8&gt;)*8+:8&gt;;
    return out;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESMixColumns"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESMixColumns</h3>
      <p class="pseudocode">// AESMixColumns()
// ===============
// Transformation in the Cipher that takes all of the columns of the
// State and mixes their data (independently of one another) to
// produce new columns.

bits(128) <a id="impl-shared.AESMixColumns.1"/>AESMixColumns(bits (128) op)
    bits(4*8) in0 = op&lt; 96+:8&gt; : op&lt; 64+:8&gt; : op&lt; 32+:8&gt; : op&lt;  0+:8&gt;;
    bits(4*8) in1 = op&lt;104+:8&gt; : op&lt; 72+:8&gt; : op&lt; 40+:8&gt; : op&lt;  8+:8&gt;;
    bits(4*8) in2 = op&lt;112+:8&gt; : op&lt; 80+:8&gt; : op&lt; 48+:8&gt; : op&lt; 16+:8&gt;;
    bits(4*8) in3 = op&lt;120+:8&gt; : op&lt; 88+:8&gt; : op&lt; 56+:8&gt; : op&lt; 24+:8&gt;;

    bits(4*8) out0;
    bits(4*8) out1;
    bits(4*8) out2;
    bits(4*8) out3;

    for c = 0 to 3
        out0&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul02.1" title="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in0&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul03.1" title="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in1&lt;c*8+:8&gt;) EOR         in2&lt;c*8+:8&gt;  EOR         in3&lt;c*8+:8&gt;;
        out1&lt;c*8+:8&gt; =          in0&lt;c*8+:8&gt;  EOR <a href="shared_pseudocode.html#impl-shared.FFmul02.1" title="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in1&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul03.1" title="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in2&lt;c*8+:8&gt;) EOR         in3&lt;c*8+:8&gt;;
        out2&lt;c*8+:8&gt; =          in0&lt;c*8+:8&gt;  EOR         in1&lt;c*8+:8&gt;  EOR <a href="shared_pseudocode.html#impl-shared.FFmul02.1" title="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in2&lt;c*8+:8&gt;) EOR <a href="shared_pseudocode.html#impl-shared.FFmul03.1" title="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in3&lt;c*8+:8&gt;);
        out3&lt;c*8+:8&gt; =  <a href="shared_pseudocode.html#impl-shared.FFmul03.1" title="function: bits(8) FFmul03(bits(8) b)">FFmul03</a>(in0&lt;c*8+:8&gt;) EOR         in1&lt;c*8+:8&gt;  EOR         in2&lt;c*8+:8&gt;  EOR <a href="shared_pseudocode.html#impl-shared.FFmul02.1" title="function: bits(8) FFmul02(bits(8) b)">FFmul02</a>(in3&lt;c*8+:8&gt;);

    return (
        out3&lt;3*8+:8&gt; : out2&lt;3*8+:8&gt; : out1&lt;3*8+:8&gt; : out0&lt;3*8+:8&gt; :
        out3&lt;2*8+:8&gt; : out2&lt;2*8+:8&gt; : out1&lt;2*8+:8&gt; : out0&lt;2*8+:8&gt; :
        out3&lt;1*8+:8&gt; : out2&lt;1*8+:8&gt; : out1&lt;1*8+:8&gt; : out0&lt;1*8+:8&gt; :
        out3&lt;0*8+:8&gt; : out2&lt;0*8+:8&gt; : out1&lt;0*8+:8&gt; : out0&lt;0*8+:8&gt;
    );</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESShiftRows"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESShiftRows</h3>
      <p class="pseudocode">// AESShiftRows()
// ==============
// Transformation in the Cipher that processes the State by cyclically
// shifting the last three rows of the State by different offsets.

bits(128) <a id="impl-shared.AESShiftRows.1"/>AESShiftRows(bits(128) op)
    return (
        op&lt; 88+:8&gt; : op&lt; 48+:8&gt; : op&lt;  8+:8&gt; : op&lt; 96+:8&gt; :
        op&lt; 56+:8&gt; : op&lt; 16+:8&gt; : op&lt;104+:8&gt; : op&lt; 64+:8&gt; :
        op&lt; 24+:8&gt; : op&lt;112+:8&gt; : op&lt; 72+:8&gt; : op&lt; 32+:8&gt; :
        op&lt;120+:8&gt; : op&lt; 80+:8&gt; : op&lt; 40+:8&gt; : op&lt;  0+:8&gt;
    );</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.AESSubBytes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/AESSubBytes</h3>
      <p class="pseudocode">// AESSubBytes()
// =============
// Transformation in the Cipher that processes the State using a nonlinear
// byte substitution table (S-box) that operates on each of the State bytes
// independently.

bits(128) <a id="impl-shared.AESSubBytes.1"/>AESSubBytes(bits(128) op)
    // S-box values
    bits(16*16*8) GF2 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x16bb54b00f2d99416842e6bf0d89a18c&lt;127:0&gt; :
        /*E*/ 0xdf2855cee9871e9b948ed9691198f8e1&lt;127:0&gt; :
        /*D*/ 0x9e1dc186b95735610ef6034866b53e70&lt;127:0&gt; :
        /*C*/ 0x8a8bbd4b1f74dde8c6b4a61c2e2578ba&lt;127:0&gt; :
        /*B*/ 0x08ae7a65eaf4566ca94ed58d6d37c8e7&lt;127:0&gt; :
        /*A*/ 0x79e4959162acd3c25c2406490a3a32e0&lt;127:0&gt; :
        /*9*/ 0xdb0b5ede14b8ee4688902a22dc4f8160&lt;127:0&gt; :
        /*8*/ 0x73195d643d7ea7c41744975fec130ccd&lt;127:0&gt; :
        /*7*/ 0xd2f3ff1021dab6bcf5389d928f40a351&lt;127:0&gt; :
        /*6*/ 0xa89f3c507f02f94585334d43fbaaefd0&lt;127:0&gt; :
        /*5*/ 0xcf584c4a39becb6a5bb1fc20ed00d153&lt;127:0&gt; :
        /*4*/ 0x842fe329b3d63b52a05a6e1b1a2c8309&lt;127:0&gt; :
        /*3*/ 0x75b227ebe28012079a059618c323c704&lt;127:0&gt; :
        /*2*/ 0x1531d871f1e5a534ccf73f362693fdb7&lt;127:0&gt; :
        /*1*/ 0xc072a49cafa2d4adf04759fa7dc982ca&lt;127:0&gt; :
        /*0*/ 0x76abd7fe2b670130c56f6bf27b777c63&lt;127:0&gt;
    );
    bits(128) out;
    for i = 0 to 15
        out&lt;i*8+:8&gt; = GF2&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(op&lt;i*8+:8&gt;)*8+:8&gt;;
    return out;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul02"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul02</h3>
      <p class="pseudocode">// FFmul02()
// =========

bits(8) <a id="impl-shared.FFmul02.1"/>FFmul02(bits(8) b)
    bits(256*8) FFmul_02 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0xE5E7E1E3EDEFE9EBF5F7F1F3FDFFF9FB&lt;127:0&gt; :
        /*E*/ 0xC5C7C1C3CDCFC9CBD5D7D1D3DDDFD9DB&lt;127:0&gt; :
        /*D*/ 0xA5A7A1A3ADAFA9ABB5B7B1B3BDBFB9BB&lt;127:0&gt; :
        /*C*/ 0x858781838D8F898B959791939D9F999B&lt;127:0&gt; :
        /*B*/ 0x656761636D6F696B757771737D7F797B&lt;127:0&gt; :
        /*A*/ 0x454741434D4F494B555751535D5F595B&lt;127:0&gt; :
        /*9*/ 0x252721232D2F292B353731333D3F393B&lt;127:0&gt; :
        /*8*/ 0x050701030D0F090B151711131D1F191B&lt;127:0&gt; :
        /*7*/ 0xFEFCFAF8F6F4F2F0EEECEAE8E6E4E2E0&lt;127:0&gt; :
        /*6*/ 0xDEDCDAD8D6D4D2D0CECCCAC8C6C4C2C0&lt;127:0&gt; :
        /*5*/ 0xBEBCBAB8B6B4B2B0AEACAAA8A6A4A2A0&lt;127:0&gt; :
        /*4*/ 0x9E9C9A98969492908E8C8A8886848280&lt;127:0&gt; :
        /*3*/ 0x7E7C7A78767472706E6C6A6866646260&lt;127:0&gt; :
        /*2*/ 0x5E5C5A58565452504E4C4A4846444240&lt;127:0&gt; :
        /*1*/ 0x3E3C3A38363432302E2C2A2826242220&lt;127:0&gt; :
        /*0*/ 0x1E1C1A18161412100E0C0A0806040200&lt;127:0&gt;
    );
    return FFmul_02&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul03"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul03</h3>
      <p class="pseudocode">// FFmul03()
// =========

bits(8) <a id="impl-shared.FFmul03.1"/>FFmul03(bits(8) b)
    bits(256*8) FFmul_03 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x1A191C1F16151013020104070E0D080B&lt;127:0&gt; :
        /*E*/ 0x2A292C2F26252023323134373E3D383B&lt;127:0&gt; :
        /*D*/ 0x7A797C7F76757073626164676E6D686B&lt;127:0&gt; :
        /*C*/ 0x4A494C4F46454043525154575E5D585B&lt;127:0&gt; :
        /*B*/ 0xDAD9DCDFD6D5D0D3C2C1C4C7CECDC8CB&lt;127:0&gt; :
        /*A*/ 0xEAE9ECEFE6E5E0E3F2F1F4F7FEFDF8FB&lt;127:0&gt; :
        /*9*/ 0xBAB9BCBFB6B5B0B3A2A1A4A7AEADA8AB&lt;127:0&gt; :
        /*8*/ 0x8A898C8F86858083929194979E9D989B&lt;127:0&gt; :
        /*7*/ 0x818287848D8E8B88999A9F9C95969390&lt;127:0&gt; :
        /*6*/ 0xB1B2B7B4BDBEBBB8A9AAAFACA5A6A3A0&lt;127:0&gt; :
        /*5*/ 0xE1E2E7E4EDEEEBE8F9FAFFFCF5F6F3F0&lt;127:0&gt; :
        /*4*/ 0xD1D2D7D4DDDEDBD8C9CACFCCC5C6C3C0&lt;127:0&gt; :
        /*3*/ 0x414247444D4E4B48595A5F5C55565350&lt;127:0&gt; :
        /*2*/ 0x717277747D7E7B78696A6F6C65666360&lt;127:0&gt; :
        /*1*/ 0x212227242D2E2B28393A3F3C35363330&lt;127:0&gt; :
        /*0*/ 0x111217141D1E1B18090A0F0C05060300&lt;127:0&gt;
    );
    return FFmul_03&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul09"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul09</h3>
      <p class="pseudocode">// FFmul09()
// =========

bits(8) <a id="impl-shared.FFmul09.1"/>FFmul09(bits(8) b)
    bits(256*8) FFmul_09 = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x464F545D626B70790E071C152A233831&lt;127:0&gt; :
        /*E*/ 0xD6DFC4CDF2FBE0E99E978C85BAB3A8A1&lt;127:0&gt; :
        /*D*/ 0x7D746F6659504B42353C272E1118030A&lt;127:0&gt; :
        /*C*/ 0xEDE4FFF6C9C0DBD2A5ACB7BE8188939A&lt;127:0&gt; :
        /*B*/ 0x3039222B141D060F78716A635C554E47&lt;127:0&gt; :
        /*A*/ 0xA0A9B2BB848D969FE8E1FAF3CCC5DED7&lt;127:0&gt; :
        /*9*/ 0x0B0219102F263D34434A5158676E757C&lt;127:0&gt; :
        /*8*/ 0x9B928980BFB6ADA4D3DAC1C8F7FEE5EC&lt;127:0&gt; :
        /*7*/ 0xAAA3B8B18E879C95E2EBF0F9C6CFD4DD&lt;127:0&gt; :
        /*6*/ 0x3A3328211E170C05727B6069565F444D&lt;127:0&gt; :
        /*5*/ 0x9198838AB5BCA7AED9D0CBC2FDF4EFE6&lt;127:0&gt; :
        /*4*/ 0x0108131A252C373E49405B526D647F76&lt;127:0&gt; :
        /*3*/ 0xDCD5CEC7F8F1EAE3949D868FB0B9A2AB&lt;127:0&gt; :
        /*2*/ 0x4C455E5768617A73040D161F2029323B&lt;127:0&gt; :
        /*1*/ 0xE7EEF5FCC3CAD1D8AFA6BDB48B829990&lt;127:0&gt; :
        /*0*/ 0x777E656C535A41483F362D241B120900&lt;127:0&gt;
    );
    return FFmul_09&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul0B"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul0B</h3>
      <p class="pseudocode">// FFmul0B()
// =========

bits(8) <a id="impl-shared.FFmul0B.1"/>FFmul0B(bits(8) b)
    bits(256*8) FFmul_0B = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0xA3A8B5BE8F849992FBF0EDE6D7DCC1CA&lt;127:0&gt; :
        /*E*/ 0x1318050E3F3429224B405D56676C717A&lt;127:0&gt; :
        /*D*/ 0xD8D3CEC5F4FFE2E9808B969DACA7BAB1&lt;127:0&gt; :
        /*C*/ 0x68637E75444F5259303B262D1C170A01&lt;127:0&gt; :
        /*B*/ 0x555E434879726F640D061B10212A373C&lt;127:0&gt; :
        /*A*/ 0xE5EEF3F8C9C2DFD4BDB6ABA0919A878C&lt;127:0&gt; :
        /*9*/ 0x2E2538330209141F767D606B5A514C47&lt;127:0&gt; :
        /*8*/ 0x9E958883B2B9A4AFC6CDD0DBEAE1FCF7&lt;127:0&gt; :
        /*7*/ 0x545F424978736E650C071A11202B363D&lt;127:0&gt; :
        /*6*/ 0xE4EFF2F9C8C3DED5BCB7AAA1909B868D&lt;127:0&gt; :
        /*5*/ 0x2F2439320308151E777C616A5B504D46&lt;127:0&gt; :
        /*4*/ 0x9F948982B3B8A5AEC7CCD1DAEBE0FDF6&lt;127:0&gt; :
        /*3*/ 0xA2A9B4BF8E859893FAF1ECE7D6DDC0CB&lt;127:0&gt; :
        /*2*/ 0x1219040F3E3528234A415C57666D707B&lt;127:0&gt; :
        /*1*/ 0xD9D2CFC4F5FEE3E8818A979CADA6BBB0&lt;127:0&gt; :
        /*0*/ 0x69627F74454E5358313A272C1D160B00&lt;127:0&gt;
    );
    return FFmul_0B&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul0D"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul0D</h3>
      <p class="pseudocode">// FFmul0D()
// =========

bits(8) <a id="impl-shared.FFmul0D.1"/>FFmul0D(bits(8) b)
    bits(256*8) FFmul_0D = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x979A8D80A3AEB9B4FFF2E5E8CBC6D1DC&lt;127:0&gt; :
        /*E*/ 0x474A5D50737E69642F2235381B16010C&lt;127:0&gt; :
        /*D*/ 0x2C21363B1815020F44495E53707D6A67&lt;127:0&gt; :
        /*C*/ 0xFCF1E6EBC8C5D2DF94998E83A0ADBAB7&lt;127:0&gt; :
        /*B*/ 0xFAF7E0EDCEC3D4D9929F8885A6ABBCB1&lt;127:0&gt; :
        /*A*/ 0x2A27303D1E130409424F5855767B6C61&lt;127:0&gt; :
        /*9*/ 0x414C5B5675786F622924333E1D10070A&lt;127:0&gt; :
        /*8*/ 0x919C8B86A5A8BFB2F9F4E3EECDC0D7DA&lt;127:0&gt; :
        /*7*/ 0x4D40575A7974636E25283F32111C0B06&lt;127:0&gt; :
        /*6*/ 0x9D90878AA9A4B3BEF5F8EFE2C1CCDBD6&lt;127:0&gt; :
        /*5*/ 0xF6FBECE1C2CFD8D59E938489AAA7B0BD&lt;127:0&gt; :
        /*4*/ 0x262B3C31121F08054E4354597A77606D&lt;127:0&gt; :
        /*3*/ 0x202D3A3714190E034845525F7C71666B&lt;127:0&gt; :
        /*2*/ 0xF0FDEAE7C4C9DED39895828FACA1B6BB&lt;127:0&gt; :
        /*1*/ 0x9B96818CAFA2B5B8F3FEE9E4C7CADDD0&lt;127:0&gt; :
        /*0*/ 0x4B46515C7F726568232E3934171A0D00&lt;127:0&gt;
    );
    return FFmul_0D&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.FFmul0E"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/FFmul0E</h3>
      <p class="pseudocode">// FFmul0E()
// =========

bits(8) <a id="impl-shared.FFmul0E.1"/>FFmul0E(bits(8) b)
    bits(256*8) FFmul_0E = (
        /*       F E D C B A 9 8 7 6 5 4 3 2 1 0       */
        /*F*/ 0x8D83919FB5BBA9A7FDF3E1EFC5CBD9D7&lt;127:0&gt; :
        /*E*/ 0x6D63717F555B49471D13010F252B3937&lt;127:0&gt; :
        /*D*/ 0x56584A446E60727C26283A341E10020C&lt;127:0&gt; :
        /*C*/ 0xB6B8AAA48E80929CC6C8DAD4FEF0E2EC&lt;127:0&gt; :
        /*B*/ 0x202E3C321816040A505E4C426866747A&lt;127:0&gt; :
        /*A*/ 0xC0CEDCD2F8F6E4EAB0BEACA28886949A&lt;127:0&gt; :
        /*9*/ 0xFBF5E7E9C3CDDFD18B859799B3BDAFA1&lt;127:0&gt; :
        /*8*/ 0x1B150709232D3F316B657779535D4F41&lt;127:0&gt; :
        /*7*/ 0xCCC2D0DEF4FAE8E6BCB2A0AE848A9896&lt;127:0&gt; :
        /*6*/ 0x2C22303E141A08065C52404E646A7876&lt;127:0&gt; :
        /*5*/ 0x17190B052F21333D67697B755F51434D&lt;127:0&gt; :
        /*4*/ 0xF7F9EBE5CFC1D3DD87899B95BFB1A3AD&lt;127:0&gt; :
        /*3*/ 0x616F7D735957454B111F0D032927353B&lt;127:0&gt; :
        /*2*/ 0x818F9D93B9B7A5ABF1FFEDE3C9C7D5DB&lt;127:0&gt; :
        /*1*/ 0xBAB4A6A8828C9E90CAC4D6D8F2FCEEE0&lt;127:0&gt; :
        /*0*/ 0x5A544648626C7E702A243638121C0E00&lt;127:0&gt;
    );
    return FFmul_0E&lt;<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(b)*8+:8&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveAESExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveAESExt</h3>
      <p class="pseudocode">// HaveAESExt()
// ============
// TRUE if AES cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveAESExt.0"/>HaveAESExt()
    return boolean IMPLEMENTATION_DEFINED "Has AES Crypto instructions";</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveBit128PMULLExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveBit128PMULLExt</h3>
      <p class="pseudocode">// HaveBit128PMULLExt()
// ====================
// TRUE if 128 bit form of PMULL instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveBit128PMULLExt.0"/>HaveBit128PMULLExt()
    return boolean IMPLEMENTATION_DEFINED "Has 128-bit form of PMULL instructions";</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSHA1Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSHA1Ext</h3>
      <p class="pseudocode">// HaveSHA1Ext()
// =============
// TRUE if SHA1 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSHA1Ext.0"/>HaveSHA1Ext()
    return boolean IMPLEMENTATION_DEFINED "Has SHA1 Crypto instructions";</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSHA256Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSHA256Ext</h3>
      <p class="pseudocode">// HaveSHA256Ext()
// ===============
// TRUE if SHA256 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSHA256Ext.0"/>HaveSHA256Ext()
    return boolean IMPLEMENTATION_DEFINED "Has SHA256 Crypto instructions";</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSHA3Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSHA3Ext</h3>
      <p class="pseudocode">// HaveSHA3Ext()
// =============
// TRUE if SHA3 cryptographic instructions support is implemented,
// and when SHA1 and SHA2 basic cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSHA3Ext.0"/>HaveSHA3Ext()
    if !<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) || !(<a href="shared_pseudocode.html#impl-shared.HaveSHA1Ext.0" title="function: boolean HaveSHA1Ext()">HaveSHA1Ext</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSHA256Ext.0" title="function: boolean HaveSHA256Ext()">HaveSHA256Ext</a>()) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SHA3 Crypto instructions";</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSHA512Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSHA512Ext</h3>
      <p class="pseudocode">// HaveSHA512Ext()
// ===============
// TRUE if SHA512 cryptographic instructions support is implemented,
// and when SHA1 and SHA2 basic cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSHA512Ext.0"/>HaveSHA512Ext()
    if !<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) || !(<a href="shared_pseudocode.html#impl-shared.HaveSHA1Ext.0" title="function: boolean HaveSHA1Ext()">HaveSHA1Ext</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSHA256Ext.0" title="function: boolean HaveSHA256Ext()">HaveSHA256Ext</a>()) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SHA512 Crypto instructions";</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSM3Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSM3Ext</h3>
      <p class="pseudocode">// HaveSM3Ext()
// ============
// TRUE if SM3 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSM3Ext.0"/>HaveSM3Ext()
    if !<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SM3 Crypto instructions";</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.HaveSM4Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/HaveSM4Ext</h3>
      <p class="pseudocode">// HaveSM4Ext()
// ============
// TRUE if SM4 cryptographic instructions support is implemented,
// FALSE otherwise.

boolean <a id="impl-shared.HaveSM4Ext.0"/>HaveSM4Ext()
    if !<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has SM4 Crypto instructions";</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.ROL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/ROL</h3>
      <p class="pseudocode">// ROL()
// =====

bits(N) <a id="impl-shared.ROL.2"/>ROL(bits(N) x, integer shift)
    assert shift &gt;= 0 &amp;&amp; shift &lt;= N;
    if (shift == 0) then
        return x;
    return <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, N-shift);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHA256hash"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHA256hash</h3>
      <p class="pseudocode">// SHA256hash()
// ============

bits(128) <a id="impl-shared.SHA256hash.4"/>SHA256hash(bits (128) X, bits(128) Y, bits(128) W, boolean part1)
    bits(32) chs, maj, t;

    for e = 0 to 3
        chs = <a href="shared_pseudocode.html#impl-shared.SHAchoose.3" title="function: bits(32) SHAchoose(bits(32) x, bits(32) y, bits(32) z)">SHAchoose</a>(Y&lt;31:0&gt;, Y&lt;63:32&gt;, Y&lt;95:64&gt;);
        maj = <a href="shared_pseudocode.html#impl-shared.SHAmajority.3" title="function: bits(32) SHAmajority(bits(32) x, bits(32) y, bits(32) z)">SHAmajority</a>(X&lt;31:0&gt;, X&lt;63:32&gt;, X&lt;95:64&gt;);
        t = Y&lt;127:96&gt; + <a href="shared_pseudocode.html#impl-shared.SHAhashSIGMA1.1" title="function: bits(32) SHAhashSIGMA1(bits(32) x)">SHAhashSIGMA1</a>(Y&lt;31:0&gt;) + chs + <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[W, e, 32];
        X&lt;127:96&gt; = t + X&lt;127:96&gt;;
        Y&lt;127:96&gt; = t + <a href="shared_pseudocode.html#impl-shared.SHAhashSIGMA0.1" title="function: bits(32) SHAhashSIGMA0(bits(32) x)">SHAhashSIGMA0</a>(X&lt;31:0&gt;) + maj;
        &lt;Y, X&gt; = <a href="shared_pseudocode.html#impl-shared.ROL.2" title="function: bits(N) ROL(bits(N) x, integer shift)">ROL</a>(Y : X, 32);
    return (if part1 then X else Y);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAchoose"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAchoose</h3>
      <p class="pseudocode">// SHAchoose()
// ===========

bits(32) <a id="impl-shared.SHAchoose.3"/>SHAchoose(bits(32) x, bits(32) y, bits(32) z)
    return (((y EOR z) AND x) EOR z);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAhashSIGMA0"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAhashSIGMA0</h3>
      <p class="pseudocode">// SHAhashSIGMA0()
// ===============

bits(32) <a id="impl-shared.SHAhashSIGMA0.1"/>SHAhashSIGMA0(bits(32) x)
    return <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 2) EOR <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 13) EOR <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 22);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAhashSIGMA1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAhashSIGMA1</h3>
      <p class="pseudocode">// SHAhashSIGMA1()
// ===============

bits(32) <a id="impl-shared.SHAhashSIGMA1.1"/>SHAhashSIGMA1(bits(32) x)
    return <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 6) EOR <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 11) EOR <a href="shared_pseudocode.html#impl-shared.ROR.2" title="function: bits(N) ROR(bits(N) x, integer shift)">ROR</a>(x, 25);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAmajority"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAmajority</h3>
      <p class="pseudocode">// SHAmajority()
// =============

bits(32) <a id="impl-shared.SHAmajority.3"/>SHAmajority(bits(32) x, bits(32) y, bits(32) z)
    return ((x AND y) OR ((x OR y) AND z));</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.SHAparity"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/SHAparity</h3>
      <p class="pseudocode">// SHAparity()
// ===========

bits(32) <a id="impl-shared.SHAparity.3"/>SHAparity(bits(32) x, bits(32) y, bits(32) z)
    return (x EOR y EOR z);</p>
    </div>
    <div class="ps"><a id="shared.functions.crypto.Sbox"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/crypto/Sbox</h3>
      <p class="pseudocode">// Sbox()
// ======
// Used in SM4E crypto instruction

bits(8) <a id="impl-shared.Sbox.1"/>Sbox(bits(8) sboxin)
    bits(8) sboxout;
    bits(2048) sboxstring = 0xd690e9fecce13db716b614c228fb2c052b679a762abe04c3aa441326498606999c4250f491ef987a33540b43edcfac62e4b31ca9c908e89580df94fa758f3fa64707a7fcf37317ba83593c19e6854fa8686b81b27164da8bf8eb0f4b70569d351e240e5e6358d1a225227c3b01217887d40046579fd327524c3602e7a0c4c89eeabf8ad240c738b5a3f7f2cef96115a1e0ae5da49b341a55ad933230f58cb1e31df6e22e8266ca60c02923ab0d534e6fd5db3745defd8e2f03ff6a726d6c5b518d1baf92bbddbc7f11d95c411f105ad80ac13188a5cd7bbd2d74d012b8e5b4b08969974a0c96777e65b9f109c56ec68418f07dec3adc4d2079ee5f3ed7cb3948&lt;2047:0&gt;;

    sboxout = sboxstring&lt;(255-<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(sboxin))*8+7:(255-<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(sboxin))*8&gt;;
    return sboxout;</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ClearExclusiveByAddress"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ClearExclusiveByAddress</h3>
      <p class="pseudocode">// Clear the global Exclusives monitors for all PEs EXCEPT processorid if they
// record any part of the physical address region of size bytes starting at paddress.
// It is IMPLEMENTATION DEFINED whether the global Exclusives monitor for processorid
// is also cleared if it records any part of the address region.
<a id="impl-shared.ClearExclusiveByAddress.3"/>ClearExclusiveByAddress(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ClearExclusiveLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ClearExclusiveLocal</h3>
      <p class="pseudocode">// Clear the local Exclusives monitor for the specified processorid.
<a id="impl-shared.ClearExclusiveLocal.1"/>ClearExclusiveLocal(integer processorid);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ClearExclusiveMonitors"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ClearExclusiveMonitors</h3>
      <p class="pseudocode">// ClearExclusiveMonitors()
// ========================
// Clear the local Exclusives monitor for the executing PE.

<a id="impl-shared.ClearExclusiveMonitors.0"/>ClearExclusiveMonitors()
    <a href="shared_pseudocode.html#impl-shared.ClearExclusiveLocal.1" title="function: ClearExclusiveLocal(integer processorid)">ClearExclusiveLocal</a>(<a href="shared_pseudocode.html#impl-shared.ProcessorID.0" title="function: integer ProcessorID()">ProcessorID</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ExclusiveMonitorsStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ExclusiveMonitorsStatus</h3>
      <p class="pseudocode">// Returns '0' to indicate success if the last memory write by this PE was to
// the same physical address region endorsed by ExclusiveMonitorsPass().
// Returns '1' to indicate failure if address translation resulted in a different
// physical address.
bit <a id="impl-shared.ExclusiveMonitorsStatus.0"/>ExclusiveMonitorsStatus();</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.IsExclusiveGlobal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/IsExclusiveGlobal</h3>
      <p class="pseudocode">// Return TRUE if the global Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.
boolean <a id="impl-shared.IsExclusiveGlobal.3"/>IsExclusiveGlobal(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.IsExclusiveLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/IsExclusiveLocal</h3>
      <p class="pseudocode">// Return TRUE if the local Exclusives monitor for processorid includes all of
// the physical address region of size bytes starting at paddress.
boolean <a id="impl-shared.IsExclusiveLocal.3"/>IsExclusiveLocal(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.MarkExclusiveGlobal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/MarkExclusiveGlobal</h3>
      <p class="pseudocode">// Record the physical address region of size bytes starting at paddress in
// the global Exclusives monitor for processorid.
<a id="impl-shared.MarkExclusiveGlobal.3"/>MarkExclusiveGlobal(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.MarkExclusiveLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/MarkExclusiveLocal</h3>
      <p class="pseudocode">// Record the physical address region of size bytes starting at paddress in
// the local Exclusives monitor for processorid.
<a id="impl-shared.MarkExclusiveLocal.3"/>MarkExclusiveLocal(<a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress, integer processorid, integer size);</p>
    </div>
    <div class="ps"><a id="shared.functions.exclusive.ProcessorID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/exclusive/ProcessorID</h3>
      <p class="pseudocode">// Return the ID of the currently executing PE.
integer <a id="impl-shared.ProcessorID.0"/>ProcessorID();</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.AArch32.HaveHPDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/AArch32.HaveHPDExt</h3>
      <p class="pseudocode">// AArch32.HaveHPDExt()
// ====================

boolean <a id="AArch32.HaveHPDExt.0"/>AArch32.HaveHPDExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has AArch32 hierarchical permission disables");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.AArch64.HaveHPDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/AArch64.HaveHPDExt</h3>
      <p class="pseudocode">// AArch64.HaveHPDExt()
// ====================

boolean <a id="AArch64.HaveHPDExt.0"/>AArch64.HaveHPDExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have16bitVMID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have16bitVMID</h3>
      <p class="pseudocode">// Have16bitVMID()
// ===============
// Returns TRUE if EL2 and support for a 16-bit VMID are implemented.

boolean <a id="impl-shared.Have16bitVMID.0"/>Have16bitVMID()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "Has 16-bit VMID");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have52BitIPAAndPASpaceExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have52BitIPAAndPASpaceExt</h3>
      <p class="pseudocode">// Have52BitIPAAndPASpaceExt()
// ===========================
// Returns TRUE if 52-bit IPA and PA extension support
// is implemented, and FALSE otherwise.

boolean <a id="impl-shared.Have52BitIPAAndPASpaceExt.0"/>Have52BitIPAAndPASpaceExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has 52-bit IPA and PA support" &amp;&amp;
            <a href="shared_pseudocode.html#impl-shared.Have52BitVAExt.0" title="function: boolean Have52BitVAExt()">Have52BitVAExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Have52BitPAExt.0" title="function: boolean Have52BitPAExt()">Have52BitPAExt</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have52BitPAExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have52BitPAExt</h3>
      <p class="pseudocode">// Have52BitPAExt()
// ================
// Returns TRUE if Large Physical Address extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.Have52BitPAExt.0"/>Have52BitPAExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
           boolean IMPLEMENTATION_DEFINED "Has large 52-bit PA/IPA support");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Have52BitVAExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Have52BitVAExt</h3>
      <p class="pseudocode">// Have52BitVAExt()
// ================
// Returns TRUE if Large Virtual Address extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.Have52BitVAExt.0"/>Have52BitVAExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has large 52-bit VA support");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAArch32BF16Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAArch32BF16Ext</h3>
      <p class="pseudocode">// HaveAArch32BF16Ext()
// ====================
// Returns TRUE if AArch32 BFloat16 instruction support is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveAArch32BF16Ext.0"/>HaveAArch32BF16Ext()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has AArch32 BFloat16 extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAArch32Int8MatMulExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAArch32Int8MatMulExt</h3>
      <p class="pseudocode">// HaveAArch32Int8MatMulExt()
// ==========================
// Returns TRUE if AArch32 8-bit integer matrix multiply instruction support
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveAArch32Int8MatMulExt.0"/>HaveAArch32Int8MatMulExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has AArch32 Int8 Mat Mul extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAltFP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAltFP</h3>
      <p class="pseudocode">// HaveAltFP()
// ===========
// Returns TRUE if alternative Floating-point extension support
// is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveAltFP.0"/>HaveAltFP()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveAtomicExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveAtomicExt</h3>
      <p class="pseudocode">// HaveAtomicExt()
// ===============

boolean <a id="impl-shared.HaveAtomicExt.0"/>HaveAtomicExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveBF16Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveBF16Ext</h3>
      <p class="pseudocode">// HaveBF16Ext()
// =============
// Returns TRUE if AArch64 BFloat16 instruction support is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveBF16Ext.0"/>HaveBF16Ext()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p6" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>) ||
            (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
             boolean IMPLEMENTATION_DEFINED "Has AArch64 BFloat16 extension"));</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveBRBEv1p1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveBRBEv1p1</h3>
      <p class="pseudocode">// HaveBRBEv1p1()
// ==============
// Returns TRUE if BRBEv1p1 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveBRBEv1p1.0"/>HaveBRBEv1p1()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(ARMv9p3) &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "Has BRBEv1p1 extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveBRBExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveBRBExt</h3>
      <p class="pseudocode">// HaveBRBExt()
// ============
// Returns TRUE if Branch Record Buffer Extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveBRBExt.0"/>HaveBRBExt()
    return boolean IMPLEMENTATION_DEFINED "Has Branch Record Buffer Extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveBTIExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveBTIExt</h3>
      <p class="pseudocode">// HaveBTIExt()
// ============
// Returns TRUE if support for Branch Target Indentification is implemented.

boolean <a id="impl-shared.HaveBTIExt.0"/>HaveBTIExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveBlockBBM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveBlockBBM</h3>
      <p class="pseudocode">// HaveBlockBBM()
// ==============
// Returns TRUE if support for changing block size without requiring
// break-before-make is implemented.

boolean <a id="impl-shared.HaveBlockBBM.0"/>HaveBlockBBM()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveCNTSCExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveCNTSCExt</h3>
      <p class="pseudocode">// HaveCNTSCExt()
// ==============
// Returns TRUE if the Generic Counter Scaling is implemented, and FALSE
// otherwise.

boolean <a id="impl-shared.HaveCNTSCExt.0"/>HaveCNTSCExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Generic Counter Scaling support");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveCommonNotPrivateTransExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveCommonNotPrivateTransExt</h3>
      <p class="pseudocode">// HaveCommonNotPrivateTransExt()
// ==============================

boolean <a id="impl-shared.HaveCommonNotPrivateTransExt.0"/>HaveCommonNotPrivateTransExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDGHExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDGHExt</h3>
      <p class="pseudocode">// HaveDGHExt()
// ============
// Returns TRUE if Data Gathering Hint instruction support is implemented, and
// FALSE otherwise.

boolean <a id="impl-shared.HaveDGHExt.0"/>HaveDGHExt()
    return boolean IMPLEMENTATION_DEFINED "Has AArch64 DGH extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDITExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDITExt</h3>
      <p class="pseudocode">// HaveDITExt()
// ============

boolean <a id="impl-shared.HaveDITExt.0"/>HaveDITExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDOTPExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDOTPExt</h3>
      <p class="pseudocode">// HaveDOTPExt()
// =============
// Returns TRUE if Dot Product feature support is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveDOTPExt.0"/>HaveDOTPExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) ||
            (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Dot Product extension"));</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDoPD"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDoPD</h3>
      <p class="pseudocode">// HaveDoPD()
// ==========
// Returns TRUE if Debug Over Power Down extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveDoPD.0"/>HaveDoPD()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has DoPD extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDoubleFaultExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDoubleFaultExt</h3>
      <p class="pseudocode">// HaveDoubleFaultExt()
// ====================

boolean <a id="impl-shared.HaveDoubleFaultExt.0"/>HaveDoubleFaultExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveIESB.0" title="function: boolean HaveIESB()">HaveIESB</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveDoubleLock"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveDoubleLock</h3>
      <p class="pseudocode">// HaveDoubleLock()
// ================
// Returns TRUE if support for the OS Double Lock is implemented.

boolean <a id="impl-shared.HaveDoubleLock.0"/>HaveDoubleLock()
    return (!<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) ||
            boolean IMPLEMENTATION_DEFINED "OS Double Lock is implemented");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveE0PDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveE0PDExt</h3>
      <p class="pseudocode">// HaveE0PDExt()
// =============
// Returns TRUE if support for constant fault times for unprivileged accesses
// to the memory map is implemented.

boolean <a id="impl-shared.HaveE0PDExt.0"/>HaveE0PDExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveECVExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveECVExt</h3>
      <p class="pseudocode">// HaveECVExt()
// ============
// Returns TRUE if Enhanced Counter Virtualization extension
// support is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveECVExt.0"/>HaveECVExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p6" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveEMPAMExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveEMPAMExt</h3>
      <p class="pseudocode">// HaveEMPAMExt()
// ==============
// Returns TRUE if Enhanced MPAM is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveEMPAMExt.0"/>HaveEMPAMExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p6" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>) &amp;&amp;
            <a href="shared_pseudocode.html#impl-shared.HaveMPAMExt.0" title="function: boolean HaveMPAMExt()">HaveMPAMExt</a>() &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has enhanced MPAM extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveETExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveETExt</h3>
      <p class="pseudocode">// HaveETExt()
// ===========
// Returns TRUE if Embedded Trace Extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveETExt.0"/>HaveETExt()
    return boolean IMPLEMENTATION_DEFINED "Has Embedded Trace Extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveExtendedCacheSets"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveExtendedCacheSets</h3>
      <p class="pseudocode">// HaveExtendedCacheSets()
// =======================

boolean <a id="impl-shared.HaveExtendedCacheSets.0"/>HaveExtendedCacheSets()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveExtendedECDebugEvents"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveExtendedECDebugEvents</h3>
      <p class="pseudocode">// HaveExtendedECDebugEvents()
// ===========================

boolean <a id="impl-shared.HaveExtendedECDebugEvents.0"/>HaveExtendedECDebugEvents()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveExtendedExecuteNeverExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveExtendedExecuteNeverExt</h3>
      <p class="pseudocode">// HaveExtendedExecuteNeverExt()
// =============================

boolean <a id="impl-shared.HaveExtendedExecuteNeverExt.0"/>HaveExtendedExecuteNeverExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFCADDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFCADDExt</h3>
      <p class="pseudocode">// HaveFCADDExt()
// ==============

boolean <a id="impl-shared.HaveFCADDExt.0"/>HaveFCADDExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFGTExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFGTExt</h3>
      <p class="pseudocode">// HaveFGTExt()
// ============
// Returns TRUE if Fine Grained Trap is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveFGTExt.0"/>HaveFGTExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p6" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFJCVTZSExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFJCVTZSExt</h3>
      <p class="pseudocode">// HaveFJCVTZSExt()
// ================

boolean <a id="impl-shared.HaveFJCVTZSExt.0"/>HaveFJCVTZSExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFP16MulNoRoundingToFP32Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFP16MulNoRoundingToFP32Ext</h3>
      <p class="pseudocode">// HaveFP16MulNoRoundingToFP32Ext()
// ================================
// Returns TRUE if has FP16 multiply with no intermediate rounding accumulate
// to FP32 instructions, and FALSE otherwise

boolean <a id="impl-shared.HaveFP16MulNoRoundingToFP32Ext.0"/>HaveFP16MulNoRoundingToFP32Ext()
    if !<a href="shared_pseudocode.html#impl-shared.HaveFP16Ext.0" title="function: boolean HaveFP16Ext()">HaveFP16Ext</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) then return TRUE;
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has accumulate FP16 product into FP32 extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatCMOW"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatCMOW</h3>
      <p class="pseudocode">// HaveFeatCMOW()
// ==============
// Returns TRUE if the SCTLR_EL1.CMOW bit is implemented and the SCTLR_EL2.CMOW and
// HCRX_EL2.CMOW bits are implemented if EL2 is implemented.

boolean <a id="impl-shared.HaveFeatCMOW.0"/>HaveFeatCMOW()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p8" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatHBC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatHBC</h3>
      <p class="pseudocode">// HaveFeatHBC()
// =============
// Returns TRUE if the BC instruction is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatHBC.0"/>HaveFeatHBC()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p8" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatHCX"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatHCX</h3>
      <p class="pseudocode">// HaveFeatHCX()
// =============
// Returns TRUE if HCRX_EL2 Trap Control register is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatHCX.0"/>HaveFeatHCX()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatHPMN0"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatHPMN0</h3>
      <p class="pseudocode">// HaveFeatHPMN0()
// ===============
// Returns TRUE if AA3264(HDCR,MDCR_EL2).HPMN is permitted to be 0 without generating
// UNPREDICTABLE behavior, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatHPMN0.0"/>HaveFeatHPMN0()
    return <a href="shared_pseudocode.html#impl-shared.HavePMUv3.0" title="function: boolean HavePMUv3()">HavePMUv3</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p8" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatLS64"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatLS64</h3>
      <p class="pseudocode">// HaveFeatLS64()
// ==============
// Returns TRUE if the LD64B, ST64B, ST64BV, and ST64BV0 instructions are
// supported, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatLS64.0"/>HaveFeatLS64()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Load Store 64-Byte instruction support");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatMOPS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatMOPS</h3>
      <p class="pseudocode">// HaveFeatMOPS()
// ==============
// Returns TRUE if the CPY* and SET* instructions are supported, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatMOPS.0"/>HaveFeatMOPS()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p8" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatNMI"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatNMI</h3>
      <p class="pseudocode">// HaveFeatNMI()
// =============
// Returns TRUE if the Non-Maskable Interrupt extension is
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatNMI.0"/>HaveFeatNMI()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p8" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatRPRES"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatRPRES</h3>
      <p class="pseudocode">// HaveFeatRPRES()
// ===============
// Returns TRUE if reciprocal estimate implements 12-bit precision
// when FPCR.AH=1, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatRPRES.0"/>HaveFeatRPRES()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp;
        (boolean IMPLEMENTATION_DEFINED "Has increased Reciprocal Estimate and Square Root Estimate precision support") &amp;&amp;
        <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatTIDCP1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatTIDCP1</h3>
      <p class="pseudocode">// HaveFeatTIDCP1()
// ================
// Returns TRUE if the SCTLR_EL1.TIDCP bit is implemented and the SCTLR_EL2.TIDCP bit
// is implemented if EL2 is implemented.

boolean <a id="impl-shared.HaveFeatTIDCP1.0"/>HaveFeatTIDCP1()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p8" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p8</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatWFxT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatWFxT</h3>
      <p class="pseudocode">// HaveFeatWFxT()
// ==============
// Returns TRUE if WFET and WFIT instruction support is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatWFxT.0"/>HaveFeatWFxT()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatWFxT2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatWFxT2</h3>
      <p class="pseudocode">// HaveFeatWFxT2()
// ===============
// Returns TRUE if the register number is reported in the ESR_ELx
// on exceptions to WFIT and WFET.

boolean <a id="impl-shared.HaveFeatWFxT2.0"/>HaveFeatWFxT2()
    return <a href="shared_pseudocode.html#impl-shared.HaveFeatWFxT.0" title="function: boolean HaveFeatWFxT()">HaveFeatWFxT</a>() &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has feature WFxT2";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFeatXS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFeatXS</h3>
      <p class="pseudocode">// HaveFeatXS()
// ============
// Returns TRUE if XS attribute and the TLBI and DSB instructions with nXS qualifier
// are supported, and FALSE otherwise.

boolean <a id="impl-shared.HaveFeatXS.0"/>HaveFeatXS()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFlagFormatExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFlagFormatExt</h3>
      <p class="pseudocode">// HaveFlagFormatExt()
// ===================
// Returns TRUE if flag format conversion instructions implemented.

boolean <a id="impl-shared.HaveFlagFormatExt.0"/>HaveFlagFormatExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFlagManipulateExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFlagManipulateExt</h3>
      <p class="pseudocode">// HaveFlagManipulateExt()
// =======================
// Returns TRUE if flag manipulate instructions are implemented.

boolean <a id="impl-shared.HaveFlagManipulateExt.0"/>HaveFlagManipulateExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveFrintExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveFrintExt</h3>
      <p class="pseudocode">// HaveFrintExt()
// ==============
// Returns TRUE if FRINT instructions are implemented.

boolean <a id="impl-shared.HaveFrintExt.0"/>HaveFrintExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveHPMDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveHPMDExt</h3>
      <p class="pseudocode">// HaveHPMDExt()
// =============

boolean <a id="impl-shared.HaveHPMDExt.0"/>HaveHPMDExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveIDSExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveIDSExt</h3>
      <p class="pseudocode">// HaveIDSExt()
// ============
// Returns TRUE if ID register handling feature is implemented.

boolean <a id="impl-shared.HaveIDSExt.0"/>HaveIDSExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveIESB"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveIESB</h3>
      <p class="pseudocode">// HaveIESB()
// ==========

boolean <a id="impl-shared.HaveIESB.0"/>HaveIESB()
    return (<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Implicit Error Synchronization Barrier");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveInt8MatMulExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveInt8MatMulExt</h3>
      <p class="pseudocode">// HaveInt8MatMulExt()
// ===================
// Returns TRUE if AArch64 8-bit integer matrix multiply instruction support
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveInt8MatMulExt.0"/>HaveInt8MatMulExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p6" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p6</a>) ||
            (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
             boolean IMPLEMENTATION_DEFINED "Has AArch64 Int8 Mat Mul extension"));</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveLSE2Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveLSE2Ext</h3>
      <p class="pseudocode">// HaveLSE2Ext()
// =============
// Returns TRUE if LSE2 is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveLSE2Ext.0"/>HaveLSE2Ext()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMPAMExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMPAMExt</h3>
      <p class="pseudocode">// HaveMPAMExt()
// =============
// Returns TRUE if MPAM is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMPAMExt.0"/>HaveMPAMExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has MPAM extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTE2Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTE2Ext</h3>
      <p class="pseudocode">// HaveMTE2Ext()
// =============
// Returns TRUE if MTE support is beyond EL0, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTE2Ext.0"/>HaveMTE2Ext()
    if !<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) then
        return FALSE;
    return boolean IMPLEMENTATION_DEFINED "Has MTE2 extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTE3Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTE3Ext</h3>
      <p class="pseudocode">// HaveMTE3Ext()
// =============
// Returns TRUE if MTE Asymmetric Fault Handling support is
// implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTE3Ext.0"/>HaveMTE3Ext()
    return ((<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>()) || (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has MTE3 extension"));</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveMTEExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveMTEExt</h3>
      <p class="pseudocode">// HaveMTEExt()
// ============
// Returns TRUE if MTE implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveMTEExt.0"/>HaveMTEExt()
    if !<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) then
        return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        return TRUE;
    return boolean IMPLEMENTATION_DEFINED "Has MTE extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveNV2Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveNV2Ext</h3>
      <p class="pseudocode">// HaveNV2Ext()
// ============
// Returns TRUE if Enhanced Nested Virtualization is implemented.

boolean <a id="impl-shared.HaveNV2Ext.0"/>HaveNV2Ext()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()">HaveNVExt</a>()
            &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has support for Enhanced Nested Virtualization");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveNVExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveNVExt</h3>
      <p class="pseudocode">// HaveNVExt()
// ===========
// Returns TRUE if Nested Virtualization is implemented.

boolean <a id="impl-shared.HaveNVExt.0"/>HaveNVExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Nested Virtualization");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveNoSecurePMUDisableOverride"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveNoSecurePMUDisableOverride</h3>
      <p class="pseudocode">// HaveNoSecurePMUDisableOverride()
// ================================

boolean <a id="impl-shared.HaveNoSecurePMUDisableOverride.0"/>HaveNoSecurePMUDisableOverride()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveNoninvasiveDebugAuth"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveNoninvasiveDebugAuth</h3>
      <p class="pseudocode">// HaveNoninvasiveDebugAuth()
// ==========================
// Returns TRUE if the Non-invasive debug controls are implemented.

boolean <a id="impl-shared.HaveNoninvasiveDebugAuth.0"/>HaveNoninvasiveDebugAuth()
    return !<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePAN3Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePAN3Ext</h3>
      <p class="pseudocode">// HavePAN3Ext()
// =============
// Returns TRUE if SCTLR_EL1.EPAN and SCTLR_EL2.EPAN support is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HavePAN3Ext.0"/>HavePAN3Ext()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) || (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>) &amp;&amp;
           boolean IMPLEMENTATION_DEFINED "Has PAN3 extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePANExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePANExt</h3>
      <p class="pseudocode">// HavePANExt()
// ============

boolean <a id="impl-shared.HavePANExt.0"/>HavePANExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePMUv3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePMUv3</h3>
      <p class="pseudocode">// HavePMUv3()
// ===========
// Returns TRUE if the Performance Monitors extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HavePMUv3.0"/>HavePMUv3()
    return boolean IMPLEMENTATION_DEFINED "Has Performance Monitors extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePMUv3p5"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePMUv3p5</h3>
      <p class="pseudocode">// HavePMUv3p5()
// =============
// Returns TRUE if the PMUv3.5 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HavePMUv3p5.0"/>HavePMUv3p5()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has PMUv3.5 extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePMUv3p7"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePMUv3p7</h3>
      <p class="pseudocode">// HavePMUv3p7()
// =============
// Returns TRUE if the PMUv3.7 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HavePMUv3p7.0"/>HavePMUv3p7()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HavePMUv3p5.0" title="function: boolean HavePMUv3p5()">HavePMUv3p5</a>() &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "Has PMUv3.7 extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePageBasedHardwareAttributes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePageBasedHardwareAttributes</h3>
      <p class="pseudocode">// HavePageBasedHardwareAttributes()
// =================================

boolean <a id="impl-shared.HavePageBasedHardwareAttributes.0"/>HavePageBasedHardwareAttributes()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HavePrivATExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HavePrivATExt</h3>
      <p class="pseudocode">// HavePrivATExt()
// ===============

boolean <a id="impl-shared.HavePrivATExt.0"/>HavePrivATExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveQRDMLAHExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveQRDMLAHExt</h3>
      <p class="pseudocode">// HaveQRDMLAHExt()
// ================

boolean <a id="impl-shared.HaveQRDMLAHExt.0"/>HaveQRDMLAHExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);

boolean <a id="impl-shared.HaveAccessFlagUpdateExt.0"/>HaveAccessFlagUpdateExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);

boolean <a id="impl-shared.HaveDirtyBitModifierExt.0"/>HaveDirtyBitModifierExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveRASExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveRASExt</h3>
      <p class="pseudocode">// HaveRASExt()
// ============

boolean <a id="impl-shared.HaveRASExt.0"/>HaveRASExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>) ||
            boolean IMPLEMENTATION_DEFINED "Has RAS extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveRME"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveRME</h3>
      <p class="pseudocode">// HaveRME()
// =========
// Returns TRUE if the Realm Management Extension is implemented, and FALSE
// otherwise.

boolean <a id="impl-shared.HaveRME.0"/>HaveRME()
    return boolean IMPLEMENTATION_DEFINED "Has RME extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveRNG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveRNG</h3>
      <p class="pseudocode">// HaveRNG()
// =========
// Returns TRUE if Random Number Generator extension
// support is implemented and FALSE otherwise.

boolean <a id="impl-shared.HaveRNG.0"/>HaveRNG()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) &amp;&amp; boolean IMPLEMENTATION_DEFINED "Has RNG extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSBExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSBExt</h3>
      <p class="pseudocode">// HaveSBExt()
// ===========
// Returns TRUE if support for SB is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveSBExt.0"/>HaveSBExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) || boolean IMPLEMENTATION_DEFINED "Has SB extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSSBSExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSSBSExt</h3>
      <p class="pseudocode">// HaveSSBSExt()
// =============
// Returns TRUE if support for SSBS is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveSSBSExt.0"/>HaveSSBSExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p5" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p5</a>) || boolean IMPLEMENTATION_DEFINED "Has SSBS extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSecureEL2Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSecureEL2Ext</h3>
      <p class="pseudocode">// HaveSecureEL2Ext()
// ==================
// Returns TRUE if Secure EL2 is implemented.

boolean <a id="impl-shared.HaveSecureEL2Ext.0"/>HaveSecureEL2Ext()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSecureExtDebugView"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSecureExtDebugView</h3>
      <p class="pseudocode">// HaveSecureExtDebugView()
// ========================
// Returns TRUE if support for Secure and Non-secure views of debug peripherals
// is implemented.

boolean <a id="impl-shared.HaveSecureExtDebugView.0"/>HaveSecureExtDebugView()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSelfHostedTrace"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSelfHostedTrace</h3>
      <p class="pseudocode">// HaveSelfHostedTrace()
// =====================

boolean <a id="impl-shared.HaveSelfHostedTrace.0"/>HaveSelfHostedTrace()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSmallTranslationTblExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSmallTranslationTblExt</h3>
      <p class="pseudocode">// HaveSmallTranslationTblExt()
// ============================
// Returns TRUE if Small Translation Table Support is implemented.

boolean <a id="impl-shared.HaveSmallTranslationTableExt.0"/>HaveSmallTranslationTableExt()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>) &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Has Small Translation Table extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveSoftwareLock"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveSoftwareLock</h3>
      <p class="pseudocode">// HaveSoftwareLock()
// ==================
// Returns TRUE if Software Lock is implemented.

boolean <a id="impl-shared.HaveSoftwareLock.1"/>HaveSoftwareLock(<a href="shared_pseudocode.html#Component" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component</a> component)
    if <a href="shared_pseudocode.html#impl-shared.Havev8p4Debug.0" title="function: boolean Havev8p4Debug()">Havev8p4Debug</a>() then
        return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveDoPD.0" title="function: boolean HaveDoPD()">HaveDoPD</a>() &amp;&amp; component != <a href="shared_pseudocode.html#Component_CTI" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_CTI</a> then
        return FALSE;
    case component of
        when <a href="shared_pseudocode.html#Component_Debug" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_Debug</a>
            return boolean IMPLEMENTATION_DEFINED "Debug has Software Lock";
        when <a href="shared_pseudocode.html#Component_PMU" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_PMU</a>
            return boolean IMPLEMENTATION_DEFINED "PMU has Software Lock";
        when <a href="shared_pseudocode.html#Component_CTI" title="enumeration Component {&#13; Component_PMU,&#13; Component_Debug,&#13; Component_CTI&#13; }">Component_CTI</a>
            return boolean IMPLEMENTATION_DEFINED "CTI has Software Lock";
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveStage2MemAttrControl"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveStage2MemAttrControl</h3>
      <p class="pseudocode">// HaveStage2MemAttrControl()
// ==========================
// Returns TRUE if support for Stage2 control of memory types and cacheability
// attributes is implemented.

boolean <a id="impl-shared.HaveStage2MemAttrControl.0"/>HaveStage2MemAttrControl()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveStatisticalProfiling"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveStatisticalProfiling</h3>
      <p class="pseudocode">// HaveStatisticalProfiling()
// ==========================
// Returns TRUE if Statistical Profiling Extension is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HaveStatisticalProfiling.0"/>HaveStatisticalProfiling()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveStatisticalProfilingv1p1"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveStatisticalProfilingv1p1</h3>
      <p class="pseudocode">// HaveStatisticalProfilingv1p1()
// ==============================
// Returns TRUE if the SPEv1p1 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveStatisticalProfilingv1p1.0"/>HaveStatisticalProfilingv1p1()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p3" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p3</a>) &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "Has SPEv1p1 extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveStatisticalProfilingv1p2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveStatisticalProfilingv1p2</h3>
      <p class="pseudocode">// HaveStatisticalProfilingv1p2()
// ==============================
// Returns TRUE if the SPEv1p2 extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveStatisticalProfilingv1p2.0"/>HaveStatisticalProfilingv1p2()
    return (<a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p7" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p7</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveStatisticalProfiling.0" title="function: boolean HaveStatisticalProfiling()">HaveStatisticalProfiling</a>() &amp;&amp;
        boolean IMPLEMENTATION_DEFINED "Has SPEv1p2 extension");</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTME"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTME</h3>
      <p class="pseudocode">// HaveTME()
// =========

boolean <a id="impl-shared.HaveTME.0"/>HaveTME()
    return boolean IMPLEMENTATION_DEFINED "Has Transactional Memory extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTWEDExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTWEDExt</h3>
      <p class="pseudocode">// HaveTWEDExt()
// =============
// Returns TRUE if Delayed Trapping of WFE instruction support is implemented,
// and FALSE otherwise.

boolean <a id="impl-shared.HaveTWEDExt.0"/>HaveTWEDExt()
    return boolean IMPLEMENTATION_DEFINED "Has TWED extension";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTraceBufferExtension"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTraceBufferExtension</h3>
      <p class="pseudocode">// HaveTraceBufferExtension()
// ==========================
// Returns TRUE if support for the Trace Buffer Extension is implemented. This
// feature depends upon the Secure External Debug view feature being
// implemented. Returns FALSE otherwise.

boolean <a id="impl-shared.HaveTraceBufferExtension.0"/>HaveTraceBufferExtension()
    return (<a href="shared_pseudocode.html#impl-shared.HaveSecureExtDebugView.0" title="function: boolean HaveSecureExtDebugView()">HaveSecureExtDebugView</a>() &amp;&amp;
            boolean IMPLEMENTATION_DEFINED "Trace Buffer Extension implemented");

// HaveTraceBufferExtension()
// ==========================
// Returns TRUE if Trace Buffer Extension is implemented, and FALSE otherwise.

boolean <a id="impl-shared.HaveTraceBufferExtension.0_2"/>HaveTraceBufferExtension()
    return boolean IMPLEMENTATION_DEFINED "Trace Buffer Extension implemented";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTraceExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTraceExt</h3>
      <p class="pseudocode">// HaveTraceExt()
// ==============
// Returns TRUE if Trace functionality as described by the Trace Architecture
// is implemented.

boolean <a id="impl-shared.HaveTraceExt.0"/>HaveTraceExt()
    return boolean IMPLEMENTATION_DEFINED "Has Trace Architecture functionality";</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveTrapLoadStoreMultipleDeviceExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveTrapLoadStoreMultipleDeviceExt</h3>
      <p class="pseudocode">// HaveTrapLoadStoreMultipleDeviceExt()
// ====================================

boolean <a id="impl-shared.HaveTrapLoadStoreMultipleDeviceExt.0"/>HaveTrapLoadStoreMultipleDeviceExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveUAOExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveUAOExt</h3>
      <p class="pseudocode">// HaveUAOExt()
// ============

boolean <a id="impl-shared.HaveUAOExt.0"/>HaveUAOExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveV82Debug"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveV82Debug</h3>
      <p class="pseudocode">// HaveV82Debug()
// ==============

boolean <a id="impl-shared.HaveV82Debug.0"/>HaveV82Debug()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p2" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p2</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.HaveVirtHostExt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/HaveVirtHostExt</h3>
      <p class="pseudocode">// HaveVirtHostExt()
// =================

boolean <a id="impl-shared.HaveVirtHostExt.0"/>HaveVirtHostExt()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p1" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p1</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.Havev8p4Debug"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/Havev8p4Debug</h3>
      <p class="pseudocode">// Havev8p4Debug()
// ===============
// Returns TRUE if support for the Debugv8p4 feature is implemented and FALSE otherwise.

boolean <a id="impl-shared.Havev8p4Debug.0"/>Havev8p4Debug()
    return <a href="shared_pseudocode.html#impl-shared.HasArchVersion.1" title="function: boolean HasArchVersion(ArchVersion version)">HasArchVersion</a>(<a href="shared_pseudocode.html#ARMv8p4" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p4</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.extension.InsertIESBBeforeException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/extension/InsertIESBBeforeException</h3>
      <p class="pseudocode">// If SCTLR_ELx.IESB is 1 when an exception is generated to ELx, any pending Unrecoverable
// SError interrupt must be taken before executing any instructions in the exception handler.
// However, this can be before the branch to the exception handler is made.
boolean <a id="impl-shared.InsertIESBBeforeException.1"/>InsertIESBBeforeException(bits(2) el);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalAbort</h3>
      <p class="pseudocode">// HandleExternalAbort()
// =====================
// Takes a Synchronous/Asynchronous abort based on fault.

<a id="impl-shared.HandleExternalAbort.5"/>HandleExternalAbort(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memretstatus, boolean iswrite,
                    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc, integer size,
                    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc)
    assert (memretstatus.statuscode IN {<a href="shared_pseudocode.html#Fault_SyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternal</a>, <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>} ||
           (!<a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() &amp;&amp; memretstatus.statuscode IN {<a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a>,
                                                         <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>}));

    fault = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
    fault.statuscode = memretstatus.statuscode;
    fault.write = iswrite;
    fault.extflag = memretstatus.extflag;
    fault.acctype = memretstatus.acctype;
    // It is implementation specific whether external aborts signaled
    // in-band synchronously are taken synchronously or asynchronously
    if (<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) &amp;&amp;
            !<a href="shared_pseudocode.html#impl-shared.IsExternalAbortTakenSynchronously.5" title="function: boolean IsExternalAbortTakenSynchronously(PhysMemRetStatus memstatus,&#13; boolean iswrite,&#13; AddressDescriptor desc,&#13; integer size,&#13; AccessDescriptor accdesc)">IsExternalAbortTakenSynchronously</a>(memretstatus, iswrite, memaddrdesc,
                                               size, accdesc)) then
        if fault.statuscode == <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>;
        else
            fault.statuscode = <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;

    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        fault.errortype = <a href="shared_pseudocode.html#impl-shared.PEErrorState.1" title="function: bits(2) PEErrorState(PhysMemRetStatus memstatus)">PEErrorState</a>(memretstatus);
    else
        fault.errortype = bits(2) UNKNOWN;

    if <a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(fault) then
        if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            <a href="shared_pseudocode.html#AArch32.Abort.2" title="function: AArch32.Abort(bits(32) vaddress, FaultRecord fault)">AArch32.Abort</a>(memaddrdesc.vaddress&lt;31:0&gt;, fault);
        else
            <a href="shared_pseudocode.html#AArch64.Abort.2" title="function: AArch64.Abort(bits(64) vaddress, FaultRecord fault)">AArch64.Abort</a>(memaddrdesc.vaddress, fault);

    else
        <a href="shared_pseudocode.html#impl-shared.PendSErrorInterrupt.1" title="function: PendSErrorInterrupt(FaultRecord fault)">PendSErrorInterrupt</a>(fault);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalReadAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalReadAbort</h3>
      <p class="pseudocode">// HandleExternalReadAbort()
// =========================
// Wrapper function for HandleExternalAbort function in case of an External
// Abort on memory read.

<a id="impl-shared.HandleExternalReadAbort.4"/>HandleExternalReadAbort(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc,
                        integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc)
    iswrite = FALSE;
    <a href="shared_pseudocode.html#impl-shared.HandleExternalAbort.5" title="function: HandleExternalAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc, integer size,&#13; AccessDescriptor accdesc)">HandleExternalAbort</a>(memstatus, iswrite, memaddrdesc, size, accdesc);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalTTWAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalTTWAbort</h3>
      <p class="pseudocode">// HandleExternalTTWAbort()
// ========================
// Take Asynchronous abort or update FaultRecord for Translation Table Walk
// based on PhysMemRetStatus.

FaultRecord <a id="impl-shared.HandleExternalTTWAbort.6"/>HandleExternalTTWAbort(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memretstatus, boolean iswrite,
                                   <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc,
                                   <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc, integer size,
                                   <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> input_fault)
    output_fault = input_fault;
    output_fault.extflag = memretstatus.extflag;
    output_fault.statuscode = memretstatus.statuscode;
    if (<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(output_fault) &amp;&amp;
            !<a href="shared_pseudocode.html#impl-shared.IsExternalAbortTakenSynchronously.5" title="function: boolean IsExternalAbortTakenSynchronously(PhysMemRetStatus memstatus,&#13; boolean iswrite,&#13; AddressDescriptor desc,&#13; integer size,&#13; AccessDescriptor accdesc)">IsExternalAbortTakenSynchronously</a>(memretstatus, iswrite,
                                               memaddrdesc,
                                               size, accdesc)) then
        if output_fault.statuscode == <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a> then
            output_fault.statuscode = <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a>;
        else
            output_fault.statuscode = <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;

    // If a synchronous fault is on a translation table walk, then update
    // the fault type
    if <a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(output_fault) then
        if output_fault.statuscode == <a href="shared_pseudocode.html#Fault_SyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParity</a> then
            output_fault.statuscode = <a href="shared_pseudocode.html#Fault_SyncParityOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncParityOnWalk</a>;
        else
            output_fault.statuscode = <a href="shared_pseudocode.html#Fault_SyncExternalOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_SyncExternalOnWalk</a>;
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        output_fault.errortype = <a href="shared_pseudocode.html#impl-shared.PEErrorState.1" title="function: bits(2) PEErrorState(PhysMemRetStatus memstatus)">PEErrorState</a>(memretstatus);
    else
        output_fault.errortype = bits(2) UNKNOWN;
    if !<a href="shared_pseudocode.html#impl-shared.IsExternalSyncAbort.1" title="function: boolean IsExternalSyncAbort(Fault statuscode)">IsExternalSyncAbort</a>(output_fault) then
        <a href="shared_pseudocode.html#impl-shared.PendSErrorInterrupt.1" title="function: PendSErrorInterrupt(FaultRecord fault)">PendSErrorInterrupt</a>(output_fault);
        output_fault.statuscode = <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    return output_fault;</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.HandleExternalWriteAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/HandleExternalWriteAbort</h3>
      <p class="pseudocode">// HandleExternalWriteAbort()
// ==========================
// Wrapper function for HandleExternalAbort function in case of an External
// Abort on memory write.

<a id="impl-shared.HandleExternalWriteAbort.4"/>HandleExternalWriteAbort(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> memaddrdesc,
                         integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc)
    iswrite = TRUE;
    <a href="shared_pseudocode.html#impl-shared.HandleExternalAbort.5" title="function: HandleExternalAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc, integer size,&#13; AccessDescriptor accdesc)">HandleExternalAbort</a>(memstatus, iswrite, memaddrdesc, size, accdesc);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.IsExternalAbortTakenSynchronously"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/IsExternalAbortTakenSynchronously</h3>
      <p class="pseudocode">// Return an implementation specific value:
// TRUE if the fault returned for the access can be taken synchronously,
// FALSE otherwise.
//
// This might vary between accesses, for example depending on the error type
// or memory type being accessed.
// External aborts on data accesses and translation table walks on data accesses
// can be either synchronous or asynchronous.
//
// When FEAT_DoubleFault is not implemented, External aborts on instruction
// fetches and translation table walks on instruction fetches can be either
// synchronous or asynchronous.
// When FEAT_DoubleFault is implemented, all External abort exceptions on
// instruction fetches and translation table walks on instruction fetches
// must be synchronous.
boolean <a id="impl-shared.IsExternalAbortTakenSynchronously.5"/>IsExternalAbortTakenSynchronously(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus,
                                          boolean iswrite,
                                          <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> desc,
                                          integer size,
                                          <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.PEErrorState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/PEErrorState</h3>
      <p class="pseudocode">constant bits(2) <a id="Sync_UC"/>Sync_UC   = '10'; // Synchronous Uncontainable
constant bits(2) <a id="Sync_UER"/>Sync_UER  = '00'; // Synchronous Recoverable
constant bits(2) <a id="Sync_UEO"/>Sync_UEO  = '11'; // Synchronous Restartable
constant bits(2) <a id="ASync_UC"/>ASync_UC  = '00'; // ASynchronous Uncontainable
constant bits(2) <a id="ASync_UEU"/>ASync_UEU = '01'; // ASynchronous Unrecoverable
constant bits(2) <a id="ASync_UER"/>ASync_UER = '11'; // ASynchronous Recoverable
constant bits(2) <a id="ASync_UEO"/>ASync_UEO = '10'; // ASynchronous Restartable

bits(2) <a id="impl-shared.PEErrorState.1"/>PEErrorState(<a href="shared_pseudocode.html#PhysMemRetStatus" title="type PhysMemRetStatus is (Fault statuscode, bit extflag, bits(2) errortype, bits(64) store64bstatus, AccType acctype)">PhysMemRetStatus</a> memstatus);</p>
    </div>
    <div class="ps"><a id="shared.functions.externalaborts.PendSErrorInterrupt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/externalaborts/PendSErrorInterrupt</h3>
      <p class="pseudocode">// Pend the SError.
<a id="impl-shared.PendSErrorInterrupt.1"/>PendSErrorInterrupt(<a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFAdd</h3>
      <p class="pseudocode">// BFAdd()
// =======
// Single-precision add following BFloat16 computation behaviors.

bits(32) <a id="impl-shared.BFAdd.2"/>BFAdd(bits(32) op1, bits(32) op2)

    bits(32) result;

    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.BFUnpack.1" title="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op1);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.BFUnpack.1" title="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op2);
    if type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
    else
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1);
        else
            result_value = value1 + value2;
            if result_value == 0.0 then
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>('0');    // Positive sign when Round to Odd
            else
                result = <a href="shared_pseudocode.html#impl-shared.BFRound.1" title="function: bits(32) BFRound(real op)">BFRound</a>(result_value);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFDotAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFDotAdd</h3>
      <p class="pseudocode">// BFDotAdd()
// ==========
// BFloat16 2-way dot-product and add to single-precision
// result = addend + op1_a*op2_a + op1_b*op2_b

bits(32) <a id="impl-shared.BFDotAdd.6"/>BFDotAdd(bits(32) addend, bits(16) op1_a, bits(16) op1_b,
                  bits(16) op2_a, bits(16) op2_b, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    bits(32) prod;

    if !<a href="shared_pseudocode.html#impl-aarch64.HaveEBF16.0" title="function: boolean HaveEBF16()">HaveEBF16</a>() || fpcr.EBF == '0' then   // Standard BFloat16 behaviors
        prod = <a href="shared_pseudocode.html#impl-shared.BFAdd.2" title="function: bits(32) BFAdd(bits(32) op1, bits(32) op2)">BFAdd</a>(<a href="shared_pseudocode.html#impl-shared.BFMul.2" title="function: bits(32) BFMul(bits(16) op1, bits(16) op2)">BFMul</a>(op1_a, op2_a), <a href="shared_pseudocode.html#impl-shared.BFMul.2" title="function: bits(32) BFMul(bits(16) op1, bits(16) op2)">BFMul</a>(op1_b, op2_b));
        result = <a href="shared_pseudocode.html#impl-shared.BFAdd.2" title="function: bits(32) BFAdd(bits(32) op1, bits(32) op2)">BFAdd</a>(addend, prod);
    else                                      // Extended BFloat16 behaviors
        boolean isbfloat16 = TRUE;
        boolean fpexc = FALSE;  // Do not generate floating-point exceptions
        fpcr.DN = '1';          // Generate default NaN values
        prod = <a href="shared_pseudocode.html#impl-shared.FPDot.7" title="function: bits(N) FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,&#13; bits(N DIV 2) op2_b, FPCRType fpcr, boolean isbfloat16, boolean fpexc)">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
        result = <a href="shared_pseudocode.html#impl-shared.FPAdd.4" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</a>(addend, prod, fpcr, fpexc);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMatMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMatMulAdd</h3>
      <p class="pseudocode">// BFMatMulAdd()
// =============
// BFloat16 matrix multiply and add to single-precision matrix
// result[2, 2] = addend[2, 2] + (op1[2, 4] * op2[4, 2])

bits(N) <a id="impl-shared.BFMatMulAdd.3"/>BFMatMulAdd(bits(N) addend, bits(N) op1, bits(N) op2)

    assert N == 128;

    bits(N) result;
    bits(32) sum;

    for i = 0 to 1
        for j = 0 to 1
            sum = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[addend, 2*i + j, 32];
            for k = 0 to 1
                bits(16) elt1_a = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 4*i + 2*k + 0, 16];
                bits(16) elt1_b = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 4*i + 2*k + 1, 16];
                bits(16) elt2_a = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 4*j + 2*k + 0, 16];
                bits(16) elt2_b = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 4*j + 2*k + 1, 16];
                sum = <a href="shared_pseudocode.html#impl-shared.BFDotAdd.6" title="function: bits(32) BFDotAdd(bits(32) addend, bits(16) op1_a, bits(16) op1_b,&#13; bits(16) op2_a, bits(16) op2_b, FPCRType fpcr)">BFDotAdd</a>(sum, elt1_a, elt1_b, elt2_a, elt2_b, FPCR[]);
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, 2*i + j, 32] = sum;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMul"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMul</h3>
      <p class="pseudocode">// BFMul()
// =======
// BFloat16 widening multiply to single-precision following BFloat16
// computation behaviors.

bits(32) <a id="impl-shared.BFMul.2"/>BFMul(bits(16) op1, bits(16) op2)

    bits(32) result;

    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.BFUnpack.1" title="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op1);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.BFUnpack.1" title="function: (FPType, bit, real) BFUnpack(bits(N) fpval)">BFUnpack</a>(op2);
    if type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
    else
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1 EOR sign2);
        else
            result = <a href="shared_pseudocode.html#impl-shared.BFRound.1" title="function: bits(32) BFRound(real op)">BFRound</a>(value1*value2);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFMulAdd</h3>
      <p class="pseudocode">// BFMulAdd()
// ==========
// Used by BFMLALB and BFMLALT instructions.

bits(N) <a id="impl-shared.BFMulAdd.4"/>BFMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';  // When TRUE:
    boolean fpexc = !altfp;                         //     Do not generate floating point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             //     Flush denormal input and output to zero
    if altfp then fpcr.RMode    = '00';             //     Use RNE rounding mode
    return <a href="shared_pseudocode.html#impl-shared.FPMulAdd.5" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAdd</a>(addend, op1, op2, fpcr, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFNeg"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFNeg</h3>
      <p class="pseudocode">// BFNeg()
// =======

bits(16) <a id="impl-shared.BFNeg.1"/>BFNeg(bits(16) op)
    return NOT(op&lt;15&gt;) : op&lt;14:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFRound"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFRound</h3>
      <p class="pseudocode">// BFRound()
// =========
// Converts a real number OP into a single-precision value using the
// Round to Odd rounding mode and following BFloat16 computation behaviors.

bits(32) <a id="impl-shared.BFRound.1"/>BFRound(real op)

    assert op != 0.0;
    bits(32) result;

    // Format parameters - minimum exponent, numbers of exponent and fraction bits.
    minimum_exp = -126;  E = 8;  F = 23;

    // Split value into sign, unrounded mantissa and exponent.
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    exponent = 0;
    while mantissa &lt; 1.0 do
        mantissa = mantissa * 2.0;  exponent = exponent - 1;
    while mantissa &gt;= 2.0 do
        mantissa = mantissa / 2.0;  exponent = exponent + 1;

    // Fixed Flush-to-zero.
    if exponent &lt; minimum_exp then
        return <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    biased_exp = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>(exponent - minimum_exp + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent);

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    int_mant = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(mantissa * 2.0^F);  // &lt; 2.0^F if biased_exp == 0, &gt;= 2.0^F if not
    error = mantissa * 2.0^F - Real(int_mant);

    // Round to Odd
    if error != 0.0 then
        int_mant&lt;0&gt; = '1';

    // Deal with overflow and generate result.
    if biased_exp &gt;= 2^E - 1 then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);      // Overflows generate appropriately-signed Infinity
    else
        result = sign : biased_exp&lt;30-F:0&gt; : int_mant&lt;F-1:0&gt;;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.BFUnpack"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/BFUnpack</h3>
      <p class="pseudocode">// BFUnpack()
// ==========
// Unpacks a BFloat16 or single-precision value into its type,
// sign bit and real number that it represents.
// The real number result has the correct sign for numbers and infinities,
// is very large in magnitude for infinities, and is 0.0 for NaNs.
// (These values are chosen to simplify the description of
// comparisons and conversions.)

(FPType, bit, real) <a id="impl-shared.BFUnpack.1"/>BFUnpack(bits(N) fpval)

    assert N IN {16,32};

    if N == 16 then
        sign   = fpval&lt;15&gt;;
        exp    = fpval&lt;14:7&gt;;
        frac   = fpval&lt;6:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
    else  // N == 32
        sign   = fpval&lt;31&gt;;
        exp    = fpval&lt;30:23&gt;;
        frac   = fpval&lt;22:0&gt;;

    if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(exp) then
        fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;    // Fixed Flush to Zero
    elsif <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp) then
        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac) then
            fptype = <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
        else    // no SNaN for BF16 arithmetic
            fptype = <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>; value = 0.0;
    else
        fptype = <a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
        value = 2.0^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(exp)-127) * (1.0 + Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac)) * 2.0^-23);

    if sign == '1' then value = -value;

    return (fptype, sign, value);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.FPConvertBF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/FPConvertBF</h3>
      <p class="pseudocode">// FPConvertBF()
// =============
// Converts a single-precision OP to BFloat16 value with using rounding mode of
// Round to Nearest Even when executed from AArch64 state and
// FPCR.AH == '1', otherwise rounding is controlled by FPCR/FPSCR.

bits(16) <a id="impl-shared.FPConvertBF.3"/>FPConvertBF(bits(32) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)

    bits(32) result;                                // BF16 value in top 16 bits
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                         // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';             // Flush denormal input and output to zero
    if altfp then rounding = <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>;    // Use RNE rounding mode

    // Unpack floating-point operand, with always flush-to-zero if fpcr.AH == '1'.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        if fpcr.DN == '1' then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(op);
        if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRoundCVBF.4" title="function: bits(32) FPRoundCVBF(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRoundCVBF</a>(value, fpcr, rounding, fpexc);

    // Returns correctly rounded BF16 value from top 16 bits
    return result&lt;31:16&gt;;

// FPConvertBF()
// =============
// Converts a single-precision operand to BFloat16 value.

bits(16) <a id="impl-shared.FPConvertBF.2"/>FPConvertBF(bits(32) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    return <a href="shared_pseudocode.html#impl-shared.FPConvertBF.3" title="function: bits(16) FPConvertBF(bits(32) op, FPCRType fpcr, FPRounding rounding)">FPConvertBF</a>(op, fpcr, <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr));</p>
    </div>
    <div class="ps"><a id="shared.functions.float.bfloat.FPRoundCVBF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/bfloat/FPRoundCVBF</h3>
      <p class="pseudocode">// FPRoundCVBF()
// =============
// Converts a real number OP into a BFloat16 value using the supplied
// rounding mode RMODE. The 'fpexc' argument controls the generation of
// floating-point exceptions.

bits(32) <a id="impl-shared.FPRoundCVBF.4"/>FPRoundCVBF(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean fpexc)
    boolean isbfloat16 = TRUE;
    return <a href="shared_pseudocode.html#impl-shared.FPRoundBase.5" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fixedtofp.FixedToFP"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fixedtofp/FixedToFP</h3>
      <p class="pseudocode">// FixedToFP()
// ===========

// Convert M-bit fixed point OP with FBITS fractional bits to
// N-bit precision floating point, controlled by UNSIGNED and ROUNDING.

bits(N) <a id="impl-shared.FixedToFP.5"/>FixedToFP(bits(M) op, integer fbits, boolean unsigned, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)

    assert N IN {16,32,64};
    assert M IN {16,32,64};
    bits(N) result;
    assert fbits &gt;= 0;
    assert rounding != <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;

    // Correct signed-ness
    int_operand = <a href="shared_pseudocode.html#impl-shared.Int.2" title="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(op, unsigned);

    // Scale by fractional bits and generate a real value
    real_operand = Real(int_operand) / 2.0^fbits;

    if real_operand == 0.0 then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>('0');
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)">FPRound</a>(real_operand, fpcr, rounding);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpabs.FPAbs"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpabs/FPAbs</h3>
      <p class="pseudocode">// FPAbs()
// =======

bits(N) <a id="impl-shared.FPAbs.1"/>FPAbs(bits(N) op)

    assert N IN {16,32,64};
    if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() then
        <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
        if fpcr.AH == '1' then
            (fptype, -, -) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op, fpcr, FALSE);
            if fptype IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
                return op;        // When fpcr.AH=1, sign of NaN has no consequence

    return '0' : op&lt;N-2:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpadd.FPAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpadd/FPAdd</h3>
      <p class="pseudocode">// FPAdd()
// =======

bits(N) <a id="impl-shared.FPAdd.3"/>FPAdd(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPAdd.4" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</a>(op1, op2, fpcr, fpexc);

// FPAdd()
// =======

bits(N) <a id="impl-shared.FPAdd.4"/>FPAdd(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);

    boolean altfmaxfmin = FALSE;    // Do not use altfp mode for FMIN, FMAX and variants
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.7" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, altfmaxfmin, fpexc);
    if !done then
        inf1  = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);  inf2  = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);      zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1);
        else
            result_value = value1 + value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcompare.FPCompare"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcompare/FPCompare</h3>
      <p class="pseudocode">// FPCompare()
// ===========

bits(4) <a id="impl-shared.FPCompare.4"/>FPCompare(bits(N) op1, bits(N) op2, boolean signal_nans, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    if type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = '0011';
        if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || signal_nans then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        if value1 == value2 then
            result = '0110';
        elsif value1 &lt; value2 then
            result = '1000';
        else  // value1 &gt; value2
            result = '0010';

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcompareeq.FPCompareEQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcompareeq/FPCompareEQ</h3>
      <p class="pseudocode">// FPCompareEQ()
// =============

boolean <a id="impl-shared.FPCompareEQ.3"/>FPCompareEQ(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    if type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = FALSE;
        if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 == value2);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcomparege.FPCompareGE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcomparege/FPCompareGE</h3>
      <p class="pseudocode">// FPCompareGE()
// =============

boolean <a id="impl-shared.FPCompareGE.3"/>FPCompareGE(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    if type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = FALSE;
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 &gt;= value2);
        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcomparegt.FPCompareGT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcomparegt/FPCompareGT</h3>
      <p class="pseudocode">// FPCompareGT()
// =============

boolean <a id="impl-shared.FPCompareGT.3"/>FPCompareGT(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    if type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} || type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then
        result = FALSE;
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        // All non-NaN cases can be evaluated on the values produced by FPUnpack()
        result = (value1 &gt; value2);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpconvert.FPConvert"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpconvert/FPConvert</h3>
      <p class="pseudocode">// FPConvert()
// ===========

// Convert floating point OP with N-bit precision to M-bit precision,
// with rounding controlled by ROUNDING.
// This is used by the FP-to-FP conversion instructions and so for
// half-precision data ignores FZ16, but observes AHP.

bits(M) <a id="impl-shared.FPConvert.3"/>FPConvert(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)

    assert M IN {16,32,64};
    assert N IN {16,32,64};
    bits(M) result;

    // Unpack floating-point operand optionally with flush-to-zero.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpackCV.2" title="function: (FPType, bit, real) FPUnpackCV(bits(N) fpval, FPCRType fpcr)">FPUnpackCV</a>(op, fpcr);

    alt_hp = (M == 16) &amp;&amp; (fpcr.AHP == '1');

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        if alt_hp then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
        elsif fpcr.DN == '1' then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(op);
        if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || alt_hp then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>,fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        if alt_hp then
            result = sign:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(M-1);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRoundCV.3" title="function: bits(N) FPRoundCV(real op, FPCRType fpcr, FPRounding rounding)">FPRoundCV</a>(value, fpcr, rounding);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result;

// FPConvert()
// ===========

bits(M) <a id="impl-shared.FPConvert.2"/>FPConvert(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    return <a href="shared_pseudocode.html#impl-shared.FPConvert.3" title="function: bits(M) FPConvert(bits(N) op, FPCRType fpcr, FPRounding rounding)">FPConvert</a>(op, fpcr, <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr));</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpconvertnan.FPConvertNaN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpconvertnan/FPConvertNaN</h3>
      <p class="pseudocode">// FPConvertNaN()
// ==============
// Converts a NaN of one floating-point type to another

bits(M) <a id="impl-shared.FPConvertNaN.1"/>FPConvertNaN(bits(N) op)

    assert N IN {16,32,64};
    assert M IN {16,32,64};
    bits(M) result;
    bits(51) frac;

    sign = op&lt;N-1&gt;;

    // Unpack payload from input NaN
    case N of
        when 64 frac = op&lt;50:0&gt;;
        when 32 frac = op&lt;21:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(29);
        when 16 frac = op&lt;8:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(42);

    // Repack payload into output NaN, while
    // converting an SNaN to a QNaN.
    case M of
        when 64 result = sign:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(M-52):frac;
        when 32 result = sign:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(M-23):frac&lt;50:29&gt;;
        when 16 result = sign:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(M-10):frac&lt;50:42&gt;;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpcrtype.FPCRType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpcrtype/FPCRType</h3>
      <p class="pseudocode">type <a id="FPCRType"/>FPCRType;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdecoderm.FPDecodeRM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdecoderm/FPDecodeRM</h3>
      <p class="pseudocode">// FPDecodeRM()
// ============

// Decode most common AArch32 floating-point rounding encoding.

FPRounding <a id="impl-shared.FPDecodeRM.1"/>FPDecodeRM(bits(2) rm)

    case rm of
        when '00' result = <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>; // A
        when '01' result = <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>; // N
        when '10' result = <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>;  // P
        when '11' result = <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>;  // M

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdecoderounding.FPDecodeRounding"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdecoderounding/FPDecodeRounding</h3>
      <p class="pseudocode">// FPDecodeRounding()
// ==================

// Decode floating-point rounding mode and common AArch64 encoding.

FPRounding <a id="impl-shared.FPDecodeRounding.1"/>FPDecodeRounding(bits(2) rmode)
    case rmode of
        when '00' return <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>; // N
        when '01' return <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>;  // P
        when '10' return <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>;  // M
        when '11' return <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>;    // Z</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdefaultnan.FPDefaultNaN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdefaultnan/FPDefaultNaN</h3>
      <p class="pseudocode">// FPDefaultNaN()
// ==============

bits(N) <a id="impl-shared.FPDefaultNaN.0"/>FPDefaultNaN()
    <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
    return <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);

bits(N) <a id="impl-shared.FPDefaultNaN.1"/>FPDefaultNaN(<a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    bit sign = if <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then fpcr.AH else '0';

    bits(E) exp  = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E);
    bits(F) frac = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F-1);

    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdiv.FPDiv"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdiv/FPDiv</h3>
      <p class="pseudocode">// FPDiv()
// =======

bits(N) <a id="impl-shared.FPDiv.3"/>FPDiv(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);

    if !done then
        inf1  = type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;
        inf2  = type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;
        zero1 = type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;
        zero2 = type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;

        if (inf1 &amp;&amp; inf2) || (zero1 &amp;&amp; zero2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif inf1 || zero2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
            if !inf1 then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>, fpcr);
        elsif zero1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1 EOR sign2);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(value1/value2, fpcr);

        if !zero2 then
            <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdot.FPDot"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdot/FPDot</h3>
      <p class="pseudocode">// FPDot()
// =======
// Calculates single-precision result of 2-way 16-bit floating-point dot-product
// with a single rounding.
// The 'fpcr' argument supplies the FPCR control bits and 'isbfloat16'
// determines whether input operands are BFloat16 or half-precision type.
// and 'fpexc' controls the generation of floating-point exceptions.

bits(N) <a id="impl-shared.FPDot.6"/>FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,
              bits(N DIV 2) op2_b, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean isbfloat16)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPDot.7" title="function: bits(N) FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,&#13; bits(N DIV 2) op2_b, FPCRType fpcr, boolean isbfloat16, boolean fpexc)">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);

bits(N) <a id="impl-shared.FPDot.7"/>FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,
              bits(N DIV 2) op2_b, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean isbfloat16, boolean fpexc)

    assert N == 32;
    bits(N) result;
    fpcr.AHP = '0';           // Ignore alternative half-precision option
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    (type1_a,sign1_a,value1_a) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op1_a, fpcr, fpexc, isbfloat16);
    (type1_b,sign1_b,value1_b) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op1_b, fpcr, fpexc, isbfloat16);
    (type2_a,sign2_a,value2_a) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op2_a, fpcr, fpexc, isbfloat16);
    (type2_b,sign2_b,value2_b) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(op2_b, fpcr, fpexc, isbfloat16);

    inf1_a = (type1_a == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero1_a = (type1_a == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf1_b = (type1_b == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero1_b = (type1_b == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf2_a = (type2_a == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero2_a = (type2_a == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf2_b = (type2_b == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero2_b = (type2_b == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs4.10" title="function: (boolean, bits(N)) FPProcessNaNs4(FPType type1, FPType type2, FPType type3, FPType type4,&#13; bits(N DIV 2) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,&#13; bits(N DIV 2) op4, FPCRType fpcr, boolean fpexc)">FPProcessNaNs4</a>(type1_a, type1_b, type2_a, type2_b,
                                   op1_a, op1_b, op2_a, op2_b, fpcr, fpexc);

    if (((inf1_a &amp;&amp; zero2_a) || (zero1_a &amp;&amp; inf2_a)) &amp;&amp;
        ((inf1_b &amp;&amp; zero2_b) || (zero1_b &amp;&amp; inf2_b))) then
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    if !done then
        // Determine sign and type products will have if it does not cause an Invalid
        // Operation.
        signPa = sign1_a EOR sign2_a;
        signPb = sign1_b EOR sign2_b;
        infPa = inf1_a || inf2_a;
        infPb = inf1_b || inf2_b;
        zeroPa = zero1_a || zero2_a;
        zeroPb = zero1_b || zero2_b;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero
        // by infinity and additions of opposite-signed infinities.
        invalidop = ((inf1_a &amp;&amp; zero2_a) || (zero1_a &amp;&amp; inf2_a) ||
            (inf1_b &amp;&amp; zero2_b) || (zero1_b &amp;&amp; inf2_b) || (infPa &amp;&amp; infPb &amp;&amp; signPa != signPb));

        if invalidop then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

       // Other cases involving infinities produce an infinity of the same sign.
        elsif (infPa &amp;&amp; signPa == '0') || (infPb &amp;&amp; signPb == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (infPa &amp;&amp; signPa == '1') || (infPb &amp;&amp; signPb == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroPa &amp;&amp; zeroPb &amp;&amp; signPa == signPb then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(signPa);

        // Otherwise calculate fused sum of products and round it.
        else
            result_value = (value1_a * value2_a) + (value1_b * value2_b);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

        if !invalidop &amp;&amp; fpexc then
            <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms4.6" title="function: FPProcessDenorms4(FPType type1, FPType type2, FPType type3, FPType type4, integer N, FPCRType fpcr)">FPProcessDenorms4</a>(type1_a, type1_b, type2_a, type2_b, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdot.FPDotAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdot/FPDotAdd</h3>
      <p class="pseudocode">// FPDotAdd()
// ==========
// Half-precision 2-way dot-product and add to single-precision.

bits(N) <a id="impl-shared.FPDotAdd.6"/>FPDotAdd(bits(N) addend, bits(N DIV 2) op1_a, bits(N DIV 2) op1_b,
                 bits(N DIV 2) op2_a, bits(N DIV 2) op2_b, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N == 32;

    bits(N) prod;
    boolean isbfloat16 = FALSE;
    boolean fpexc = TRUE;     // Generate floating-point exceptions
    prod = <a href="shared_pseudocode.html#impl-shared.FPDot.7" title="function: bits(N) FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,&#13; bits(N DIV 2) op2_b, FPCRType fpcr, boolean isbfloat16, boolean fpexc)">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
    result = <a href="shared_pseudocode.html#impl-shared.FPAdd.4" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</a>(addend, prod, fpcr, fpexc);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpdot.FPDotAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpdot/FPDotAdd_ZA</h3>
      <p class="pseudocode">// FPDotAdd_ZA()
// =============
// Half-precision 2-way dot-product and add to single-precision
// for SME ZA-targeting instructions.

bits(N) <a id="impl-shared.FPDotAdd_ZA.6"/>FPDotAdd_ZA(bits(N) addend, bits(N DIV 2) op1_a, bits(N DIV 2) op1_b,
                    bits(N DIV 2) op2_a, bits(N DIV 2) op2_b, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    assert N == 32;

    bits(N) prod;
    boolean isbfloat16 = FALSE;
    boolean fpexc = FALSE;    // Do not generate floating-point exceptions
    fpcr.DN = '1';            // Generate default NaN values
    prod = <a href="shared_pseudocode.html#impl-shared.FPDot.7" title="function: bits(N) FPDot(bits(N DIV 2) op1_a, bits(N DIV 2) op1_b, bits(N DIV 2) op2_a,&#13; bits(N DIV 2) op2_b, FPCRType fpcr, boolean isbfloat16, boolean fpexc)">FPDot</a>(op1_a, op1_b, op2_a, op2_b, fpcr, isbfloat16, fpexc);
    result = <a href="shared_pseudocode.html#impl-shared.FPAdd.4" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean fpexc)">FPAdd</a>(addend, prod, fpcr, fpexc);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpexc.FPExc"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpexc/FPExc</h3>
      <p class="pseudocode">enumeration <a id="FPExc"/>FPExc       {<a id="FPExc_InvalidOp"/>FPExc_InvalidOp, <a id="FPExc_DivideByZero"/>FPExc_DivideByZero, <a id="FPExc_Overflow"/>FPExc_Overflow,
                         <a id="FPExc_Underflow"/>FPExc_Underflow, <a id="FPExc_Inexact"/>FPExc_Inexact, <a id="FPExc_InputDenorm"/>FPExc_InputDenorm};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpinfinity.FPInfinity"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpinfinity/FPInfinity</h3>
      <p class="pseudocode">// FPInfinity()
// ============

bits(N) <a id="impl-shared.FPInfinity.1"/>FPInfinity(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    bits(E) exp  = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E);
    bits(F) frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);

    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmatmul.FPMatMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmatmul/FPMatMulAdd</h3>
      <p class="pseudocode">// FPMatMulAdd()
// =============
//
// Floating point matrix multiply and add to same precision matrix
// result[2, 2] = addend[2, 2] + (op1[2, 2] * op2[2, 2])

bits(N) <a id="impl-shared.FPMatMulAdd.5"/>FPMatMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, integer esize, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N == esize * 2 * 2;
    bits(N)  result;
    bits(esize) prod0, prod1, sum;

    for i = 0 to 1
        for j = 0 to 1
            sum   = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[addend, 2*i + j, esize];
            prod0 = <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 2*i + 0, esize],
                          <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 2*j + 0, esize], fpcr);
            prod1 = <a href="shared_pseudocode.html#impl-shared.FPMul.3" title="function: bits(N) FPMul(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPMul</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 2*i + 1, esize],
                          <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 2*j + 1, esize], fpcr);
            sum   = <a href="shared_pseudocode.html#impl-shared.FPAdd.3" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPAdd</a>(sum, <a href="shared_pseudocode.html#impl-shared.FPAdd.3" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPAdd</a>(prod0, prod1, fpcr), fpcr);
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, 2*i + j, esize] = sum;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmax.FPMax"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmax/FPMax</h3>
      <p class="pseudocode">// FPMax()
// =======

bits(N) <a id="impl-shared.FPMax.3"/>FPMax(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    return <a href="shared_pseudocode.html#impl-shared.FPMax.4" title="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean altfp)">FPMax</a>(op1, op2, fpcr, altfp);

// FPMax()
// =======
// Compare two inputs and return the larger value after rounding. The
// 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative floating-point behaviour.

bits(N) <a id="impl-shared.FPMax.4"/>FPMax(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean altfp)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    if (altfp &amp;&amp; type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp;
        ((sign1 == '0' &amp;&amp; sign2 == '1') || (sign1 == '1' &amp;&amp; sign2 == '0'))) then
        return <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign2);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.7" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, altfp, TRUE);

    if !done then
        if value1 &gt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        if fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
        elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
            sign = sign1 AND sign2;         // Use most positive sign
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
                fpcr.FZ16 = '0';

            result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRound</a>(value, fpcr, rounding, TRUE);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmaxnormal.FPMaxNormal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmaxnormal/FPMaxNormal</h3>
      <p class="pseudocode">// FPMaxNormal()
// =============

bits(N) <a id="impl-shared.FPMaxNormal.1"/>FPMaxNormal(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E-1):'0';
    frac = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(F);

    return sign : exp : frac;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmaxnum.FPMaxNum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmaxnum/FPMaxNum</h3>
      <p class="pseudocode">// FPMaxNum()
// ==========

bits(N) <a id="impl-shared.FPMaxNum.3"/>FPMaxNum(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    boolean type1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean type2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as -Infinity.
        if type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op1 = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');
        elsif type1 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op2 = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');

    altfmaxfmin = FALSE;    // Restrict use of FMAX/FMIN NaN propagation rules
    result = <a href="shared_pseudocode.html#impl-shared.FPMax.4" title="function: bits(N) FPMax(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean altfp)">FPMax</a>(op1, op2, fpcr, altfmaxfmin);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmerge.IsMerging"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmerge/IsMerging</h3>
      <p class="pseudocode">// IsMerging()
// ===========
// Returns TRUE if the output elements other than the lowest are taken from
// the destination register.

boolean <a id="impl-shared.IsMerging.1"/>IsMerging(<a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean merge = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.NEP == '1';
    return merge;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmin.FPMin"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmin/FPMin</h3>
      <p class="pseudocode">// FPMin()
// =======

bits(N) <a id="impl-shared.FPMin.3"/>FPMin(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    return <a href="shared_pseudocode.html#impl-shared.FPMin.4" title="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean altfp)">FPMin</a>(op1, op2, fpcr, altfp);

// FPMin()
// =======
// Compare two operands and return the smaller operand after rounding. The
// 'fpcr' argument supplies the FPCR control bits and 'altfp' determines
// if the function should use alternative behaviour.

bits(N) <a id="impl-shared.FPMin.4"/>FPMin(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean altfp)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    if (altfp &amp;&amp; type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> &amp;&amp;
        ((sign1 == '0' &amp;&amp; sign2 == '1') || (sign1 == '1' &amp;&amp; sign2 == '0'))) then
        return <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign2);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.7" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, altfp, TRUE);

    if !done then
        if value1 &lt; value2 then
            (fptype,sign,value) = (type1,sign1,value1);
        else
            (fptype,sign,value) = (type2,sign2,value2);
        if fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
        elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
            sign = sign1 OR sign2;              // Use most negative sign
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
        else
            // The use of FPRound() covers the case where there is a trapped underflow exception
            // for a denormalized number even though the result is exact.
            rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
            if altfp then    // Denormal output is not flushed to zero
                fpcr.FZ = '0';
                fpcr.FZ16 = '0';

            result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRound</a>(value, fpcr, rounding, TRUE);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpminnum.FPMinNum"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpminnum/FPMinNum</h3>
      <p class="pseudocode">// FPMinNum()
// ==========

bits(N) <a id="impl-shared.FPMinNum.3"/>FPMinNum(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,-,-) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    boolean type1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean type2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    if !(altfp &amp;&amp; type1_nan &amp;&amp; type2_nan) then
        // Treat a single quiet-NaN as +Infinity.
        if type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op1 = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif type1 != <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
            op2 = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');

    altfmaxfmin = FALSE;    // Restrict use of FMAX/FMIN NaN propagation rules
    result = <a href="shared_pseudocode.html#impl-shared.FPMin.4" title="function: bits(N) FPMin(bits(N) op1, bits(N) op2, FPCRType fpcr, boolean altfp)">FPMin</a>(op1, op2, fpcr, altfmaxfmin);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmul.FPMul"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmul/FPMul</h3>
      <p class="pseudocode">// FPMul()
// =======

bits(N) <a id="impl-shared.FPMul.3"/>FPMul(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);
    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1 EOR sign2);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(value1*value2, fpcr);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladd.FPMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladd/FPMulAdd</h3>
      <p class="pseudocode">// FPMulAdd()
// ==========

bits(N) <a id="impl-shared.FPMulAdd.4"/>FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPMulAdd.5" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAdd</a>(addend, op1, op2, fpcr, fpexc);

// FPMulAdd()
// ==========
//
// Calculates addend + op1*op2 with a single rounding. The 'fpcr' argument
// supplies the FPCR control bits, and 'fpexc' controls the generation of
// floating-point exceptions.

bits(N) <a id="impl-shared.FPMulAdd.5"/>FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,
                 <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};

    (typeA,signA,valueA) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(addend, fpcr, fpexc);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs3.8" title="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N) op2, bits(N) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3</a>(typeA, type1, type2, addend, op1, op2, fpcr, fpexc);

    if !(<a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1') then
        if typeA == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    if !done then
        infA = (typeA == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zeroA = (typeA == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        // Determine sign and type product will have if it does not cause an
        // Invalid Operation.
        signP = sign1 EOR sign2;
        infP  = inf1 || inf2;
        zeroP = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero
        // by infinity and additions of opposite-signed infinities.
        invalidop = (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP);

        if invalidop then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(signA);

        // Otherwise calculate numerical result and round it.
        else
            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

        if !invalidop &amp;&amp; fpexc then
            <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms3.5" title="function: FPProcessDenorms3(FPType type1, FPType type2, FPType type3, integer N, FPCRType fpcr)">FPProcessDenorms3</a>(typeA, type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladd.FPMulAdd_ZA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladd/FPMulAdd_ZA</h3>
      <p class="pseudocode">// FPMulAdd_ZA()
// =============
// Calculates addend + op1*op2 with a single rounding for SME ZA-targeting
// instructions.

bits(N) <a id="impl-shared.FPMulAdd_ZA.4"/>FPMulAdd_ZA(bits(N) addend, bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = FALSE;      // Do not generate floating-point exceptions
    fpcr.DN = '1';              // Generate default NaN values
    return <a href="shared_pseudocode.html#impl-shared.FPMulAdd.5" title="function: bits(N) FPMulAdd(bits(N) addend, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAdd</a>(addend, op1, op2, fpcr, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladdh.FPMulAddH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladdh/FPMulAddH</h3>
      <p class="pseudocode">// FPMulAddH()
// ===========
// Calculates addend + op1*op2.

bits(N) <a id="impl-shared.FPMulAddH.4"/>FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;       // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPMulAddH.5" title="function: bits(N) FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2,&#13; FPCRType fpcr, boolean fpexc)">FPMulAddH</a>(addend, op1, op2, fpcr, fpexc);

// FPMulAddH()
// ===========
// Calculates addend + op1*op2.

bits(N) <a id="impl-shared.FPMulAddH.5"/>FPMulAddH(bits(N) addend, bits(N DIV 2) op1, bits(N DIV 2) op2,
                  <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N == 32;
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    (typeA,signA,valueA) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(addend, fpcr, fpexc);
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op1, fpcr, fpexc);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op2, fpcr, fpexc);
    inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
    inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs3H.8" title="function: (boolean, bits(N)) FPProcessNaNs3H(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3H</a>(typeA, type1, type2, addend, op1, op2, fpcr, fpexc);

    if !(<a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1') then
        if typeA == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> &amp;&amp; ((inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2)) then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    if !done then
        infA = (typeA == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>); zeroA = (typeA == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        // Determine sign and type product will have if it does not cause an
        // Invalid Operation.
        signP = sign1 EOR sign2;
        infP = inf1 || inf2;
        zeroP = zero1 || zero2;

        // Non SNaN-generated Invalid Operation cases are multiplies of zero by infinity and
        // additions of opposite-signed infinities.
        invalidop = (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) || (infA &amp;&amp; infP &amp;&amp; signA != signP);

        if invalidop then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

        // Other cases involving infinities produce an infinity of the same sign.
        elsif (infA &amp;&amp; signA == '0') || (infP &amp;&amp; signP == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (infA &amp;&amp; signA == '1') || (infP &amp;&amp; signP == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');

        // Cases where the result is exactly zero and its sign is not determined by the
        // rounding mode are additions of same-signed zeros.
        elsif zeroA &amp;&amp; zeroP &amp;&amp; signA == signP then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(signA);

        // Otherwise calculate numerical result and round it.
        else
            result_value = valueA + (value1 * value2);
            if result_value == 0.0 then // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.4" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding, boolean fpexc)">FPRound</a>(result_value, fpcr, rounding, fpexc);

        if !invalidop &amp;&amp; fpexc then
            <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(typeA, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmuladdh.FPProcessNaNs3H"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmuladdh/FPProcessNaNs3H</h3>
      <p class="pseudocode">// FPProcessNaNs3H()
// =================

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs3H.8"/>FPProcessNaNs3H(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3,
                                   bits(N) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,
                                   <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {32,64};

    bits(N) result;
    // When TRUE, use alternative NaN propagation rules.
    boolean altfp   = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean op1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op3_nan = type3 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    if altfp then
        if (type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type3 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>) then
            type_nan = <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
        else
            type_nan = <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>;

    if altfp &amp;&amp; op1_nan &amp;&amp; op2_nan &amp;&amp; op3_nan then          // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc));
    elsif altfp &amp;&amp; op2_nan &amp;&amp; (op1_nan || op3_nan) then     // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc));
    elsif altfp &amp;&amp; op3_nan &amp;&amp; op1_nan then                  // &lt;m&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op3, fpcr, fpexc));
    elsif type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc));
    elsif type3 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc));
    elsif type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc));
    elsif type3 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE; result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc));
    else
        done = FALSE; result = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>(); // 'Don't care' result
    return (done, result);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpmulx.FPMulX"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpmulx/FPMulX</h3>
      <p class="pseudocode">// FPMulX()
// ========

bits(N) <a id="impl-shared.FPMulX.3"/>FPMulX(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    bits(N) result;
    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if (inf1 &amp;&amp; zero2) || (zero1 &amp;&amp; inf2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPTwo.1" title="function: bits(N) FPTwo(bit sign)">FPTwo</a>(sign1 EOR sign2);
        elsif inf1 || inf2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign1 EOR sign2);
        elsif zero1 || zero2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1 EOR sign2);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(value1*value2, fpcr);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpneg.FPNeg"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpneg/FPNeg</h3>
      <p class="pseudocode">// FPNeg()
// =======

bits(N) <a id="impl-shared.FPNeg.1"/>FPNeg(bits(N) op)

    assert N IN {16,32,64};
    if !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() then
        <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr = FPCR[];
        if fpcr.AH == '1' then
            (fptype, -, -) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op, fpcr, FALSE);
            if fptype IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>} then

                return op;        // When fpcr.AH=1, sign of NaN has no consequence

    return NOT(op&lt;N-1&gt;) : op&lt;N-2:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fponepointfive.FPOnePointFive"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fponepointfive/FPOnePointFive</h3>
      <p class="pseudocode">// FPOnePointFive()
// ================

bits(N) <a id="impl-shared.FPOnePointFive.1"/>FPOnePointFive(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '0':<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(E-1);
    frac = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F-1);
    result = sign : exp : frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorm</h3>
      <p class="pseudocode">// FPProcessDenorm()
// =================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<a id="impl-shared.FPProcessDenorm.3"/>FPProcessDenorm(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype, integer N, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; fptype == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorms"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorms</h3>
      <p class="pseudocode">// FPProcessDenorms()
// ==================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<a id="impl-shared.FPProcessDenorms.4"/>FPProcessDenorms(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, integer N, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type2 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>) then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorms3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorms3</h3>
      <p class="pseudocode">// FPProcessDenorms3()
// ===================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<a id="impl-shared.FPProcessDenorms3.5"/>FPProcessDenorms3(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3, integer N, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type2 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> ||
        type3 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>) then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessdenorms.FPProcessDenorms4"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessdenorms/FPProcessDenorms4</h3>
      <p class="pseudocode">// FPProcessDenorms4()
// ===================
// Handles denormal input in case of single-precision or double-precision
// when using alternative floating-point mode.

<a id="impl-shared.FPProcessDenorms4.6"/>FPProcessDenorms4(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type4, integer N, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp &amp;&amp; N != 16 &amp;&amp; (type1 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type2 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> ||
        type3 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a> || type4 == <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>) then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessexception.FPProcessException"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessexception/FPProcessException</h3>
      <p class="pseudocode">// FPProcessException()
// ====================
//
// The 'fpcr' argument supplies FPCR control bits. Status information is
// updated directly in the FPSR where appropriate.

<a id="impl-shared.FPProcessException.2"/>FPProcessException(<a href="shared_pseudocode.html#FPExc" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc</a> exception, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    // Determine the cumulative exception bit number
    case exception of
        when <a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>     cumul = 0;
        when <a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>  cumul = 1;
        when <a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Overflow</a>      cumul = 2;
        when <a href="shared_pseudocode.html#FPExc_Underflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Underflow</a>     cumul = 3;
        when <a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>       cumul = 4;
        when <a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>   cumul = 7;
    enable = cumul + 8;
    if fpcr&lt;enable&gt; == '1' then
        // Trapping of the exception enabled.
        // It is IMPLEMENTATION DEFINED whether the enable bit may be set at all,
        // and if so then how exceptions and in what order that they may be
        // accumulated before calling FPTrappedException().
        bits(8) accumulated_exceptions = <a href="shared_pseudocode.html#impl-shared.GetAccumulatedFPExceptions.0" title="function: bits(8) GetAccumulatedFPExceptions()">GetAccumulatedFPExceptions</a>();
        accumulated_exceptions&lt;cumul&gt; = '1';
        if boolean IMPLEMENTATION_DEFINED "Process floating-point exception" then
            if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
                <a href="shared_pseudocode.html#AArch32.FPTrappedException.1" title="function: AArch32.FPTrappedException(bits(8) accumulated_exceptions)">AArch32.FPTrappedException</a>(accumulated_exceptions);
            else
                is_ase = <a href="shared_pseudocode.html#impl-shared.IsASEInstruction.0" title="function: boolean IsASEInstruction()">IsASEInstruction</a>();
                <a href="shared_pseudocode.html#AArch64.FPTrappedException.2" title="function: AArch64.FPTrappedException(boolean is_ase, bits(8) accumulated_exceptions)">AArch64.FPTrappedException</a>(is_ase, accumulated_exceptions);
        else
            // The exceptions generated by this instruction are accumulated by the PE and
            // FPTrappedException is called later during its execution, before the next
            // instruction is executed. This field is cleared at the start of each FP instruction.
            <a href="shared_pseudocode.html#impl-shared.SetAccumulatedFPExceptions.1" title="function: SetAccumulatedFPExceptions(bits(8) accumulated_exceptions)">SetAccumulatedFPExceptions</a>(accumulated_exceptions);
    elsif <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        // Set the cumulative exception bit
        FPSCR&lt;cumul&gt; = '1';
    else
        // Set the cumulative exception bit
        FPSR&lt;cumul&gt; = '1';

    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnan.FPProcessNaN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnan/FPProcessNaN</h3>
      <p class="pseudocode">// FPProcessNaN()
// ==============

bits(N) <a id="impl-shared.FPProcessNaN.3"/>FPProcessNaN(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype, bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, op, fpcr, fpexc);

// FPProcessNaN()
// ==============
// Handle NaN input operands, returning the operand or default NaN value
// if fpcr.DN is selected. The 'fpcr' argument supplies the FPCR control bits.
// The 'fpexc' argument controls the generation of exceptions, regardless of
// whether 'fptype' is a signalling NaN or a quiet NaN.

bits(N) <a id="impl-shared.FPProcessNaN.4"/>FPProcessNaN(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> fptype, bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    assert fptype IN {<a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>};

    case N of
        when 16 topfrac =  9;
        when 32 topfrac = 22;
        when 64 topfrac = 51;

    result = op;
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        result&lt;topfrac&gt; = '1';
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    if fpcr.DN == '1' then  // DefaultNaN requested
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnans.FPProcessNaNs"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnans/FPProcessNaNs</h3>
      <p class="pseudocode">// FPProcessNaNs()
// ===============

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs.5"/>FPProcessNaNs(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, bits(N) op1,
                                 bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean altfmaxfmin = FALSE;    // Do not use alfp mode for FMIN, FMAX and variants
    boolean fpexc       = TRUE;     // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.7" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1, bits(N) op2,&#13; FPCRType fpcr, boolean altfmaxfmin, boolean fpexc)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr, altfmaxfmin, fpexc);

// FPProcessNaNs()
// ===============
//
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits and 'altfmaxfmin' controls
// alternative floating-point behaviour for FMAX, FMIN and variants. 'fpexc'
// controls the generation of floating-point exceptions. Status information
// is updated directly in the FPSR where appropriate.

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs.7"/>FPProcessNaNs(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, bits(N) op1, bits(N) op2,
                                 <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean altfmaxfmin, boolean fpexc)

    assert N IN {16,32,64};
    boolean altfp    = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean op1_nan  = type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op2_nan  = type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean any_snan = type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
    <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a>  type_nan = if any_snan then <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> else <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>;

    if altfmaxfmin &amp;&amp; (op1_nan || op2_nan) then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        done = TRUE; sign2 = op2&lt;N-1&gt;;
        result = if type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign2) else op2;
    elsif altfp &amp;&amp; op1_nan &amp;&amp; op2_nan then
        // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op1, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    else
        done = FALSE;  result = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();  // 'Don't care' result

    return (done, result);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnans3.FPProcessNaNs3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnans3/FPProcessNaNs3</h3>
      <p class="pseudocode">// FPProcessNaNs3()
// ================

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs3.7"/>FPProcessNaNs3(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3,
                                  bits(N) op1, bits(N) op2, bits(N) op3,
                                  <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs3.8" title="function: (boolean, bits(N)) FPProcessNaNs3(FPType type1, FPType type2, FPType type3,&#13; bits(N) op1, bits(N) op2, bits(N) op3,&#13; FPCRType fpcr, boolean fpexc)">FPProcessNaNs3</a>(type1, type2, type3, op1, op2, op3, fpcr, fpexc);

// FPProcessNaNs3()
// ================
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate.

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs3.8"/>FPProcessNaNs3(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3,
                                  bits(N) op1, bits(N) op2, bits(N) op3,
                                  <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N IN {16,32,64};
    boolean op1_nan = type1 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op2_nan = type2 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};
    boolean op3_nan = type3 IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>};

    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    if altfp then
        if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || type3 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
            type_nan = <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
        else
            type_nan = <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>;

    if altfp &amp;&amp; op1_nan &amp;&amp; op2_nan &amp;&amp; op3_nan then
        // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc);
    elsif altfp &amp;&amp; op2_nan &amp;&amp; (op1_nan || op3_nan) then
        // &lt;n&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op2, fpcr, fpexc);
    elsif altfp &amp;&amp; op3_nan &amp;&amp; op1_nan then
        // &lt;m&gt; register NaN selected
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type_nan, op3, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    elsif type3 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc);
    elsif type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc);
    elsif type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc);
    elsif type3 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc);
    else
        done = FALSE;  result = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();  // 'Don't care' result

    return (done, result);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpprocessnans4.FPProcessNaNs4"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpprocessnans4/FPProcessNaNs4</h3>
      <p class="pseudocode">// FPProcessNaNs4()
// ================
// The boolean part of the return value says whether a NaN has been found and
// processed. The bits(N) part is only relevant if it has and supplies the
// result of the operation.
//
// The 'fpcr' argument supplies FPCR control bits.
// Status information is updated directly in the FPSR where appropriate.
// The 'fpexc' controls the generation of floating-point exceptions.

(boolean, bits(N)) <a id="impl-shared.FPProcessNaNs4.10"/>FPProcessNaNs4(<a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type1, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type2, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type3, <a href="shared_pseudocode.html#FPType" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType</a> type4,
                                  bits(N DIV 2) op1, bits(N DIV 2) op2, bits(N DIV 2) op3,
                                  bits(N DIV 2) op4, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)

    assert N == 32;

    bits(N) result;
    // The FPCR.AH control does not affect these checks
    if type1 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc));
    elsif type2 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc));
    elsif type3 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc));
    elsif type4 == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type4, op4, fpcr, fpexc));
    elsif type1 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type1, op1, fpcr, fpexc));
    elsif type2 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type2, op2, fpcr, fpexc));
    elsif type3 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type3, op3, fpcr, fpexc));
    elsif type4 == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        done = TRUE;  result = <a href="shared_pseudocode.html#impl-shared.FPConvertNaN.1" title="function: bits(M) FPConvertNaN(bits(N) op)">FPConvertNaN</a>(<a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(type4, op4, fpcr, fpexc));
    else
        done = FALSE;  result = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();  // 'Don't care' result

    return (done, result);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprecipestimate.FPRecipEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprecipestimate/FPRecipEstimate</h3>
      <p class="pseudocode">// FPRecipEstimate()
// =================

bits(N) <a id="impl-shared.FPRecipEstimate.2"/>FPRecipEstimate(bits(N) operand, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    // When using alternative floating-point behaviour, do not generate
    // floating-point exceptions, flush denormal input and output to zero,
    // and use RNE rounding mode.
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';
    if altfp then fpcr.RMode    = '00';

    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(operand, fpcr, fpexc);

    <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, operand, fpcr, fpexc);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>, fpcr);
    elsif (
            (N == 16 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &lt; 2.0^-16) ||
            (N == 32 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &lt; 2.0^-128) ||
            (N == 64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &lt; 2.0^-1024)
          ) then
        case rounding of
            when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                overflow_to_inf = TRUE;
            when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                overflow_to_inf = (sign == '0');
            when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                overflow_to_inf = (sign == '1');
            when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
                overflow_to_inf = FALSE;
        result = if overflow_to_inf then <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign) else <a href="shared_pseudocode.html#impl-shared.FPMaxNormal.1" title="function: bits(N) FPMaxNormal(bit sign)">FPMaxNormal</a>(sign);
        if fpexc then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Overflow</a>, fpcr);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);
    elsif ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16))
          &amp;&amp; (
               (N == 16 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &gt;= 2.0^14) ||
               (N == 32 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &gt;= 2.0^126) ||
               (N == 64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.Abs.1" title="function: integer Abs(integer x)">Abs</a>(value) &gt;= 2.0^1022)
             ) then
        // Result flushed to zero of correct sign
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);

        // Flush-to-zero never generates a trapped exception.
        if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            FPSCR.UFC = '1';
        else
            if fpexc then FPSR.UFC = '1';
    else
        // Scale to a fixed point value in the range 0.5 &lt;= x &lt; 1.0 in steps of 1/512, and
        // calculate result exponent. Scaled value has copied sign bit,
        // exponent = 1022 = double-precision biased version of -1,
        // fraction = original fraction
        case N of
            when 16
                fraction = operand&lt;9:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(42);
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;14:10&gt;);
            when 32
                fraction = operand&lt;22:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(29);
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;30:23&gt;);
            when 64
                fraction = operand&lt;51:0&gt;;
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;62:52&gt;);

        if exp == 0 then
            if fraction&lt;51&gt; == '0' then
                exp = -1;
                fraction = fraction&lt;49:0&gt;:'00';
            else
                fraction = fraction&lt;50:0&gt;:'0';

        integer scaled;
        boolean increasedprecision = N==32 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatRPRES.0" title="function: boolean HaveFeatRPRES()">HaveFeatRPRES</a>() &amp;&amp; altfp;

        if !increasedprecision then
            scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:44&gt;);
        else
            scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:41&gt;);

        case N of
            when 16 result_exp =   29 - exp; // In range 29-30 = -1 to 29+1 = 30
            when 32 result_exp =  253 - exp; // In range 253-254 = -1 to 253+1 = 254
            when 64 result_exp = 2045 - exp; // In range 2045-2046 = -1 to 2045+1 = 2046

        // Scaled is in range 256 .. 511 or 2048 .. 4095 range representing a
        // fixed-point number in range [0.5 .. 1.0].
        estimate = <a href="shared_pseudocode.html#impl-shared.RecipEstimate.2" title="function: integer RecipEstimate(integer a, boolean increasedprecision)">RecipEstimate</a>(scaled, increasedprecision);

        // Estimate is in the range 256 .. 511 or 4096 .. 8191 representing a
        // fixed-point result in the range [1.0 .. 2.0].
        // Convert to scaled floating point result with copied sign bit,
        // high-order bits from estimate, and exponent calculated above.
        if !increasedprecision then
            fraction = estimate&lt;7:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(44);
        else
            fraction = estimate&lt;11:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(40);

        if result_exp == 0 then
            fraction = '1' : fraction&lt;51:1&gt;;
        elsif result_exp == -1 then
            fraction = '01' : fraction&lt;51:2&gt;;
            result_exp = 0;

        case N of
            when 16 result = sign : result_exp&lt;N-12:0&gt; : fraction&lt;51:42&gt;;
            when 32 result = sign : result_exp&lt;N-25:0&gt; : fraction&lt;51:29&gt;;
            when 64 result = sign : result_exp&lt;N-54:0&gt; : fraction&lt;51:0&gt;;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprecipestimate.RecipEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprecipestimate/RecipEstimate</h3>
      <p class="pseudocode">// RecipEstimate()
// ===============
// Compute estimate of reciprocal of 9-bit fixed-point number.
//
// a is in range 256 .. 511 or 2048 .. 4096 representing a number in
// the range 0.5 &lt;= x &lt; 1.0.
// increasedprecision determines if the mantissa is 8-bit or 12-bit.
// result is in the range 256 .. 511 or 4096 .. 8191 representing a
// number in the range 1.0 to 511/256 or 1.00 to 8191/4096.

integer <a id="impl-shared.RecipEstimate.2"/>RecipEstimate(integer a, boolean increasedprecision)

    integer r;
    if !increasedprecision then
        assert 256 &lt;= a &amp;&amp; a &lt; 512;
        a = a*2+1;                       // Round to nearest
        integer b = (2 ^ 19) DIV a;
        r = (b+1) DIV 2;                 // Round to nearest
        assert 256 &lt;= r &amp;&amp; r &lt; 512;
    else
        assert 2048 &lt;= a &amp;&amp; a &lt; 4096;
        a = a*2+1;                       // Round to nearest
        real real_val = Real(2^25)/Real(a);
        r = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(real_val);
        real error = real_val - Real(r);
        boolean round_up = error &gt; 0.5;  // Error cannot be exactly 0.5 so do not need tie case
        if round_up then r = r+1;
        assert 4096 &lt;= r &amp;&amp; r &lt; 8192;

    return r;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprecpx.FPRecpX"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprecpx/FPRecpX</h3>
      <p class="pseudocode">// FPRecpX()
// =========

bits(N) <a id="impl-shared.FPRecpX.2"/>FPRecpX(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};

    case N of
        when 16 esize =  5;
        when 32 esize =  8;
        when 64 esize = 11;

    bits(N)           result;
    bits(esize)       exp;
    bits(esize)       max_exp;
    bits(N-(esize+1)) frac = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();

    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;                 // Generate no floating-point exceptions
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';     // Flush denormal input and output to zero
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    case N of
        when 16 exp = op&lt;10+esize-1:10&gt;;
        when 32 exp = op&lt;23+esize-1:23&gt;;
        when 64 exp = op&lt;52+esize-1:52&gt;;

    max_exp = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(esize) - 1;

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, op, fpcr, fpexc);
    else
        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(exp) then                 // Zero and denormals
            result = sign:max_exp:frac;
        else                                // Infinities and normals
            result = sign:NOT(exp):frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpround.FPRound"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpround/FPRound</h3>
      <p class="pseudocode">// FPRound()
// =========
// Used by data processing and int/fixed &lt;-&gt; FP conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.

bits(N) <a id="impl-shared.FPRound.3"/>FPRound(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)
    fpcr.AHP = '0';
    boolean fpexc = TRUE;    // Generate floating-point exceptions
    boolean isbfloat16  = FALSE;
    return <a href="shared_pseudocode.html#impl-shared.FPRoundBase.5" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc);

// FPRound()
// =========
// Used by data processing and int/fixed &lt;-&gt; FP conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.
//
// The 'fpcr' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate.

bits(N) <a id="impl-shared.FPRound.4"/>FPRound(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean fpexc)
    fpcr.AHP = '0';
    boolean isbfloat16 = FALSE;
    return <a href="shared_pseudocode.html#impl-shared.FPRoundBase.5" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc);

// FPRound()
// =========

bits(N) <a id="impl-shared.FPRound.2"/>FPRound(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    return <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)">FPRound</a>(op, fpcr, <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr));</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpround.FPRoundBase"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpround/FPRoundBase</h3>
      <p class="pseudocode">// FPRoundBase()
// =============

bits(N) <a id="impl-shared.FPRoundBase.4"/>FPRoundBase(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean isbfloat16)
    boolean fpexc = TRUE;    // Generate floating-point exceptions
    return <a href="shared_pseudocode.html#impl-shared.FPRoundBase.5" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc);

// FPRoundBase()
// =============
// Convert a real number OP into an N-bit floating-point value using the
// supplied rounding mode RMODE.
//
// The 'fpcr' argument supplies FPCR control bits and 'fpexc' controls the
// generation of floating-point exceptions. Status information is updated
// directly in the FPSR where appropriate.

bits(N) <a id="impl-shared.FPRoundBase.5"/>FPRoundBase(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding,
                    boolean isbfloat16, boolean fpexc)

    assert N IN {16,32,64};
    assert op != 0.0;
    assert rounding != <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>;
    bits(N) result;

    // Obtain format parameters - minimum exponent, numbers of exponent and fraction bits.
    if N == 16 then
        minimum_exp = -14;  E = 5;  F = 10;
    elsif N == 32 &amp;&amp; isbfloat16 then
        minimum_exp = -126;  E = 8;  F = 7;
    elsif N == 32 then
        minimum_exp = -126;  E = 8;  F = 23;
    else  // N == 64
        minimum_exp = -1022;  E = 11;  F = 52;

    // Split value into sign, unrounded mantissa and exponent.
    if op &lt; 0.0 then
        sign = '1';  mantissa = -op;
    else
        sign = '0';  mantissa = op;
    exponent = 0;
    while mantissa &lt; 1.0 do
        mantissa = mantissa * 2.0;  exponent = exponent - 1;
    while mantissa &gt;= 2.0 do
        mantissa = mantissa / 2.0;  exponent = exponent + 1;

    // When TRUE, detection of underflow occurs after rounding and the test for a
    // denormalized number for single and double precision values occurs after rounding.
    altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';

    // Deal with flush-to-zero before rounding if FPCR.AH != '1'.
    if (!altfp &amp;&amp; ((fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16)) &amp;&amp;
        exponent &lt; minimum_exp) then
        // Flush-to-zero never generates a trapped exception.
        if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
            FPSCR.UFC = '1';
        else
            if fpexc then FPSR.UFC = '1';
        return <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);

    biased_exp_unconstrained = exponent - minimum_exp + 1;
    int_mant_unconstrained = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(mantissa * 2.0^F);
    error_unconstrained = mantissa * 2.0^F - Real(int_mant_unconstrained);

    // Start creating the exponent value for the result. Start by biasing the actual exponent
    // so that the minimum exponent becomes 1, lower values 0 (indicating possible underflow).
    biased_exp = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>(exponent - minimum_exp + 1, 0);
    if biased_exp == 0 then mantissa = mantissa / 2.0^(minimum_exp - exponent);

    // Get the unrounded mantissa as an integer, and the "units in last place" rounding error.
    int_mant = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(mantissa * 2.0^F);  // &lt; 2.0^F if biased_exp == 0, &gt;= 2.0^F if not
    error = mantissa * 2.0^F - Real(int_mant);

    // Underflow occurs if exponent is too small before rounding, and result is inexact or
    // the Underflow exception is trapped. This applies before rounding if FPCR.AH != '1'.
    if !altfp &amp;&amp; biased_exp == 0 &amp;&amp; (error != 0.0 || fpcr.UFE == '1') then
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Underflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Underflow</a>, fpcr);

    // Round result according to rounding mode.
    if altfp then
        case rounding of
            when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up_unconstrained = (error_unconstrained &gt; 0.5 ||
                   (error_unconstrained == 0.5 &amp;&amp; int_mant_unconstrained&lt;0&gt; == '1'));
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_mant&lt;0&gt; == '1'));
                overflow_to_inf = TRUE;
            when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up_unconstrained = (error_unconstrained != 0.0 &amp;&amp; sign == '0');
                round_up = (error != 0.0 &amp;&amp; sign == '0');
                overflow_to_inf = (sign == '0');
            when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up_unconstrained = (error_unconstrained != 0.0 &amp;&amp; sign == '1');
                round_up = (error != 0.0 &amp;&amp; sign == '1');
                overflow_to_inf = (sign == '1');
            when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>, <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>
                round_up_unconstrained = FALSE;
                round_up = FALSE;
                overflow_to_inf = FALSE;

        if round_up_unconstrained then
            int_mant_unconstrained = int_mant_unconstrained + 1;
            if int_mant_unconstrained == 2^(F+1) then    // Rounded up to next exponent
                biased_exp_unconstrained = biased_exp_unconstrained + 1;
                int_mant_unconstrained   = int_mant_unconstrained DIV 2;

        // Deal with flush-to-zero and underflow after rounding if FPCR.AH == '1'.
        if biased_exp_unconstrained &lt; 1 &amp;&amp; int_mant_unconstrained != 0 then
            // the result of unconstrained rounding is less than the minimum normalized number
            if (fpcr.FZ == '1' &amp;&amp; N != 16) || (fpcr.FZ16 == '1' &amp;&amp; N == 16) then   // Flush-to-zero
                if fpexc then
                    FPSR.UFC = '1';
                    <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);
                return <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
            elsif error != 0.0 || fpcr.UFE == '1' then
                if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Underflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Underflow</a>, fpcr);
    else    // altfp == FALSE
        case rounding of
            when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_mant&lt;0&gt; == '1'));
                overflow_to_inf = TRUE;
            when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up = (error != 0.0 &amp;&amp; sign == '0');
                overflow_to_inf = (sign == '0');
            when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up = (error != 0.0 &amp;&amp; sign == '1');
                overflow_to_inf = (sign == '1');
            when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>, <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>
                round_up = FALSE;
                overflow_to_inf = FALSE;

    if round_up then
        int_mant = int_mant + 1;
        if int_mant == 2^F then      // Rounded up from denormalized to normalized
            biased_exp = 1;
        if int_mant == 2^(F+1) then  // Rounded up to next exponent
            biased_exp = biased_exp + 1;
            int_mant = int_mant DIV 2;

    // Handle rounding to odd
    if error != 0.0 &amp;&amp; rounding == <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a> then
        int_mant&lt;0&gt; = '1';

    // Deal with overflow and generate result.
    if N != 16 || fpcr.AHP == '0' then  // Single, double or IEEE half precision
        if biased_exp &gt;= 2^E - 1 then
            result = if overflow_to_inf then <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign) else <a href="shared_pseudocode.html#impl-shared.FPMaxNormal.1" title="function: bits(N) FPMaxNormal(bit sign)">FPMaxNormal</a>(sign);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Overflow" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Overflow</a>, fpcr);
            error = 1.0;  // Ensure that an Inexact exception occurs
        else
            result = sign : biased_exp&lt;E-1:0&gt; : int_mant&lt;F-1:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-(E+F+1));
    else                                     // Alternative half precision
        if biased_exp &gt;= 2^E then
            result = sign : <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(N-1);
            if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
            error = 0.0;  // Ensure that an Inexact exception does not occur
        else
            result = sign : biased_exp&lt;E-1:0&gt; : int_mant&lt;F-1:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-(E+F+1));

    // Deal with Inexact exception.
    if error != 0.0 then
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpround.FPRoundCV"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpround/FPRoundCV</h3>
      <p class="pseudocode">// FPRoundCV()
// ===========
// Used for FP &lt;-&gt; FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.

bits(N) <a id="impl-shared.FPRoundCV.3"/>FPRoundCV(real op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)
    fpcr.FZ16 = '0';
    boolean fpexc = TRUE;    // Generate floating-point exceptions
    boolean isbfloat16 = FALSE;
    return <a href="shared_pseudocode.html#impl-shared.FPRoundBase.5" title="function: bits(N) FPRoundBase(real op, FPCRType fpcr, FPRounding rounding,&#13; boolean isbfloat16, boolean fpexc)">FPRoundBase</a>(op, fpcr, rounding, isbfloat16, fpexc);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprounding.FPRounding"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprounding/FPRounding</h3>
      <p class="pseudocode">enumeration <a id="FPRounding"/>FPRounding  {<a id="FPRounding_TIEEVEN"/>FPRounding_TIEEVEN, <a id="FPRounding_POSINF"/>FPRounding_POSINF,
                         <a id="FPRounding_NEGINF"/>FPRounding_NEGINF,  <a id="FPRounding_ZERO"/>FPRounding_ZERO,
                         <a id="FPRounding_TIEAWAY"/>FPRounding_TIEAWAY, <a id="FPRounding_ODD"/>FPRounding_ODD};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fproundingmode.FPRoundingMode"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fproundingmode/FPRoundingMode</h3>
      <p class="pseudocode">// FPRoundingMode()
// ================
// Return the current floating-point rounding mode.

FPRounding <a id="impl-shared.FPRoundingMode.1"/>FPRoundingMode(<a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    return <a href="shared_pseudocode.html#impl-shared.FPDecodeRounding.1" title="function: FPRounding FPDecodeRounding(bits(2) rmode)">FPDecodeRounding</a>(fpcr.RMode);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fproundint.FPRoundInt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fproundint/FPRoundInt</h3>
      <p class="pseudocode">// FPRoundInt()
// ============

// Round op to nearest integral floating point value using rounding mode in FPCR/FPSCR.
// If EXACT is TRUE, set FPSR.IXC if result is not numerically equal to op.

bits(N) <a id="impl-shared.FPRoundInt.4"/>FPRoundInt(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, boolean exact)

    assert rounding != <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;
    assert N IN {16,32,64};

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    fpexc = !altfp;

    // Unpack using FPCR to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr)">FPProcessNaN</a>(fptype, op, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    else
        // Extract integer component.
        int_result = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(value);
        error = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment.
        case rounding of
            when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0&gt; == '1'));
            when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up = (error != 0.0);
            when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up = FALSE;
            when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
                round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
            when <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>
                round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0));

        if round_up then int_result = int_result + 1;

        // Convert integer value into an equivalent real value.
        real_result = Real(int_result);

        // Re-encode as a floating-point value, result is always exact.
        if real_result == 0.0 then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
        else
            result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)">FPRound</a>(real_result, fpcr, <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>);

        // Generate inexact exceptions.
        if error != 0.0 &amp;&amp; exact then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fproundintn.FPRoundIntN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fproundintn/FPRoundIntN</h3>
      <p class="pseudocode">// FPRoundIntN()
// =============

bits(N) <a id="impl-shared.FPRoundIntN.4"/>FPRoundIntN(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding, integer intsize)
    assert rounding != <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;
    assert N IN {32,64};
    assert intsize IN {32, 64};
    integer exp;
    constant integer E = (if N == 32 then 8 else 11);
    constant integer F = N - (E + 1);

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    fpexc = !altfp;

    // Unpack using FPCR to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    if fptype IN {<a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>, <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a>, <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>} then
        if N == 32 then
            exp = 126 + intsize;
            result = '1':exp&lt;(E-1):0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
        else
            exp = 1022+intsize;
            result = '1':exp&lt;(E-1):0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    else
        // Extract integer component.
        int_result = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(value);
        error = value - Real(int_result);

        // Determine whether supplied rounding mode requires an increment.
        case rounding of
            when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
                round_up = error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0&gt; == '1');
            when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
                round_up = error != 0.0;
            when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
                round_up = FALSE;
            when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
                round_up = error != 0.0 &amp;&amp; int_result &lt; 0;
            when <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>
                round_up = error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0);

        if round_up then int_result = int_result + 1;
        overflow = int_result &gt; 2^(intsize-1)-1 || int_result &lt; -1*2^(intsize-1);

        if overflow then
            if N == 32 then
                exp = 126 + intsize;
                result = '1':exp&lt;(E-1):0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
            else
                exp = 1022 + intsize;
                result = '1':exp&lt;(E-1):0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
            // This case shouldn't set Inexact.
            error = 0.0;

        else
            // Convert integer value into an equivalent real value.
            real_result = Real(int_result);

            // Re-encode as a floating-point value, result is always exact.
            if real_result == 0.0 then
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)">FPRound</a>(real_result, fpcr, <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>);

        // Generate inexact exceptions.
        if error != 0.0 then
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprsqrtestimate.FPRSqrtEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprsqrtestimate/FPRSqrtEstimate</h3>
      <p class="pseudocode">// FPRSqrtEstimate()
// =================

bits(N) <a id="impl-shared.FPRSqrtEstimate.2"/>FPRSqrtEstimate(bits(N) operand, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};

    // When using alternative floating-point behaviour, do not generate
    // floating-point exceptions and flush denormal input to zero.
    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    boolean fpexc = !altfp;
    if altfp then fpcr.&lt;FIZ,FZ&gt; = '11';

    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(operand, fpcr, fpexc);

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.4" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr, boolean fpexc)">FPProcessNaN</a>(fptype, operand, fpcr, fpexc);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_DivideByZero" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_DivideByZero</a>, fpcr);
    elsif sign == '1' then
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>('0');
    else
        // Scale to a fixed-point value in the range 0.25 &lt;= x &lt; 1.0 in steps of 512, with the
        // evenness or oddness of the exponent unchanged, and calculate result exponent.
        // Scaled value has copied sign bit, exponent = 1022 or 1021 = double-precision
        // biased version of -1 or -2, fraction = original fraction extended with zeros.

        case N of
            when 16
                fraction = operand&lt;9:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(42);
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;14:10&gt;);
            when 32
                fraction = operand&lt;22:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(29);
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;30:23&gt;);
            when 64
                fraction = operand&lt;51:0&gt;;
                exp = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;62:52&gt;);

        if exp == 0 then
            while fraction&lt;51&gt; == '0' do
                fraction = fraction&lt;50:0&gt; : '0';
                exp = exp - 1;
            fraction = fraction&lt;50:0&gt; : '0';

        integer scaled;
        boolean increasedprecision = N==32 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatRPRES.0" title="function: boolean HaveFeatRPRES()">HaveFeatRPRES</a>() &amp;&amp; altfp;

        if !increasedprecision then
            if exp&lt;0&gt; == '0' then
                scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:44&gt;);
            else
                scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('01':fraction&lt;51:45&gt;);
        else
            if exp&lt;0&gt; == '0' then
                scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('1':fraction&lt;51:41&gt;);
            else
                scaled = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('01':fraction&lt;51:42&gt;);

        case N of
            when 16 result_exp = (  44 - exp) DIV 2;
            when 32 result_exp = ( 380 - exp) DIV 2;
            when 64 result_exp = (3068 - exp) DIV 2;

        estimate = <a href="shared_pseudocode.html#impl-shared.RecipSqrtEstimate.2" title="function: integer RecipSqrtEstimate(integer a, boolean increasedprecision)">RecipSqrtEstimate</a>(scaled, increasedprecision);

        // Estimate is in the range 256 .. 511 or 4096 .. 8191 representing a
        // fixed-point result in the range [1.0 .. 2.0].
        // Convert to scaled floating point result with copied sign bit and high-order
        // fraction bits, and exponent calculated above.
        case N of
            when 16 result = '0' : result_exp&lt;N-12:0&gt; : estimate&lt;7:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(2);
            when 32
                if !increasedprecision then
                    result = '0' : result_exp&lt;N-25:0&gt; : estimate&lt;7:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(15);
                else
                    result = '0' : result_exp&lt;N-25:0&gt; : estimate&lt;11:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(11);
            when 64 result = '0' : result_exp&lt;N-54:0&gt; : estimate&lt;7:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(44);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fprsqrtestimate.RecipSqrtEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fprsqrtestimate/RecipSqrtEstimate</h3>
      <p class="pseudocode">// RecipSqrtEstimate()
// ===================
// Compute estimate of reciprocal square root of 9-bit fixed-point number.
//
// a is in range 128 .. 511 or 1024 .. 4095, with increased precision,
// representing a number in the range 0.25 &lt;= x &lt; 1.0.
// increasedprecision determines if the mantissa is 8-bit or 12-bit.
// result is in the range 256 .. 511 or 4096 .. 8191, with increased precision,
// representing a number in the range 1.0 to 511/256 or 8191/4096.

integer <a id="impl-shared.RecipSqrtEstimate.2"/>RecipSqrtEstimate(integer a, boolean increasedprecision)

    integer r;
    if !increasedprecision then
        assert 128 &lt;= a &amp;&amp; a &lt; 512;
        if a &lt; 256 then                      // 0.25 .. 0.5
            a = a*2+1;                       // a in units of 1/512 rounded to nearest
        else                                 // 0.5 .. 1.0
            a = (a &gt;&gt; 1) &lt;&lt; 1;               // Discard bottom bit
            a = (a+1)*2;                     // a in units of 1/256 rounded to nearest
        integer b = 512;
        while a*(b+1)*(b+1) &lt; 2^28 do
            b = b+1;
        // b = largest b such that b &lt; 2^14 / sqrt(a)
        r = (b+1) DIV 2;                     // Round to nearest
        assert 256 &lt;= r &amp;&amp; r &lt; 512;
    else
        assert 1024 &lt;= a &amp;&amp; a &lt; 4096;
        real real_val;
        real error;
        integer int_val;

        if a &lt; 2048 then                     // 0.25... 0.5
            a = a*2 + 1;                     // Take 10 bits of fraction and force a 1 at the bottom
            real_val = Real(a)/2.0;
        else                                 // 0.5..1.0
            a = (a &gt;&gt; 1) &lt;&lt; 1;               // Discard bottom bit
            a = a+1;                         // Take 10 bits of fraction and force a 1 at the bottom
            real_val = Real(a);

        real_val = Sqrt(real_val);           // This number will lie in the range of 32 to 64
                                             // Round to nearest even for a DP float number
        real_val = real_val * Real(2^47);    // The integer is the size of the whole DP mantissa
        int_val  = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(real_val);      // Calculate rounding value
        error    = real_val - Real(int_val);
        round_up = error &gt; 0.5;              // Error cannot be exactly 0.5 so do not need tie case
        if round_up then int_val = int_val+1;

        real_val = Real(2^65)/Real(int_val); // Lies in the range 4096 &lt;= real_val &lt; 8192
        int_val  = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(real_val);      // Round that (to nearest even) to give integer
        error    = real_val - Real(int_val);
        round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_val&lt;0&gt; == '1'));
        if round_up then int_val = int_val+1;

        r = int_val;
        assert 4096 &lt;= r &amp;&amp; r &lt; 8192;

    return r;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpsqrt.FPSqrt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpsqrt/FPSqrt</h3>
      <p class="pseudocode">// FPSqrt()
// ========

bits(N) <a id="impl-shared.FPSqrt.2"/>FPSqrt(bits(N) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op, fpcr);

    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPProcessNaN.3" title="function: bits(N) FPProcessNaN(FPType fptype, bits(N) op, FPCRType fpcr)">FPProcessNaN</a>(fptype, op, fpcr);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a> then
        result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign);
    elsif fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> &amp;&amp; sign == '0' then
        result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>(sign);
    elsif sign == '1' then
        result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    else
        result = <a href="shared_pseudocode.html#impl-shared.FPRound.2" title="function: bits(N) FPRound(real op, FPCRType fpcr)">FPRound</a>(Sqrt(value), fpcr);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorm.3" title="function: FPProcessDenorm(FPType fptype, integer N, FPCRType fpcr)">FPProcessDenorm</a>(fptype, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpsub.FPSub"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpsub/FPSub</h3>
      <p class="pseudocode">// FPSub()
// =======

bits(N) <a id="impl-shared.FPSub.3"/>FPSub(bits(N) op1, bits(N) op2, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)

    assert N IN {16,32,64};
    rounding = <a href="shared_pseudocode.html#impl-shared.FPRoundingMode.1" title="function: FPRounding FPRoundingMode(FPCRType fpcr)">FPRoundingMode</a>(fpcr);

    (type1,sign1,value1) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op1, fpcr);
    (type2,sign2,value2) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.2" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr)">FPUnpack</a>(op2, fpcr);

    (done,result) = <a href="shared_pseudocode.html#impl-shared.FPProcessNaNs.5" title="function: (boolean, bits(N)) FPProcessNaNs(FPType type1, FPType type2, bits(N) op1,&#13; bits(N) op2, FPCRType fpcr)">FPProcessNaNs</a>(type1, type2, op1, op2, fpcr);
    if !done then
        inf1 = (type1 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        inf2 = (type2 == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>);
        zero1 = (type1 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);
        zero2 = (type2 == <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>);

        if inf1 &amp;&amp; inf2 &amp;&amp; sign1 == sign2 then
            result = <a href="shared_pseudocode.html#impl-shared.FPDefaultNaN.1" title="function: bits(N) FPDefaultNaN(FPCRType fpcr)">FPDefaultNaN</a>(fpcr);
            <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        elsif (inf1 &amp;&amp; sign1 == '0') || (inf2 &amp;&amp; sign2 == '1') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('0');
        elsif (inf1 &amp;&amp; sign1 == '1') || (inf2 &amp;&amp; sign2 == '0') then
            result = <a href="shared_pseudocode.html#impl-shared.FPInfinity.1" title="function: bits(N) FPInfinity(bit sign)">FPInfinity</a>('1');
        elsif zero1 &amp;&amp; zero2 &amp;&amp; sign1 == NOT(sign2) then
            result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(sign1);
        else
            result_value = value1 - value2;
            if result_value == 0.0 then  // Sign of exact zero result depends on rounding mode
                result_sign = if rounding == <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a> then '1' else '0';
                result = <a href="shared_pseudocode.html#impl-shared.FPZero.1" title="function: bits(N) FPZero(bit sign)">FPZero</a>(result_sign);
            else
                result = <a href="shared_pseudocode.html#impl-shared.FPRound.3" title="function: bits(N) FPRound(real op, FPCRType fpcr, FPRounding rounding)">FPRound</a>(result_value, fpcr, rounding);

        <a href="shared_pseudocode.html#impl-shared.FPProcessDenorms.4" title="function: FPProcessDenorms(FPType type1, FPType type2, integer N, FPCRType fpcr)">FPProcessDenorms</a>(type1, type2, N, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpthree.FPThree"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpthree/FPThree</h3>
      <p class="pseudocode">// FPThree()
// =========

bits(N) <a id="impl-shared.FPThree.1"/>FPThree(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(E-1);
    frac = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F-1);
    result = sign : exp : frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptofixed.FPToFixed"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptofixed/FPToFixed</h3>
      <p class="pseudocode">// FPToFixed()
// ===========

// Convert N-bit precision floating point OP to M-bit fixed point with
// FBITS fractional bits, controlled by UNSIGNED and ROUNDING.

bits(M) <a id="impl-shared.FPToFixed.5"/>FPToFixed(bits(N) op, integer fbits, boolean unsigned, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, <a href="shared_pseudocode.html#FPRounding" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding</a> rounding)

    assert N IN {16,32,64};
    assert M IN {16,32,64};
    assert fbits &gt;= 0;
    assert rounding != <a href="shared_pseudocode.html#FPRounding_ODD" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ODD</a>;

    // When alternative floating-point support is TRUE, do not generate
    // Input Denormal floating-point exceptions.
    altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1';
    fpexc = !altfp;

    // Unpack using fpcr to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc);

    // If NaN, set cumulative flag or take exception.
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);

    // Scale by fractional bits and produce integer rounded towards minus-infinity.
    value = value * 2.0^fbits;
    int_result = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(value);
    error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment.
    case rounding of
        when <a href="shared_pseudocode.html#FPRounding_TIEEVEN" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEEVEN</a>
            round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result&lt;0&gt; == '1'));
        when <a href="shared_pseudocode.html#FPRounding_POSINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_POSINF</a>
            round_up = (error != 0.0);
        when <a href="shared_pseudocode.html#FPRounding_NEGINF" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_NEGINF</a>
            round_up = FALSE;
        when <a href="shared_pseudocode.html#FPRounding_ZERO" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_ZERO</a>
            round_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
        when <a href="shared_pseudocode.html#FPRounding_TIEAWAY" title="enumeration FPRounding  {FPRounding_TIEEVEN, FPRounding_POSINF,&#13; FPRounding_NEGINF,  FPRounding_ZERO,&#13; FPRounding_TIEAWAY, FPRounding_ODD}">FPRounding_TIEAWAY</a>
            round_up = (error &gt; 0.5 || (error == 0.5 &amp;&amp; int_result &gt;= 0));

    if round_up then int_result = int_result + 1;

    // Generate saturated result and exceptions.
    (result, overflow) = <a href="shared_pseudocode.html#impl-shared.SatQ.3" title="function: (bits(N), boolean) SatQ(integer i, integer N, boolean unsigned)">SatQ</a>(int_result, M, unsigned);
    if overflow then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
    elsif error != 0.0 then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptofixedjs.FPToFixedJS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptofixedjs/FPToFixedJS</h3>
      <p class="pseudocode">// FPToFixedJS()
// =============

// Converts a double precision floating point input value
// to a signed integer, with rounding to zero.

(bits(N), bit) <a id="impl-shared.FPToFixedJS.3"/>FPToFixedJS(bits(M) op, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean Is64)

    assert M == 64 &amp;&amp; N == 32;

    // If FALSE, never generate Input Denormal floating-point exceptions.
    fpexc_idenorm = !(<a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; fpcr.AH == '1');

    // Unpack using fpcr to determine if subnormals are flushed-to-zero.
    (fptype,sign,value) = <a href="shared_pseudocode.html#impl-shared.FPUnpack.3" title="function: (FPType, bit, real) FPUnpack(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpack</a>(op, fpcr, fpexc_idenorm);

    Z = '1';
    // If NaN, set cumulative flag or take exception.
    if fptype == <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a> || fptype == <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        Z = '0';

    int_result = <a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(value);
    error = value - Real(int_result);

    // Determine whether supplied rounding mode requires an increment.

    round_it_up = (error != 0.0 &amp;&amp; int_result &lt; 0);
    if round_it_up then int_result = int_result + 1;

    if int_result &lt; 0 then
        result = int_result - 2^32*<a href="shared_pseudocode.html#impl-shared.RoundUp.1" title="function: integer RoundUp(real x)">RoundUp</a>(Real(int_result)/Real(2^32));
    else
        result = int_result - 2^32*<a href="shared_pseudocode.html#impl-shared.RoundDown.1" title="function: integer RoundDown(real x)">RoundDown</a>(Real(int_result)/Real(2^32));

    // Generate exceptions.
    if int_result &lt; -(2^31) || int_result &gt; (2^31)-1 then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InvalidOp" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InvalidOp</a>, fpcr);
        Z = '0';
    elsif error != 0.0 then
        <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_Inexact" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_Inexact</a>, fpcr);
        Z = '0';
    elsif sign == '1' &amp;&amp; value == 0.0 then
        Z = '0';
    elsif sign == '0' &amp;&amp; value == 0.0 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(op&lt;51:0&gt;) then
        Z = '0';

    if fptype == <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a> then result = 0;

    return (result&lt;N-1:0&gt;, Z);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptwo.FPTwo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptwo/FPTwo</h3>
      <p class="pseudocode">// FPTwo()
// =======

bits(N) <a id="impl-shared.FPTwo.1"/>FPTwo(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = '1':<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(E-1);
    frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    result = sign : exp : frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fptype.FPType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fptype/FPType</h3>
      <p class="pseudocode">enumeration <a id="FPType"/>FPType {<a id="FPType_Zero"/>FPType_Zero,
                    <a id="FPType_Denormal"/>FPType_Denormal,
                    <a id="FPType_Nonzero"/>FPType_Nonzero,
                    <a id="FPType_Infinity"/>FPType_Infinity,
                    <a id="FPType_QNaN"/>FPType_QNaN,
                    <a id="FPType_SNaN"/>FPType_SNaN};</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpunpack.FPUnpack"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpunpack/FPUnpack</h3>
      <p class="pseudocode">// FPUnpack()
// ==========

(FPType, bit, real) <a id="impl-shared.FPUnpack.2"/>FPUnpack(bits(N) fpval, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    fpcr.AHP = '0';
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    (fp_type, sign, value) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.3" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpackBase</a>(fpval, fpcr, fpexc);
    return (fp_type, sign, value);

// FPUnpack()
// ==========
//
// Used by data processing and int/fixed &lt;-&gt; FP conversion instructions.
// For half-precision data it ignores AHP, and observes FZ16.

(FPType, bit, real) <a id="impl-shared.FPUnpack.3"/>FPUnpack(bits(N) fpval, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)
    fpcr.AHP = '0';
    (fp_type, sign, value) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.3" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpackBase</a>(fpval, fpcr, fpexc);
    return (fp_type, sign, value);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpunpack.FPUnpackBase"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpunpack/FPUnpackBase</h3>
      <p class="pseudocode">// FPUnpackBase()
// ==============

(FPType, bit, real) <a id="impl-shared.FPUnpackBase.3"/>FPUnpackBase(bits(N) fpval, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc)
    boolean isbfloat16 = FALSE;
    (fp_type, sign, value) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.4" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc,&#13; boolean isbfloat16)">FPUnpackBase</a>(fpval, fpcr, fpexc, isbfloat16);
    return (fp_type, sign, value);

// FPUnpackBase()
// ==============
//
// Unpack a floating-point number into its type, sign bit and the real number
// that it represents. The real number result has the correct sign for numbers
// and infinities, is very large in magnitude for infinities, and is 0.0 for
// NaNs. (These values are chosen to simplify the description of comparisons
// and conversions.)
//
// The 'fpcr' argument supplies FPCR control bits, 'fpexc' controls the
// generation of floating-point exceptions and 'isbfloat16' determines whether
// N=16 signifies BFloat16 or half-precision type. Status information is updated
// directly in the FPSR where appropriate.

(FPType, bit, real) <a id="impl-shared.FPUnpackBase.4"/>FPUnpackBase(bits(N) fpval, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr, boolean fpexc,
                                 boolean isbfloat16)

    assert N IN {16,32,64};

    boolean altfp = <a href="shared_pseudocode.html#impl-shared.HaveAltFP.0" title="function: boolean HaveAltFP()">HaveAltFP</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    boolean fiz   = altfp &amp;&amp; fpcr.FIZ == '1';
    boolean fz    = fpcr.FZ == '1' &amp;&amp; !(altfp &amp;&amp; fpcr.AH == '1');

    if N == 16 &amp;&amp; !isbfloat16 then
        sign   = fpval&lt;15&gt;;
        exp16  = fpval&lt;14:10&gt;;
        frac16 = fpval&lt;9:0&gt;;
        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(exp16) then
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac16) || fpcr.FZ16 == '1' then
                fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
            else
                fptype = <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>;  value = 2.0^-14 * (Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac16)) * 2.0^-10);
        elsif <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp16) &amp;&amp; fpcr.AHP == '0' then  // Infinity or NaN in IEEE format
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac16) then
                fptype = <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac16&lt;9&gt; == '1' then <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> else <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
                value = 0.0;
        else
            fptype = <a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
            value = 2.0^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(exp16)-15) * (1.0 + Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac16)) * 2.0^-10);

    elsif N == 32 || isbfloat16 then
        if isbfloat16 then
            sign   = fpval&lt;15&gt;;
            exp32  = fpval&lt;14:7&gt;;
            frac32 = fpval&lt;6:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16);
        else
            sign   = fpval&lt;31&gt;;
            exp32  = fpval&lt;30:23&gt;;
            frac32 = fpval&lt;22:0&gt;;

        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(exp32) then
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac32) then
                // Produce zero if value is zero.
                fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
            elsif fz || fiz then        // Flush-to-zero if FIZ==1 or AH,FZ==01
                fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
                // Check whether to raise Input Denormal floating-point exception.
                // fpcr.FIZ==1 does not raise Input Denormal exception.
                if fz then
                    // Denormalized input flushed to zero
                    if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);
            else
                fptype = <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>;  value = 2.0^-126 * (Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac32)) * 2.0^-23);
        elsif <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp32) then
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac32) then
                fptype = <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac32&lt;22&gt; == '1' then <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> else <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
                value = 0.0;
        else
            fptype = <a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
            value = 2.0^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(exp32)-127) * (1.0 + Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac32)) * 2.0^-23);

    else // N == 64
        sign   = fpval&lt;63&gt;;
        exp64  = fpval&lt;62:52&gt;;
        frac64 = fpval&lt;51:0&gt;;

        if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(exp64) then
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac64) then
                // Produce zero if value is zero.
                fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
            elsif fz || fiz then        // Flush-to-zero if FIZ==1 or AH,FZ==01
                fptype = <a href="shared_pseudocode.html#FPType_Zero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Zero</a>;  value = 0.0;
                // Check whether to raise Input Denormal floating-point exception.
                // fpcr.FIZ==1 does not raise Input Denormal exception.
                if fz then
                    // Denormalized input flushed to zero
                    if fpexc then <a href="shared_pseudocode.html#impl-shared.FPProcessException.2" title="function: FPProcessException(FPExc exception, FPCRType fpcr)">FPProcessException</a>(<a href="shared_pseudocode.html#FPExc_InputDenorm" title="enumeration FPExc       {FPExc_InvalidOp, FPExc_DivideByZero, FPExc_Overflow,&#13; FPExc_Underflow, FPExc_Inexact, FPExc_InputDenorm}">FPExc_InputDenorm</a>, fpcr);
            else
                fptype = <a href="shared_pseudocode.html#FPType_Denormal" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Denormal</a>;  value = 2.0^-1022 * (Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac64)) * 2.0^-52);
        elsif <a href="shared_pseudocode.html#impl-shared.IsOnes.1" title="function: boolean IsOnes(bits(N) x)">IsOnes</a>(exp64) then
            if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(frac64) then
                fptype = <a href="shared_pseudocode.html#FPType_Infinity" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Infinity</a>;  value = 2.0^1000000;
            else
                fptype = if frac64&lt;51&gt; == '1' then <a href="shared_pseudocode.html#FPType_QNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_QNaN</a> else <a href="shared_pseudocode.html#FPType_SNaN" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_SNaN</a>;
                value = 0.0;
        else
            fptype = <a href="shared_pseudocode.html#FPType_Nonzero" title="enumeration FPType {FPType_Zero,&#13; FPType_Denormal,&#13; FPType_Nonzero,&#13; FPType_Infinity,&#13; FPType_QNaN,&#13; FPType_SNaN}">FPType_Nonzero</a>;
            value = 2.0^(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(exp64)-1023) * (1.0 + Real(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(frac64)) * 2.0^-52);

    if sign == '1' then value = -value;

    return (fptype, sign, value);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpunpack.FPUnpackCV"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpunpack/FPUnpackCV</h3>
      <p class="pseudocode">// FPUnpackCV()
// ============
//
// Used for FP &lt;-&gt; FP conversion instructions.
// For half-precision data ignores FZ16 and observes AHP.

(FPType, bit, real) <a id="impl-shared.FPUnpackCV.2"/>FPUnpackCV(bits(N) fpval, <a href="shared_pseudocode.html#FPCRType" title="type FPCRType">FPCRType</a> fpcr)
    fpcr.FZ16 = '0';
    boolean fpexc = TRUE;   // Generate floating-point exceptions
    (fp_type, sign, value) = <a href="shared_pseudocode.html#impl-shared.FPUnpackBase.3" title="function: (FPType, bit, real) FPUnpackBase(bits(N) fpval, FPCRType fpcr, boolean fpexc)">FPUnpackBase</a>(fpval, fpcr, fpexc);
    return (fp_type, sign, value);</p>
    </div>
    <div class="ps"><a id="shared.functions.float.fpzero.FPZero"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/fpzero/FPZero</h3>
      <p class="pseudocode">// FPZero()
// ========

bits(N) <a id="impl-shared.FPZero.1"/>FPZero(bit sign)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - (E + 1);
    exp  = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(E);
    frac = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F);
    result = sign : exp : frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.float.vfpexpandimm.VFPExpandImm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/float/vfpexpandimm/VFPExpandImm</h3>
      <p class="pseudocode">// VFPExpandImm()
// ==============

bits(N) <a id="impl-shared.VFPExpandImm.1"/>VFPExpandImm(bits(8) imm8)

    assert N IN {16,32,64};
    constant integer E = (if N == 16 then 5 elsif N == 32 then 8 else 11);
    constant integer F = N - E - 1;
    sign = imm8&lt;7&gt;;
    exp  = NOT(imm8&lt;6&gt;):<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;,E-3):imm8&lt;5:4&gt;;
    frac = imm8&lt;3:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(F-4);
    result = sign : exp : frac;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.integer.AddWithCarry"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/integer/AddWithCarry</h3>
      <p class="pseudocode">// AddWithCarry()
// ==============
// Integer addition with carry input, returning result and NZCV flags

(bits(N), bits(4)) <a id="impl-shared.AddWithCarry.3"/>AddWithCarry(bits(N) x, bits(N) y, bit carry_in)
    integer unsigned_sum = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(x) + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(y) + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(carry_in);
    integer signed_sum = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(x) + <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(y) + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(carry_in);
    bits(N) result = unsigned_sum&lt;N-1:0&gt;; // same value as signed_sum&lt;N-1:0&gt;
    bit n = result&lt;N-1&gt;;
    bit z = if <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(result) then '1' else '0';
    bit c = if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(result) == unsigned_sum then '0' else '1';
    bit v = if <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(result) == signed_sum then '0' else '1';
    return (result, n:z:c:v);</p>
    </div>
    <div class="ps"><a id="shared.functions.interrupts.InterruptID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/interrupts/InterruptID</h3>
      <p class="pseudocode">enumeration <a id="InterruptID"/>InterruptID {<a id="InterruptID_PMUIRQ"/>InterruptID_PMUIRQ, <a id="InterruptID_COMMIRQ"/>InterruptID_COMMIRQ, <a id="InterruptID_CTIIRQ"/>InterruptID_CTIIRQ,
                         <a id="InterruptID_COMMRX"/>InterruptID_COMMRX, <a id="InterruptID_COMMTX"/>InterruptID_COMMTX, <a id="InterruptID_CNTP"/>InterruptID_CNTP,
                         <a id="InterruptID_CNTHP"/>InterruptID_CNTHP, <a id="InterruptID_CNTHPS"/>InterruptID_CNTHPS, <a id="InterruptID_CNTPS"/>InterruptID_CNTPS,
                         <a id="InterruptID_CNTV"/>InterruptID_CNTV, <a id="InterruptID_CNTHV"/>InterruptID_CNTHV, <a id="InterruptID_CNTHVS"/>InterruptID_CNTHVS};</p>
    </div>
    <div class="ps"><a id="shared.functions.interrupts.SetInterruptRequestLevel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/interrupts/SetInterruptRequestLevel</h3>
      <p class="pseudocode">// Set a level-sensitive interrupt to the specified level.
SetInterruptRequestLevel(<a href="shared_pseudocode.html#InterruptID" title="enumeration InterruptID {InterruptID_PMUIRQ, InterruptID_COMMIRQ, InterruptID_CTIIRQ,&#13; InterruptID_COMMRX, InterruptID_COMMTX, InterruptID_CNTP,&#13; InterruptID_CNTHP, InterruptID_CNTHPS, InterruptID_CNTPS,&#13; InterruptID_CNTV, InterruptID_CNTHV, InterruptID_CNTHVS}">InterruptID</a> id, signal level);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AArch64.BranchAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AArch64.BranchAddr</h3>
      <p class="pseudocode">// AArch64.BranchAddr()
// ====================
// Return the virtual address with tag bits removed for storing to the program counter.

bits(64) <a id="AArch64.BranchAddr.1"/>AArch64.BranchAddr(bits(64) vaddress)
    assert !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    msbit = <a href="shared_pseudocode.html#impl-shared.AddrTop.3" title="function: integer AddrTop(bits(64) address, boolean IsInstr, bits(2) el)">AddrTop</a>(vaddress, TRUE, PSTATE.EL);
    if msbit == 63 then
        return vaddress;
    elsif (PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} || <a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>()) &amp;&amp; vaddress&lt;msbit&gt; == '1' then
        return <a href="shared_pseudocode.html#impl-shared.SignExtend.1" title="function: bits(N) SignExtend(bits(M) x)">SignExtend</a>(vaddress&lt;msbit:0&gt;);
    else
        return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(vaddress&lt;msbit:0&gt;);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AccType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AccType</h3>
      <p class="pseudocode">enumeration <a id="AccType"/>AccType {<a id="AccType_NORMAL"/>AccType_NORMAL,            // Normal loads and stores
                     <a id="AccType_VEC"/>AccType_VEC,
                     <a id="AccType_STREAM"/>AccType_STREAM,            // Streaming loads and stores
                     <a id="AccType_VECSTREAM"/>AccType_VECSTREAM,
                     <a id="AccType_UNPRIVSTREAM"/>AccType_UNPRIVSTREAM,      // Streaming unprivileged loads and stores
                     <a id="AccType_A32LSMD"/>AccType_A32LSMD,           // Load and store multiple
                     <a id="AccType_ATOMIC"/>AccType_ATOMIC,            // Atomic loads and stores
                     <a id="AccType_ATOMICRW"/>AccType_ATOMICRW,
                     <a id="AccType_ORDERED"/>AccType_ORDERED,           // Load-Acquire and Store-Release
                     <a id="AccType_ORDEREDRW"/>AccType_ORDEREDRW,
                     <a id="AccType_ORDEREDATOMIC"/>AccType_ORDEREDATOMIC,     // Load-Acquire and Store-Release with atomic access
                     <a id="AccType_ORDEREDATOMICRW"/>AccType_ORDEREDATOMICRW,
                     <a id="AccType_ATOMICLS64"/>AccType_ATOMICLS64,        // Atomic 64-byte loads and stores
                     <a id="AccType_LIMITEDORDERED"/>AccType_LIMITEDORDERED,    // Load-LOAcquire and Store-LORelease
                     <a id="AccType_UNPRIV"/>AccType_UNPRIV,            // Load and store unprivileged
                     <a id="AccType_IFETCH"/>AccType_IFETCH,            // Instruction fetch
                     <a id="AccType_TTW"/>AccType_TTW,               // Translation table walk
                     <a id="AccType_NONFAULT"/>AccType_NONFAULT,          // Non-faulting loads
                     <a id="AccType_CNOTFIRST"/>AccType_CNOTFIRST,         // Contiguous FF load, not first element
                     <a id="AccType_NV2REGISTER"/>AccType_NV2REGISTER,       // MRS/MSR instruction used at EL1 and which is
                                                // converted to a memory access that uses the
                                                // EL2 translation regime
                     <a id="AccType_TRBE"/>AccType_TRBE,              // TRBE memory access
                     // Other operations
                     <a id="AccType_DC"/>AccType_DC,                // Data cache maintenance
                     <a id="AccType_IC"/>AccType_IC,                // Instruction cache maintenance
                     <a id="AccType_DCZVA"/>AccType_DCZVA,             // DC ZVA instructions
                     <a id="AccType_ATPAN"/>AccType_ATPAN,             // Address translation with PAN permission checks
                     <a id="AccType_AT"/>AccType_AT};               // Address translation</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AccessDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AccessDescriptor</h3>
      <p class="pseudocode">type <a id="AccessDescriptor"/>AccessDescriptor is (
    boolean transactional,
    <a href="shared_pseudocode.html#MPAMinfo" title="type MPAMinfo is ( PARTIDspaceType mpam_sp, PARTIDtype partid, PMGtype pmg )">MPAMinfo</a> mpam,
    <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.AddrTop"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/AddrTop</h3>
      <p class="pseudocode">// AddrTop()
// =========
// Return the MSB number of a virtual address in the stage 1 translation regime for "el".
// If EL1 is using AArch64 then addresses from EL0 using AArch32 are zero-extended to 64 bits.

integer <a id="impl-shared.AddrTop.3"/>AddrTop(bits(64) address, boolean IsInstr, bits(2) el)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime) then
        // AArch32 translation regime.
        return 31;
    else
        if <a href="shared_pseudocode.html#impl-shared.EffectiveTBI.3" title="function: bit EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)">EffectiveTBI</a>(address, IsInstr, el) == '1' then
            return 55;
        else
            return 63;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Allocation"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Allocation</h3>
      <p class="pseudocode">constant bits(2) <a id="MemHint_No"/>MemHint_No = '00';     // No Read-Allocate, No Write-Allocate
constant bits(2) <a id="MemHint_WA"/>MemHint_WA = '01';     // No Read-Allocate, Write-Allocate
constant bits(2) <a id="MemHint_RA"/>MemHint_RA = '10';     // Read-Allocate, No Write-Allocate
constant bits(2) <a id="MemHint_RWA"/>MemHint_RWA = '11';    // Read-Allocate, Write-Allocate</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.BigEndian"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/BigEndian</h3>
      <p class="pseudocode">// BigEndian()
// ===========

boolean <a id="impl-shared.BigEndian.1"/>BigEndian(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    boolean bigend;
    if <a href="shared_pseudocode.html#impl-shared.HaveNV2Ext.0" title="function: boolean HaveNV2Ext()">HaveNV2Ext</a>() &amp;&amp; acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
        return SCTLR_EL2.EE == '1';

    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        bigend = (PSTATE.E != '0');
    elsif PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        bigend = (<a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].E0E != '0');
    else
        bigend = (<a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[].EE != '0');
    return bigend;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.BigEndianReverse"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/BigEndianReverse</h3>
      <p class="pseudocode">// BigEndianReverse()
// ==================

bits(width) <a id="impl-shared.BigEndianReverse.1"/>BigEndianReverse (bits(width) value)
    assert width IN {8, 16, 32, 64, 128};
    integer half = width DIV 2;
    if width == 8 then return value;
    return <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value&lt;half-1:0&gt;) : <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(value&lt;width-1:half&gt;);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Cacheability"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Cacheability</h3>
      <p class="pseudocode">constant bits(2) <a id="MemAttr_NC"/>MemAttr_NC = '00';     // Non-cacheable
constant bits(2) <a id="MemAttr_WT"/>MemAttr_WT = '10';     // Write-through
constant bits(2) <a id="MemAttr_WB"/>MemAttr_WB = '11';     // Write-back</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.CreateAccessDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/CreateAccessDescriptor</h3>
      <p class="pseudocode">// CreateAccessDescriptor()
// ========================

AccessDescriptor <a id="impl-shared.CreateAccessDescriptor.1"/>CreateAccessDescriptor(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc;
    accdesc.acctype = acctype;
    accdesc.transactional = FALSE;
    accdesc.mpam = <a href="shared_pseudocode.html#impl-shared.GenMPAMcurEL.1" title="function: MPAMinfo GenMPAMcurEL(AccType acctype)">GenMPAMcurEL</a>(acctype);
    return accdesc;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.DataMemoryBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/DataMemoryBarrier</h3>
      <p class="pseudocode"><a id="impl-shared.DataMemoryBarrier.2"/>DataMemoryBarrier(<a href="shared_pseudocode.html#MBReqDomain" title="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain</a> domain, <a href="shared_pseudocode.html#MBReqTypes" title="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}">MBReqTypes</a> types);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.DataSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/DataSynchronizationBarrier</h3>
      <p class="pseudocode"><a id="impl-shared.DataSynchronizationBarrier.3"/>DataSynchronizationBarrier(<a href="shared_pseudocode.html#MBReqDomain" title="enumeration MBReqDomain    {MBReqDomain_Nonshareable, MBReqDomain_InnerShareable,&#13; MBReqDomain_OuterShareable, MBReqDomain_FullSystem}">MBReqDomain</a> domain, <a href="shared_pseudocode.html#MBReqTypes" title="enumeration MBReqTypes     {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}">MBReqTypes</a> types, boolean nXS);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.DeviceType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/DeviceType</h3>
      <p class="pseudocode">enumeration <a id="DeviceType"/>DeviceType {<a id="DeviceType_GRE"/>DeviceType_GRE, <a id="DeviceType_nGRE"/>DeviceType_nGRE, <a id="DeviceType_nGnRE"/>DeviceType_nGnRE, <a id="DeviceType_nGnRnE"/>DeviceType_nGnRnE};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.EffectiveTBI"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/EffectiveTBI</h3>
      <p class="pseudocode">// EffectiveTBI()
// ==============
// Returns the effective TBI in the AArch64 stage 1 translation regime for "el".

bit <a id="impl-shared.EffectiveTBI.3"/>EffectiveTBI(bits(64) address, boolean IsInstr, bits(2) el)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    assert(!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime));

    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            tbi = if address&lt;55&gt; == '1' then TCR_EL1.TBI1 else TCR_EL1.TBI0;
            if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() then
                tbid = if address&lt;55&gt; == '1' then TCR_EL1.TBID1 else TCR_EL1.TBID0;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(el) then
                tbi = if address&lt;55&gt; == '1' then TCR_EL2.TBI1 else TCR_EL2.TBI0;
                if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() then
                    tbid = if address&lt;55&gt; == '1' then TCR_EL2.TBID1 else TCR_EL2.TBID0;
            else
                tbi = TCR_EL2.TBI;
                if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() then tbid = TCR_EL2.TBID;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            tbi = TCR_EL3.TBI;
            if <a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() then tbid = TCR_EL3.TBID;

    return (if tbi == '1' &amp;&amp; (!<a href="shared_pseudocode.html#impl-aarch64.HavePACExt.0" title="function: boolean HavePACExt()">HavePACExt</a>() || tbid == '0' || !IsInstr) then '1' else '0');</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.EffectiveTCMA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/EffectiveTCMA</h3>
      <p class="pseudocode">// EffectiveTCMA()
// ===============
// Returns the effective TCMA of a virtual address in the stage 1 translation regime for "el".

bit <a id="impl-shared.EffectiveTCMA.2"/>EffectiveTCMA(bits(64) address, bits(2) el)
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el);
    regime = <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(el);
    assert(!<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(regime));

    case regime of
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            tcma = if address&lt;55&gt; == '1' then TCR_EL1.TCMA1 else TCR_EL1.TCMA0;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(el) then
                tcma = if address&lt;55&gt; == '1' then TCR_EL2.TCMA1 else TCR_EL2.TCMA0;
            else
                tcma = TCR_EL2.TCMA;
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            tcma = TCR_EL3.TCMA;

    return tcma;</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Fault"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Fault</h3>
      <p class="pseudocode">enumeration <a id="Fault"/>Fault {<a id="Fault_None"/>Fault_None,
                   <a id="Fault_AccessFlag"/>Fault_AccessFlag,
                   <a id="Fault_Alignment"/>Fault_Alignment,
                   <a id="Fault_Background"/>Fault_Background,
                   <a id="Fault_Domain"/>Fault_Domain,
                   <a id="Fault_Permission"/>Fault_Permission,
                   <a id="Fault_Translation"/>Fault_Translation,
                   <a id="Fault_AddressSize"/>Fault_AddressSize,
                   <a id="Fault_SyncExternal"/>Fault_SyncExternal,
                   <a id="Fault_SyncExternalOnWalk"/>Fault_SyncExternalOnWalk,
                   <a id="Fault_SyncParity"/>Fault_SyncParity,
                   <a id="Fault_SyncParityOnWalk"/>Fault_SyncParityOnWalk,
                   <a id="Fault_GPCFOnWalk"/>Fault_GPCFOnWalk,
                   <a id="Fault_GPCFOnOutput"/>Fault_GPCFOnOutput,
                   <a id="Fault_AsyncParity"/>Fault_AsyncParity,
                   <a id="Fault_AsyncExternal"/>Fault_AsyncExternal,
                   <a id="Fault_Debug"/>Fault_Debug,
                   <a id="Fault_TLBConflict"/>Fault_TLBConflict,
                   <a id="Fault_BranchTarget"/>Fault_BranchTarget,
                   <a id="Fault_HWUpdateAccessFlag"/>Fault_HWUpdateAccessFlag,
                   <a id="Fault_Lockdown"/>Fault_Lockdown,
                   <a id="Fault_Exclusive"/>Fault_Exclusive,
                   <a id="Fault_ICacheMaint"/>Fault_ICacheMaint};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.FaultRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/FaultRecord</h3>
      <p class="pseudocode">type <a id="FaultRecord"/>FaultRecord is (<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a>    statuscode,  // Fault Status
                     <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a>  acctype,      // Type of access that faulted
                     <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> ipaddress, // Intermediate physical address
                     <a href="shared_pseudocode.html#GPCFRecord" title="type GPCFRecord is ( GPCF gpf, integer level )">GPCFRecord</a> gpcf,       // Granule Protection Check Fault record
                     <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> paddress,  // Physical address
                     boolean  gpcfs2walk,   // GPC for a stage 2 translation table walk
                     boolean  s2fs1walk,    // Is on a Stage 1 translation table walk
                     boolean  write,        // TRUE for a write, FALSE for a read
                     integer  level,        // For translation, access flag and permission faults
                     bit      extflag,      // IMPLEMENTATION DEFINED syndrome for External aborts
                     boolean  secondstage,  // Is a Stage 2 abort
                     bits(4)  domain,       // Domain number, AArch32 only
                     bits(2)  errortype,    // [Armv8.2 RAS] AArch32 AET or AArch64 SET
                     bits(4)  debugmoe)     // Debug method of entry, from AArch32 only</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.FullAddress"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/FullAddress</h3>
      <p class="pseudocode">type <a id="FullAddress"/>FullAddress is (
    <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a>  paspace,
    bits(52) address
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.GPCF"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/GPCF</h3>
      <p class="pseudocode">enumeration <a id="GPCF"/>GPCF {
    <a id="GPCF_None"/>GPCF_None,        // No fault
    <a id="GPCF_AddressSize"/>GPCF_AddressSize, // GPT address size fault
    <a id="GPCF_Walk"/>GPCF_Walk,        // GPT walk fault
    <a id="GPCF_EABT"/>GPCF_EABT,        // Synchronous External abort on GPT fetch
    <a id="GPCF_Fail"/>GPCF_Fail         // Granule protection fault
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.GPCFRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/GPCFRecord</h3>
      <p class="pseudocode">type <a id="GPCFRecord"/>GPCFRecord is (
    <a href="shared_pseudocode.html#GPCF" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF</a>    gpf,
    integer level
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Hint_Prefetch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Hint_Prefetch</h3>
      <p class="pseudocode">// Signals the memory system that memory accesses of type HINT to or from the specified address are
// likely in the near future. The memory system may take some action to speed up the memory
// accesses when they do occur, such as pre-loading the the specified address into one or more
// caches as indicated by the innermost cache level target (0=L1, 1=L2, etc) and non-temporal hint
// stream. Any or all prefetch hints may be treated as a NOP. A prefetch hint must not cause a
// synchronous abort due to Alignment or Translation faults and the like. Its only effect on
// software-visible state should be on caches and TLBs associated with address, which must be
// accessible by reads, writes or execution, as defined in the translation regime of the current
// Exception level. It is guaranteed not to access Device memory.
// A Prefetch_EXEC hint must not result in an access that could not be performed by a speculative
// instruction fetch, therefore if all associated MMUs are disabled, then it cannot access any
// memory location that cannot be accessed by instruction fetches.
<a id="impl-shared.Hint_Prefetch.4"/>Hint_Prefetch(bits(64) address, <a href="shared_pseudocode.html#PrefetchHint" title="enumeration PrefetchHint {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}">PrefetchHint</a> hint, integer target, boolean stream);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.IsDataAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/IsDataAccess</h3>
      <p class="pseudocode">// IsDataAccess()
// ==============
// Return TRUE if access is to data memory.

boolean <a id="impl-shared.IsDataAccess.1"/>IsDataAccess(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    return !(acctype IN {<a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>,
                         <a href="shared_pseudocode.html#AccType_DC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_DC</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>,
                         <a href="shared_pseudocode.html#AccType_AT" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_AT</a>, <a href="shared_pseudocode.html#AccType_ATPAN" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATPAN</a>
                        });</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MBReqDomain"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MBReqDomain</h3>
      <p class="pseudocode">enumeration <a id="MBReqDomain"/>MBReqDomain    {<a id="MBReqDomain_Nonshareable"/>MBReqDomain_Nonshareable, <a id="MBReqDomain_InnerShareable"/>MBReqDomain_InnerShareable,
                            <a id="MBReqDomain_OuterShareable"/>MBReqDomain_OuterShareable, <a id="MBReqDomain_FullSystem"/>MBReqDomain_FullSystem};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MBReqTypes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MBReqTypes</h3>
      <p class="pseudocode">enumeration <a id="MBReqTypes"/>MBReqTypes     {<a id="MBReqTypes_Reads"/>MBReqTypes_Reads, <a id="MBReqTypes_Writes"/>MBReqTypes_Writes, <a id="MBReqTypes_All"/>MBReqTypes_All};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MPAM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MPAM</h3>
      <p class="pseudocode">type <a id="PARTIDtype"/>PARTIDtype = bits(16);
type <a id="PMGtype"/>PMGtype = bits(8);
type <a id="PARTIDspaceType"/>PARTIDspaceType = bits(2);
constant PARTIDspaceType <a id="PIdSpace_Secure"/>PIdSpace_Secure    = '00';
constant PARTIDspaceType <a id="PIdSpace_NonSecure"/>PIdSpace_NonSecure = '01';
constant PARTIDspaceType <a id="PIdSpace_Root"/>PIdSpace_Root      = '10';
constant PARTIDspaceType <a id="PIdSpace_Realm"/>PIdSpace_Realm     = '11';

type <a id="MPAMinfo"/>MPAMinfo is (
     <a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> mpam_sp,
     <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> partid,
     <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> pmg
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemAttrHints"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemAttrHints</h3>
      <p class="pseudocode">type <a id="MemAttrHints"/>MemAttrHints is (
    bits(2) attrs,  // See MemAttr_*, Cacheability attributes
    bits(2) hints,  // See MemHint_*, Allocation hints
    boolean transient
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemType</h3>
      <p class="pseudocode">enumeration <a id="MemType"/>MemType {<a id="MemType_Normal"/>MemType_Normal, <a id="MemType_Device"/>MemType_Device};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.MemoryAttributes"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/MemoryAttributes</h3>
      <p class="pseudocode">type <a id="MemoryAttributes"/>MemoryAttributes is (
    <a href="shared_pseudocode.html#MemType" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType</a>      memtype,
    <a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType</a>   device,       // For Device memory types
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> inner,        // Inner hints and attributes
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> outer,        // Outer hints and attributes
    <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> shareability, // Shareability attribute
    boolean      tagged,       // Tagged access
    bit          xs            // XS attribute
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PASpace"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PASpace</h3>
      <p class="pseudocode">enumeration <a id="PASpace"/>PASpace {
    <a id="PAS_NonSecure"/>PAS_NonSecure,
    <a id="PAS_Secure"/>PAS_Secure,
    <a id="PAS_Root"/>PAS_Root,
    <a id="PAS_Realm"/>PAS_Realm
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Permissions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Permissions</h3>
      <p class="pseudocode">type <a id="Permissions"/>Permissions is (
    bits(2) ap_table,   // Stage 1 hierarchical access permissions
    bit     xn_table,   // Stage 1 hierarchical execute-never for single EL regimes
    bit     pxn_table,  // Stage 1 hierarchical privileged execute-never
    bit     uxn_table,  // Stage 1 hierarchical unprivileged execute-never
    bits(3) ap,         // Stage 1 access permissions
    bit     xn,         // Stage 1 execute-never for single EL regimes
    bit     uxn,        // Stage 1 unprivileged execute-never
    bit     pxn,        // Stage 1 privileged execute-never
    bits(2) s2ap,       // Stage 2 access permissions
    bit     s2xnx,      // Stage 2 extended execute-never
    bit     s2xn        // Stage 2 execute-never
)</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PhysMemRead"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PhysMemRead</h3>
      <p class="pseudocode">// Returns the value read from memory, and a status.
// Returned value is UNKNOWN if an external abort occurred while reading the
// memory.
// Otherwise the PhysMemRetStatus statuscode is Fault_None.
(PhysMemRetStatus, bits(8*size)) <a id="impl-shared.PhysMemRead.3"/>PhysMemRead(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> desc, integer size,
                                             <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PhysMemRetStatus"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PhysMemRetStatus</h3>
      <p class="pseudocode">type <a id="PhysMemRetStatus"/>PhysMemRetStatus is (<a href="shared_pseudocode.html#Fault" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault</a>    statuscode,     // Fault Status
                          bit      extflag,        // IMPLEMENTATION DEFINED
                                                   // syndrome for External aborts
                          bits(2)  errortype,      // optional error state
                                                   // returned on a physical
                                                   // memory access
                          bits(64) store64bstatus, // status of 64B store
                          <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a>  acctype)        // Type of access that faulted</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PhysMemWrite"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PhysMemWrite</h3>
      <p class="pseudocode">// Writes the value to memory, and returns the status of the write.
// If there is an external abort on the write, the PhysMemRetStatus indicates this.
// Otherwise the statuscode of PhysMemRetStatus is Fault_None.
PhysMemRetStatus <a id="impl-shared.PhysMemWrite.4"/>PhysMemWrite(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> desc, integer size, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc,
                              bits(8*size) value);</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.PrefetchHint"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/PrefetchHint</h3>
      <p class="pseudocode">enumeration <a id="PrefetchHint"/>PrefetchHint {<a id="Prefetch_READ"/>Prefetch_READ, <a id="Prefetch_WRITE"/>Prefetch_WRITE, <a id="Prefetch_EXEC"/>Prefetch_EXEC};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Shareability"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Shareability</h3>
      <p class="pseudocode">enumeration <a id="Shareability"/>Shareability {
    <a id="Shareability_NSH"/>Shareability_NSH,
    <a id="Shareability_ISH"/>Shareability_ISH,
    <a id="Shareability_OSH"/>Shareability_OSH
};</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.SpeculativeStoreBypassBarrierToPA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/SpeculativeStoreBypassBarrierToPA</h3>
      <p class="pseudocode"><a id="impl-shared.SpeculativeStoreBypassBarrierToPA.0"/>SpeculativeStoreBypassBarrierToPA();</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.SpeculativeStoreBypassBarrierToVA"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/SpeculativeStoreBypassBarrierToVA</h3>
      <p class="pseudocode"><a id="impl-shared.SpeculativeStoreBypassBarrierToVA.0"/>SpeculativeStoreBypassBarrierToVA();</p>
    </div>
    <div class="ps"><a id="shared.functions.memory.Tag"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/memory/Tag</h3>
      <p class="pseudocode">constant integer <a id="LOG2_TAG_GRANULE"/>LOG2_TAG_GRANULE = 4;

constant integer <a id="TAG_GRANULE"/>TAG_GRANULE = 1 &lt;&lt; <a href="shared_pseudocode.html#LOG2_TAG_GRANULE" title="constant integer LOG2_TAG_GRANULE = 4">LOG2_TAG_GRANULE</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.AltPARTIDspace"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/AltPARTIDspace</h3>
      <p class="pseudocode">// AltPARTIDspace()
// ================
// From the Security state, EL and ALTSP configuration, determine
// whether to primary space or the alt space is selected and which
// PARTID space is the alternative space. Return that alternative
// PARTID space if selected or the primary space if not.

PARTIDspaceType <a id="impl-shared.AltPARTIDspace.3"/>AltPARTIDspace(bits(2) el, <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security,
                                <a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> primaryPIdSpace)
    case security of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            assert el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            return primaryPIdSpace; // there is no ALTSP for Non_secure
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            assert el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            if primaryPIdSpace == <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a> then
                return primaryPIdSpace;
            return <a href="shared_pseudocode.html#impl-shared.AltPIdSecure.2" title="function: PARTIDspaceType AltPIdSecure(bits(2) el, PARTIDspaceType primaryPIdSpace)">AltPIdSecure</a>(el, primaryPIdSpace);
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>
            assert el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            if MPAM3_EL3.ALTSP_EL3 == '1' then
                if MPAM3_EL3.RT_ALTSP_NS == '1' then
                    return <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
                else
                    return <a href="shared_pseudocode.html#PIdSpace_Secure" title="constant PARTIDspaceType PIdSpace_Secure = '00'">PIdSpace_Secure</a>;
            else
                return primaryPIdSpace;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            assert el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            return <a href="shared_pseudocode.html#impl-shared.AltPIdRealm.2" title="function: PARTIDspaceType AltPIdRealm(bits(2) el, PARTIDspaceType primaryPIdSpace)">AltPIdRealm</a>(el, primaryPIdSpace);
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.AltPIdRealm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/AltPIdRealm</h3>
      <p class="pseudocode">// AltPIdRealm()
// =============
// Compute PARTID space as either the primary PARTID space or
// alternative PARTID space in the Realm Security state.
// Helper for AltPARTIDspace.

PARTIDspaceType <a id="impl-shared.AltPIdRealm.2"/>AltPIdRealm(bits(2) el, <a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> primaryPIdSpace)
    <a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> PIdSpace = primaryPIdSpace;
    case el of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            if <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>) then
                if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL2.0" title="function: boolean UsePrimarySpaceEL2()">UsePrimarySpaceEL2</a>() then
                    PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
            elsif !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL10.0" title="function: boolean UsePrimarySpaceEL10()">UsePrimarySpaceEL10</a>() then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL10.0" title="function: boolean UsePrimarySpaceEL10()">UsePrimarySpaceEL10</a>() then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL2.0" title="function: boolean UsePrimarySpaceEL2()">UsePrimarySpaceEL2</a>() then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return PIdSpace;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.AltPIdSecure"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/AltPIdSecure</h3>
      <p class="pseudocode">// AltPIdSecure()
// ==============
// Compute PARTID space as either the primary PARTID space or
// alternative PARTID space in the Secure Security state.
// Helper for AltPARTIDspace.

PARTIDspaceType <a id="impl-shared.AltPIdSecure.2"/>AltPIdSecure(bits(2) el, <a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> primaryPIdSpace)
    <a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> PIdSpace = primaryPIdSpace;
    boolean el2en = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
    case el of
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            if el2en then
                if <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>) then
                    if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL2.0" title="function: boolean UsePrimarySpaceEL2()">UsePrimarySpaceEL2</a>() then
                        PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
                elsif !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL10.0" title="function: boolean UsePrimarySpaceEL10()">UsePrimarySpaceEL10</a>() then
                    PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
            elsif MPAM3_EL3.ALTSP_HEN == '0' &amp;&amp; MPAM3_EL3.ALTSP_HFC == '1' then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            if el2en then
                if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL10.0" title="function: boolean UsePrimarySpaceEL10()">UsePrimarySpaceEL10</a>() then
                    PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
            elsif MPAM3_EL3.ALTSP_HEN == '0' &amp;&amp; MPAM3_EL3.ALTSP_HFC == '1' then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if !<a href="shared_pseudocode.html#impl-shared.UsePrimarySpaceEL2.0" title="function: boolean UsePrimarySpaceEL2()">UsePrimarySpaceEL2</a>() then
                PIdSpace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return PIdSpace;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.DefaultMPAMinfo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/DefaultMPAMinfo</h3>
      <p class="pseudocode">// DefaultMPAMinfo()
// =================
// Returns default MPAM info.  The partidspace argument sets
// the PARTID space of the default MPAM information returned.

MPAMinfo <a id="impl-shared.DefaultMPAMinfo.1"/>DefaultMPAMinfo(<a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> partidspace)
    <a href="shared_pseudocode.html#MPAMinfo" title="type MPAMinfo is ( PARTIDspaceType mpam_sp, PARTIDtype partid, PMGtype pmg )">MPAMinfo</a> DefaultInfo;
    DefaultInfo.mpam_sp = partidspace;
    DefaultInfo.partid  = <a href="shared_pseudocode.html#DefaultPARTID" title="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>;
    DefaultInfo.pmg     = <a href="shared_pseudocode.html#DefaultPMG" title="constant PMGtype DefaultPMG = 0&lt;7:0&gt;">DefaultPMG</a>;
    return DefaultInfo;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.DefaultPARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/DefaultPARTID</h3>
      <p class="pseudocode">constant PARTIDtype <a id="DefaultPARTID"/>DefaultPARTID = 0&lt;15:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.DefaultPMG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/DefaultPMG</h3>
      <p class="pseudocode">constant PMGtype    <a id="DefaultPMG"/>DefaultPMG = 0&lt;7:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.GenMPAMcurEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/GenMPAMcurEL</h3>
      <p class="pseudocode">// GenMPAMcurEL()
// ==============
// Returns MPAMinfo for the current EL and security state.
// May be called if MPAM is not implemented (but in an version that supports
// MPAM), MPAM is disabled, or in AArch32.  In AArch32, convert the mode to
// EL if can and use that to drive MPAM information generation.  If mode
// cannot be converted, MPAM is not implemented, or MPAM is disabled return
// default MPAM information for the current security state.

MPAMinfo <a id="impl-shared.GenMPAMcurEL.1"/>GenMPAMcurEL(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    bits(2) mpamEL;
    boolean validEL = FALSE;
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security = <a href="shared_pseudocode.html#AArch64.CurrentSecurityState.0" title="function: SecurityState AArch64.CurrentSecurityState()">AArch64.CurrentSecurityState</a>();
    boolean InD = FALSE;
    <a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> pspace = <a href="shared_pseudocode.html#impl-shared.PARTIDspaceFromSS.1" title="function: PARTIDspaceType PARTIDspaceFromSS(SecurityState security)">PARTIDspaceFromSS</a>(security);
    if pspace == <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.MPAMisEnabled.0" title="function: boolean MPAMisEnabled()">MPAMisEnabled</a>() then
        return <a href="shared_pseudocode.html#impl-shared.DefaultMPAMinfo.1" title="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        (validEL, mpamEL) = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(PSTATE.M);
    else
        mpamEL = PSTATE.EL;
        validEL = TRUE;
    case acctype of
        when <a href="shared_pseudocode.html#AccType_IFETCH" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IFETCH</a>, <a href="shared_pseudocode.html#AccType_IC" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_IC</a>
            InD = TRUE;
        otherwise
            // other access types are DATA accesses
            InD = FALSE;
    if !validEL then
        return <a href="shared_pseudocode.html#impl-shared.DefaultMPAMinfo.1" title="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    elsif MPAMIDR_EL1.HAS_ALTSP == '1' then
        // Substitute alternative PARTID space if selected
        pspace = <a href="shared_pseudocode.html#impl-shared.AltPARTIDspace.3" title="function: PARTIDspaceType AltPARTIDspace(bits(2) el, SecurityState security,&#13; PARTIDspaceType primaryPIdSpace)">AltPARTIDspace</a>(mpamEL, security, pspace);
    if <a href="shared_pseudocode.html#impl-shared.HaveEMPAMExt.0" title="function: boolean HaveEMPAMExt()">HaveEMPAMExt</a>() &amp;&amp; security == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        if MPAM3_EL3.FORCE_NS == '1' then
            pspace = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
        if MPAM3_EL3.SDEFLT == '1' then
            return <a href="shared_pseudocode.html#impl-shared.DefaultMPAMinfo.1" title="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    if !<a href="shared_pseudocode.html#impl-shared.MPAMisEnabled.0" title="function: boolean MPAMisEnabled()">MPAMisEnabled</a>() then
        return <a href="shared_pseudocode.html#impl-shared.DefaultMPAMinfo.1" title="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(pspace);
    else
        return <a href="shared_pseudocode.html#impl-shared.genMPAM.3" title="function: MPAMinfo genMPAM(bits(2) el, boolean InD, PARTIDspaceType pspace)">genMPAM</a>(mpamEL, InD, pspace);</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.MAP_vPARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/MAP_vPARTID</h3>
      <p class="pseudocode">// MAP_vPARTID()
// =============
// Performs conversion of virtual PARTID into physical PARTID
// Contains all of the error checking and implementation
// choices for the conversion.

(PARTIDtype, boolean) <a id="impl-shared.MAP_vPARTID.1"/>MAP_vPARTID(<a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> vpartid)
    // should not ever be called if EL2 is not implemented
    // or is implemented but not enabled in the current
    // security state.
    <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> ret;
    boolean err;
    integer virt    = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vpartid);
    integer vpmrmax = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MPAMIDR_EL1.VPMR_MAX);

    // vpartid_max is largest vpartid supported
    integer vpartid_max = (vpmrmax &lt;&lt; 2) + 3;

    // One of many ways to reduce vpartid to value less than vpartid_max.
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(vpartid) &gt; vpartid_max then
        virt = virt MOD (vpartid_max+1);

    // Check for valid mapping entry.
    if MPAMVPMV_EL2&lt;virt&gt; == '1' then
        // vpartid has a valid mapping so access the map.
        ret = <a href="shared_pseudocode.html#impl-shared.mapvpmw.1" title="function: PARTIDtype mapvpmw(integer vpartid)">mapvpmw</a>(virt);
        err = FALSE;

    // Is the default virtual PARTID valid?
    elsif MPAMVPMV_EL2&lt;0&gt; == '1' then
        // Yes, so use default mapping for vpartid == 0.
        ret = MPAMVPM0_EL2&lt;0 +: 16&gt;;
        err = FALSE;

    // Neither is valid so use default physical PARTID.
    else
        ret = <a href="shared_pseudocode.html#DefaultPARTID" title="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>;
        err = TRUE;

    // Check that the physical PARTID is in-range.
    // This physical PARTID came from a virtual mapping entry.
    integer partid_max = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MPAMIDR_EL1.PARTID_MAX);
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(ret) &gt; partid_max then
        // Out of range, so return default physical PARTID
        ret = <a href="shared_pseudocode.html#DefaultPARTID" title="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>;
        err = TRUE;
    return (ret, err);</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.MPAMisEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/MPAMisEnabled</h3>
      <p class="pseudocode">// MPAMisEnabled()
// ===============
// Returns TRUE if MPAMisEnabled.

boolean <a id="impl-shared.MPAMisEnabled.0"/>MPAMisEnabled()
    el = <a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()">HighestEL</a>();
    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> return MPAM3_EL3.MPAMEN == '1';
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> return MPAM2_EL2.MPAMEN == '1';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> return MPAM1_EL1.MPAMEN == '1';</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.MPAMisVirtual"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/MPAMisVirtual</h3>
      <p class="pseudocode">// MPAMisVirtual()
// ===============
// Returns TRUE if MPAM is configured to be virtual at EL.

boolean <a id="impl-shared.MPAMisVirtual.1"/>MPAMisVirtual(bits(2) el)
    return (MPAMIDR_EL1.HAS_HCR == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
            ((el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; MPAMHCR_EL2.EL0_VPMEN == '1' &amp;&amp;
               (HCR_EL2.E2H == '0' || HCR_EL2.TGE == '0')) ||
             (el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; MPAMHCR_EL2.EL1_VPMEN == '1')));</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.PARTIDspaceFromSS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/PARTIDspaceFromSS</h3>
      <p class="pseudocode">// PARTIDspaceFromSS()
// ===================
// Returns the primary PARTID space from the Security State.

PARTIDspaceType <a id="impl-shared.PARTIDspaceFromSS.1"/>PARTIDspaceFromSS(<a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security)
    case security of
        when <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>
            return <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
        when <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>
            return <a href="shared_pseudocode.html#PIdSpace_Root" title="constant PARTIDspaceType PIdSpace_Root = '10'">PIdSpace_Root</a>;
        when <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>
            return <a href="shared_pseudocode.html#PIdSpace_Realm" title="constant PARTIDspaceType PIdSpace_Realm = '11'">PIdSpace_Realm</a>;
        when <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>
            return <a href="shared_pseudocode.html#PIdSpace_Secure" title="constant PARTIDspaceType PIdSpace_Secure = '00'">PIdSpace_Secure</a>;
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.UsePrimarySpaceEL10"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/UsePrimarySpaceEL10</h3>
      <p class="pseudocode">// UsePrimarySpaceEL10()
// =====================
// Checks whether Primary space is configured in the
// MPAM3_EL3 and MPAM2_EL2 ALTSP control bits that affect
// MPAM ALTSP use at EL1 and EL0.

boolean <a id="impl-shared.UsePrimarySpaceEL10.0"/>UsePrimarySpaceEL10()
    boolean hen3 = MPAM3_EL3.ALTSP_HEN == '1';
    return ((!hen3 &amp;&amp; MPAM3_EL3.ALTSP_HFC == '0') ||
            ( hen3 &amp;&amp; MPAM2_EL2.ALTSP_HFC == '0'));</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.UsePrimarySpaceEL2"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/UsePrimarySpaceEL2</h3>
      <p class="pseudocode">// UsePrimarySpaceEL2()
// ====================
// Checks whether Primary space is configured in the
// MPAM3_EL3 and MPAM2_EL2 ALTSP control bits that affect
// MPAM ALTSP use at EL2.

boolean <a id="impl-shared.UsePrimarySpaceEL2.0"/>UsePrimarySpaceEL2()
    boolean hen3 = MPAM3_EL3.ALTSP_HEN == '1';
    return ((!hen3 &amp;&amp; MPAM3_EL3.ALTSP_HFC == '0') ||
            ( hen3 &amp;&amp; MPAM2_EL2.ALTSP_EL2 == '0'));</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.genMPAM"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/genMPAM</h3>
      <p class="pseudocode">// genMPAM()
// =========
// Returns MPAMinfo for exception level el.
// If InD is TRUE returns MPAM information using PARTID_I and PMG_I fields
// of MPAMel_ELx register and otherwise using PARTID_D and PMG_D fields.
// Produces a PARTID in PARTID space pspace.

MPAMinfo <a id="impl-shared.genMPAM.3"/>genMPAM(bits(2) el, boolean InD, <a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> pspace)
    <a href="shared_pseudocode.html#MPAMinfo" title="type MPAMinfo is ( PARTIDspaceType mpam_sp, PARTIDtype partid, PMGtype pmg )">MPAMinfo</a> returninfo;
    <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> partidel;
    boolean perr;
    // gstplk is guest OS application locked by the EL2 hypervisor to
    // only use EL1 the virtual machine's PARTIDs.
    boolean gstplk = (el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp;
                      MPAMHCR_EL2.GSTAPP_PLK == '1' &amp;&amp;
                      HCR_EL2.TGE == '0');
    bits(2) eff_el = if gstplk then <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> else el;
    (partidel, perr) = <a href="shared_pseudocode.html#impl-shared.genPARTID.2" title="function: (PARTIDtype, boolean) genPARTID(bits(2) el, boolean InD)">genPARTID</a>(eff_el, InD);
    <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> groupel  = <a href="shared_pseudocode.html#impl-shared.genPMG.3" title="function: PMGtype genPMG(bits(2) el, boolean InD, boolean partid_err)">genPMG</a>(eff_el, InD, perr);
    returninfo.mpam_sp = pspace;
    returninfo.partid  = partidel;
    returninfo.pmg     = groupel;
    return returninfo;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.genMPAMel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/genMPAMel</h3>
      <p class="pseudocode">// genMPAMel()
// ===========
// Returns MPAMinfo for specified EL in the current security state.
// InD is TRUE for instruction access and FALSE otherwise.

MPAMinfo <a id="impl-shared.genMPAMel.2"/>genMPAMel(bits(2) el, boolean InD)
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> security = <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(el);
    <a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> space = <a href="shared_pseudocode.html#impl-shared.PARTIDspaceFromSS.1" title="function: PARTIDspaceType PARTIDspaceFromSS(SecurityState security)">PARTIDspaceFromSS</a>(security);
    boolean use_default = !(<a href="shared_pseudocode.html#impl-shared.HaveMPAMExt.0" title="function: boolean HaveMPAMExt()">HaveMPAMExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.MPAMisEnabled.0" title="function: boolean MPAMisEnabled()">MPAMisEnabled</a>());
    <a href="shared_pseudocode.html#PARTIDspaceType" title="type PARTIDspaceType">PARTIDspaceType</a> altspace = <a href="shared_pseudocode.html#impl-shared.AltPARTIDspace.3" title="function: PARTIDspaceType AltPARTIDspace(bits(2) el, SecurityState security,&#13; PARTIDspaceType primaryPIdSpace)">AltPARTIDspace</a>(el, security, space);
    space = altspace;
    if <a href="shared_pseudocode.html#impl-shared.HaveEMPAMExt.0" title="function: boolean HaveEMPAMExt()">HaveEMPAMExt</a>() &amp;&amp; security == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        if MPAM3_EL3.FORCE_NS == '1' then
            space = <a href="shared_pseudocode.html#PIdSpace_NonSecure" title="constant PARTIDspaceType PIdSpace_NonSecure = '01'">PIdSpace_NonSecure</a>;
        if MPAM3_EL3.SDEFLT == '1' then
            use_default = TRUE;
    if !use_default then
        return <a href="shared_pseudocode.html#impl-shared.genMPAM.3" title="function: MPAMinfo genMPAM(bits(2) el, boolean InD, PARTIDspaceType pspace)">genMPAM</a>(el, InD, space);
    else
        return <a href="shared_pseudocode.html#impl-shared.DefaultMPAMinfo.1" title="function: MPAMinfo DefaultMPAMinfo(PARTIDspaceType partidspace)">DefaultMPAMinfo</a>(space);</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.genPARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/genPARTID</h3>
      <p class="pseudocode">// genPARTID()
// ===========
// Returns physical PARTID and error boolean for exception level el.
// If InD is TRUE then PARTID is from MPAMel_ELx.PARTID_I and
// otherwise from MPAMel_ELx.PARTID_D.

(PARTIDtype, boolean) <a id="impl-shared.genPARTID.2"/>genPARTID(bits(2) el, boolean InD)
    <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> partidel = <a href="shared_pseudocode.html#impl-shared.getMPAM_PARTID.2" title="function: PARTIDtype getMPAM_PARTID(bits(2) MPAMn, boolean InD)">getMPAM_PARTID</a>(el, InD);
    <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> partid_max = MPAMIDR_EL1.PARTID_MAX;
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(partidel) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(partid_max) then
        return (<a href="shared_pseudocode.html#DefaultPARTID" title="constant PARTIDtype DefaultPARTID = 0&lt;15:0&gt;">DefaultPARTID</a>, TRUE);
    if <a href="shared_pseudocode.html#impl-shared.MPAMisVirtual.1" title="function: boolean MPAMisVirtual(bits(2) el)">MPAMisVirtual</a>(el) then
        return <a href="shared_pseudocode.html#impl-shared.MAP_vPARTID.1" title="function: (PARTIDtype, boolean) MAP_vPARTID(PARTIDtype vpartid)">MAP_vPARTID</a>(partidel);
    else
        return (partidel, FALSE);</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.genPMG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/genPMG</h3>
      <p class="pseudocode">// genPMG()
// ========
// Returns PMG for exception level el and I- or D-side (InD).
// If PARTID generation (genPARTID) encountered an error, genPMG() should be
// called with partid_err as TRUE.

PMGtype <a id="impl-shared.genPMG.3"/>genPMG(bits(2) el, boolean InD, boolean partid_err)
    integer pmg_max = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(MPAMIDR_EL1.PMG_MAX);
    // It is CONSTRAINED UNPREDICTABLE whether partid_err forces PMG to
    // use the default or if it uses the PMG from getMPAM_PMG.
    if partid_err then
        return <a href="shared_pseudocode.html#DefaultPMG" title="constant PMGtype DefaultPMG = 0&lt;7:0&gt;">DefaultPMG</a>;
    <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> groupel = <a href="shared_pseudocode.html#impl-shared.getMPAM_PMG.2" title="function: PMGtype getMPAM_PMG(bits(2) MPAMn, boolean InD)">getMPAM_PMG</a>(el, InD);
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(groupel) &lt;= pmg_max then
        return groupel;
    return <a href="shared_pseudocode.html#DefaultPMG" title="constant PMGtype DefaultPMG = 0&lt;7:0&gt;">DefaultPMG</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.getMPAM_PARTID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/getMPAM_PARTID</h3>
      <p class="pseudocode">// getMPAM_PARTID()
// ================
// Returns a PARTID from one of the MPAMn_ELx registers.
// MPAMn selects the MPAMn_ELx register used.
// If InD is TRUE, selects the PARTID_I field of that
// register.  Otherwise, selects the PARTID_D field.

PARTIDtype <a id="impl-shared.getMPAM_PARTID.2"/>getMPAM_PARTID(bits(2) MPAMn, boolean InD)
    <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> partid;
    boolean el2avail = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    if InD then
        case MPAMn of
            when '11' partid = MPAM3_EL3.PARTID_I;
            when '10' partid = if el2avail then MPAM2_EL2.PARTID_I else <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
            when '01' partid = MPAM1_EL1.PARTID_I;
            when '00' partid = MPAM0_EL1.PARTID_I;
            otherwise partid = <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> UNKNOWN;
    else
        case MPAMn of
            when '11' partid = MPAM3_EL3.PARTID_D;
            when '10' partid = if el2avail then MPAM2_EL2.PARTID_D else <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
            when '01' partid = MPAM1_EL1.PARTID_D;
            when '00' partid = MPAM0_EL1.PARTID_D;
            otherwise partid = <a href="shared_pseudocode.html#PARTIDtype" title="type PARTIDtype">PARTIDtype</a> UNKNOWN;
    return partid;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.getMPAM_PMG"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/getMPAM_PMG</h3>
      <p class="pseudocode">// getMPAM_PMG()
// =============
// Returns a PMG from one of the MPAMn_ELx registers.
// MPAMn selects the MPAMn_ELx register used.
// If InD is TRUE, selects the PMG_I field of that
// register.  Otherwise, selects the PMG_D field.

PMGtype <a id="impl-shared.getMPAM_PMG.2"/>getMPAM_PMG(bits(2) MPAMn, boolean InD)
    <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> pmg;
    boolean el2avail = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();

    if InD then
        case MPAMn of
            when '11' pmg = MPAM3_EL3.PMG_I;
            when '10' pmg = if el2avail then MPAM2_EL2.PMG_I else <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
            when '01' pmg = MPAM1_EL1.PMG_I;
            when '00' pmg = MPAM0_EL1.PMG_I;
            otherwise pmg = <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> UNKNOWN;
    else
        case MPAMn of
            when '11' pmg = MPAM3_EL3.PMG_D;
            when '10' pmg = if el2avail then MPAM2_EL2.PMG_D else <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
            when '01' pmg = MPAM1_EL1.PMG_D;
            when '00' pmg = MPAM0_EL1.PMG_D;
            otherwise pmg = <a href="shared_pseudocode.html#PMGtype" title="type PMGtype">PMGtype</a> UNKNOWN;
    return pmg;</p>
    </div>
    <div class="ps"><a id="shared.functions.mpam.mapvpmw"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/mpam/mapvpmw</h3>
      <p class="pseudocode">// mapvpmw()
// =========
// Map a virtual PARTID into a physical PARTID using
// the MPAMVPMn_EL2 registers.
// vpartid is now assumed in-range and valid (checked by caller)
// returns physical PARTID from mapping entry.

PARTIDtype <a id="impl-shared.mapvpmw.1"/>mapvpmw(integer vpartid)
    bits(64) vpmw;
    integer  wd = vpartid DIV 4;
    case wd of
        when 0 vpmw = MPAMVPM0_EL2;
        when 1 vpmw = MPAMVPM1_EL2;
        when 2 vpmw = MPAMVPM2_EL2;
        when 3 vpmw = MPAMVPM3_EL2;
        when 4 vpmw = MPAMVPM4_EL2;
        when 5 vpmw = MPAMVPM5_EL2;
        when 6 vpmw = MPAMVPM6_EL2;
        when 7 vpmw = MPAMVPM7_EL2;
        otherwise vpmw = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
    // vpme_lsb selects LSB of field within register
    integer vpme_lsb = (vpartid MOD 4) * 16;
    return vpmw&lt;vpme_lsb +: 16&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.ASID"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/ASID</h3>
      <p class="pseudocode">// ASID[]
// ======
// Effective ASID.

bits(16) <a id="impl-shared.ASID.read.0"/>ASID[]
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; HCR_EL2.&lt;E2H, TGE&gt; == '11' then
        if TCR_EL2.A1 == '1' then
            return TTBR1_EL2.ASID;
        else
            return TTBR0_EL2.ASID;

    elsif !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>) then
        if TCR_EL1.A1 == '1' then
            return TTBR1_EL1.ASID;
        else
            return TTBR0_EL1.ASID;

    else
        if TTBCR.EAE == '0' then
            return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(CONTEXTIDR.ASID, 16);
        else
            if TTBCR.A1 == '1' then
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR1.ASID, 16);
            else
                return <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(TTBR0.ASID, 16);</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.ExecutionCntxt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/ExecutionCntxt</h3>
      <p class="pseudocode">type <a id="ExecutionCntxt"/>ExecutionCntxt is (
    boolean          is_vmid_valid, // is vmid valid for current context
    boolean          all_vmid,      // should the operation be applied for all vmids
    bits(16)         vmid,          // if all_vmid = FALSE, vmid to which operation is applied
    boolean          is_asid_valid, // is asid valid for current context
    boolean          all_asid,      // should the operation be applied for all asids
    bits(16)         asid,          // if all_asid = FALSE, ASID to which operation is applied
    bits(2)          target_el,     // target EL at which operation is performed
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a>    security,
    <a href="shared_pseudocode.html#RestrictType" title="enumeration RestrictType {&#13; RestrictType_DataValue,&#13; RestrictType_ControlFlow,&#13; RestrictType_CachePrefetch&#13; }">RestrictType</a>     restriction    // type of restriction operation
)</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.RESTRICT_PREDICTIONS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/RESTRICT_PREDICTIONS</h3>
      <p class="pseudocode">// RESTRICT_PREDICTIONS()
// ======================
// Clear all speculated values.

<a id="impl-shared.RESTRICT_PREDICTIONS.1"/>RESTRICT_PREDICTIONS(<a href="shared_pseudocode.html#ExecutionCntxt" title="type ExecutionCntxt is ( boolean is_vmid_valid, boolean all_vmid, bits(16) vmid, boolean is_asid_valid, boolean all_asid, bits(16) asid, bits(2) target_el, SecurityState security, RestrictType restriction )">ExecutionCntxt</a> c)
    IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.RestrictType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/RestrictType</h3>
      <p class="pseudocode">enumeration <a id="RestrictType"/>RestrictType {
    <a id="RestrictType_DataValue"/>RestrictType_DataValue,
    <a id="RestrictType_ControlFlow"/>RestrictType_ControlFlow,
    <a id="RestrictType_CachePrefetch"/>RestrictType_CachePrefetch
};</p>
    </div>
    <div class="ps"><a id="shared.functions.predictionrestrict.TargetSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/predictionrestrict/TargetSecurityState</h3>
      <p class="pseudocode">// TargetSecurityState()
// =====================
// Decode the target security state for the prediction context.

SecurityState <a id="impl-shared.TargetSecurityState.2"/>TargetSecurityState(bit NS, bit NSE)
    curr_ss =  <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(PSTATE.EL);
    if curr_ss == <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a> then
        return <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    elsif curr_ss == <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a> then
        case NS of
            when '0' return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
            when '1' return <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        if curr_ss == <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a> then
            case NSE:NS of
                when '00' return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>;
                when '01' return <a href="shared_pseudocode.html#SS_NonSecure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_NonSecure</a>;
                when '11' return <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>;
                when '10' return <a href="shared_pseudocode.html#SS_Root" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Root</a>;
        elsif curr_ss == <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a> then
            return <a href="shared_pseudocode.html#SS_Realm" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Realm</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.BranchTo"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/BranchTo</h3>
      <p class="pseudocode">// BranchTo()
// ==========
// Set program counter to a new address, with a branch type.
// Parameter branch_conditional indicates whether the executed branch has a conditional encoding.
// In AArch64 state the address might include a tag in the top eight bits.

<a id="impl-shared.BranchTo.3"/>BranchTo(bits(N) target, <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type, boolean branch_conditional)
    <a href="shared_pseudocode.html#impl-shared.Hint_Branch.1" title="function: Hint_Branch(BranchType hint)">Hint_Branch</a>(branch_type);
    if N == 32 then
        assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
        _PC = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(target);
    else
        assert N == 64 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
        bits(64) target_vaddress = <a href="shared_pseudocode.html#AArch64.BranchAddr.1" title="function: bits(64) AArch64.BranchAddr(bits(64) vaddress)">AArch64.BranchAddr</a>(target&lt;63:0&gt;);
        if (<a href="shared_pseudocode.html#impl-shared.HaveBRBExt.0" title="function: boolean HaveBRBExt()">HaveBRBExt</a>() &amp;&amp;
            branch_type IN {<a href="shared_pseudocode.html#BranchType_DIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIR</a>, <a href="shared_pseudocode.html#BranchType_INDIR" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDIR</a>,
                            <a href="shared_pseudocode.html#BranchType_DIRCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_DIRCALL</a>, <a href="shared_pseudocode.html#BranchType_INDCALL" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_INDCALL</a>,
                            <a href="shared_pseudocode.html#BranchType_RET" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType_RET</a>}) then
            <a href="shared_pseudocode.html#impl-aarch64.BRBEBranch.3" title="function: BRBEBranch(BranchType br_type, boolean cond, bits(64) target_address)">BRBEBranch</a>(branch_type, branch_conditional, target_vaddress);
        _PC = target_vaddress;
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.BranchToAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/BranchToAddr</h3>
      <p class="pseudocode">// BranchToAddr()
// ==============
// Set program counter to a new address, with a branch type.
// In AArch64 state the address does not include a tag in the top eight bits.

<a id="impl-shared.BranchToAddr.2"/>BranchToAddr(bits(N) target, <a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> branch_type)
    <a href="shared_pseudocode.html#impl-shared.Hint_Branch.1" title="function: Hint_Branch(BranchType hint)">Hint_Branch</a>(branch_type);
    if N == 32 then
        assert <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
        _PC = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(target);
    else
        assert N == 64 &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
        _PC = target&lt;63:0&gt;;
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.BranchType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/BranchType</h3>
      <p class="pseudocode">enumeration <a id="BranchType"/>BranchType {
    <a id="BranchType_DIRCALL"/>BranchType_DIRCALL,     // Direct Branch with link
    <a id="BranchType_INDCALL"/>BranchType_INDCALL,     // Indirect Branch with link
    <a id="BranchType_ERET"/>BranchType_ERET,        // Exception return (indirect)
    <a id="BranchType_DBGEXIT"/>BranchType_DBGEXIT,     // Exit from Debug state
    <a id="BranchType_RET"/>BranchType_RET,         // Indirect branch with function return hint
    <a id="BranchType_DIR"/>BranchType_DIR,         // Direct branch
    <a id="BranchType_INDIR"/>BranchType_INDIR,       // Indirect branch
    <a id="BranchType_EXCEPTION"/>BranchType_EXCEPTION,   // Exception entry
    <a id="BranchType_TMFAIL"/>BranchType_TMFAIL,      // Transaction failure
    <a id="BranchType_RESET"/>BranchType_RESET,       // Reset
    <a id="BranchType_UNKNOWN"/>BranchType_UNKNOWN};    // Other</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.Hint_Branch"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/Hint_Branch</h3>
      <p class="pseudocode">// Report the hint passed to BranchTo() and BranchToAddr(), for consideration when processing
// the next instruction.
<a id="impl-shared.Hint_Branch.1"/>Hint_Branch(<a href="shared_pseudocode.html#BranchType" title="enumeration BranchType {&#13; BranchType_DIRCALL, BranchType_INDCALL, BranchType_ERET, BranchType_DBGEXIT, BranchType_RET, BranchType_DIR, BranchType_INDIR, BranchType_EXCEPTION, BranchType_TMFAIL, BranchType_RESET, BranchType_UNKNOWN}">BranchType</a> hint);</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.NextInstrAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/NextInstrAddr</h3>
      <p class="pseudocode">// Return address of the sequentially next instruction.
bits(N) <a id="impl-shared.NextInstrAddr.0"/>NextInstrAddr();</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.ResetExternalDebugRegisters"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/ResetExternalDebugRegisters</h3>
      <p class="pseudocode">// Reset the External Debug registers in the Core power domain.
<a id="impl-shared.ResetExternalDebugRegisters.1"/>ResetExternalDebugRegisters(boolean cold_reset);</p>
    </div>
    <div class="ps"><a id="shared.functions.registers.ThisInstrAddr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/ThisInstrAddr</h3>
      <p class="pseudocode">// ThisInstrAddr()
// ===============
// Return address of the current instruction.

bits(N) <a id="impl-shared.ThisInstrAddr.0"/>ThisInstrAddr()
    assert N == 64 || (N == 32 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>());
    return _PC&lt;N-1:0&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers._PC"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/_PC</h3>
      <p class="pseudocode">bits(64) _PC;</p>
    </div>
    <div class="ps"><a id="shared.functions.registers._R"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/registers/_R</h3>
      <p class="pseudocode">array bits(64) _R[0..30];</p>
    </div>
    <div class="ps"><a id="shared.functions.sysregisters.SPSR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/sysregisters/SPSR</h3>
      <p class="pseudocode">// SPSR[] - non-assignment form
// ============================

bits(N) <a id="impl-shared.SPSR.read.0"/>SPSR[]
    bits(N) result;
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        assert N == 32;
        case PSTATE.M of
            when <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>      result = SPSR_fiq&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>      result = SPSR_irq&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>      result = SPSR_svc&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>  result = SPSR_mon&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>    result = SPSR_abt&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>      result = SPSR_hyp&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>    result = SPSR_und&lt;N-1:0&gt;;
            otherwise         <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    else
        assert N == 64;
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>          result = SPSR_EL1&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>          result = SPSR_EL2&lt;N-1:0&gt;;
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>          result = SPSR_EL3&lt;N-1:0&gt;;
            otherwise         <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return result;

// SPSR[] - assignment form
// ========================

<a id="impl-shared.SPSR.write.0"/>SPSR[] = bits(N) value
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        assert N == 32;
        case PSTATE.M of
            when <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>      SPSR_fiq = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>      SPSR_irq = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>      SPSR_svc = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>  SPSR_mon = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>    SPSR_abt = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>      SPSR_hyp = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>    SPSR_und = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            otherwise         <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    else
        assert N == 64;
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>          SPSR_EL1 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>          SPSR_EL2 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>          SPSR_EL3 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(value);
            otherwise         <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ArchVersion"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ArchVersion</h3>
      <p class="pseudocode">enumeration <a id="ArchVersion"/>ArchVersion {
    <a id="ARMv8p0"/>ARMv8p0
    , <a id="ARMv8p1"/>ARMv8p1
    , <a id="ARMv8p2"/>ARMv8p2
    , <a id="ARMv8p3"/>ARMv8p3
    , <a id="ARMv8p4"/>ARMv8p4
    , <a id="ARMv8p5"/>ARMv8p5
    , <a id="ARMv8p6"/>ARMv8p6
    , <a id="ARMv8p7"/>ARMv8p7
    , <a id="ARMv8p8"/>ARMv8p8
};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.BranchTargetCheck"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/BranchTargetCheck</h3>
      <p class="pseudocode">// BranchTargetCheck()
// ===================
// This function is executed checks if the current instruction is a valid target for a branch
// taken into, or inside, a guarded page. It is executed on every cycle once the current
// instruction has been decoded and the values of InGuardedPage and BTypeCompatible have been
// determined for the current instruction.

<a id="impl-shared.BranchTargetCheck.0"/>BranchTargetCheck()
    assert <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();

    // The branch target check considers two state variables:
    // * InGuardedPage, which is evaluated during instruction fetch.
    // * BTypeCompatible, which is evaluated during instruction decode.
    if InGuardedPage &amp;&amp; PSTATE.BTYPE != '00' &amp;&amp; !BTypeCompatible &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.Halted.0" title="function: boolean Halted()">Halted</a>() then
        bits(64) pc = <a href="shared_pseudocode.html#impl-shared.ThisInstrAddr.0" title="function: bits(N) ThisInstrAddr()">ThisInstrAddr</a>();
        <a href="shared_pseudocode.html#AArch64.BranchTargetException.1" title="function: AArch64.BranchTargetException(bits(52) vaddress)">AArch64.BranchTargetException</a>(pc&lt;51:0&gt;);

    boolean branch_instr = <a href="shared_pseudocode.html#AArch64.ExecutingBROrBLROrRetInstr.0" title="function: boolean AArch64.ExecutingBROrBLROrRetInstr()">AArch64.ExecutingBROrBLROrRetInstr</a>();
    boolean bti_instr    = <a href="shared_pseudocode.html#AArch64.ExecutingBTIInstr.0" title="function: boolean AArch64.ExecutingBTIInstr()">AArch64.ExecutingBTIInstr</a>();

    // PSTATE.BTYPE defaults to 00 for instructions that do not explictly set BTYPE.
    if !(branch_instr || bti_instr) then
        BTypeNext = '00';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ClearEventRegister"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ClearEventRegister</h3>
      <p class="pseudocode">// ClearEventRegister()
// ====================
// Clear the Event Register of this PE.

<a id="impl-shared.ClearEventRegister.0"/>ClearEventRegister()
    EventRegister = '0';
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ClearPendingPhysicalSError"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ClearPendingPhysicalSError</h3>
      <p class="pseudocode">// Clear a pending physical SError interrupt.
<a id="impl-shared.ClearPendingPhysicalSError.0"/>ClearPendingPhysicalSError();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ClearPendingVirtualSError"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ClearPendingVirtualSError</h3>
      <p class="pseudocode">// Clear a pending virtual SError interrupt.
<a id="impl-shared.ClearPendingVirtualSError.0"/>ClearPendingVirtualSError();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ConditionHolds"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ConditionHolds</h3>
      <p class="pseudocode">// ConditionHolds()
// ================
// Return TRUE iff COND currently holds

boolean <a id="impl-shared.ConditionHolds.1"/>ConditionHolds(bits(4) cond)
    // Evaluate base condition.
    case cond&lt;3:1&gt; of
        when '000' result = (PSTATE.Z == '1');                          // EQ or NE
        when '001' result = (PSTATE.C == '1');                          // CS or CC
        when '010' result = (PSTATE.N == '1');                          // MI or PL
        when '011' result = (PSTATE.V == '1');                          // VS or VC
        when '100' result = (PSTATE.C == '1' &amp;&amp; PSTATE.Z == '0');       // HI or LS
        when '101' result = (PSTATE.N == PSTATE.V);                     // GE or LT
        when '110' result = (PSTATE.N == PSTATE.V &amp;&amp; PSTATE.Z == '0');  // GT or LE
        when '111' result = TRUE;                                       // AL

    // Condition flag values in the set '111x' indicate always true
    // Otherwise, invert condition if necessary.
    if cond&lt;0&gt; == '1' &amp;&amp; cond != '1111' then
        result = !result;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ConsumptionOfSpeculativeDataBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ConsumptionOfSpeculativeDataBarrier</h3>
      <p class="pseudocode"><a id="impl-shared.ConsumptionOfSpeculativeDataBarrier.0"/>ConsumptionOfSpeculativeDataBarrier();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.CurrentInstrSet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/CurrentInstrSet</h3>
      <p class="pseudocode">// CurrentInstrSet()
// =================

InstrSet <a id="impl-shared.CurrentInstrSet.0"/>CurrentInstrSet()
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then
        result = if PSTATE.T == '0' then <a href="shared_pseudocode.html#InstrSet_A32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A32</a> else <a href="shared_pseudocode.html#InstrSet_T32" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_T32</a>;
        // PSTATE.J is RES0. Implementation of T32EE or Jazelle state not permitted.
    else
        result = <a href="shared_pseudocode.html#InstrSet_A64" title="enumeration InstrSet {InstrSet_A64, InstrSet_A32, InstrSet_T32}">InstrSet_A64</a>;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.CurrentPL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/CurrentPL</h3>
      <p class="pseudocode">// CurrentPL()
// ===========

PrivilegeLevel <a id="impl-shared.CurrentPL.0"/>CurrentPL()
    return <a href="shared_pseudocode.html#impl-shared.PLOfEL.1" title="function: PrivilegeLevel PLOfEL(bits(2) el)">PLOfEL</a>(PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.DSBAlias"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/DSBAlias</h3>
      <p class="pseudocode">enumeration <a id="DSBAlias"/>DSBAlias {<a id="DSBAlias_SSBB"/>DSBAlias_SSBB, <a id="DSBAlias_PSSBB"/>DSBAlias_PSSBB, <a id="DSBAlias_DSB"/>DSBAlias_DSB};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EL0"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EL0</h3>
      <p class="pseudocode">constant bits(2) <a id="EL3"/>EL3 = '11';
constant bits(2) <a id="EL2"/>EL2 = '10';
constant bits(2) <a id="EL1"/>EL1 = '01';
constant bits(2) <a id="EL0"/>EL0 = '00';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EL2Enabled</h3>
      <p class="pseudocode">// EL2Enabled()
// ============
// Returns TRUE if EL2 is present and executing
// - with SCR_EL3.NS==1 when Non-secure EL2 is implemented, or
// - with SCR_EL3.NS==1 when Realm EL2 is implemented, or
// - with SCR_EL3.NS==0 when Secure EL2 is implemented and enabled, or
// - when EL3 is not implemented.

boolean <a id="impl-shared.EL2Enabled.0"/>EL2Enabled()
    return <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || SCR_EL3.NS == '1' || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELFromM32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELFromM32</h3>
      <p class="pseudocode">// ELFromM32()
// ===========

(boolean,bits(2)) <a id="impl-shared.ELFromM32.1"/>ELFromM32(bits(5) mode)
    // Convert an AArch32 mode encoding to an Exception level.
    // Returns (valid,EL):
    //   'valid' is TRUE if 'mode&lt;4:0&gt;' encodes a mode that is both valid for this implementation
    //           and the current value of SCR.NS/SCR_EL3.NS.
    //   'EL'    is the Exception level decoded from 'mode'.
    bits(2) el;
    boolean valid = !<a href="shared_pseudocode.html#impl-aarch32.BadMode.1" title="function: boolean BadMode(bits(5) mode)">BadMode</a>(mode);  // Check for modes that are not valid for this implementation
    case mode of
        when <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a>
            el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
        when <a href="shared_pseudocode.html#M32_Hyp" title="constant bits(5) M32_Hyp = '11010'">M32_Hyp</a>
            el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
            valid = valid &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '1');
        when <a href="shared_pseudocode.html#M32_FIQ" title="constant bits(5) M32_FIQ = '10001'">M32_FIQ</a>, <a href="shared_pseudocode.html#M32_IRQ" title="constant bits(5) M32_IRQ = '10010'">M32_IRQ</a>, <a href="shared_pseudocode.html#M32_Svc" title="constant bits(5) M32_Svc = '10011'">M32_Svc</a>, <a href="shared_pseudocode.html#M32_Abort" title="constant bits(5) M32_Abort = '10111'">M32_Abort</a>, <a href="shared_pseudocode.html#M32_Undef" title="constant bits(5) M32_Undef = '11011'">M32_Undef</a>, <a href="shared_pseudocode.html#M32_System" title="constant bits(5) M32_System = '11111'">M32_System</a>
            // If EL3 is implemented and using AArch32, then these modes are EL3 modes in Secure
            // state, and EL1 modes in Non-secure state. If EL3 is not implemented or is using
            // AArch64, then these modes are EL1 modes.
            el = (if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() &amp;&amp; SCR.NS == '0' then <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> else <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        when <a href="shared_pseudocode.html#M32_User" title="constant bits(5) M32_User = '10000'">M32_User</a>
            el = <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
        otherwise
            valid = FALSE;           // Passed an illegal mode value
    if !valid then el = bits(2) UNKNOWN;
    return (valid, el);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELFromSPSR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELFromSPSR</h3>
      <p class="pseudocode">// ELFromSPSR()
// ============

// Convert an SPSR value encoding to an Exception level.
// Returns (valid,EL):
//   'valid' is TRUE if 'spsr&lt;4:0&gt;' encodes a valid mode for the current state.
//   'EL'    is the Exception level decoded from 'spsr'.

(boolean,bits(2)) <a id="impl-shared.ELFromSPSR.1"/>ELFromSPSR(bits(N) spsr)
    if spsr&lt;4&gt; == '0' then                      // AArch64 state
        el = spsr&lt;3:2&gt;;
        if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then                  // No AArch64 support
            valid = FALSE;
        elsif !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el) then                  // Exception level not implemented
            valid = FALSE;
        elsif spsr&lt;1&gt; == '1' then               // M[1] must be 0
            valid = FALSE;
        elsif el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; spsr&lt;0&gt; == '1' then  // for EL0, M[0] must be 0
            valid = FALSE;
        elsif <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() &amp;&amp; (el IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>}) &amp;&amp; SCR_EL3.&lt;NSE,NS&gt; == '10' then
            valid = FALSE;
        elsif el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>() &amp;&amp; SCR_EL3.NS == '0' then
            valid = FALSE;                      // Unless Secure EL2 is enabled, EL2 only valid in Non-secure state
        else
            valid = TRUE;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() then                    // AArch32 state
        (valid, el) = <a href="shared_pseudocode.html#impl-shared.ELFromM32.1" title="function: (boolean,bits(2)) ELFromM32(bits(5) mode)">ELFromM32</a>(spsr&lt;4:0&gt;);
    else
        valid = FALSE;

    if !valid then el = bits(2) UNKNOWN;
    return (valid,el);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELIsInHost"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELIsInHost</h3>
      <p class="pseudocode">// ELIsInHost()
// ============

boolean <a id="impl-shared.ELIsInHost.1"/>ELIsInHost(bits(2) el)
    if !<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() || <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        return FALSE;
    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            return FALSE;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            return <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.E2H == '1';
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>
            return FALSE;
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>
            return <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; == '11';
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELStateUsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELStateUsingAArch32</h3>
      <p class="pseudocode">// ELStateUsingAArch32()
// =====================

boolean <a id="impl-shared.ELStateUsingAArch32.2"/>ELStateUsingAArch32(bits(2) el, boolean secure)
    // See ELStateUsingAArch32K() for description. Must only be called in circumstances where
    // result is valid (typically, that means 'el IN {EL1,EL2,EL3}').
    (known, aarch32) = <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32K.2" title="function: (boolean,boolean) ELStateUsingAArch32K(bits(2) el, boolean secure)">ELStateUsingAArch32K</a>(el, secure);
    assert known;
    return aarch32;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELStateUsingAArch32K"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELStateUsingAArch32K</h3>
      <p class="pseudocode">// ELStateUsingAArch32K()
// ======================

(boolean,boolean) <a id="impl-shared.ELStateUsingAArch32K.2"/>ELStateUsingAArch32K(bits(2) el, boolean secure)
    // Returns (known, aarch32):
    //   'known'   is FALSE for EL0 if the current Exception level is not EL0 and EL1 is
    //             using AArch64, since it cannot determine the state of EL0; TRUE otherwise.
    //   'aarch32' is TRUE if the specified Exception level is using AArch32; FALSE otherwise.
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch32EL.1" title="function: boolean HaveAArch32EL(bits(2) el)">HaveAArch32EL</a>(el) then
        return (TRUE, FALSE);                      // Exception level is using AArch64
    elsif secure &amp;&amp; el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        return (TRUE, FALSE);                      // Secure EL2 is using AArch64
    elsif !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        return (TRUE, TRUE);                       // Highest Exception level, and therefore all levels are using AArch32

    // Remainder of function deals with the interprocessing cases when highest Exception level is using AArch64

    boolean aarch32 = boolean UNKNOWN;
    boolean known = TRUE;

    aarch32_below_el3 = <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.RW == '0' &amp;&amp; (!secure || !<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() || SCR_EL3.EEL2 == '0');
    aarch32_at_el1 = (aarch32_below_el3 || (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp;
                                            ((<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() &amp;&amp; SCR_EL3.EEL2 == '1') || !secure) &amp;&amp; HCR_EL2.RW == '0' &amp;&amp;
                                            !(HCR_EL2.E2H == '1' &amp;&amp; HCR_EL2.TGE == '1' &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>())));
    if el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !aarch32_at_el1 then       // Only know if EL0 using AArch32 from PSTATE
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            aarch32 = PSTATE.nRW == '1';       // EL0 controlled by PSTATE
        else
            known = FALSE;                     // EL0 state is UNKNOWN
    else
        aarch32 = (aarch32_below_el3 &amp;&amp; el != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) || (aarch32_at_el1 &amp;&amp; el IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>,<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>});

    if !known then aarch32 = boolean UNKNOWN;
    return (known, aarch32);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELUsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELUsingAArch32</h3>
      <p class="pseudocode">// ELUsingAArch32()
// ================

boolean <a id="impl-shared.ELUsingAArch32.1"/>ELUsingAArch32(bits(2) el)
    return <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32.2" title="function: boolean ELStateUsingAArch32(bits(2) el, boolean secure)">ELStateUsingAArch32</a>(el, <a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ELUsingAArch32K"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ELUsingAArch32K</h3>
      <p class="pseudocode">// ELUsingAArch32K()
// =================

(boolean,boolean) <a id="impl-shared.ELUsingAArch32K.1"/>ELUsingAArch32K(bits(2) el)
    return <a href="shared_pseudocode.html#impl-shared.ELStateUsingAArch32K.2" title="function: (boolean,boolean) ELStateUsingAArch32K(bits(2) el, boolean secure)">ELStateUsingAArch32K</a>(el, <a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>());</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EndOfInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EndOfInstruction</h3>
      <p class="pseudocode">// Terminate processing of the current instruction.
<a id="impl-shared.EndOfInstruction.0"/>EndOfInstruction();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EnterLowPowerState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EnterLowPowerState</h3>
      <p class="pseudocode">// PE enters a low-power state.
<a id="impl-shared.EnterLowPowerState.0"/>EnterLowPowerState();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.EventRegister"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/EventRegister</h3>
      <p class="pseudocode">bits(1) EventRegister;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ExceptionalOccurrenceTargetState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ExceptionalOccurrenceTargetState</h3>
      <p class="pseudocode">enumeration <a id="ExceptionalOccurrenceTargetState"/>ExceptionalOccurrenceTargetState {
    <a id="AArch32_NonDebugState"/>AArch32_NonDebugState,
    <a id="AArch64_NonDebugState"/>AArch64_NonDebugState,
    <a id="DebugState"/>DebugState
};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.FIQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/FIQPending</h3>
      <p class="pseudocode">// Returns a tuple indicating if there is any pending physical FIQ
// and if the pending FIQ has superpriority.
(boolean, boolean) <a id="impl-shared.FIQPending.0"/>FIQPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.GetAccumulatedFPExceptions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/GetAccumulatedFPExceptions</h3>
      <p class="pseudocode">// Returns FP exceptions accumulated by the PE.
bits(8) <a id="impl-shared.GetAccumulatedFPExceptions.0"/>GetAccumulatedFPExceptions();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.GetPSRFromPSTATE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/GetPSRFromPSTATE</h3>
      <p class="pseudocode">// GetPSRFromPSTATE()
// ==================
// Return a PSR value which represents the current PSTATE

bits(N) <a id="impl-shared.GetPSRFromPSTATE.1"/>GetPSRFromPSTATE(<a href="shared_pseudocode.html#ExceptionalOccurrenceTargetState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">ExceptionalOccurrenceTargetState</a> targetELState)
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; (targetELState IN {<a href="shared_pseudocode.html#AArch32_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a>, <a href="shared_pseudocode.html#DebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</a>}) then
        assert N == 32;
    else
        assert N == 64;
    bits(N) spsr = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
    spsr&lt;31:28&gt; = PSTATE.&lt;N,Z,C,V&gt;;
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then spsr&lt;22&gt; = PSTATE.PAN;
    spsr&lt;20&gt;    = PSTATE.IL;
    if PSTATE.nRW == '1' then                           // AArch32 state
        spsr&lt;27&gt;    = PSTATE.Q;
        spsr&lt;26:25&gt; = PSTATE.IT&lt;1:0&gt;;
        if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then spsr&lt;23&gt; = PSTATE.SSBS;
        if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then
            if targetELState == <a href="shared_pseudocode.html#AArch32_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch32_NonDebugState</a> then
                spsr&lt;21&gt; = PSTATE.DIT;
            else                                        //AArch64_NonDebugState or DebugState
                spsr&lt;24&gt; = PSTATE.DIT;
        if targetELState IN {<a href="shared_pseudocode.html#AArch64_NonDebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">AArch64_NonDebugState</a>, <a href="shared_pseudocode.html#DebugState" title="enumeration ExceptionalOccurrenceTargetState {&#13; AArch32_NonDebugState,&#13; AArch64_NonDebugState,&#13; DebugState&#13; }">DebugState</a>} then
            spsr&lt;21&gt; = PSTATE.SS;
        spsr&lt;19:16&gt; = PSTATE.GE;
        spsr&lt;15:10&gt; = PSTATE.IT&lt;7:2&gt;;
        spsr&lt;9&gt;     = PSTATE.E;
        spsr&lt;8:6&gt;   = PSTATE.&lt;A,I,F&gt;;                   // No PSTATE.D in AArch32 state
        spsr&lt;5&gt;     = PSTATE.T;
        assert PSTATE.M&lt;4&gt; == PSTATE.nRW;               // bit [4] is the discriminator
        spsr&lt;4:0&gt;   = PSTATE.M;
    else                                                // AArch64 state
        if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then spsr&lt;25&gt; = PSTATE.TCO;
        if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then spsr&lt;24&gt; = PSTATE.DIT;
        if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then spsr&lt;23&gt; = PSTATE.UAO;
        spsr&lt;21&gt;    = PSTATE.SS;
        if <a href="shared_pseudocode.html#impl-shared.HaveFeatNMI.0" title="function: boolean HaveFeatNMI()">HaveFeatNMI</a>() then spsr&lt;13&gt; = PSTATE.ALLINT;
        if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then spsr&lt;12&gt; = PSTATE.SSBS;
        if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then spsr&lt;11:10&gt; = PSTATE.BTYPE;
        spsr&lt;9:6&gt;   = PSTATE.&lt;D,A,I,F&gt;;
        spsr&lt;4&gt;     = PSTATE.nRW;
        spsr&lt;3:2&gt;   = PSTATE.EL;
        spsr&lt;0&gt;     = PSTATE.SP;
    return spsr;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HasArchVersion"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HasArchVersion</h3>
      <p class="pseudocode">// HasArchVersion()
// ================
// Returns TRUE if the implemented architecture includes the extensions defined in the specified
// architecture version.

boolean <a id="impl-shared.HasArchVersion.1"/>HasArchVersion(<a href="shared_pseudocode.html#ArchVersion" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ArchVersion</a> version)
    return version == <a href="shared_pseudocode.html#ARMv8p0" title="enumeration ArchVersion {&#13; ARMv8p0&#13; , ARMv8p1&#13; , ARMv8p2&#13; , ARMv8p3&#13; , ARMv8p4&#13; , ARMv8p5&#13; , ARMv8p6&#13; , ARMv8p7&#13; , ARMv8p8&#13; }">ARMv8p0</a> || boolean IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveAArch32</h3>
      <p class="pseudocode">// HaveAArch32()
// =============
// Return TRUE if AArch32 state is supported at at least EL0.

boolean <a id="impl-shared.HaveAArch32.0"/>HaveAArch32()
    return boolean IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveAArch32EL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveAArch32EL</h3>
      <p class="pseudocode">// HaveAArch32EL()
// ===============

boolean <a id="impl-shared.HaveAArch32EL.1"/>HaveAArch32EL(bits(2) el)
    // Return TRUE if Exception level 'el' supports AArch32 in this implementation
    if !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(el) then
        return FALSE;                    // The Exception level is not implemented
    elsif !<a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() then
        return FALSE;                    // No Exception level can use AArch32
    elsif !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        return TRUE;                     // All Exception levels are using AArch32
    elsif el == <a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()">HighestEL</a>() then
        return FALSE;                    // The highest Exception level is using AArch64
    elsif el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        return TRUE;                     // EL0 must support using AArch32 if any AArch32
    return boolean IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveAArch64"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveAArch64</h3>
      <p class="pseudocode">// HaveAArch64()
// =============
// Return TRUE if AArch64 state is supported at the highest Exception level.

boolean <a id="impl-shared.HaveAArch64.0"/>HaveAArch64()
    return boolean IMPLEMENTATION_DEFINED "Highest EL using AArch64";</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveEL</h3>
      <p class="pseudocode">// HaveEL()
// ========
// Return TRUE if Exception level 'el' is supported

boolean <a id="impl-shared.HaveEL.1"/>HaveEL(bits(2) el)
    if el IN {<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>,<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>} then
        return TRUE;                             // EL1 and EL0 must exist
    return boolean IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveELUsingSecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveELUsingSecurityState</h3>
      <p class="pseudocode">// HaveELUsingSecurityState()
// ==========================
// Returns TRUE if Exception level 'el' with Security state 'secure' is supported,
// FALSE otherwise.

boolean <a id="impl-shared.HaveELUsingSecurityState.2"/>HaveELUsingSecurityState(bits(2) el, boolean secure)

    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>
            assert secure;
            return <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>
            if secure then
                return <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>();
            else
                return <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        otherwise
            return (<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) ||
                    (secure == boolean IMPLEMENTATION_DEFINED "Secure-only implementation"));</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HaveFP16Ext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HaveFP16Ext</h3>
      <p class="pseudocode">// HaveFP16Ext()
// =============
// Return TRUE if FP16 extension is supported

boolean <a id="impl-shared.HaveFP16Ext.0"/>HaveFP16Ext()
    return boolean IMPLEMENTATION_DEFINED;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.HighestEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/HighestEL</h3>
      <p class="pseudocode">// HighestEL()
// ===========
// Returns the highest implemented Exception level.

bits(2) <a id="impl-shared.HighestEL.0"/>HighestEL()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        return <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
        return <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        return <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_DGH"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_DGH</h3>
      <p class="pseudocode">// Provides a hint to close any gathering occurring within the micro-architecture.
<a id="impl-shared.Hint_DGH.0"/>Hint_DGH();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_WFE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_WFE</h3>
      <p class="pseudocode">// Hint_WFE()
// ==========
// Provides a hint indicating that the PE can enter a low-power state
// and remain there until a wakeup event occurs or, for WFET,  a local
// timeout event is generated when the virtual timer value equals or
// exceeds the supplied threshold value.

<a id="impl-shared.Hint_WFE.2"/>Hint_WFE(integer localtimeout, <a href="shared_pseudocode.html#WFxType" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    if <a href="shared_pseudocode.html#impl-shared.IsEventRegisterSet.0" title="function: boolean IsEventRegisterSet()">IsEventRegisterSet</a>() then
        <a href="shared_pseudocode.html#impl-shared.ClearEventRegister.0" title="function: ClearEventRegister()">ClearEventRegister</a>();
    else
        trap = FALSE;
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            // Check for traps described by the OS which may be EL1 or EL2.
            if <a href="shared_pseudocode.html#impl-shared.HaveTWEDExt.0" title="function: boolean HaveTWEDExt()">HaveTWEDExt</a>() then
                sctlr     = <a href="shared_pseudocode.html#impl-aarch64.SCTLR.read.0" title="accessor: SCTLRType SCTLR[]">SCTLR</a>[];
                trap      = sctlr.nTWE == '0';
                target_el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
            else
                <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, wfxtype);
        if !trap &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            // Check for traps described by the Hypervisor.
            if <a href="shared_pseudocode.html#impl-shared.HaveTWEDExt.0" title="function: boolean HaveTWEDExt()">HaveTWEDExt</a>() then
                trap      = HCR_EL2.TWE == '1';
                target_el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
            else
                <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, wfxtype);

        if !trap &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            // Check for traps described by the Secure Monitor.
            if <a href="shared_pseudocode.html#impl-shared.HaveTWEDExt.0" title="function: boolean HaveTWEDExt()">HaveTWEDExt</a>() then
                trap      = SCR_EL3.TWE == '1';
                target_el = <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
            else
                <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, wfxtype);

        if trap &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            (delay_enabled, delay) = <a href="shared_pseudocode.html#impl-aarch64.WFETrapDelay.1" title="function: (boolean, integer) WFETrapDelay(bits(2) target_el)">WFETrapDelay</a>(target_el);    // (If trap delay is enabled, Delay amount)
            if !<a href="shared_pseudocode.html#impl-aarch64.WaitForEventUntilDelay.2" title="function: boolean WaitForEventUntilDelay(boolean delay_enabled, integer delay)">WaitForEventUntilDelay</a>(delay_enabled, delay) then
                // Event did not arrive before delay expired
                <a href="shared_pseudocode.html#AArch64.WFxTrap.2" title="function: AArch64.WFxTrap(WFxType wfxtype, bits(2) target_el)">AArch64.WFxTrap</a>(wfxtype, target_el);             // Trap WFE
        else
            <a href="shared_pseudocode.html#impl-shared.WaitForEvent.1" title="function: WaitForEvent(integer localtimeout)">WaitForEvent</a>(localtimeout);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_WFI"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_WFI</h3>
      <p class="pseudocode">// Hint_WFI()
// ==========
// Provides a hint indicating that the PE can enter a low-power state and
// remain there until a wakeup event occurs or, for WFIT, a local timeout
// event is generated when the virtual timer value equals or exceeds the
// supplied threshold value.

<a id="impl-shared.Hint_WFI.2"/>Hint_WFI(integer localtimeout, <a href="shared_pseudocode.html#WFxType" title="enumeration WFxType {WFxType_WFE, WFxType_WFI, WFxType_WFET, WFxType_WFIT}">WFxType</a> wfxtype)
    if <a href="shared_pseudocode.html#impl-shared.HaveTME.0" title="function: boolean HaveTME()">HaveTME</a>() &amp;&amp; TSTATE.depth &gt; 0 then
        <a href="shared_pseudocode.html#impl-aarch64.FailTransaction.2" title="function: FailTransaction(TMFailure cause, boolean retry)">FailTransaction</a>(<a href="shared_pseudocode.html#TMFailure_ERR" title="enumeration TMFailure {&#13; TMFailure_CNCL, TMFailure_DBG, TMFailure_ERR, TMFailure_NEST, TMFailure_SIZE, TMFailure_MEM, TMFailure_TRIVIAL, TMFailure_IMP }">TMFailure_ERR</a>, FALSE);

    if !<a href="shared_pseudocode.html#impl-shared.InterruptPending.0" title="function: boolean InterruptPending()">InterruptPending</a>() then
        if PSTATE.EL == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
            // Check for traps described by the OS.
            <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>, wfxtype);
        if PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsInHost.0" title="function: boolean IsInHost()">IsInHost</a>() then
            // Check for traps described by the Hypervisor.
            <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>, wfxtype);
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; PSTATE.EL != <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
            // Check for traps described by the Secure Monitor.
            <a href="shared_pseudocode.html#AArch64.CheckForWFxTrap.2" title="function: AArch64.CheckForWFxTrap(bits(2) target_el, WFxType wfxtype)">AArch64.CheckForWFxTrap</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>, wfxtype);
        <a href="shared_pseudocode.html#impl-shared.WaitForInterrupt.1" title="function: WaitForInterrupt(integer localtimeout)">WaitForInterrupt</a>(localtimeout);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Hint_Yield"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Hint_Yield</h3>
      <p class="pseudocode">// Provides a hint that the task performed by a thread is of low
// importance so that it could yield to improve overall performance.
<a id="impl-shared.Hint_Yield.0"/>Hint_Yield();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IRQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IRQPending</h3>
      <p class="pseudocode">// Returns a tuple indicating if there is any pending physical IRQ
// and if the pending IRQ has superpriority.
(boolean, boolean) <a id="impl-shared.IRQPending.0"/>IRQPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IllegalExceptionReturn"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IllegalExceptionReturn</h3>
      <p class="pseudocode">// IllegalExceptionReturn()
// ========================

boolean <a id="impl-shared.IllegalExceptionReturn.1"/>IllegalExceptionReturn(bits(N) spsr)

    // Check for illegal return:
    //   * To an unimplemented Exception level.
    //   * To EL2 in Secure state, when SecureEL2 is not enabled.
    //   * To EL0 using AArch64 state, with SPSR.M[0]==1.
    //   * To AArch64 state with SPSR.M[1]==1.
    //   * To AArch32 state with an illegal value of SPSR.M.
    (valid, target) = <a href="shared_pseudocode.html#impl-shared.ELFromSPSR.1" title="function: (boolean,bits(2)) ELFromSPSR(bits(N) spsr)">ELFromSPSR</a>(spsr);
    if !valid then return TRUE;

    // Check for return to higher Exception level
    if <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(target) &gt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(PSTATE.EL) then return TRUE;

    spsr_mode_is_aarch32 = (spsr&lt;4&gt; == '1');

    // Check for illegal return:
    //   * To EL1, EL2 or EL3 with register width specified in the SPSR different from the
    //     Execution state used in the Exception level being returned to, as determined by
    //     the SCR_EL3.RW or HCR_EL2.RW bits, or as configured from reset.
    //   * To EL0 using AArch64 state when EL1 is using AArch32 state as determined by the
    //     SCR_EL3.RW or HCR_EL2.RW bits or as configured from reset.
    //   * To AArch64 state from AArch32 state (should be caught by above)
    (known, target_el_is_aarch32) = <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32K.1" title="function: (boolean,boolean) ELUsingAArch32K(bits(2) el)">ELUsingAArch32K</a>(target);
    assert known || (target == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>));
    if known &amp;&amp; spsr_mode_is_aarch32 != target_el_is_aarch32 then return TRUE;

    // Check for illegal return from AArch32 to AArch64
    if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; !spsr_mode_is_aarch32 then return TRUE;

    // Check for illegal return to EL1 when HCR.TGE is set and when either of
    // * SecureEL2 is enabled.
    // * SecureEL2 is not enabled and EL1 is in Non-secure state.
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; target == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> &amp;&amp; HCR_EL2.TGE == '1' then
        if (!<a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>() || <a href="shared_pseudocode.html#impl-shared.IsSecureEL2Enabled.0" title="function: boolean IsSecureEL2Enabled()">IsSecureEL2Enabled</a>()) then return TRUE;
    return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.InstrSet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/InstrSet</h3>
      <p class="pseudocode">enumeration <a id="InstrSet"/>InstrSet {<a id="InstrSet_A64"/>InstrSet_A64, <a id="InstrSet_A32"/>InstrSet_A32, <a id="InstrSet_T32"/>InstrSet_T32};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.InstructionSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/InstructionSynchronizationBarrier</h3>
      <p class="pseudocode"><a id="impl-shared.InstructionSynchronizationBarrier.0"/>InstructionSynchronizationBarrier();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.InterruptPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/InterruptPending</h3>
      <p class="pseudocode">// InterruptPending()
// ==================
// Returns TRUE if there are any pending physical or virtual
// interrupts, and FALSE otherwise.

boolean <a id="impl-shared.InterruptPending.0"/>InterruptPending()
    boolean pending_virtual_interrupt = FALSE;
    (irq_pending, -) = <a href="shared_pseudocode.html#impl-shared.IRQPending.0" title="function: (boolean, boolean) IRQPending()">IRQPending</a>();
    (fiq_pending, -) = <a href="shared_pseudocode.html#impl-shared.FIQPending.0" title="function: (boolean, boolean) FIQPending()">FIQPending</a>();
    boolean pending_physical_interrupt = (irq_pending || fiq_pending ||
                                          <a href="shared_pseudocode.html#impl-shared.IsPhysicalSErrorPending.0" title="function: boolean IsPhysicalSErrorPending()">IsPhysicalSErrorPending</a>());

    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; PSTATE.EL IN {<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>, <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>} &amp;&amp; HCR_EL2.TGE == '0' then
        boolean virq_pending = HCR_EL2.IMO == '1' &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.VirtualIRQPending.0" title="function: boolean VirtualIRQPending()">VirtualIRQPending</a>() || HCR_EL2.VI == '1') ;
        boolean vfiq_pending = HCR_EL2.FMO == '1' &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.VirtualFIQPending.0" title="function: boolean VirtualFIQPending()">VirtualFIQPending</a>() || HCR_EL2.VF == '1');
        boolean vsei_pending = HCR_EL2.AMO == '1' &amp;&amp; (<a href="shared_pseudocode.html#impl-shared.IsVirtualSErrorPending.0" title="function: boolean IsVirtualSErrorPending()">IsVirtualSErrorPending</a>() || HCR_EL2.VSE == '1');
        pending_virtual_interrupt = vsei_pending || virq_pending || vfiq_pending;

    return pending_physical_interrupt || pending_virtual_interrupt;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsASEInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsASEInstruction</h3>
      <p class="pseudocode">// Returns TRUE if the current instruction is an ASIMD or SVE vector instruction.
boolean <a id="impl-shared.IsASEInstruction.0"/>IsASEInstruction();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsCMOWControlledInstruction"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsCMOWControlledInstruction</h3>
      <p class="pseudocode">// When using AArch64, returns TRUE if the current instruction is one of IC IVAU,
// DC CIVAC, DC CIGDVAC, or DC CIGVAC.
// When using AArch32, returns TRUE if the current instruction is ICIMVAU or DCCIMVAC.
boolean <a id="impl-shared.IsCMOWControlledInstruction.0"/>IsCMOWControlledInstruction();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsEventRegisterSet"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsEventRegisterSet</h3>
      <p class="pseudocode">// IsEventRegisterSet()
// ====================
// Return TRUE if the Event Register of this PE is set, and FALSE if it is clear.

boolean <a id="impl-shared.IsEventRegisterSet.0"/>IsEventRegisterSet()
    return EventRegister == '1';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsHighestEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsHighestEL</h3>
      <p class="pseudocode">// IsHighestEL()
// =============
// Returns TRUE if given exception level is the highest exception level implemented

boolean <a id="impl-shared.IsHighestEL.1"/>IsHighestEL(bits(2) el)
    return <a href="shared_pseudocode.html#impl-shared.HighestEL.0" title="function: bits(2) HighestEL()">HighestEL</a>() == el;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsInHost"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsInHost</h3>
      <p class="pseudocode">// IsInHost()
// ==========

boolean <a id="impl-shared.IsInHost.0"/>IsInHost()
    return <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsPhysicalSErrorPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsPhysicalSErrorPending</h3>
      <p class="pseudocode">// Returns TRUE if a physical SError interrupt is pending.
boolean <a id="impl-shared.IsPhysicalSErrorPending.0"/>IsPhysicalSErrorPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsSErrorEdgeTriggered"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsSErrorEdgeTriggered</h3>
      <p class="pseudocode">// IsSErrorEdgeTriggered()
// =======================
// Returns TRUE if the physical SError interrupt is edge-triggered
// and FALSE otherwise.

boolean <a id="impl-shared.IsSErrorEdgeTriggered.2"/>IsSErrorEdgeTriggered(bits(2) target_el, bits(25) syndrome)
    if <a href="shared_pseudocode.html#impl-shared.HaveRASExt.0" title="function: boolean HaveRASExt()">HaveRASExt</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveDoubleFaultExt.0" title="function: boolean HaveDoubleFaultExt()">HaveDoubleFaultExt</a>() then
            return TRUE;

        if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(target_el) then
            if syndrome&lt;11:10&gt; != '00' then
                // AArch32 and not Uncontainable.
                return TRUE;
        else
            if syndrome&lt;24&gt; == '0' &amp;&amp; syndrome&lt;5:0&gt; != '000000' then
                // AArch64 and neither IMPLEMENTATION DEFINED syndrome nor Uncategorized.
                return TRUE;
    return boolean IMPLEMENTATION_DEFINED "Edge-triggered SError";</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsSecure"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsSecure</h3>
      <p class="pseudocode">// IsSecure()
// ==========
// Returns TRUE if current Exception level is in Secure state.

boolean <a id="impl-shared.IsSecure.0"/>IsSecure()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; PSTATE.EL == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        return TRUE;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() &amp;&amp; PSTATE.M == <a href="shared_pseudocode.html#M32_Monitor" title="constant bits(5) M32_Monitor = '10110'">M32_Monitor</a> then
        return TRUE;
    return <a href="shared_pseudocode.html#impl-shared.IsSecureBelowEL3.0" title="function: boolean IsSecureBelowEL3()">IsSecureBelowEL3</a>();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsSecureBelowEL3"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsSecureBelowEL3</h3>
      <p class="pseudocode">// IsSecureBelowEL3()
// ==================
// Return TRUE if an Exception level below EL3 is in Secure state
// or would be following an exception return to that level.
//
// Differs from IsSecure in that it ignores the current EL or Mode
// in considering security state.
// That is, if at AArch64 EL3 or in AArch32 Monitor mode, whether an
// exception return would pass to Secure or Non-secure state.

boolean <a id="impl-shared.IsSecureBelowEL3.0"/>IsSecureBelowEL3()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        return <a href="shared_pseudocode.html#impl-shared.SCR_GEN.read.0" title="accessor: SCRType SCR_GEN[]">SCR_GEN</a>[].NS == '0';
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; (!<a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() || !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>()) then
        // If Secure EL2 is not an architecture option then we must be Non-secure.
        return FALSE;
    else
        // TRUE if processor is Secure or FALSE if Non-secure.
        return boolean IMPLEMENTATION_DEFINED "Secure-only implementation";</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsSecureEL2Enabled"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsSecureEL2Enabled</h3>
      <p class="pseudocode">// IsSecureEL2Enabled()
// ====================
// Returns TRUE if Secure EL2 is enabled, FALSE otherwise.

boolean <a id="impl-shared.IsSecureEL2Enabled.0"/>IsSecureEL2Enabled()
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveSecureEL2Ext.0" title="function: boolean HaveSecureEL2Ext()">HaveSecureEL2Ext</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            if !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR_EL3.EEL2 == '1' then
                return TRUE;
            else
                return FALSE;
        else
            return <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    else
        return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsSynchronizablePhysicalSErrorPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsSynchronizablePhysicalSErrorPending</h3>
      <p class="pseudocode">// Returns TRUE if a synchronizable physical SError interrupt is pending.
boolean <a id="impl-shared.IsSynchronizablePhysicalSErrorPending.0"/>IsSynchronizablePhysicalSErrorPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.IsVirtualSErrorPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/IsVirtualSErrorPending</h3>
      <p class="pseudocode">// Returns TRUE if a virtual SError interrupt is pending.
boolean <a id="impl-shared.IsVirtualSErrorPending.0"/>IsVirtualSErrorPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.LocalTimeoutEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/LocalTimeoutEvent</h3>
      <p class="pseudocode">// Returns TRUE if a local timeout event is generated when the value of
// CNTVCT_EL0 equals or exceeds the threshold value for the first time.
// If the threshold value is less than zero a local timeout event will
// not be generated.
boolean <a id="impl-shared.LocalTimeoutEvent.1"/>LocalTimeoutEvent(integer localtimeout);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Mode_Bits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Mode_Bits</h3>
      <p class="pseudocode">constant bits(5) <a id="M32_User"/>M32_User    = '10000';
constant bits(5) <a id="M32_FIQ"/>M32_FIQ     = '10001';
constant bits(5) <a id="M32_IRQ"/>M32_IRQ     = '10010';
constant bits(5) <a id="M32_Svc"/>M32_Svc     = '10011';
constant bits(5) <a id="M32_Monitor"/>M32_Monitor = '10110';
constant bits(5) <a id="M32_Abort"/>M32_Abort   = '10111';
constant bits(5) <a id="M32_Hyp"/>M32_Hyp     = '11010';
constant bits(5) <a id="M32_Undef"/>M32_Undef   = '11011';
constant bits(5) <a id="M32_System"/>M32_System  = '11111';</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PLOfEL"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PLOfEL</h3>
      <p class="pseudocode">// PLOfEL()
// ========

PrivilegeLevel <a id="impl-shared.PLOfEL.1"/>PLOfEL(bits(2) el)
    case el of
        when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  return if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then <a href="shared_pseudocode.html#PL1" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL1</a> else <a href="shared_pseudocode.html#PL3" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL3</a>;
        when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  return <a href="shared_pseudocode.html#PL2" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL2</a>;
        when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  return <a href="shared_pseudocode.html#PL1" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL1</a>;
        when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  return <a href="shared_pseudocode.html#PL0" title="enumeration PrivilegeLevel {PL3, PL2, PL1, PL0}">PL0</a>;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PSTATE"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PSTATE</h3>
      <p class="pseudocode"><a href="shared_pseudocode.html#ProcState" title="type ProcState is ( bits (1) N, bits (1) Z, bits (1) C, bits (1) V, bits (1) D, bits (1) A, bits (1) I, bits (1) F, bits (1) PAN, bits (1) UAO, bits (1) DIT, bits (1) TCO, bits (2) BTYPE, bits (1) ZA, bits (1) SM, bits (1) ALLINT, bits (1) SS, bits (1) IL, bits (2) EL, bits (1) nRW, bits (1) SP, bits (1) Q, bits (4) GE, bits (1) SSBS, bits (8) IT, bits (1) J, bits (1) T, bits (1) E, bits (5) M )">ProcState</a> PSTATE;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PhysicalCountInt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PhysicalCountInt</h3>
      <p class="pseudocode">// PhysicalCountInt()
// ==================
// Returns the integral part of physical count value of the System counter.

bits(64) <a id="impl-shared.PhysicalCountInt.0"/>PhysicalCountInt()
    return PhysicalCount&lt;87:24&gt;;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.PrivilegeLevel"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/PrivilegeLevel</h3>
      <p class="pseudocode">enumeration <a id="PrivilegeLevel"/>PrivilegeLevel {<a id="PL3"/>PL3, <a id="PL2"/>PL2, <a id="PL1"/>PL1, <a id="PL0"/>PL0};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ProcState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ProcState</h3>
      <p class="pseudocode">type <a id="ProcState"/>ProcState is (
    bits (1) N,        // Negative condition flag
    bits (1) Z,        // Zero condition flag
    bits (1) C,        // Carry condition flag
    bits (1) V,        // Overflow condition flag
    bits (1) D,        // Debug mask bit                     [AArch64 only]
    bits (1) A,        // SError interrupt mask bit
    bits (1) I,        // IRQ mask bit
    bits (1) F,        // FIQ mask bit
    bits (1) PAN,      // Privileged Access Never Bit        [v8.1]
    bits (1) UAO,      // User Access Override               [v8.2]
    bits (1) DIT,      // Data Independent Timing            [v8.4]
    bits (1) TCO,      // Tag Check Override                 [v8.5, AArch64 only]
    bits (2) BTYPE,    // Branch Type                        [v8.5]
    bits (1) ZA,       // Accumulation array enabled         [SME]
    bits (1) SM,       // Streaming SVE mode enabled         [SME]
    bits (1) ALLINT,   // Interrupt mask bit
    bits (1) SS,       // Software step bit
    bits (1) IL,       // Illegal Execution state bit
    bits (2) EL,       // Exception level
    bits (1) nRW,      // not Register Width: 0=64, 1=32
    bits (1) <a href="shared_pseudocode.html#impl-aarch32.SP.write.none" title="accessor: SP = bits(32) value">SP</a>,       // Stack pointer select: 0=SP0, 1=SPx [AArch64 only]
    bits (1) Q,        // Cumulative saturation flag         [AArch32 only]
    bits (4) GE,       // Greater than or Equal flags        [AArch32 only]
    bits (1) SSBS,     // Speculative Store Bypass Safe
    bits (8) IT,       // If-then bits, RES0 in CPSR         [AArch32 only]
    bits (1) J,        // J bit, RES0                        [AArch32 only, RES0 in SPSR and CPSR]
    bits (1) T,        // T32 bit, RES0 in CPSR              [AArch32 only]
    bits (1) E,        // Endianness bit                     [AArch32 only]
    bits (5) M         // Mode field                         [AArch32 only]
)</p>
    </div>
    <div class="ps"><a id="shared.functions.system.RestoredITBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/RestoredITBits</h3>
      <p class="pseudocode">// RestoredITBits()
// ================
// Get the value of PSTATE.IT to be restored on this exception return.

bits(8) <a id="impl-shared.RestoredITBits.1"/>RestoredITBits(bits(N) spsr)
    it = spsr&lt;15:10,26:25&gt;;

    // When PSTATE.IL is set, it is CONSTRAINED UNPREDICTABLE whether the IT bits are each set
    // to zero or copied from the SPSR.
    if PSTATE.IL == '1' then
        if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ILZEROIT" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ILZEROIT</a>) then return '00000000';
        else return it;

    // The IT bits are forced to zero when they are set to a reserved value.
    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(it&lt;7:4&gt;) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(it&lt;3:0&gt;) then
        return '00000000';

    // The IT bits are forced to zero when returning to A32 state, or when returning to an EL
    // with the ITD bit set to 1, and the IT bits are describing a multi-instruction block.
    itd = if PSTATE.EL == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then HSCTLR.ITD else SCTLR.ITD;
    if (spsr&lt;5&gt; == '0' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(it)) || (itd == '1' &amp;&amp; !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(it&lt;2:0&gt;)) then
        return '00000000';
    else
        return it;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SCRType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SCRType</h3>
      <p class="pseudocode">type <a id="SCRType"/>SCRType;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SCR_GEN"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SCR_GEN</h3>
      <p class="pseudocode">// SCR_GEN[]
// =========

SCRType <a id="impl-shared.SCR_GEN.read.0"/>SCR_GEN[]
    // AArch32 secure &amp; AArch64 EL3 registers are not architecturally mapped
    assert <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
    bits(64) r;
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then
        r = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.1" title="function: bits(N) ZeroExtend(bits(M) x)">ZeroExtend</a>(SCR);
    else
        r = SCR_EL3;
    return r;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SecurityState"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SecurityState</h3>
      <p class="pseudocode">enumeration <a id="SecurityState"/>SecurityState {
    <a id="SS_NonSecure"/>SS_NonSecure,
    <a id="SS_Root"/>SS_Root,
    <a id="SS_Realm"/>SS_Realm,
    <a id="SS_Secure"/>SS_Secure
};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SendEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SendEvent</h3>
      <p class="pseudocode">// Signal an event to all PEs in a multiprocessor system to set their Event Registers.
// When a PE executes the SEV instruction, it causes this function to be executed.
<a id="impl-shared.SendEvent.0"/>SendEvent();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SendEventLocal"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SendEventLocal</h3>
      <p class="pseudocode">// SendEventLocal()
// ================
// Set the local Event Register of this PE.
// When a PE executes the SEVL instruction, it causes this function to be executed.

<a id="impl-shared.SendEventLocal.0"/>SendEventLocal()
    EventRegister = '1';
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SetAccumulatedFPExceptions"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SetAccumulatedFPExceptions</h3>
      <p class="pseudocode">// Stores FP Exceptions accumulated by the PE.
<a id="impl-shared.SetAccumulatedFPExceptions.1"/>SetAccumulatedFPExceptions(bits(8) accumulated_exceptions);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SetPSTATEFromPSR"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SetPSTATEFromPSR</h3>
      <p class="pseudocode">// SetPSTATEFromPSR()
// ==================

<a id="impl-shared.SetPSTATEFromPSR.1"/>SetPSTATEFromPSR(bits(N) spsr)
    boolean illegal_psr_state = <a href="shared_pseudocode.html#impl-shared.IllegalExceptionReturn.1" title="function: boolean IllegalExceptionReturn(bits(N) spsr)">IllegalExceptionReturn</a>(spsr);
    <a href="shared_pseudocode.html#impl-shared.SetPSTATEFromPSR.2" title="function: SetPSTATEFromPSR(bits(N) spsr, boolean illegal_psr_state)">SetPSTATEFromPSR</a>(spsr, illegal_psr_state);

// SetPSTATEFromPSR()
// ==================
// Set PSTATE based on a PSR value

<a id="impl-shared.SetPSTATEFromPSR.2"/>SetPSTATEFromPSR(bits(N) spsr, boolean illegal_psr_state)
    boolean from_aarch64 = !<a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>();
    assert N == (if from_aarch64 then 64 else 32);
    PSTATE.SS = <a href="shared_pseudocode.html#impl-shared.DebugExceptionReturnSS.1" title="function: bit DebugExceptionReturnSS(bits(N) spsr)">DebugExceptionReturnSS</a>(spsr);
    ShouldAdvanceSS = FALSE;
    if illegal_psr_state then
        PSTATE.IL = '1';
        if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = bit UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = bits(2) UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = bit UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then PSTATE.DIT = bit UNKNOWN;
        if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = bit UNKNOWN;
    else
        // State that is reinstated only on a legal exception return
        PSTATE.IL = spsr&lt;20&gt;;
        if spsr&lt;4&gt; == '1' then                    // AArch32 state
            <a href="shared_pseudocode.html#AArch32.WriteMode.1" title="function: AArch32.WriteMode(bits(5) mode)">AArch32.WriteMode</a>(spsr&lt;4:0&gt;);         // Sets PSTATE.EL correctly
            if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = spsr&lt;23&gt;;
        else                                      // AArch64 state
            PSTATE.nRW = '0';
            PSTATE.EL  = spsr&lt;3:2&gt;;
            PSTATE.SP  = spsr&lt;0&gt;;
            if <a href="shared_pseudocode.html#impl-shared.HaveBTIExt.0" title="function: boolean HaveBTIExt()">HaveBTIExt</a>() then PSTATE.BTYPE = spsr&lt;11:10&gt;;
            if <a href="shared_pseudocode.html#impl-shared.HaveSSBSExt.0" title="function: boolean HaveSSBSExt()">HaveSSBSExt</a>() then PSTATE.SSBS = spsr&lt;12&gt;;
            if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() then PSTATE.UAO = spsr&lt;23&gt;;
            if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then PSTATE.DIT = spsr&lt;24&gt;;
            if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then PSTATE.TCO = spsr&lt;25&gt;;

    // If PSTATE.IL is set, it is CONSTRAINED UNPREDICTABLE whether the T bit is set to zero or
    // copied from SPSR.
    if PSTATE.IL == '1' &amp;&amp; PSTATE.nRW == '1' then
        if <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_ILZEROT" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ILZEROT</a>) then spsr&lt;5&gt; = '0';

    // State that is reinstated regardless of illegal exception return
    PSTATE.&lt;N,Z,C,V&gt; = spsr&lt;31:28&gt;;
    if <a href="shared_pseudocode.html#impl-shared.HavePANExt.0" title="function: boolean HavePANExt()">HavePANExt</a>() then PSTATE.PAN = spsr&lt;22&gt;;
    if PSTATE.nRW == '1' then                     // AArch32 state
        PSTATE.Q         = spsr&lt;27&gt;;
        PSTATE.IT        = <a href="shared_pseudocode.html#impl-shared.RestoredITBits.1" title="function: bits(8) RestoredITBits(bits(N) spsr)">RestoredITBits</a>(spsr);
        ShouldAdvanceIT  = FALSE;
        if <a href="shared_pseudocode.html#impl-shared.HaveDITExt.0" title="function: boolean HaveDITExt()">HaveDITExt</a>() then PSTATE.DIT = (if (<a href="shared_pseudocode.html#impl-shared.Restarting.0" title="function: boolean Restarting()">Restarting</a>() || from_aarch64) then spsr&lt;24&gt; else spsr&lt;21&gt;);
        PSTATE.GE        = spsr&lt;19:16&gt;;
        PSTATE.E         = spsr&lt;9&gt;;
        PSTATE.&lt;A,I,F&gt;   = spsr&lt;8:6&gt;;             // No PSTATE.D in AArch32 state
        PSTATE.T         = spsr&lt;5&gt;;               // PSTATE.J is RES0
    else                                          // AArch64 state
        if <a href="shared_pseudocode.html#impl-shared.HaveFeatNMI.0" title="function: boolean HaveFeatNMI()">HaveFeatNMI</a>() then PSTATE.ALLINT = spsr&lt;13&gt;;
        PSTATE.&lt;D,A,I,F&gt; = spsr&lt;9:6&gt;;             // No PSTATE.&lt;Q,IT,GE,E,T&gt; in AArch64 state
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ShouldAdvanceIT"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ShouldAdvanceIT</h3>
      <p class="pseudocode">boolean ShouldAdvanceIT;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ShouldAdvanceSS"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ShouldAdvanceSS</h3>
      <p class="pseudocode">boolean ShouldAdvanceSS;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SpeculationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SpeculationBarrier</h3>
      <p class="pseudocode"><a id="impl-shared.SpeculationBarrier.0"/>SpeculationBarrier();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SynchronizeContext"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SynchronizeContext</h3>
      <p class="pseudocode"><a id="impl-shared.SynchronizeContext.0"/>SynchronizeContext();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.SynchronizeErrors"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/SynchronizeErrors</h3>
      <p class="pseudocode">// Implements the error synchronization event.
<a id="impl-shared.SynchronizeErrors.0"/>SynchronizeErrors();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.TakeUnmaskedPhysicalSErrorInterrupts"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/TakeUnmaskedPhysicalSErrorInterrupts</h3>
      <p class="pseudocode">// Take any pending unmasked physical SError interrupt.
<a id="impl-shared.TakeUnmaskedPhysicalSErrorInterrupts.1"/>TakeUnmaskedPhysicalSErrorInterrupts(boolean iesb_req);</p>
    </div>
    <div class="ps"><a id="shared.functions.system.TakeUnmaskedSErrorInterrupts"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/TakeUnmaskedSErrorInterrupts</h3>
      <p class="pseudocode">// Take any pending unmasked physical SError interrupt or unmasked virtual SError
// interrupt.
<a id="impl-shared.TakeUnmaskedSErrorInterrupts.0"/>TakeUnmaskedSErrorInterrupts();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ThisInstr"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ThisInstr</h3>
      <p class="pseudocode">bits(32) <a id="impl-shared.ThisInstr.0"/>ThisInstr();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.ThisInstrLength"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/ThisInstrLength</h3>
      <p class="pseudocode">integer <a id="impl-shared.ThisInstrLength.0"/>ThisInstrLength();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.Unreachable"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/Unreachable</h3>
      <p class="pseudocode"><a id="impl-shared.Unreachable.0"/>Unreachable()
    assert FALSE;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.UsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/UsingAArch32</h3>
      <p class="pseudocode">// UsingAArch32()
// ==============
// Return TRUE if the current Exception level is using AArch32, FALSE if using AArch64.

boolean <a id="impl-shared.UsingAArch32.0"/>UsingAArch32()
    boolean aarch32 = (PSTATE.nRW == '1');
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch32.0" title="function: boolean HaveAArch32()">HaveAArch32</a>() then assert !aarch32;
    if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then assert aarch32;
    return aarch32;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.VirtualFIQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/VirtualFIQPending</h3>
      <p class="pseudocode">// Returns TRUE if there is any pending virtual FIQ.
boolean <a id="impl-shared.VirtualFIQPending.0"/>VirtualFIQPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.VirtualIRQPending"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/VirtualIRQPending</h3>
      <p class="pseudocode">// Returns TRUE if there is any pending virtual IRQ.
boolean <a id="impl-shared.VirtualIRQPending.0"/>VirtualIRQPending();</p>
    </div>
    <div class="ps"><a id="shared.functions.system.WFxType"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/WFxType</h3>
      <p class="pseudocode">enumeration <a id="WFxType"/>WFxType {<a id="WFxType_WFE"/>WFxType_WFE, <a id="WFxType_WFI"/>WFxType_WFI, <a id="WFxType_WFET"/>WFxType_WFET, <a id="WFxType_WFIT"/>WFxType_WFIT};</p>
    </div>
    <div class="ps"><a id="shared.functions.system.WaitForEvent"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/WaitForEvent</h3>
      <p class="pseudocode">// WaitForEvent()
// ==============
// PE optionally suspends execution until one of the following occurs:
// - A WFE wake-up event.
// - A reset.
// - The implementation chooses to resume execution.
// - A Wait for Event with Timeout (WFET) is executing, and a local timeout event occurs
// It is IMPLEMENTATION DEFINED whether restarting execution after the period of
// suspension causes the Event Register to be cleared.

<a id="impl-shared.WaitForEvent.1"/>WaitForEvent(integer localtimeout)
    if !(<a href="shared_pseudocode.html#impl-shared.IsEventRegisterSet.0" title="function: boolean IsEventRegisterSet()">IsEventRegisterSet</a>() || <a href="shared_pseudocode.html#impl-shared.LocalTimeoutEvent.1" title="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</a>(localtimeout)) then
        <a href="shared_pseudocode.html#impl-shared.EnterLowPowerState.0" title="function: EnterLowPowerState()">EnterLowPowerState</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.system.WaitForInterrupt"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/system/WaitForInterrupt</h3>
      <p class="pseudocode">// WaitForInterrupt()
// ==================
// PE optionally suspends execution until one of the following occurs:
// - A WFI wake-up event.
// - A reset.
// - The implementation chooses to resume execution.
// - A Wait for Interrupt with Timeout (WFIT) is executing, and a local timeout event occurs.

<a id="impl-shared.WaitForInterrupt.1"/>WaitForInterrupt(integer localtimeout)
    if localtimeout &lt; 0 then
        <a href="shared_pseudocode.html#impl-shared.EnterLowPowerState.0" title="function: EnterLowPowerState()">EnterLowPowerState</a>();
    else
        if !<a href="shared_pseudocode.html#impl-shared.LocalTimeoutEvent.1" title="function: boolean LocalTimeoutEvent(integer localtimeout)">LocalTimeoutEvent</a>(localtimeout) then
            <a href="shared_pseudocode.html#impl-shared.EnterLowPowerState.0" title="function: EnterLowPowerState()">EnterLowPowerState</a>();
    return;</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictable"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictable</h3>
      <p class="pseudocode">// ConstrainUnpredictable()
// ========================
// Return the appropriate Constraint result to control the caller's behavior. The return value
// is IMPLEMENTATION DEFINED within a permitted list for each UNPREDICTABLE case.
// (The permitted list is determined by an assert or case statement at the call site.)

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// The extra argument is used here to allow this example definition. This is an example only and
// does not imply a fixed implementation of these behaviors. Indeed the intention is that it should
// be defined by each implementation, according to its implementation choices.

Constraint <a id="impl-shared.ConstrainUnpredictable.1"/>ConstrainUnpredictable(<a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable</a> which)
    case which of
        when <a href="shared_pseudocode.html#Unpredictable_VMSR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_VMSR</a>
            return <a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>;
        when <a href="shared_pseudocode.html#Unpredictable_WBOVERLAPLD" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WBOVERLAPLD</a>
            return <a href="shared_pseudocode.html#Constraint_WBSUPPRESS" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WBSUPPRESS</a>; // return loaded value
        when <a href="shared_pseudocode.html#Unpredictable_WBOVERLAPST" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WBOVERLAPST</a>
            return <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>;     // store pre-writeback value
        when <a href="shared_pseudocode.html#Unpredictable_LDPOVERLAP" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_LDPOVERLAP</a>
            return <a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>;    // instruction is UNDEFINED
        when <a href="shared_pseudocode.html#Unpredictable_BASEOVERLAP" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BASEOVERLAP</a>
            return <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // use UNKNOWN address
        when <a href="shared_pseudocode.html#Unpredictable_DATAOVERLAP" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DATAOVERLAP</a>
            return <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // store UNKNOWN value
        when <a href="shared_pseudocode.html#Unpredictable_DEVPAGE2" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DEVPAGE2</a>
            return <a href="shared_pseudocode.html#Constraint_FAULT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FAULT</a>;    // take an alignment fault
        when <a href="shared_pseudocode.html#Unpredictable_DEVICETAGSTORE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DEVICETAGSTORE</a>
            return <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>;     // Do not take a fault
        when <a href="shared_pseudocode.html#Unpredictable_INSTRDEVICE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_INSTRDEVICE</a>
            return <a href="shared_pseudocode.html#Constraint_NONE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NONE</a>;     // Do not take a fault
        when <a href="shared_pseudocode.html#Unpredictable_RESCPACR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESCPACR</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESMAIR</a>
            return <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#Unpredictable_S1CTAGGED" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_S1CTAGGED</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // SCTLR_ELx.C == '0' marks address as untagged
        when <a href="shared_pseudocode.html#Unpredictable_S2RESMEMATTR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_S2RESMEMATTR</a>
            return <a href="shared_pseudocode.html#Constraint_NC" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NC</a>;       // Map to Noncacheable value
        when <a href="shared_pseudocode.html#Unpredictable_RESTEXCB" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESTEXCB</a>
            return <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#Unpredictable_RESDACR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESDACR</a>
            return <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#Unpredictable_RESPRRR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESPRRR</a>
            return <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#Unpredictable_RESVTCRS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESVTCRS</a>
            return <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a>;  // Map to UNKNOWN value
        when <a href="shared_pseudocode.html#Unpredictable_RESTnSZ" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESTnSZ</a>
            return <a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a>;    // Map to the limit value
        when <a href="shared_pseudocode.html#Unpredictable_OORTnSZ" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_OORTnSZ</a>
            return <a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a>;    // Map to the limit value
        when <a href="shared_pseudocode.html#Unpredictable_LARGEIPA" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_LARGEIPA</a>
            return <a href="shared_pseudocode.html#Constraint_FORCE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FORCE</a>;    // Restrict the IA size to the PAMax value
        when <a href="shared_pseudocode.html#Unpredictable_ESRCONDPASS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ESRCONDPASS</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Report as "AL"
        when <a href="shared_pseudocode.html#Unpredictable_ILZEROIT" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ILZEROIT</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Do not zero PSTATE.IT
        when <a href="shared_pseudocode.html#Unpredictable_ILZEROT" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ILZEROT</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Do not zero PSTATE.T
        when <a href="shared_pseudocode.html#Unpredictable_BPVECTORCATCHPRI" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPVECTORCATCHPRI</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Debug Vector Catch: match on 2nd halfword
        when <a href="shared_pseudocode.html#Unpredictable_VCMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_VCMATCHHALF</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // No match
        when <a href="shared_pseudocode.html#Unpredictable_VCMATCHDAPA" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_VCMATCHDAPA</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // No match on Data Abort or Prefetch abort
        when <a href="shared_pseudocode.html#Unpredictable_WPMASKANDBAS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WPMASKANDBAS</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Watchpoint disabled
        when <a href="shared_pseudocode.html#Unpredictable_WPBASCONTIGUOUS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WPBASCONTIGUOUS</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Watchpoint disabled
        when <a href="shared_pseudocode.html#Unpredictable_RESWPMASK" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESWPMASK</a>
            return <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>; // Watchpoint disabled
        when <a href="shared_pseudocode.html#Unpredictable_WPMASKEDBITS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WPMASKEDBITS</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Watchpoint disabled
        when <a href="shared_pseudocode.html#Unpredictable_RESBPWPCTRL" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESBPWPCTRL</a>
            return <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>; // Breakpoint/watchpoint disabled
        when <a href="shared_pseudocode.html#Unpredictable_BPNOTIMPL" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPNOTIMPL</a>
            return <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>; // Breakpoint disabled
        when <a href="shared_pseudocode.html#Unpredictable_RESBPTYPE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESBPTYPE</a>
            return <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>; // Breakpoint disabled
        when <a href="shared_pseudocode.html#Unpredictable_BPNOTCTXCMP" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPNOTCTXCMP</a>
            return <a href="shared_pseudocode.html#Constraint_DISABLED" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_DISABLED</a>; // Breakpoint disabled
        when <a href="shared_pseudocode.html#Unpredictable_BPMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPMATCHHALF</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // No match
        when <a href="shared_pseudocode.html#Unpredictable_BPMISMATCHHALF" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BPMISMATCHHALF</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // No match
        when <a href="shared_pseudocode.html#Unpredictable_RESTARTALIGNPC" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESTARTALIGNPC</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Do not force alignment
        when <a href="shared_pseudocode.html#Unpredictable_RESTARTZEROUPPERPC" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESTARTZEROUPPERPC</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Force zero extension
        when <a href="shared_pseudocode.html#Unpredictable_ZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ZEROUPPER</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // zero top halves of X registers
        when <a href="shared_pseudocode.html#Unpredictable_ERETZEROUPPERPC" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ERETZEROUPPERPC</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // zero top half of PC
        when <a href="shared_pseudocode.html#Unpredictable_A32FORCEALIGNPC" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_A32FORCEALIGNPC</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Do not force alignment
        when <a href="shared_pseudocode.html#Unpredictable_SMD" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SMD</a>
            return <a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>;    // disabled SMC is Unallocated
        when <a href="shared_pseudocode.html#Unpredictable_NONFAULT" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_NONFAULT</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // Speculation enabled
        when <a href="shared_pseudocode.html#Unpredictable_SVEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SVEZEROUPPER</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // zero top bits of Z registers
        when <a href="shared_pseudocode.html#Unpredictable_SVELDNFDATA" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SVELDNFDATA</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Load mem data in NF loads
        when <a href="shared_pseudocode.html#Unpredictable_SVELDNFZERO" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SVELDNFZERO</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Write zeros in NF loads
        when <a href="shared_pseudocode.html#Unpredictable_CHECKSPNONEACTIVE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_CHECKSPNONEACTIVE</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Check SP alignment
        when <a href="shared_pseudocode.html#Unpredictable_SMEZEROUPPER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_SMEZEROUPPER</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // zero top bits of ZA registers
        when <a href="shared_pseudocode.html#Unpredictable_NVNV1" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_NVNV1</a>
            return <a href="shared_pseudocode.html#Constraint_NVNV1_00" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NVNV1_00</a>; // Map unpredictable configuration of HCR_EL2&lt;NV,NV1&gt;
                                        // to NV = 0 and NV1 = 0
        when <a href="shared_pseudocode.html#Unpredictable_Shareability" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_Shareability</a>
            return <a href="shared_pseudocode.html#Constraint_OSH" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_OSH</a>;      // Map reserved encoding of shareability to outer shareable
        when <a href="shared_pseudocode.html#Unpredictable_AFUPDATE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_AFUPDATE</a>     // AF update for alignment or permission fault
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#Unpredictable_IESBinDebug" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_IESBinDebug</a>  // Use SCTLR[].IESB in Debug state
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#Unpredictable_BADPMSFCR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_BADPMSFCR</a>    // Bad settings for PMSFCR_EL1/PMSEVFR_EL1/PMSLATFR_EL1
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;
        when <a href="shared_pseudocode.html#Unpredictable_ZEROBTYPE" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ZEROBTYPE</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Save BTYPE in SPSR_ELx/DPSR_EL0 as '00'
        when <a href="shared_pseudocode.html#Unpredictable_CLEARERRITEZERO" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_CLEARERRITEZERO</a> // Clearing sticky errors when instruction in flight
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#Unpredictable_ALUEXCEPTIONRETURN" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_ALUEXCEPTIONRETURN</a>
            return <a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>;
        when <a href="shared_pseudocode.html#Unpredictable_DBGxVR_RESS" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_DBGxVR_RESS</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;
        when <a href="shared_pseudocode.html#Unpredictable_PMSCR_PCT" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_PMSCR_PCT</a>
            return <a href="shared_pseudocode.html#Constraint_PMSCR_PCT_VIRT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_PMSCR_PCT_VIRT</a>;
        when <a href="shared_pseudocode.html#Unpredictable_WFxTDEBUG" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_WFxTDEBUG</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;    // WFxT in Debug state does not execute as a NOP
        when <a href="shared_pseudocode.html#Unpredictable_LS64UNSUPPORTED" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_LS64UNSUPPORTED</a>
            return <a href="shared_pseudocode.html#Constraint_LIMITED_ATOMICITY" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_LIMITED_ATOMICITY</a>; // Accesses are not single-copy atomic above the byte level
       // Misaligned exclusives, atomics, acquire/release to region that is not Normal Cacheable WB are atomic
        when <a href="shared_pseudocode.html#Unpredictable_MISALIGNEDATOMIC" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_MISALIGNEDATOMIC</a>
            return <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>;

        when <a href="shared_pseudocode.html#Unpredictable_IGNORETRAPINDEBUG" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_IGNORETRAPINDEBUG</a>
            return <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>;     // Trap to register access in debug state is ignored
        when <a href="shared_pseudocode.html#Unpredictable_PMUEVENTCOUNTER" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_PMUEVENTCOUNTER</a>
            return <a href="shared_pseudocode.html#Constraint_UNDEF" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNDEF</a>;    // Accesses to the register are UNDEFINED</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableBits"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableBits</h3>
      <p class="pseudocode">// ConstrainUnpredictableBits()
// ============================

// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN.
// If the result is Constraint_UNKNOWN then the function also returns UNKNOWN value, but that
// value is always an allocated value; that is, one for which the behavior is not itself
// CONSTRAINED.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

// This is an example placeholder only and does not imply a fixed implementation of the bits part
// of the result, and may not be applicable in all cases.

(Constraint,bits(width)) <a id="impl-shared.ConstrainUnpredictableBits.1"/>ConstrainUnpredictableBits(<a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable</a> which)

    c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(which);

    if c == <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a> then
        return (c, <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(width));           // See notes; this is an example implementation only
    elsif c == <a href="shared_pseudocode.html#Constraint_PMSCR_PCT_VIRT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_PMSCR_PCT_VIRT</a> then
        return (c,<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(width));
    else
        return (c, bits(width) UNKNOWN);    // bits result not used</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableBool"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableBool</h3>
      <p class="pseudocode">// ConstrainUnpredictableBool()
// ============================

// This is a simple wrapper function for cases where the constrained result is either TRUE or FALSE.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

boolean <a id="impl-shared.ConstrainUnpredictableBool.1"/>ConstrainUnpredictableBool(<a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable</a> which)

    c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(which);
    assert c IN {<a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>, <a href="shared_pseudocode.html#Constraint_FALSE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_FALSE</a>};
    return (c == <a href="shared_pseudocode.html#Constraint_TRUE" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_TRUE</a>);</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.ConstrainUnpredictableInteger"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/ConstrainUnpredictableInteger</h3>
      <p class="pseudocode">// ConstrainUnpredictableInteger()
// ===============================

// This is a variant of ConstrainUnpredictable for when the result can be Constraint_UNKNOWN. If
// the result is Constraint_UNKNOWN then the function also returns an UNKNOWN value in the range
// low to high, inclusive.

// NOTE: This version of the function uses an Unpredictable argument to define the call site.
// This argument does not appear in the version used in the Armv8 Architecture Reference Manual.
// See the NOTE on ConstrainUnpredictable() for more information.

// This is an example placeholder only and does not imply a fixed implementation of the integer part
// of the result.

(Constraint,integer) <a id="impl-shared.ConstrainUnpredictableInteger.3"/>ConstrainUnpredictableInteger(integer low, integer high, <a href="shared_pseudocode.html#Unpredictable" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable</a> which)

    c = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(which);

    if c == <a href="shared_pseudocode.html#Constraint_UNKNOWN" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_UNKNOWN</a> then
        return (c, low);                // See notes; this is an example implementation only
    else
        return (c, integer UNKNOWN);    // integer result not used</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.Constraint"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/Constraint</h3>
      <p class="pseudocode">enumeration <a id="Constraint"/>Constraint    {// General
                           <a id="Constraint_NONE"/>Constraint_NONE,              // Instruction executes with
                                                         //   no change or side-effect to its described behavior
                           <a id="Constraint_UNKNOWN"/>Constraint_UNKNOWN,           // Destination register has UNKNOWN value
                           <a id="Constraint_UNDEF"/>Constraint_UNDEF,             // Instruction is UNDEFINED
                           <a id="Constraint_UNDEFEL0"/>Constraint_UNDEFEL0,          // Instruction is UNDEFINED at EL0 only
                           <a id="Constraint_NOP"/>Constraint_NOP,               // Instruction executes as NOP
                           <a id="Constraint_TRUE"/>Constraint_TRUE,
                           <a id="Constraint_FALSE"/>Constraint_FALSE,
                           <a id="Constraint_DISABLED"/>Constraint_DISABLED,
                           <a id="Constraint_UNCOND"/>Constraint_UNCOND,            // Instruction executes unconditionally
                           <a id="Constraint_COND"/>Constraint_COND,              // Instruction executes conditionally
                           <a id="Constraint_ADDITIONAL_DECODE"/>Constraint_ADDITIONAL_DECODE, // Instruction executes with additional decode
                           // Load-store
                           <a id="Constraint_WBSUPPRESS"/>Constraint_WBSUPPRESS,
                           <a id="Constraint_FAULT"/>Constraint_FAULT,
                           <a id="Constraint_LIMITED_ATOMICITY"/>Constraint_LIMITED_ATOMICITY, // Accesses are not single-copy atomic above the byte level
                           <a id="Constraint_NVNV1_00"/>Constraint_NVNV1_00,
                           <a id="Constraint_NVNV1_01"/>Constraint_NVNV1_01,
                           <a id="Constraint_NVNV1_11"/>Constraint_NVNV1_11,
                           <a id="Constraint_OSH"/>Constraint_OSH,               // Constrain to Outer shareable
                           <a id="Constraint_ISH"/>Constraint_ISH,               // Constrain to Inner shareable
                           <a id="Constraint_NSH"/>Constraint_NSH,               // Constrain to Nonshareable

                           <a id="Constraint_NC"/>Constraint_NC,                // Constrain to Noncacheable
                           <a id="Constraint_WT"/>Constraint_WT,                // Constrain to Writethrough
                           <a id="Constraint_WB"/>Constraint_WB,                // Constrain to Writeback

                           // IPA too large
                           <a id="Constraint_FORCE"/>Constraint_FORCE, <a id="Constraint_FORCENOSLCHECK"/>Constraint_FORCENOSLCHECK,
                           // PMSCR_PCT reserved values select Virtual timestamp
                           <a id="Constraint_PMSCR_PCT_VIRT"/>Constraint_PMSCR_PCT_VIRT};</p>
    </div>
    <div class="ps"><a id="shared.functions.unpredictable.Unpredictable"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/unpredictable/Unpredictable</h3>
      <p class="pseudocode">enumeration <a id="Unpredictable"/>Unpredictable {// VMSR on MVFR
                           <a id="Unpredictable_VMSR"/>Unpredictable_VMSR,
                           // Writeback/transfer register overlap (load)
                           <a id="Unpredictable_WBOVERLAPLD"/>Unpredictable_WBOVERLAPLD,
                           // Writeback/transfer register overlap (store)
                           <a id="Unpredictable_WBOVERLAPST"/>Unpredictable_WBOVERLAPST,
                           // Load Pair transfer register overlap
                           <a id="Unpredictable_LDPOVERLAP"/>Unpredictable_LDPOVERLAP,
                           // Store-exclusive base/status register overlap
                           <a id="Unpredictable_BASEOVERLAP"/>Unpredictable_BASEOVERLAP,
                           // Store-exclusive data/status register overlap
                           <a id="Unpredictable_DATAOVERLAP"/>Unpredictable_DATAOVERLAP,
                           // Load-store alignment checks
                           <a id="Unpredictable_DEVPAGE2"/>Unpredictable_DEVPAGE2,
                           // Instruction fetch from Device memory
                           <a id="Unpredictable_INSTRDEVICE"/>Unpredictable_INSTRDEVICE,
                           // Reserved CPACR value
                           <a id="Unpredictable_RESCPACR"/>Unpredictable_RESCPACR,
                           // Reserved MAIR value
                           <a id="Unpredictable_RESMAIR"/>Unpredictable_RESMAIR,
                           // Effect of SCTLR_ELx.C on Tagged attribute
                           <a id="Unpredictable_S1CTAGGED"/>Unpredictable_S1CTAGGED,
                           // Reserved Stage 2 MemAttr value
                           <a id="Unpredictable_S2RESMEMATTR"/>Unpredictable_S2RESMEMATTR,
                           // Reserved TEX:C:B value
                           <a id="Unpredictable_RESTEXCB"/>Unpredictable_RESTEXCB,
                           // Reserved PRRR value
                           <a id="Unpredictable_RESPRRR"/>Unpredictable_RESPRRR,
                           // Reserved DACR field
                           <a id="Unpredictable_RESDACR"/>Unpredictable_RESDACR,
                           // Reserved VTCR.S value
                           <a id="Unpredictable_RESVTCRS"/>Unpredictable_RESVTCRS,
                           // Reserved TCR.TnSZ value
                           <a id="Unpredictable_RESTnSZ"/>Unpredictable_RESTnSZ,
                           // Reserved SCTLR_ELx.TCF value
                           <a id="Unpredictable_RESTCF"/>Unpredictable_RESTCF,
                           // Tag stored to Device memory
                           <a id="Unpredictable_DEVICETAGSTORE"/>Unpredictable_DEVICETAGSTORE,
                           // Out-of-range TCR.TnSZ value
                           <a id="Unpredictable_OORTnSZ"/>Unpredictable_OORTnSZ,
                           // IPA size exceeds PA size
                           <a id="Unpredictable_LARGEIPA"/>Unpredictable_LARGEIPA,
                           // Syndrome for a known-passing conditional A32 instruction
                           <a id="Unpredictable_ESRCONDPASS"/>Unpredictable_ESRCONDPASS,
                           // Illegal State exception: zero PSTATE.IT
                           <a id="Unpredictable_ILZEROIT"/>Unpredictable_ILZEROIT,
                           // Illegal State exception: zero PSTATE.T
                           <a id="Unpredictable_ILZEROT"/>Unpredictable_ILZEROT,
                           // Debug: prioritization of Vector Catch
                           <a id="Unpredictable_BPVECTORCATCHPRI"/>Unpredictable_BPVECTORCATCHPRI,
                           // Debug Vector Catch: match on 2nd halfword
                           <a id="Unpredictable_VCMATCHHALF"/>Unpredictable_VCMATCHHALF,
                           // Debug Vector Catch: match on Data Abort or Prefetch abort
                           <a id="Unpredictable_VCMATCHDAPA"/>Unpredictable_VCMATCHDAPA,
                           // Debug watchpoints: non-zero MASK and non-ones BAS
                           <a id="Unpredictable_WPMASKANDBAS"/>Unpredictable_WPMASKANDBAS,
                           // Debug watchpoints: non-contiguous BAS
                           <a id="Unpredictable_WPBASCONTIGUOUS"/>Unpredictable_WPBASCONTIGUOUS,
                           // Debug watchpoints: reserved MASK
                           <a id="Unpredictable_RESWPMASK"/>Unpredictable_RESWPMASK,
                           // Debug watchpoints: non-zero MASKed bits of address
                           <a id="Unpredictable_WPMASKEDBITS"/>Unpredictable_WPMASKEDBITS,
                           // Debug breakpoints and watchpoints: reserved control bits
                           <a id="Unpredictable_RESBPWPCTRL"/>Unpredictable_RESBPWPCTRL,
                           // Debug breakpoints: not implemented
                           <a id="Unpredictable_BPNOTIMPL"/>Unpredictable_BPNOTIMPL,
                           // Debug breakpoints: reserved type
                           <a id="Unpredictable_RESBPTYPE"/>Unpredictable_RESBPTYPE,
                           // Debug breakpoints: not-context-aware breakpoint
                           <a id="Unpredictable_BPNOTCTXCMP"/>Unpredictable_BPNOTCTXCMP,
                           // Debug breakpoints: match on 2nd halfword of instruction
                           <a id="Unpredictable_BPMATCHHALF"/>Unpredictable_BPMATCHHALF,
                           // Debug breakpoints: mismatch on 2nd halfword of instruction
                           <a id="Unpredictable_BPMISMATCHHALF"/>Unpredictable_BPMISMATCHHALF,
                           // Debug: restart to a misaligned AArch32 PC value
                           <a id="Unpredictable_RESTARTALIGNPC"/>Unpredictable_RESTARTALIGNPC,
                           // Debug: restart to a not-zero-extended AArch32 PC value
                           <a id="Unpredictable_RESTARTZEROUPPERPC"/>Unpredictable_RESTARTZEROUPPERPC,
                           // Zero top 32 bits of X registers in AArch32 state
                           <a id="Unpredictable_ZEROUPPER"/>Unpredictable_ZEROUPPER,
                           // Zero top 32 bits of PC on illegal return to AArch32 state
                           <a id="Unpredictable_ERETZEROUPPERPC"/>Unpredictable_ERETZEROUPPERPC,
                           // Force address to be aligned when interworking branch to A32 state
                           <a id="Unpredictable_A32FORCEALIGNPC"/>Unpredictable_A32FORCEALIGNPC,
                           // SMC disabled
                           <a id="Unpredictable_SMD"/>Unpredictable_SMD,
                           // FF speculation
                           <a id="Unpredictable_NONFAULT"/>Unpredictable_NONFAULT,
                           // Zero top bits of Z registers in EL change
                           <a id="Unpredictable_SVEZEROUPPER"/>Unpredictable_SVEZEROUPPER,
                           // Load mem data in NF loads
                           <a id="Unpredictable_SVELDNFDATA"/>Unpredictable_SVELDNFDATA,
                           // Write zeros in NF loads
                           <a id="Unpredictable_SVELDNFZERO"/>Unpredictable_SVELDNFZERO,
                           // SP alignment fault when predicate is all zero
                           <a id="Unpredictable_CHECKSPNONEACTIVE"/>Unpredictable_CHECKSPNONEACTIVE,
                           // Zero top bits of ZA registers in EL change
                           <a id="Unpredictable_SMEZEROUPPER"/>Unpredictable_SMEZEROUPPER,
                           // HCR_EL2.&lt;NV,NV1&gt; == '01'
                           <a id="Unpredictable_NVNV1"/>Unpredictable_NVNV1,
                           // Reserved shareability encoding
                           <a id="Unpredictable_Shareability"/>Unpredictable_Shareability,
                           // Access Flag Update by HW
                           <a id="Unpredictable_AFUPDATE"/>Unpredictable_AFUPDATE,
                           // Consider SCTLR[].IESB in Debug state
                           <a id="Unpredictable_IESBinDebug"/>Unpredictable_IESBinDebug,
                           // Bad settings for PMSFCR_EL1/PMSEVFR_EL1/PMSLATFR_EL1
                           <a id="Unpredictable_BADPMSFCR"/>Unpredictable_BADPMSFCR,
                           // Zero saved BType value in SPSR_ELx/DPSR_EL0
                           <a id="Unpredictable_ZEROBTYPE"/>Unpredictable_ZEROBTYPE,
                           // Timestamp constrained to virtual or physical
                           <a id="Unpredictable_EL2TIMESTAMP"/>Unpredictable_EL2TIMESTAMP,
                           <a id="Unpredictable_EL1TIMESTAMP"/>Unpredictable_EL1TIMESTAMP,
                           // WFET or WFIT instruction in Debug state
                           <a id="Unpredictable_WFxTDEBUG"/>Unpredictable_WFxTDEBUG,
                           // Address does not support LS64 instructions
                           <a id="Unpredictable_LS64UNSUPPORTED"/>Unpredictable_LS64UNSUPPORTED,
                           // Misaligned exclusives, atomics, acquire/release to region that is not Normal Cacheable WB are atomic
                           <a id="Unpredictable_MISALIGNEDATOMIC"/>Unpredictable_MISALIGNEDATOMIC,
                           // Clearing DCC/ITR sticky flags when instruction is in flight
                           <a id="Unpredictable_CLEARERRITEZERO"/>Unpredictable_CLEARERRITEZERO,
                           // ALUEXCEPTIONRETURN when in user/system mode in A32 instructions
                           <a id="Unpredictable_ALUEXCEPTIONRETURN"/>Unpredictable_ALUEXCEPTIONRETURN,
                           // Trap to register in debug state are ignored
                           <a id="Unpredictable_IGNORETRAPINDEBUG"/>Unpredictable_IGNORETRAPINDEBUG,
                           // Compare DBGBVR.RESS for BP/WP
                           <a id="Unpredictable_DBGxVR_RESS"/>Unpredictable_DBGxVR_RESS,
                           // Inaccessible event counter
                           <a id="Unpredictable_PMUEVENTCOUNTER"/>Unpredictable_PMUEVENTCOUNTER,
                           // Reserved PMSCR.PCT behaviour.
                           <a id="Unpredictable_PMSCR_PCT"/>Unpredictable_PMSCR_PCT};</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.AdvSIMDExpandImm"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/AdvSIMDExpandImm</h3>
      <p class="pseudocode">// AdvSIMDExpandImm()
// ==================

bits(64) <a id="impl-shared.AdvSIMDExpandImm.3"/>AdvSIMDExpandImm(bit op, bits(4) cmode, bits(8) imm8)
    case cmode&lt;3:1&gt; of
        when '000'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24):imm8, 2);
        when '001'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16):imm8:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8), 2);
        when '010'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8):imm8:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16), 2);
        when '011'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(24), 2);
        when '100'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8):imm8, 4);
        when '101'
            imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8), 4);
        when '110'
            if cmode&lt;0&gt; == '0' then
                imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(16):imm8:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(8), 2);
            else
                imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8):imm8:<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(16), 2);
        when '111'
            if cmode&lt;0&gt; == '0' &amp;&amp; op == '0' then
                imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8, 8);
            if cmode&lt;0&gt; == '0' &amp;&amp; op == '1' then
                imm8a = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;7&gt;, 8); imm8b = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;, 8);
                imm8c = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;5&gt;, 8); imm8d = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;4&gt;, 8);
                imm8e = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;3&gt;, 8); imm8f = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;2&gt;, 8);
                imm8g = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;1&gt;, 8); imm8h = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;0&gt;, 8);
                imm64 = imm8a:imm8b:imm8c:imm8d:imm8e:imm8f:imm8g:imm8h;
            if cmode&lt;0&gt; == '1' &amp;&amp; op == '0' then
                imm32 = imm8&lt;7&gt;:NOT(imm8&lt;6&gt;):<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;,5):imm8&lt;5:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(19);
                imm64 = <a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm32, 2);
            if cmode&lt;0&gt; == '1' &amp;&amp; op == '1' then
                if <a href="shared_pseudocode.html#impl-shared.UsingAArch32.0" title="function: boolean UsingAArch32()">UsingAArch32</a>() then ReservedEncoding();
                imm64 = imm8&lt;7&gt;:NOT(imm8&lt;6&gt;):<a href="shared_pseudocode.html#impl-shared.Replicate.2" title="function: bits(M*N) Replicate(bits(M) x, integer N)">Replicate</a>(imm8&lt;6&gt;,8):imm8&lt;5:0&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(48);

    return imm64;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.MatMulAdd"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/MatMulAdd</h3>
      <p class="pseudocode">// MatMulAdd()
// ===========
//
// Signed or unsigned 8-bit integer matrix multiply and add to 32-bit integer matrix
// result[2, 2] = addend[2, 2] + (op1[2, 8] * op2[8, 2])

bits(N) <a id="impl-shared.MatMulAdd.5"/>MatMulAdd(bits(N) addend, bits(N) op1, bits(N) op2, boolean op1_unsigned, boolean op2_unsigned)
    assert N == 128;

    bits(N)  result;
    bits(32) sum;
    integer  prod;

    for i = 0 to 1
        for j = 0 to 1
            sum = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[addend, 2*i + j, 32];
            for k = 0 to 7
                prod = <a href="shared_pseudocode.html#impl-shared.Int.2" title="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op1, 8*i + k, 8], op1_unsigned) * <a href="shared_pseudocode.html#impl-shared.Int.2" title="function: integer Int(bits(N) x, boolean unsigned)">Int</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[op2, 8*j + k, 8], op2_unsigned);
                sum  = sum + prod;
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, 2*i + j, 32] = sum;

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.PolynomialMult"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/PolynomialMult</h3>
      <p class="pseudocode">// PolynomialMult()
// ================

bits(M+N) <a id="impl-shared.PolynomialMult.2"/>PolynomialMult(bits(M) op1, bits(N) op2)
    result = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(M+N);
    extended_op2 = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(op2, M+N);
    for i=0 to M-1
        if op1&lt;i&gt; == '1' then
            result = result EOR <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(extended_op2, i);
    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.SatQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/SatQ</h3>
      <p class="pseudocode">// SatQ()
// ======

(bits(N), boolean) <a id="impl-shared.SatQ.3"/>SatQ(integer i, integer N, boolean unsigned)
    (result, sat) = if unsigned then <a href="shared_pseudocode.html#impl-shared.UnsignedSatQ.2" title="function: (bits(N), boolean) UnsignedSatQ(integer i, integer N)">UnsignedSatQ</a>(i, N) else <a href="shared_pseudocode.html#impl-shared.SignedSatQ.2" title="function: (bits(N), boolean) SignedSatQ(integer i, integer N)">SignedSatQ</a>(i, N);
    return (result, sat);</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.SignedSatQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/SignedSatQ</h3>
      <p class="pseudocode">// SignedSatQ()
// ============

(bits(N), boolean) <a id="impl-shared.SignedSatQ.2"/>SignedSatQ(integer i, integer N)
    if i &gt; 2^(N-1) - 1 then
        result = 2^(N-1) - 1;  saturated = TRUE;
    elsif i &lt; -(2^(N-1)) then
        result = -(2^(N-1));  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    return (result&lt;N-1:0&gt;, saturated);</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.UnsignedRSqrtEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/UnsignedRSqrtEstimate</h3>
      <p class="pseudocode">// UnsignedRSqrtEstimate()
// =======================

bits(N) <a id="impl-shared.UnsignedRSqrtEstimate.1"/>UnsignedRSqrtEstimate(bits(N) operand)
    assert N == 32;
    if operand&lt;N-1:N-2&gt; == '00' then  // Operands &lt;= 0x3FFFFFFF produce 0xFFFFFFFF
        result = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(N);
    else
        // input is in the range 0x40000000 .. 0xffffffff representing [0.25 .. 1.0)
        // estimate is in the range 256 .. 511 representing [1.0 .. 2.0)
        increasedprecision = FALSE;
        estimate = <a href="shared_pseudocode.html#impl-shared.RecipSqrtEstimate.2" title="function: integer RecipSqrtEstimate(integer a, boolean increasedprecision)">RecipSqrtEstimate</a>(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;31:23&gt;), increasedprecision);
        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate&lt;8:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-9);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.UnsignedRecipEstimate"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/UnsignedRecipEstimate</h3>
      <p class="pseudocode">// UnsignedRecipEstimate()
// =======================

bits(N) <a id="impl-shared.UnsignedRecipEstimate.1"/>UnsignedRecipEstimate(bits(N) operand)
    assert N == 32;
    if operand&lt;N-1&gt; == '0' then  // Operands &lt;= 0x7FFFFFFF produce 0xFFFFFFFF
        result = <a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(N);
    else
        // input is in the range 0x80000000 .. 0xffffffff representing [0.5 .. 1.0)

        // estimate is in the range 256 to 511 representing [1.0 .. 2.0)
        increasedprecision = FALSE;
        estimate = <a href="shared_pseudocode.html#impl-shared.RecipEstimate.2" title="function: integer RecipEstimate(integer a, boolean increasedprecision)">RecipEstimate</a>(<a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(operand&lt;31:23&gt;), increasedprecision);

        // result is in the range 0x80000000 .. 0xff800000 representing [1.0 .. 2.0)
        result = estimate&lt;8:0&gt; : <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(N-9);

    return result;</p>
    </div>
    <div class="ps"><a id="shared.functions.vector.UnsignedSatQ"/><h3 class="pseudocode">
            Library pseudocode for shared/functions/vector/UnsignedSatQ</h3>
      <p class="pseudocode">// UnsignedSatQ()
// ==============

(bits(N), boolean) <a id="impl-shared.UnsignedSatQ.2"/>UnsignedSatQ(integer i, integer N)
    if i &gt; 2^N - 1 then
        result = 2^N - 1;  saturated = TRUE;
    elsif i &lt; 0 then
        result = 0;  saturated = TRUE;
    else
        result = i;  saturated = FALSE;
    return (result&lt;N-1:0&gt;, saturated);</p>
    </div>
    <div class="ps"><a id="shared.trace.Common.GetTimestamp"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/Common/GetTimestamp</h3>
      <p class="pseudocode">// GetTimestamp()
// ==============
// Returns the Timestamp depending on the type

bits(64) <a id="impl-shared.GetTimestamp.1"/>GetTimestamp(<a href="shared_pseudocode.html#TimeStamp" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp</a> timeStampType)
    case timeStampType of
        when <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>
            return <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>();
        when <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>
            return <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>() - CNTVOFF_EL2;
        when <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>
            return <a href="shared_pseudocode.html#impl-shared.PhysicalCountInt.0" title="function: bits(64) PhysicalCountInt()">PhysicalCountInt</a>() - CNTPOFF_EL2;
        when <a href="shared_pseudocode.html#TimeStamp_None" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_None</a>
            return <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(64);
        when <a href="shared_pseudocode.html#TimeStamp_CoreSight" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_CoreSight</a>
            return bits(64) IMPLEMENTATION_DEFINED "CoreSight timestamp";
        otherwise
            <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TraceBufferEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TraceBufferEnabled</h3>
      <p class="pseudocode">// TraceBufferEnabled()
// ====================

boolean <a id="impl-shared.TraceBufferEnabled.0"/>TraceBufferEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveTraceBufferExtension.0" title="function: boolean HaveTraceBufferExtension()">HaveTraceBufferExtension</a>() || TRBLIMITR_EL1.E == '0' then
        return FALSE;
    if !<a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() then
        return FALSE;
    (-, el) = <a href="shared_pseudocode.html#impl-shared.TraceBufferOwner.0" title="function: (boolean, bits(2)) TraceBufferOwner()">TraceBufferOwner</a>();
    return !<a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(el);</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TraceBufferOwner"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TraceBufferOwner</h3>
      <p class="pseudocode">// TraceBufferOwner()
// ==================
// Return the owning Security state and Exception level. Must only be called
// when SelfHostedTraceEnabled() is TRUE.

(boolean, bits(2)) <a id="impl-shared.TraceBufferOwner.0"/>TraceBufferOwner()
    assert <a href="shared_pseudocode.html#impl-shared.HaveTraceBufferExtension.0" title="function: boolean HaveTraceBufferExtension()">HaveTraceBufferExtension</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>();
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        secure = (MDCR_EL3.NSTB&lt;1&gt; == '0');
    else
        secure = <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>();
    if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; MDCR_EL2.E2TB == '00' then
        el = <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        el = <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;
    return (secure, el);</p>
    </div>
    <div class="ps"><a id="shared.trace.TraceBuffer.TraceBufferRunning"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/TraceBuffer/TraceBufferRunning</h3>
      <p class="pseudocode">// TraceBufferRunning()
// ====================

boolean <a id="impl-shared.TraceBufferRunning.0"/>TraceBufferRunning()
    return <a href="shared_pseudocode.html#impl-shared.TraceBufferEnabled.0" title="function: boolean TraceBufferEnabled()">TraceBufferEnabled</a>() &amp;&amp; TRBSR_EL1.S == '0';</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.SelfHostedTraceEnabled"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/SelfHostedTraceEnabled</h3>
      <p class="pseudocode">// SelfHostedTraceEnabled()
// ========================
// Returns TRUE if Self-hosted Trace is enabled.

boolean <a id="impl-shared.SelfHostedTraceEnabled.0"/>SelfHostedTraceEnabled()
    if !<a href="shared_pseudocode.html#impl-shared.HaveTraceExt.0" title="function: boolean HaveTraceExt()">HaveTraceExt</a>() || !<a href="shared_pseudocode.html#impl-shared.HaveSelfHostedTrace.0" title="function: boolean HaveSelfHostedTrace()">HaveSelfHostedTrace</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
        secure_trace_enable = (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.STE else MDCR_EL3.STE);
        niden = (secure_trace_enable == '0' || <a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>());
    else
        // If no EL3, IsSecure() returns the Effective value of (SCR_EL3.NS == '0')
        niden = (!<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>());
    return (EDSCR.TFO == '0' || !niden);</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceAllowed"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceAllowed</h3>
      <p class="pseudocode">// TraceAllowed()
// ==============
// Returns TRUE if Self-hosted Trace is allowed in the current Security state and Exception level

boolean <a id="impl-shared.TraceAllowed.0"/>TraceAllowed()
    if !<a href="shared_pseudocode.html#impl-shared.HaveTraceExt.0" title="function: boolean HaveTraceExt()">HaveTraceExt</a>() then return FALSE;
    if <a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            secure_trace_enable = (if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then SDCR.STE else MDCR_EL3.STE);
            if secure_trace_enable == '0' then return FALSE;
        TGE_bit = if <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() then HCR_EL2.TGE else '0';
        case PSTATE.EL of
            when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>  TRE_bit = if !<a href="shared_pseudocode.html#impl-shared.HaveAArch64.0" title="function: boolean HaveAArch64()">HaveAArch64</a>() then TRFCR.E1TRE else '0';
            when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>  TRE_bit = TRFCR_EL2.E2TRE;
            when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>  TRE_bit = TRFCR_EL1.E1TRE;
            when <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>  TRE_bit = if TGE_bit == '1' then TRFCR_EL2.E0HTRE else TRFCR_EL1.E0TRE;
        return TRE_bit == '1';
    else
        return (!<a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() || <a href="shared_pseudocode.html#impl-shared.ExternalSecureNoninvasiveDebugEnabled.0" title="function: boolean ExternalSecureNoninvasiveDebugEnabled()">ExternalSecureNoninvasiveDebugEnabled</a>());</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceContextIDR2"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceContextIDR2</h3>
      <p class="pseudocode">// TraceContextIDR2()
// ==================

boolean <a id="impl-shared.TraceContextIDR2.0"/>TraceContextIDR2()
    if !<a href="shared_pseudocode.html#impl-shared.TraceAllowed.0" title="function: boolean TraceAllowed()">TraceAllowed</a>()|| !<a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then return FALSE;
    return (!<a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() || TRFCR_EL2.CX == '1');</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceSynchronizationBarrier"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceSynchronizationBarrier</h3>
      <p class="pseudocode">// Memory barrier instruction that preserves the relative order of memory accesses to System
// registers due to trace operations and other memory accesses to the same registers
<a id="impl-shared.TraceSynchronizationBarrier.0"/>TraceSynchronizationBarrier();</p>
    </div>
    <div class="ps"><a id="shared.trace.selfhosted.TraceTimeStamp"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/selfhosted/TraceTimeStamp</h3>
      <p class="pseudocode">// TraceTimeStamp()
// ================

TimeStamp <a id="impl-shared.TraceTimeStamp.0"/>TraceTimeStamp()
    if <a href="shared_pseudocode.html#impl-shared.SelfHostedTraceEnabled.0" title="function: boolean SelfHostedTraceEnabled()">SelfHostedTraceEnabled</a>() then
        if <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then
            TS_el2 = TRFCR_EL2.TS;
            if !<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; TS_el2 == '10' then
                // Reserved value
                (-, TS_el2) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_EL2TIMESTAMP" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_EL2TIMESTAMP</a>);

            case TS_el2 of
                when '00'
                    // Falls out to check TRFCR_EL1.TS
                when '01'
                    return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
                when '10'
                    assert <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>();  // Otherwise ConstrainUnpredictableBits removes this case
                    return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
                when '11'
                    return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;

        TS_el1 = TRFCR_EL1.TS;
        if TS_el1 == '00' || (!<a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>() &amp;&amp; TS_el1 == '10') then
            // Reserved value
            (-, TS_el1) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_EL1TIMESTAMP" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_EL1TIMESTAMP</a>);

        case TS_el1 of
            when '01'
                return <a href="shared_pseudocode.html#TimeStamp_Virtual" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Virtual</a>;
            when '10'
                assert <a href="shared_pseudocode.html#impl-shared.HaveECVExt.0" title="function: boolean HaveECVExt()">HaveECVExt</a>();
                return <a href="shared_pseudocode.html#TimeStamp_OffsetPhysical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_OffsetPhysical</a>;
            when '11'
                return <a href="shared_pseudocode.html#TimeStamp_Physical" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_Physical</a>;
            otherwise
                <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();         // ConstrainUnpredictableBits removes this case
    else
        return <a href="shared_pseudocode.html#TimeStamp_CoreSight" title="enumeration TimeStamp {&#13; TimeStamp_None, TimeStamp_CoreSight, TimeStamp_Physical, TimeStamp_OffsetPhysical, TimeStamp_Virtual  }">TimeStamp_CoreSight</a>;</p>
    </div>
    <div class="ps"><a id="shared.trace.system.IsTraceCorePowered"/><h3 class="pseudocode">
            Library pseudocode for shared/trace/system/IsTraceCorePowered</h3>
      <p class="pseudocode">// Returns TRUE if the Trace Core Power Domain is powered up
boolean <a id="impl-shared.IsTraceCorePowered.0"/>IsTraceCorePowered();</p>
    </div>
    <div class="ps"><a id="shared.translation.at.ATAccess"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/ATAccess</h3>
      <p class="pseudocode">enumeration <a id="ATAccess"/>ATAccess {
    <a id="ATAccess_Read"/>ATAccess_Read,
    <a id="ATAccess_Write"/>ATAccess_Write,
    <a id="ATAccess_ReadPAN"/>ATAccess_ReadPAN,
    <a id="ATAccess_WritePAN"/>ATAccess_WritePAN
};</p>
    </div>
    <div class="ps"><a id="shared.translation.at.EncodePARAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/EncodePARAttrs</h3>
      <p class="pseudocode">// EncodePARAttrs()
// ================
// Convert orthogonal attributes and hints to 64-bit PAR ATTR field.

bits(8) <a id="impl-shared.EncodePARAttrs.1"/>EncodePARAttrs(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    bits(8) result;

    if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() &amp;&amp; memattrs.tagged then
        result&lt;7:0&gt; = '11110000';
        return result;

    if memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        result&lt;7:4&gt; = '0000';
        if memattrs.device == <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> then
            result&lt;3:0&gt; = '0000';
        elsif memattrs.device == <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> then
            result&lt;3:0&gt; = '0100';
        elsif memattrs.device == <a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a> then
            result&lt;3:0&gt; = '1000';
        else // DeviceType_GRE
            result&lt;3:0&gt; = '1100';
    else
        if memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
            result&lt;7:6&gt; = if memattrs.outer.transient then '00' else '10';
            result&lt;5:4&gt; = memattrs.outer.hints;
        elsif memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
            result&lt;7:6&gt; = if memattrs.outer.transient then '01' else '11';
            result&lt;5:4&gt; = memattrs.outer.hints;
        else // MemAttr_NC
            result&lt;7:4&gt; = '0100';

        if memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
            result&lt;3:2&gt; = if memattrs.inner.transient then '00' else '10';
            result&lt;1:0&gt; = memattrs.inner.hints;
        elsif memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> then
            result&lt;3:2&gt; = if memattrs.inner.transient then '01' else '11';
            result&lt;1:0&gt; = memattrs.inner.hints;
        else // MemAttr_NC
            result&lt;3:0&gt; = '0100';

    return result;</p>
    </div>
    <div class="ps"><a id="shared.translation.at.PAREncodeShareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/PAREncodeShareability</h3>
      <p class="pseudocode">// PAREncodeShareability()
// =======================
// Derive 64-bit PAR SH field.

bits(2) <a id="impl-shared.PAREncodeShareability.1"/>PAREncodeShareability(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if (memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> ||
            (memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp;
             memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>)) then
        // Force Outer-Shareable on Device and Normal Non-Cacheable memory
        return '10';

    case memattrs.shareability of
        when <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a> return '00';
        when <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a> return '11';
        when <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> return '10';</p>
    </div>
    <div class="ps"><a id="shared.translation.at.TranslationStage"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/at/TranslationStage</h3>
      <p class="pseudocode">enumeration <a id="TranslationStage"/>TranslationStage {
    <a id="TranslationStage_1"/>TranslationStage_1,
    <a id="TranslationStage_12"/>TranslationStage_12
};</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeDevice"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeDevice</h3>
      <p class="pseudocode">// DecodeDevice()
// ==============
// Decode output Device type

DeviceType <a id="impl-shared.DecodeDevice.1"/>DecodeDevice(bits(2) device)
    case device of
        when '00'   return <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
        when '01'   return <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
        when '10'   return <a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a>;
        when '11'   return <a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a>;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeLDFAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeLDFAttr</h3>
      <p class="pseudocode">// DecodeLDFAttr()
// ===============
// Decode memory attributes using LDF (Long Descriptor Format) mapping

MemAttrHints <a id="impl-shared.DecodeLDFAttr.1"/>DecodeLDFAttr(bits(4) attr)
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> ldfattr;

    if    attr == 'x0xx' then ldfattr.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>; // Write-through
    elsif attr == '0100' then ldfattr.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>; // Non-cacheable
    elsif attr == 'x1xx' then ldfattr.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>; // Write-back
    else                      <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    // Allocation hints are applicable only to cacheable memory.
    if ldfattr.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
        case attr&lt;1:0&gt; of
            when '00' ldfattr.hints = <a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'">MemHint_No</a>;  // No allocation hints
            when '01' ldfattr.hints = <a href="shared_pseudocode.html#MemHint_WA" title="constant bits(2) MemHint_WA = '01'">MemHint_WA</a>;  // Write-allocate
            when '10' ldfattr.hints = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;  // Read-allocate
            when '11' ldfattr.hints = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>; // Read/Write allocate

    // The Transient hint applies only to cacheable memory with some allocation hints.
    if ldfattr.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp; ldfattr.hints != <a href="shared_pseudocode.html#MemHint_No" title="constant bits(2) MemHint_No = '00'">MemHint_No</a> then
        ldfattr.transient = attr&lt;3&gt; == '0';

    return ldfattr;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeSDFAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeSDFAttr</h3>
      <p class="pseudocode">// DecodeSDFAttr()
// ===============
// Decode memory attributes using SDF (Short Descriptor Format) mapping

MemAttrHints <a id="impl-shared.DecodeSDFAttr.1"/>DecodeSDFAttr(bits(2) rgn)
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> sdfattr;

    case rgn of
        when '00'                   // Non-cacheable (no allocate)
            sdfattr.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
        when '01'                   // Write-back, Read and Write allocate
            sdfattr.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            sdfattr.hints = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
        when '10'                   // Write-through, Read allocate
            sdfattr.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            sdfattr.hints = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
        when '11'                   // Write-back, Read allocate
            sdfattr.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            sdfattr.hints = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;

    sdfattr.transient = FALSE;

    return sdfattr;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.DecodeShareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/DecodeShareability</h3>
      <p class="pseudocode">// DecodeShareability()
// ====================
// Decode shareability of target memory region

Shareability <a id="impl-shared.DecodeShareability.1"/>DecodeShareability(bits(2) sh)
    case sh of
        when '10' return <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
        when '11' return <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
        when '00' return <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;
        otherwise
            case <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_Shareability" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_Shareability</a>) of
                when <a href="shared_pseudocode.html#Constraint_OSH" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_OSH</a> return <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
                when <a href="shared_pseudocode.html#Constraint_ISH" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_ISH</a> return <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
                when <a href="shared_pseudocode.html#Constraint_NSH" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NSH</a> return <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.EffectiveShareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/EffectiveShareability</h3>
      <p class="pseudocode">// EffectiveShareability()
// =======================
// Force Outer Shareability on Device and Normal iNCoNC memory

Shareability <a id="impl-shared.EffectiveShareability.1"/>EffectiveShareability(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    if (memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> ||
            (memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> &amp;&amp;
             memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>)) then
        return <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
    else
        return memattrs.shareability;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.MAIRAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/MAIRAttr</h3>
      <p class="pseudocode">// MAIRAttr()
// ==========
// Retrieve the memory attribute encoding indexed in the given MAIR

bits(8) <a id="impl-shared.MAIRAttr.2"/>MAIRAttr(integer index, <a href="shared_pseudocode.html#MAIRType" title="type MAIRType">MAIRType</a> mair)
    bit_index = 8 * index;
    return mair&lt;bit_index+7:bit_index&gt;;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.NormalNCMemAttr"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/NormalNCMemAttr</h3>
      <p class="pseudocode">// NormalNCMemAttr()
// =================
// Normal Non-cacheable memory attributes

MemoryAttributes <a id="impl-shared.NormalNCMemAttr.0"/>NormalNCMemAttr()
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> non_cacheable;
    non_cacheable.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> nc_memattrs;
    nc_memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
    nc_memattrs.outer        = non_cacheable;
    nc_memattrs.inner        = non_cacheable;
    nc_memattrs.shareability = <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
    nc_memattrs.tagged       = FALSE;

    return nc_memattrs;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S1ConstrainUnpredictableRESMAIR"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S1ConstrainUnpredictableRESMAIR</h3>
      <p class="pseudocode">// S1ConstrainUnpredictableRESMAIR()
// =================================
// Determine whether a reserved value occupies MAIR_ELx.AttrN

boolean <a id="impl-shared.S1ConstrainUnpredictableRESMAIR.2"/>S1ConstrainUnpredictableRESMAIR(bits(8) attr, boolean s1aarch64)
    case attr of
        when '0000xx01' return !(s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatXS.0" title="function: boolean HaveFeatXS()">HaveFeatXS</a>());
        when '0000xxxx' return attr&lt;1:0&gt; != '00';
        when '01000000' return !(s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatXS.0" title="function: boolean HaveFeatXS()">HaveFeatXS</a>());
        when '10100000' return !(s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatXS.0" title="function: boolean HaveFeatXS()">HaveFeatXS</a>());
        when '11110000' return !(s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>());
        when 'xxxx0000' return TRUE;
        otherwise       return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S1DecodeMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S1DecodeMemAttrs</h3>
      <p class="pseudocode">// S1DecodeMemAttrs()
// ==================
// Decode MAIR-format memory attributes assigned in stage 1

MemoryAttributes <a id="impl-shared.S1DecodeMemAttrs.3"/>S1DecodeMemAttrs(bits(8) attr, bits(2) sh, boolean s1aarch64)
    if <a href="shared_pseudocode.html#impl-shared.S1ConstrainUnpredictableRESMAIR.2" title="function: boolean S1ConstrainUnpredictableRESMAIR(bits(8) attr, boolean s1aarch64)">S1ConstrainUnpredictableRESMAIR</a>(attr, s1aarch64) then
        (-, attr) = <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBits.1" title="function: (Constraint,bits(width)) ConstrainUnpredictableBits(Unpredictable which)">ConstrainUnpredictableBits</a>(<a href="shared_pseudocode.html#Unpredictable_RESMAIR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_RESMAIR</a>);

    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;
    case attr of
        when '0000xxxx' // Device memory
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device  = <a href="shared_pseudocode.html#impl-shared.DecodeDevice.1" title="function: DeviceType DecodeDevice(bits(2) device)">DecodeDevice</a>(attr&lt;3:2&gt;);
            memattrs.tagged  = FALSE;
            memattrs.xs      = if s1aarch64 then NOT attr&lt;0&gt; else '1';
        when '01000000'
            assert s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatXS.0" title="function: boolean HaveFeatXS()">HaveFeatXS</a>();
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.tagged  = FALSE;
            memattrs.outer.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.inner.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
            memattrs.xs          = '0';

        when '10100000'
            assert s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveFeatXS.0" title="function: boolean HaveFeatXS()">HaveFeatXS</a>();
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.tagged  = FALSE;
            memattrs.outer.attrs     = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.outer.hints     = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.outer.transient = FALSE;
            memattrs.inner.attrs     = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
            memattrs.inner.hints     = <a href="shared_pseudocode.html#MemHint_RA" title="constant bits(2) MemHint_RA = '10'">MemHint_RA</a>;
            memattrs.inner.transient = FALSE;
            memattrs.xs              = '0';
        when '11110000' // Tagged memory
            assert s1aarch64 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>();
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.tagged  = TRUE;
            memattrs.outer.attrs     = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.outer.hints     = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.outer.transient = FALSE;
            memattrs.inner.attrs     = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;
            memattrs.inner.hints     = <a href="shared_pseudocode.html#MemHint_RWA" title="constant bits(2) MemHint_RWA = '11'">MemHint_RWA</a>;
            memattrs.inner.transient = FALSE;
            memattrs.xs              = '0';
        otherwise
            memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.outer   = <a href="shared_pseudocode.html#impl-shared.DecodeLDFAttr.1" title="function: MemAttrHints DecodeLDFAttr(bits(4) attr)">DecodeLDFAttr</a>(attr&lt;7:4&gt;);
            memattrs.inner   = <a href="shared_pseudocode.html#impl-shared.DecodeLDFAttr.1" title="function: MemAttrHints DecodeLDFAttr(bits(4) attr)">DecodeLDFAttr</a>(attr&lt;3:0&gt;);
            memattrs.tagged  = FALSE;

            if (memattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
                    memattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>) then
                memattrs.xs = '0';
            else
                memattrs.xs = '1';

    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.DecodeShareability.1" title="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);

    return memattrs;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1AttrHints"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1AttrHints</h3>
      <p class="pseudocode">// S2CombineS1AttrHints()
// ======================
// Determine resultant Normal memory cacheability and allocation hints from
// combining stage 1 Normal memory attributes and stage 2 cacheability attributes.

MemAttrHints <a id="impl-shared.S2CombineS1AttrHints.2"/>S2CombineS1AttrHints(<a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> s1_attrhints, <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> s2_attrhints)
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> attrhints;

    if s1_attrhints.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> || s2_attrhints.attrs == <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
        attrhints.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
    elsif s1_attrhints.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> || s2_attrhints.attrs == <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a> then
        attrhints.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
    else
        attrhints.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;

    // Stage 2 does not assign any allocation hints
    // Instead, they are inherited from stage 1
    if attrhints.attrs != <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a> then
        attrhints.hints     = s1_attrhints.hints;
        attrhints.transient = s1_attrhints.transient;

    return attrhints;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1Device"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1Device</h3>
      <p class="pseudocode">// S2CombineS1Device()
// ===================
// Determine resultant Device type from combining output memory attributes
// in stage 1 and Device attributes in stage 2

DeviceType <a id="impl-shared.S2CombineS1Device.2"/>S2CombineS1Device(<a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType</a> s1_device, <a href="shared_pseudocode.html#DeviceType" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType</a> s2_device)
    if s1_device == <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> || s2_device == <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a> then
        return <a href="shared_pseudocode.html#DeviceType_nGnRnE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRnE</a>;
    elsif s1_device == <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> || s2_device == <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a> then
        return <a href="shared_pseudocode.html#DeviceType_nGnRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGnRE</a>;
    elsif s1_device == <a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a> || s2_device == <a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a> then
        return <a href="shared_pseudocode.html#DeviceType_nGRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_nGRE</a>;
    else
        return <a href="shared_pseudocode.html#DeviceType_GRE" title="enumeration DeviceType {DeviceType_GRE, DeviceType_nGRE, DeviceType_nGnRE, DeviceType_nGnRnE}">DeviceType_GRE</a>;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1MemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1MemAttrs</h3>
      <p class="pseudocode">// S2CombineS1MemAttrs()
// =====================
// Combine stage 2 with stage 1 memory attributes

MemoryAttributes <a id="impl-shared.S2CombineS1MemAttrs.2"/>S2CombineS1MemAttrs(<a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> s1_memattrs,
                                     <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> s2_memattrs)
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;

    if s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> &amp;&amp; s2_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then
        memattrs.memtype = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
        memattrs.device  = <a href="shared_pseudocode.html#impl-shared.S2CombineS1Device.2" title="function: DeviceType S2CombineS1Device(DeviceType s1_device, DeviceType s2_device)">S2CombineS1Device</a>(s1_memattrs.device, s2_memattrs.device);
    elsif s1_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then    // S2 Normal, S1 Device
        memattrs = s1_memattrs;
    elsif s2_memattrs.memtype == <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a> then    // S2 Device, S1 Normal
        memattrs = s2_memattrs;
    else                                                // S2 Normal, S1 Normal
        memattrs.memtype = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
        memattrs.inner   = <a href="shared_pseudocode.html#impl-shared.S2CombineS1AttrHints.2" title="function: MemAttrHints S2CombineS1AttrHints(MemAttrHints s1_attrhints, MemAttrHints s2_attrhints)">S2CombineS1AttrHints</a>(s1_memattrs.inner, s2_memattrs.inner);
        memattrs.outer   = <a href="shared_pseudocode.html#impl-shared.S2CombineS1AttrHints.2" title="function: MemAttrHints S2CombineS1AttrHints(MemAttrHints s1_attrhints, MemAttrHints s2_attrhints)">S2CombineS1AttrHints</a>(s1_memattrs.outer, s2_memattrs.outer);

    if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) || !<a href="shared_pseudocode.html#impl-shared.HaveMTE2Ext.0" title="function: boolean HaveMTE2Ext()">HaveMTE2Ext</a>() then
        memattrs.tagged = FALSE;
    else
        memattrs.tagged = <a href="shared_pseudocode.html#AArch64.IsS2ResultTagged.2" title="function: boolean AArch64.IsS2ResultTagged(MemoryAttributes s2_memattrs, boolean s1_tagged)">AArch64.IsS2ResultTagged</a>(memattrs, s1_memattrs.tagged);

    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.S2CombineS1Shareability.2" title="function: Shareability S2CombineS1Shareability(Shareability s1_shareability,&#13; Shareability s2_shareability)">S2CombineS1Shareability</a>(s1_memattrs.shareability,
                                                    s2_memattrs.shareability);
    memattrs.xs           = s2_memattrs.xs;

    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.EffectiveShareability.1" title="function: Shareability EffectiveShareability(MemoryAttributes memattrs)">EffectiveShareability</a>(memattrs);
    return memattrs;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2CombineS1Shareability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2CombineS1Shareability</h3>
      <p class="pseudocode">// S2CombineS1Shareability()
// =========================
// Combine stage 2 shareability with stage 1

Shareability <a id="impl-shared.S2CombineS1Shareability.2"/>S2CombineS1Shareability(<a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> s1_shareability,
                                     <a href="shared_pseudocode.html#Shareability" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability</a> s2_shareability)

    if (s1_shareability == <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a> ||
            s2_shareability == <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>) then
        return <a href="shared_pseudocode.html#Shareability_OSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_OSH</a>;
    elsif (s1_shareability == <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a> ||
            s2_shareability == <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>) then
        return <a href="shared_pseudocode.html#Shareability_ISH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_ISH</a>;
    else
        return <a href="shared_pseudocode.html#Shareability_NSH" title="enumeration Shareability {&#13; Shareability_NSH,&#13; Shareability_ISH,&#13; Shareability_OSH&#13; }">Shareability_NSH</a>;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2DecodeCacheability"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2DecodeCacheability</h3>
      <p class="pseudocode">// S2DecodeCacheability()
// ======================
// Determine the stage 2 cacheability for Normal memory

MemAttrHints <a id="impl-shared.S2DecodeCacheability.1"/>S2DecodeCacheability(bits(2) attr)
    <a href="shared_pseudocode.html#MemAttrHints" title="type MemAttrHints is ( bits(2) attrs, bits(2) hints, boolean transient )">MemAttrHints</a> s2attr;

    case attr of
        when '01' s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;  // Non-cacheable
        when '10' s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;  // Write-through
        when '11' s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;  // Write-back
        otherwise // Constrained unpredictable
            case <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictable.1" title="function: Constraint ConstrainUnpredictable(Unpredictable which)">ConstrainUnpredictable</a>(<a href="shared_pseudocode.html#Unpredictable_S2RESMEMATTR" title="enumeration Unpredictable { Unpredictable_VMSR,&#13;  Unpredictable_WBOVERLAPLD,&#13;  Unpredictable_WBOVERLAPST,&#13;  Unpredictable_LDPOVERLAP,&#13;  Unpredictable_BASEOVERLAP,&#13;  Unpredictable_DATAOVERLAP,&#13;  Unpredictable_DEVPAGE2,&#13;  Unpredictable_INSTRDEVICE,&#13;  Unpredictable_RESCPACR,&#13;  Unpredictable_RESMAIR,&#13;  Unpredictable_S1CTAGGED,&#13;  Unpredictable_S2RESMEMATTR,&#13;  Unpredictable_RESTEXCB,&#13;  Unpredictable_RESPRRR,&#13;  Unpredictable_RESDACR,&#13;  Unpredictable_RESVTCRS,&#13;  Unpredictable_RESTnSZ,&#13;  Unpredictable_RESTCF,&#13;  Unpredictable_DEVICETAGSTORE,&#13;  Unpredictable_OORTnSZ,&#13;  Unpredictable_LARGEIPA,&#13;  Unpredictable_ESRCONDPASS,&#13;  Unpredictable_ILZEROIT,&#13;  Unpredictable_ILZEROT,&#13;  Unpredictable_BPVECTORCATCHPRI,&#13;  Unpredictable_VCMATCHHALF,&#13;  Unpredictable_VCMATCHDAPA,&#13;  Unpredictable_WPMASKANDBAS,&#13;  Unpredictable_WPBASCONTIGUOUS,&#13;  Unpredictable_RESWPMASK,&#13;  Unpredictable_WPMASKEDBITS,&#13;  Unpredictable_RESBPWPCTRL,&#13;  Unpredictable_BPNOTIMPL,&#13;  Unpredictable_RESBPTYPE,&#13;  Unpredictable_BPNOTCTXCMP,&#13;  Unpredictable_BPMATCHHALF,&#13;  Unpredictable_BPMISMATCHHALF,&#13;  Unpredictable_RESTARTALIGNPC,&#13;  Unpredictable_RESTARTZEROUPPERPC,&#13;  Unpredictable_ZEROUPPER,&#13;  Unpredictable_ERETZEROUPPERPC,&#13;  Unpredictable_A32FORCEALIGNPC,&#13;  Unpredictable_SMD,&#13;  Unpredictable_NONFAULT,&#13;  Unpredictable_SVEZEROUPPER,&#13;  Unpredictable_SVELDNFDATA,&#13;  Unpredictable_SVELDNFZERO,&#13;  Unpredictable_CHECKSPNONEACTIVE,&#13;  Unpredictable_SMEZEROUPPER,&#13;  Unpredictable_NVNV1,&#13;  Unpredictable_Shareability,&#13;  Unpredictable_AFUPDATE,&#13;  Unpredictable_IESBinDebug,&#13;  Unpredictable_BADPMSFCR,&#13;  Unpredictable_ZEROBTYPE,&#13;  Unpredictable_EL2TIMESTAMP,&#13; Unpredictable_EL1TIMESTAMP,&#13;  Unpredictable_WFxTDEBUG,&#13;  Unpredictable_LS64UNSUPPORTED,&#13;  Unpredictable_MISALIGNEDATOMIC,&#13;  Unpredictable_CLEARERRITEZERO,&#13;  Unpredictable_ALUEXCEPTIONRETURN,&#13;  Unpredictable_IGNORETRAPINDEBUG,&#13;  Unpredictable_DBGxVR_RESS,&#13;  Unpredictable_PMUEVENTCOUNTER,&#13;  Unpredictable_PMSCR_PCT}">Unpredictable_S2RESMEMATTR</a>) of
                when <a href="shared_pseudocode.html#Constraint_NC" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_NC</a> s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_NC" title="constant bits(2) MemAttr_NC = '00'">MemAttr_NC</a>;
                when <a href="shared_pseudocode.html#Constraint_WT" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WT</a> s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_WT" title="constant bits(2) MemAttr_WT = '10'">MemAttr_WT</a>;
                when <a href="shared_pseudocode.html#Constraint_WB" title="enumeration Constraint    { Constraint_NONE,  Constraint_UNKNOWN, Constraint_UNDEF, Constraint_UNDEFEL0, Constraint_NOP, Constraint_TRUE,&#13; Constraint_FALSE,&#13; Constraint_DISABLED,&#13; Constraint_UNCOND, Constraint_COND, Constraint_ADDITIONAL_DECODE,  Constraint_WBSUPPRESS,&#13; Constraint_FAULT,&#13; Constraint_LIMITED_ATOMICITY, Constraint_NVNV1_00,&#13; Constraint_NVNV1_01,&#13; Constraint_NVNV1_11,&#13; Constraint_OSH, Constraint_ISH, Constraint_NSH, &#13; Constraint_NC, Constraint_WT, Constraint_WB, &#13;  Constraint_FORCE, Constraint_FORCENOSLCHECK,&#13;  Constraint_PMSCR_PCT_VIRT}">Constraint_WB</a> s2attr.attrs = <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>;

    // Stage 2 does not assign hints or the transient property
    // They are inherited from stage 1 if the result of the combination allows it
    s2attr.hints     = bits(2) UNKNOWN;
    s2attr.transient = boolean UNKNOWN;

    return s2attr;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.S2DecodeMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/S2DecodeMemAttrs</h3>
      <p class="pseudocode">// S2DecodeMemAttrs()
// ==================
// Decode stage 2 memory attributes

MemoryAttributes <a id="impl-shared.S2DecodeMemAttrs.2"/>S2DecodeMemAttrs(bits(4) attr, bits(2) sh)
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs;

    case attr of
        when '00xx' // Device memory
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Device" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Device</a>;
            memattrs.device       = <a href="shared_pseudocode.html#impl-shared.DecodeDevice.1" title="function: DeviceType DecodeDevice(bits(2) device)">DecodeDevice</a>(attr&lt;1:0&gt;);
        otherwise   // Normal memory
            memattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
            memattrs.outer        = <a href="shared_pseudocode.html#impl-shared.S2DecodeCacheability.1" title="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</a>(attr&lt;3:2&gt;);
            memattrs.inner        = <a href="shared_pseudocode.html#impl-shared.S2DecodeCacheability.1" title="function: MemAttrHints S2DecodeCacheability(bits(2) attr)">S2DecodeCacheability</a>(attr&lt;1:0&gt;);

    memattrs.shareability = <a href="shared_pseudocode.html#impl-shared.DecodeShareability.1" title="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);

    return memattrs;</p>
    </div>
    <div class="ps"><a id="shared.translation.attrs.WalkMemAttrs"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/attrs/WalkMemAttrs</h3>
      <p class="pseudocode">// WalkMemAttrs()
// ==============
// Retrieve memory attributes of translation table walk

MemoryAttributes <a id="impl-shared.WalkMemAttrs.3"/>WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> walkmemattrs;

    walkmemattrs.memtype      = <a href="shared_pseudocode.html#MemType_Normal" title="enumeration MemType {MemType_Normal, MemType_Device}">MemType_Normal</a>;
    walkmemattrs.shareability = <a href="shared_pseudocode.html#impl-shared.DecodeShareability.1" title="function: Shareability DecodeShareability(bits(2) sh)">DecodeShareability</a>(sh);
    walkmemattrs.inner        = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(irgn);
    walkmemattrs.outer        = <a href="shared_pseudocode.html#impl-shared.DecodeSDFAttr.1" title="function: MemAttrHints DecodeSDFAttr(bits(2) rgn)">DecodeSDFAttr</a>(orgn);
    walkmemattrs.tagged       = FALSE;
    if (walkmemattrs.inner.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a> &amp;&amp;
            walkmemattrs.outer.attrs == <a href="shared_pseudocode.html#MemAttr_WB" title="constant bits(2) MemAttr_WB = '11'">MemAttr_WB</a>) then
        walkmemattrs.xs = '0';
    else
        walkmemattrs.xs = '1';

    return walkmemattrs;</p>
    </div>
    <div class="ps"><a id="shared.translation.faults.AlignmentFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/faults/AlignmentFault</h3>
      <p class="pseudocode">// AlignmentFault()
// ================

FaultRecord <a id="impl-shared.AlignmentFault.3"/>AlignmentFault(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype, boolean iswrite, boolean secondstage)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = <a href="shared_pseudocode.html#Fault_Alignment" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_Alignment</a>;
    fault.acctype     = acctype;
    fault.write       = iswrite;
    fault.secondstage = secondstage;

    return fault;</p>
    </div>
    <div class="ps"><a id="shared.translation.faults.AsyncExternalAbort"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/faults/AsyncExternalAbort</h3>
      <p class="pseudocode">// AsyncExternalAbort()
// ====================
// Return a fault record indicating an asynchronous external abort

FaultRecord <a id="impl-shared.AsyncExternalAbort.3"/>AsyncExternalAbort(boolean parity, bits(2) errortype, bit extflag)
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = if parity then <a href="shared_pseudocode.html#Fault_AsyncParity" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncParity</a> else <a href="shared_pseudocode.html#Fault_AsyncExternal" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_AsyncExternal</a>;
    fault.extflag     = extflag;
    fault.errortype   = errortype;
    fault.acctype     = <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;

    return fault;</p>
    </div>
    <div class="ps"><a id="shared.translation.faults.NoFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/faults/NoFault</h3>
      <p class="pseudocode">// NoFault()
// =========
// Return a clear fault record indicating no faults have occured

FaultRecord <a id="impl-shared.NoFault.0"/>NoFault()
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault;

    fault.statuscode  = <a href="shared_pseudocode.html#Fault_None" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_None</a>;
    fault.acctype     = <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NORMAL</a>;
    fault.secondstage = FALSE;
    fault.s2fs1walk   = FALSE;
    fault.gpcfs2walk  = FALSE;
    fault.gpcf        = <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();

    return fault;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.AbovePPS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/AbovePPS</h3>
      <p class="pseudocode">// AbovePPS()
// ==========
// Returns TRUE if an address exceeds the range configured in GPCCR_EL3.PPS.

boolean <a id="impl-shared.AbovePPS.1"/>AbovePPS(bits(52) address)
    pps = <a href="shared_pseudocode.html#impl-shared.DecodePPS.0" title="function: integer DecodePPS()">DecodePPS</a>();
    if pps == 52 then
        return FALSE;

    return !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(address&lt;51:pps&gt;);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTBlock"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTBlock</h3>
      <p class="pseudocode">// DecodeGPTBlock()
// ================
// Validate and decode a GPT Block descriptor

(GPCF, GPTEntry) <a id="impl-shared.DecodeGPTBlock.2"/>DecodeGPTBlock(<a href="shared_pseudocode.html#PGSe" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGSe</a> pgs, bits(64) entry)
    assert entry&lt;3:0&gt; == <a href="shared_pseudocode.html#GPT_Block" title="constant bits(4) GPT_Block = '0001'">GPT_Block</a>;
    <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> result;

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(entry&lt;63:8&gt;) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> UNKNOWN);

    if !<a href="shared_pseudocode.html#impl-shared.GPIValid.1" title="function: boolean GPIValid(bits(4) gpi)">GPIValid</a>(entry&lt;7:4&gt;) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> UNKNOWN);

    result.gpi   = entry&lt;7:4&gt;;
    result.level = 0;

    // GPT information from a level 0 GPT Block descriptor is permitted
    // to be cached in a TLB as though the Block is a contiguous region
    // of granules each of the size configured in GPCCR_EL3.PGS.
    case pgs of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  result.size = <a href="shared_pseudocode.html#GPTRange_4KB" title="constant integer GPTRange_4KB = 12">GPTRange_4KB</a>;
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_16KB" title="constant integer GPTRange_16KB = 14">GPTRange_16KB</a>;
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_64KB" title="constant integer GPTRange_64KB = 16">GPTRange_64KB</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    result.contig_size = <a href="shared_pseudocode.html#impl-shared.GPTL0Size.0" title="function: integer GPTL0Size()">GPTL0Size</a>();

    return (<a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>, result);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTContiguous"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTContiguous</h3>
      <p class="pseudocode">// DecodeGPTContiguous()
// =====================
// Validate and decode a GPT Contiguous descriptor

(GPCF, GPTEntry) <a id="impl-shared.DecodeGPTContiguous.2"/>DecodeGPTContiguous(<a href="shared_pseudocode.html#PGSe" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGSe</a> pgs, bits(64) entry)
    assert entry&lt;3:0&gt; == <a href="shared_pseudocode.html#GPT_Contig" title="constant bits(4) GPT_Contig = '0001'">GPT_Contig</a>;
    <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> result;

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(entry&lt;63:10&gt;) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, result);

    result.gpi = entry&lt;7:4&gt;;
    if !<a href="shared_pseudocode.html#impl-shared.GPIValid.1" title="function: boolean GPIValid(bits(4) gpi)">GPIValid</a>(result.gpi) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, result);

    case pgs of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  result.size = <a href="shared_pseudocode.html#GPTRange_4KB" title="constant integer GPTRange_4KB = 12">GPTRange_4KB</a>;
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_16KB" title="constant integer GPTRange_16KB = 14">GPTRange_16KB</a>;
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_64KB" title="constant integer GPTRange_64KB = 16">GPTRange_64KB</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    case entry&lt;9:8&gt; of
        when '01' result.contig_size = <a href="shared_pseudocode.html#GPTRange_2MB" title="constant integer GPTRange_2MB = 21">GPTRange_2MB</a>;
        when '10' result.contig_size = <a href="shared_pseudocode.html#GPTRange_32MB" title="constant integer GPTRange_32MB = 25">GPTRange_32MB</a>;
        when '11' result.contig_size = <a href="shared_pseudocode.html#GPTRange_512MB" title="constant integer GPTRange_512MB = 29">GPTRange_512MB</a>;
        otherwise return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> UNKNOWN);

    result.level = 1;

    return (<a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>, result);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTGranules"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTGranules</h3>
      <p class="pseudocode">// DecodeGPTGranules()
// ===================
// Validate and decode a GPT Granules descriptor

(GPCF, GPTEntry) <a id="impl-shared.DecodeGPTGranules.3"/>DecodeGPTGranules(<a href="shared_pseudocode.html#PGSe" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGSe</a> pgs, integer index, bits(64) entry)
    <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> result;

    for i = 0 to 15
        if !<a href="shared_pseudocode.html#impl-shared.GPIValid.1" title="function: boolean GPIValid(bits(4) gpi)">GPIValid</a>(entry&lt;i*4 +:4&gt;) then
            return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, result);

    result.gpi = entry&lt;index*4 +:4&gt;;

    case pgs of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  result.size = <a href="shared_pseudocode.html#GPTRange_4KB" title="constant integer GPTRange_4KB = 12">GPTRange_4KB</a>;
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_16KB" title="constant integer GPTRange_16KB = 14">GPTRange_16KB</a>;
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> result.size = <a href="shared_pseudocode.html#GPTRange_64KB" title="constant integer GPTRange_64KB = 16">GPTRange_64KB</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    result.contig_size = result.size; // No contiguity
    result.level = 1;

    return (<a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>, result);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodeGPTTable"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodeGPTTable</h3>
      <p class="pseudocode">// DecodeGPTTable()
// ================
// Validate and decode a GPT Table descriptor

(GPCF, GPTTable) <a id="impl-shared.DecodeGPTTable.2"/>DecodeGPTTable(<a href="shared_pseudocode.html#PGSe" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGSe</a> pgs, bits(64) entry)
    assert entry&lt;3:0&gt; == <a href="shared_pseudocode.html#GPT_Table" title="constant bits(4) GPT_Table = '0011'">GPT_Table</a>;
    <a href="shared_pseudocode.html#GPTTable" title="type GPTTable is ( bits(52) address )">GPTTable</a> result;

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(entry&lt;63:52,11:4&gt;) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, <a href="shared_pseudocode.html#GPTTable" title="type GPTTable is ( bits(52) address )">GPTTable</a> UNKNOWN);

    l0sz = <a href="shared_pseudocode.html#impl-shared.GPTL0Size.0" title="function: integer GPTL0Size()">GPTL0Size</a>();
    case pgs of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  p = 12;
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> p = 14;
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> p = 16;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    if !<a href="shared_pseudocode.html#impl-shared.IsZero.1" title="function: boolean IsZero(bits(N) x)">IsZero</a>(entry&lt;l0sz-p-2:12&gt;) then
        return (<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, <a href="shared_pseudocode.html#GPTTable" title="type GPTTable is ( bits(52) address )">GPTTable</a> UNKNOWN);

    case pgs of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  result.address = entry&lt;51:17&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(17);
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> result.address = entry&lt;51:15&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(15);
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> result.address = entry&lt;51:13&gt;:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(13);
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();

    // The address must be within the range covered by the GPT
    if <a href="shared_pseudocode.html#impl-shared.AbovePPS.1" title="function: boolean AbovePPS(bits(52) address)">AbovePPS</a>(result.address) then
        return (<a href="shared_pseudocode.html#GPCF_AddressSize" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_AddressSize</a>, <a href="shared_pseudocode.html#GPTTable" title="type GPTTable is ( bits(52) address )">GPTTable</a> UNKNOWN);

    return (<a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>, result);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodePGS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodePGS</h3>
      <p class="pseudocode">// DecodePGS()
// ===========

PGSe <a id="impl-shared.DecodePGS.1"/>DecodePGS(bits(2) pgs)
    case pgs of
        when '00' return <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>;
        when '10' return <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a>;
        when '01' return <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.DecodePPS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/DecodePPS</h3>
      <p class="pseudocode">// DecodePPS()
// ===========
// Size of region protected by the GPT, in bits.

integer <a id="impl-shared.DecodePPS.0"/>DecodePPS()
    case GPCCR_EL3.PPS of
        when '000' return 32;
        when '001' return 36;
        when '010' return 40;
        when '011' return 42;
        when '100' return 44;
        when '101' return 48;
        when '110' return 52;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPCFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPCFault</h3>
      <p class="pseudocode">// GPCFault()
// ==========
// Constructs and returns a GPCF

GPCFRecord <a id="impl-shared.GPCFault.2"/>GPCFault(<a href="shared_pseudocode.html#GPCF" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF</a> gpf, integer level)
    <a href="shared_pseudocode.html#GPCFRecord" title="type GPCFRecord is ( GPCF gpf, integer level )">GPCFRecord</a> fault;
    fault.gpf   = gpf;
    fault.level = level;
    return fault;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPCNoFault"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPCNoFault</h3>
      <p class="pseudocode">// GPCNoFault()
// ============
// Returns the default properties of a GPCF that does not represent a fault

GPCFRecord <a id="impl-shared.GPCNoFault.0"/>GPCNoFault()
    <a href="shared_pseudocode.html#GPCFRecord" title="type GPCFRecord is ( GPCF gpf, integer level )">GPCFRecord</a> result;
    result.gpf = <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a>;
    return result;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPCRegistersConsistent"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPCRegistersConsistent</h3>
      <p class="pseudocode">// GPCRegistersConsistent()
// ========================
// Returns whether the GPT registers are configured correctly.
// This returns false if any fields select a Reserved value.

boolean <a id="impl-shared.GPCRegistersConsistent.0"/>GPCRegistersConsistent()

    // Check for Reserved register values
    if GPCCR_EL3.PPS == '111' || <a href="shared_pseudocode.html#impl-shared.DecodePPS.0" title="function: integer DecodePPS()">DecodePPS</a>() &gt; <a href="shared_pseudocode.html#AArch64.PAMax.0" title="function: integer AArch64.PAMax()">AArch64.PAMax</a>() then
        return FALSE;
    if GPCCR_EL3.PGS == '11' then
        return FALSE;
    if GPCCR_EL3.SH == '01' then
        return FALSE;

    // Inner and Outer Non-cacheable requires Outer Shareable
    if GPCCR_EL3.&lt;ORGN, IRGN&gt; == '0000' &amp;&amp; GPCCR_EL3.SH != '10' then
        return FALSE;

    return TRUE;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPICheck"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPICheck</h3>
      <p class="pseudocode">// GPICheck()
// ==========
// Returns whether an access to a given physical address space is permitted
// given the configured GPI value.
// paspace: Physical address space of the access
// gpi: Value read from GPT for the access

boolean <a id="impl-shared.GPICheck.2"/>GPICheck(<a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a> paspace, bits(4) gpi)

    case gpi of
        when <a href="shared_pseudocode.html#GPT_NoAccess" title="constant bits(4) GPT_NoAccess = '0000'">GPT_NoAccess</a>  return FALSE;
        when <a href="shared_pseudocode.html#GPT_Secure" title="constant bits(4) GPT_Secure = '1000'">GPT_Secure</a>    return paspace == <a href="shared_pseudocode.html#PAS_Secure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Secure</a>;
        when <a href="shared_pseudocode.html#GPT_NonSecure" title="constant bits(4) GPT_NonSecure = '1001'">GPT_NonSecure</a> return paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a>;
        when <a href="shared_pseudocode.html#GPT_Root" title="constant bits(4) GPT_Root = '1010'">GPT_Root</a>      return paspace == <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>;
        when <a href="shared_pseudocode.html#GPT_Realm" title="constant bits(4) GPT_Realm = '1011'">GPT_Realm</a>     return paspace == <a href="shared_pseudocode.html#PAS_Realm" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Realm</a>;
        when <a href="shared_pseudocode.html#GPT_Any" title="constant bits(4) GPT_Any = '1111'">GPT_Any</a>       return TRUE;
        otherwise          <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPIIndex"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPIIndex</h3>
      <p class="pseudocode">// GPIIndex()
// ==========

integer <a id="impl-shared.GPIIndex.1"/>GPIIndex(bits(52) pa)
    case <a href="shared_pseudocode.html#impl-shared.DecodePGS.1" title="function: PGSe DecodePGS(bits(2) pgs)">DecodePGS</a>(GPCCR_EL3.PGS) of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;15:12&gt;);
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;17:14&gt;);
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;19:16&gt;);
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPIValid"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPIValid</h3>
      <p class="pseudocode">// GPIValid()
// ==========
// Returns whether a given value is a valid encoding for a GPI value

boolean <a id="impl-shared.GPIValid.1"/>GPIValid(bits(4) gpi)
    return gpi IN {<a href="shared_pseudocode.html#GPT_NoAccess" title="constant bits(4) GPT_NoAccess = '0000'">GPT_NoAccess</a>,
                   <a href="shared_pseudocode.html#GPT_Secure" title="constant bits(4) GPT_Secure = '1000'">GPT_Secure</a>,
                   <a href="shared_pseudocode.html#GPT_NonSecure" title="constant bits(4) GPT_NonSecure = '1001'">GPT_NonSecure</a>,
                   <a href="shared_pseudocode.html#GPT_Root" title="constant bits(4) GPT_Root = '1010'">GPT_Root</a>,
                   <a href="shared_pseudocode.html#GPT_Realm" title="constant bits(4) GPT_Realm = '1011'">GPT_Realm</a>,
                   <a href="shared_pseudocode.html#GPT_Any" title="constant bits(4) GPT_Any = '1111'">GPT_Any</a>};</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTL0Size"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTL0Size</h3>
      <p class="pseudocode">// GPTL0Size()
// ===========
// Returns number of bits covered by a level 0 GPT entry

integer <a id="impl-shared.GPTL0Size.0"/>GPTL0Size()
    case GPCCR_EL3.L0GPTSZ of
        when '0000' return <a href="shared_pseudocode.html#GPTRange_1GB" title="constant integer GPTRange_1GB = 30">GPTRange_1GB</a>;
        when '0100' return <a href="shared_pseudocode.html#GPTRange_16GB" title="constant integer GPTRange_16GB = 34">GPTRange_16GB</a>;
        when '0110' return <a href="shared_pseudocode.html#GPTRange_64GB" title="constant integer GPTRange_64GB = 36">GPTRange_64GB</a>;
        when '1001' return <a href="shared_pseudocode.html#GPTRange_512GB" title="constant integer GPTRange_512GB = 39">GPTRange_512GB</a>;
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();
    return 30;</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTLevel0Index"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTLevel0Index</h3>
      <p class="pseudocode">// GPTLevel0Index()
// ================
// Compute the level 0 index based on input PA.

integer <a id="impl-shared.GPTLevel0Index.1"/>GPTLevel0Index(bits(52) pa)
    // Input address and index bounds
    pps = <a href="shared_pseudocode.html#impl-shared.DecodePPS.0" title="function: integer DecodePPS()">DecodePPS</a>();
    l0sz = <a href="shared_pseudocode.html#impl-shared.GPTL0Size.0" title="function: integer GPTL0Size()">GPTL0Size</a>();
    if pps &lt;= l0sz then
        return 0;

    return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;pps-1:l0sz&gt;);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTLevel1Index"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTLevel1Index</h3>
      <p class="pseudocode">// GPTLevel1Index()
// ================
// Compute the level 1 index based on input PA.

integer <a id="impl-shared.GPTLevel1Index.1"/>GPTLevel1Index(bits(52) pa)
    // Input address and index bounds
    l0sz = <a href="shared_pseudocode.html#impl-shared.GPTL0Size.0" title="function: integer GPTL0Size()">GPTL0Size</a>();
    case <a href="shared_pseudocode.html#impl-shared.DecodePGS.1" title="function: PGSe DecodePGS(bits(2) pgs)">DecodePGS</a>(GPCCR_EL3.PGS) of
        when <a href="shared_pseudocode.html#PGS_4KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_4KB</a>  return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;l0sz-1:16&gt;);
        when <a href="shared_pseudocode.html#PGS_16KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_16KB</a> return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;l0sz-1:18&gt;);
        when <a href="shared_pseudocode.html#PGS_64KB" title="enumeration PGSe {&#13; PGS_4KB,&#13; PGS_16KB,&#13; PGS_64KB&#13; }">PGS_64KB</a> return <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(pa&lt;l0sz-1:20&gt;);
        otherwise <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GPTWalk"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GPTWalk</h3>
      <p class="pseudocode">// GPTWalk()
// =========
// Get the GPT entry for a given physical address, pa

(GPCFRecord, GPTEntry) <a id="impl-shared.GPTWalk.2"/>GPTWalk(bits(52) pa, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc)

    // GPT base address
    bits(52) base;
    pgs = <a href="shared_pseudocode.html#impl-shared.DecodePGS.1" title="function: PGSe DecodePGS(bits(2) pgs)">DecodePGS</a>(GPCCR_EL3.PGS);

    // The level 0 GPT base address is aligned to the greater of:
    // * the size of the level 0 GPT, determined by GPCCR_EL3.{PPS, L0GPTSZ}.
    // * 4KB
    base = GPTBR_EL3.BADDR:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);
    pps = <a href="shared_pseudocode.html#impl-shared.DecodePPS.0" title="function: integer DecodePPS()">DecodePPS</a>();
    l0sz = <a href="shared_pseudocode.html#impl-shared.GPTL0Size.0" title="function: integer GPTL0Size()">GPTL0Size</a>();
    integer alignment = <a href="shared_pseudocode.html#impl-shared.Max.2" title="function: integer Max(integer a, integer b)">Max</a>(pps - l0sz + 3, 12);
    base = base AND NOT <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Ones.1" title="function: bits(N) Ones(integer N)">Ones</a>(alignment), 52);

    // Access attributes and address for GPT fetches
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> gptaddrdesc;
    gptaddrdesc.fault    = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();
    gptaddrdesc.memattrs = <a href="shared_pseudocode.html#impl-shared.WalkMemAttrs.3" title="function: MemoryAttributes WalkMemAttrs(bits(2) sh, bits(2) irgn, bits(2) orgn)">WalkMemAttrs</a>(GPCCR_EL3.SH, GPCCR_EL3.ORGN, GPCCR_EL3.IRGN);

    // Address of level 0 GPT entry
    gptaddrdesc.paddress.paspace = <a href="shared_pseudocode.html#PAS_Root" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_Root</a>;
    gptaddrdesc.paddress.address = base + <a href="shared_pseudocode.html#impl-shared.GPTLevel0Index.1" title="function: integer GPTLevel0Index(bits(52) pa)">GPTLevel0Index</a>(pa) * 8;

    // Fetch L0GPT entry
    bits(64) level_0_entry;
    (memstatus, level_0_entry) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(gptaddrdesc, 8, accdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>, 0), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> UNKNOWN);

    <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> result;
    <a href="shared_pseudocode.html#GPTTable" title="type GPTTable is ( bits(52) address )">GPTTable</a> table;
    case level_0_entry&lt;3:0&gt; of
        when <a href="shared_pseudocode.html#GPT_Block" title="constant bits(4) GPT_Block = '0001'">GPT_Block</a>
            // Decode the GPI value and return that
            (gpf, result) = <a href="shared_pseudocode.html#impl-shared.DecodeGPTBlock.2" title="function: (GPCF, GPTEntry) DecodeGPTBlock(PGSe pgs, bits(64) entry)">DecodeGPTBlock</a>(pgs, level_0_entry);
            return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(gpf, 0), result);
        when <a href="shared_pseudocode.html#GPT_Table" title="constant bits(4) GPT_Table = '0011'">GPT_Table</a>
            // Decode the table entry and continue walking
            (gpf, table) = <a href="shared_pseudocode.html#impl-shared.DecodeGPTTable.2" title="function: (GPCF, GPTTable) DecodeGPTTable(PGSe pgs, bits(64) entry)">DecodeGPTTable</a>(pgs, level_0_entry);
            if gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
                return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(gpf, 0), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> UNKNOWN);
        otherwise
            // GPF - invalid encoding
            return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, 0), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> UNKNOWN);

    // Must be a GPT Table entry
    assert level_0_entry&lt;3:0&gt; == <a href="shared_pseudocode.html#GPT_Table" title="constant bits(4) GPT_Table = '0011'">GPT_Table</a>;

    // Address of level 1 GPT entry
    offset = <a href="shared_pseudocode.html#impl-shared.GPTLevel1Index.1" title="function: integer GPTLevel1Index(bits(52) pa)">GPTLevel1Index</a>(pa) * 8;
    gptaddrdesc.paddress.address = table.address + offset;

    // Fetch L1GPT entry
    bits(64) level_1_entry;
    (memstatus, level_1_entry) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(gptaddrdesc, 8, accdesc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_EABT" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_EABT</a>, 1), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> UNKNOWN);

    case level_1_entry&lt;3:0&gt; of
        when <a href="shared_pseudocode.html#GPT_Contig" title="constant bits(4) GPT_Contig = '0001'">GPT_Contig</a>
            (gpf, result) = <a href="shared_pseudocode.html#impl-shared.DecodeGPTContiguous.2" title="function: (GPCF, GPTEntry) DecodeGPTContiguous(PGSe pgs, bits(64) entry)">DecodeGPTContiguous</a>(pgs, level_1_entry);
        otherwise
            gpi_index = <a href="shared_pseudocode.html#impl-shared.GPIIndex.1" title="function: integer GPIIndex(bits(52) pa)">GPIIndex</a>(pa);
            (gpf, result) = <a href="shared_pseudocode.html#impl-shared.DecodeGPTGranules.3" title="function: (GPCF, GPTEntry) DecodeGPTGranules(PGSe pgs, integer index, bits(64) entry)">DecodeGPTGranules</a>(pgs, gpi_index, level_1_entry);

    if gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
        return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(gpf, 1), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> UNKNOWN);

    if !<a href="shared_pseudocode.html#impl-shared.GPIValid.1" title="function: boolean GPIValid(bits(4) gpi)">GPIValid</a>(result.gpi) then
        return (<a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, 1), <a href="shared_pseudocode.html#GPTEntry" title="type GPTEntry is ( bits(4) gpi, integer size, integer contig_size, integer level )">GPTEntry</a> UNKNOWN);

    return (<a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>(), result);</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.GranuleProtectionCheck"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/GranuleProtectionCheck</h3>
      <p class="pseudocode">// GranuleProtectionCheck()
// ========================
// Returns whether a given access is permitted, according to the
// granule protection check.
// addrdesc and accdesc describe the access to be checked.

GPCFRecord <a id="impl-shared.GranuleProtectionCheck.2"/>GranuleProtectionCheck(<a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc, <a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( boolean transactional, MPAMinfo mpam, AccType acctype)">AccessDescriptor</a> accdesc)

    assert <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>();

    // The address to be checked
    address = addrdesc.paddress;

    // Bypass mode - all accesses pass
    if GPCCR_EL3.GPC == '0' then
        return <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();

    // Configuration consistency check
    if !<a href="shared_pseudocode.html#impl-shared.GPCRegistersConsistent.0" title="function: boolean GPCRegistersConsistent()">GPCRegistersConsistent</a>() then
        return <a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_Walk" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Walk</a>, 0);

    // Input address size check
    if <a href="shared_pseudocode.html#impl-shared.AbovePPS.1" title="function: boolean AbovePPS(bits(52) address)">AbovePPS</a>(address.address) then
        if address.paspace == <a href="shared_pseudocode.html#PAS_NonSecure" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PAS_NonSecure</a> then
            return <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();
        else
            return <a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a>, 0);

    // GPT base address size check
    bits(52) gpt_base = GPTBR_EL3.BADDR:<a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(12);
    if <a href="shared_pseudocode.html#impl-shared.AbovePPS.1" title="function: boolean AbovePPS(bits(52) address)">AbovePPS</a>(gpt_base) then
        return <a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_AddressSize" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_AddressSize</a>, 0);

    // GPT lookup
    (gpcf, gpt_entry) = <a href="shared_pseudocode.html#impl-shared.GPTWalk.2" title="function: (GPCFRecord, GPTEntry) GPTWalk(bits(52) pa, AccessDescriptor accdesc)">GPTWalk</a>(address.address, accdesc);
    if gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
        return gpcf;

    // Check input physical address space against GPI
    permitted = <a href="shared_pseudocode.html#impl-shared.GPICheck.2" title="function: boolean GPICheck(PASpace paspace, bits(4) gpi)">GPICheck</a>(address.paspace, gpt_entry.gpi);

    if !permitted then
        gpcf = <a href="shared_pseudocode.html#impl-shared.GPCFault.2" title="function: GPCFRecord GPCFault(GPCF gpf, integer level)">GPCFault</a>(<a href="shared_pseudocode.html#GPCF_Fail" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_Fail</a>, gpt_entry.level);
        return gpcf;

    // Check passed
    return <a href="shared_pseudocode.html#impl-shared.GPCNoFault.0" title="function: GPCFRecord GPCNoFault()">GPCNoFault</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.PGS"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/PGS</h3>
      <p class="pseudocode">enumeration <a id="PGSe"/>PGSe {
    <a id="PGS_4KB"/>PGS_4KB,
    <a id="PGS_16KB"/>PGS_16KB,
    <a id="PGS_64KB"/>PGS_64KB
};</p>
    </div>
    <div class="ps"><a id="shared.translation.gpc.Table"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/gpc/Table</h3>
      <p class="pseudocode">constant bits(4) <a id="GPT_NoAccess"/>GPT_NoAccess  = '0000';
constant bits(4) <a id="GPT_Table"/>GPT_Table     = '0011';
constant bits(4) <a id="GPT_Block"/>GPT_Block     = '0001';
constant bits(4) <a id="GPT_Contig"/>GPT_Contig    = '0001';
constant bits(4) <a id="GPT_Secure"/>GPT_Secure    = '1000';
constant bits(4) <a id="GPT_NonSecure"/>GPT_NonSecure = '1001';
constant bits(4) <a id="GPT_Root"/>GPT_Root      = '1010';
constant bits(4) <a id="GPT_Realm"/>GPT_Realm     = '1011';
constant bits(4) <a id="GPT_Any"/>GPT_Any       = '1111';
constant integer <a id="GPTRange_4KB"/>GPTRange_4KB   = 12;
constant integer <a id="GPTRange_16KB"/>GPTRange_16KB  = 14;
constant integer <a id="GPTRange_64KB"/>GPTRange_64KB  = 16;
constant integer <a id="GPTRange_2MB"/>GPTRange_2MB   = 21;
constant integer <a id="GPTRange_32MB"/>GPTRange_32MB  = 25;
constant integer <a id="GPTRange_512MB"/>GPTRange_512MB = 29;
constant integer <a id="GPTRange_1GB"/>GPTRange_1GB   = 30;
constant integer <a id="GPTRange_16GB"/>GPTRange_16GB  = 34;
constant integer <a id="GPTRange_64GB"/>GPTRange_64GB  = 36;
constant integer <a id="GPTRange_512GB"/>GPTRange_512GB = 39;

type <a id="GPTTable"/>GPTTable is (
    bits(52) address        // Base address of next table
)

type <a id="GPTEntry"/>GPTEntry is (
    bits(4) gpi,            // GPI value for this region
    integer size,           // Region size
    integer contig_size,    // Contiguous region size
    integer level           // Level of GPT lookup
)</p>
    </div>
    <div class="ps"><a id="shared.translation.translation.S1TranslationRegime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/translation/S1TranslationRegime</h3>
      <p class="pseudocode">// S1TranslationRegime()
// =====================
// Stage 1 translation regime for the given Exception level

bits(2) <a id="impl-shared.S1TranslationRegime.1"/>S1TranslationRegime(bits(2) el)
    if el != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        return el;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveEL.1" title="function: boolean HaveEL(bits(2) el)">HaveEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) &amp;&amp; SCR.NS == '0' then
        return <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>;
    elsif <a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(el) then
        return <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>;
    else
        return <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>;

// S1TranslationRegime()
// =====================
// Returns the Exception level controlling the current Stage 1 translation regime. For the most
// part this is unused in code because the system register accessors (SCTLR[], etc.) implicitly
// return the correct value.

bits(2) <a id="impl-shared.S1TranslationRegime.0"/>S1TranslationRegime()
    return <a href="shared_pseudocode.html#impl-shared.S1TranslationRegime.1" title="function: bits(2) S1TranslationRegime(bits(2) el)">S1TranslationRegime</a>(PSTATE.EL);</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.AddressDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/AddressDescriptor</h3>
      <p class="pseudocode">type <a id="AddressDescriptor"/>AddressDescriptor is (
    <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a>      fault,      // fault.statuscode indicates whether the address is valid
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs,
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a>      paddress,
    bits(64)         vaddress
)

constant integer <a id="FINAL_LEVEL"/>FINAL_LEVEL = 3;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.ContiguousSize"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/ContiguousSize</h3>
      <p class="pseudocode">// ContiguousSize()
// ================
// Return the number of entries log 2 marking a contiguous output range

integer <a id="impl-shared.ContiguousSize.2"/>ContiguousSize(<a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    case tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>
            assert level IN {1, 2, 3};
            return 4;
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a>
            assert level IN {2, 3};
            return if level == 2 then 5 else 7;
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a>
            assert level IN {2, 3};
            return 5;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.CreateAddressDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/CreateAddressDescriptor</h3>
      <p class="pseudocode">// CreateAddressDescriptor()
// =========================
// Set internal members for address descriptor type to valid values

AddressDescriptor <a id="impl-shared.CreateAddressDescriptor.3"/>CreateAddressDescriptor(bits(64) va, <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> pa,
                                          <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a> memattrs)
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc;

    addrdesc.paddress = pa;
    addrdesc.vaddress = va;
    addrdesc.memattrs = memattrs;
    addrdesc.fault    = <a href="shared_pseudocode.html#impl-shared.NoFault.0" title="function: FaultRecord NoFault()">NoFault</a>();

    return addrdesc;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.CreateFaultyAddressDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/CreateFaultyAddressDescriptor</h3>
      <p class="pseudocode">// CreateFaultyAddressDescriptor()
// ===============================
// Set internal members for address descriptor type with values indicating error

AddressDescriptor <a id="impl-shared.CreateFaultyAddressDescriptor.2"/>CreateFaultyAddressDescriptor(bits(64) va, <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> addrdesc;

    addrdesc.vaddress = va;
    addrdesc.fault    = fault;

    return addrdesc;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.DescriptorType"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/DescriptorType</h3>
      <p class="pseudocode">enumeration <a id="DescriptorType"/>DescriptorType {
    <a id="DescriptorType_Table"/>DescriptorType_Table,
    <a id="DescriptorType_Block"/>DescriptorType_Block,
    <a id="DescriptorType_Page"/>DescriptorType_Page,
    <a id="DescriptorType_Invalid"/>DescriptorType_Invalid
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.Domains"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/Domains</h3>
      <p class="pseudocode">constant bits(2) <a id="Domain_NoAccess"/>Domain_NoAccess = '00';
constant bits(2) <a id="Domain_Client"/>Domain_Client   = '01';
constant bits(2) <a id="Domain_Manager"/>Domain_Manager  = '11';</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.FetchDescriptor"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/FetchDescriptor</h3>
      <p class="pseudocode">// FetchDescriptor()
// =================
// Fetch a translation table descriptor

(FaultRecord, bits(N)) <a id="impl-shared.FetchDescriptor.3"/>FetchDescriptor(bit ee, <a href="shared_pseudocode.html#AddressDescriptor" title="type AddressDescriptor is ( FaultRecord fault, MemoryAttributes memattrs, FullAddress paddress, bits(64) vaddress )">AddressDescriptor</a> walkaddress,
                                       <a href="shared_pseudocode.html#FaultRecord" title="type FaultRecord is (Fault statuscode, AccType acctype, FullAddress ipaddress, GPCFRecord gpcf, FullAddress paddress, boolean gpcfs2walk, boolean s2fs1walk, boolean write, integer level, bit extflag, boolean secondstage, bits(4) domain, bits(2) errortype, bits(4) debugmoe)">FaultRecord</a> fault)
    // 32-bit descriptors for AArch32 Short-descriptor format
    // 64-bit descriptors for AArch64 or AArch32 Long-descriptor format
    assert N == 32 || N == 64;
    bits(N) descriptor;

    walkacc = <a href="shared_pseudocode.html#impl-shared.CreateAccessDescriptor.1" title="function: AccessDescriptor CreateAccessDescriptor(AccType acctype)">CreateAccessDescriptor</a>(<a href="shared_pseudocode.html#AccType_TTW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_TTW</a>);
    if <a href="shared_pseudocode.html#impl-shared.HaveRME.0" title="function: boolean HaveRME()">HaveRME</a>() then
        fault.gpcf = <a href="shared_pseudocode.html#impl-shared.GranuleProtectionCheck.2" title="function: GPCFRecord GranuleProtectionCheck(AddressDescriptor addrdesc, AccessDescriptor accdesc)">GranuleProtectionCheck</a>(walkaddress, walkacc);
        if fault.gpcf.gpf != <a href="shared_pseudocode.html#GPCF_None" title="enumeration GPCF {&#13; GPCF_None, GPCF_AddressSize, GPCF_Walk, GPCF_EABT, GPCF_Fail }">GPCF_None</a> then
            fault.statuscode = <a href="shared_pseudocode.html#Fault_GPCFOnWalk" title="enumeration Fault {Fault_None,&#13; Fault_AccessFlag,&#13; Fault_Alignment,&#13; Fault_Background,&#13; Fault_Domain,&#13; Fault_Permission,&#13; Fault_Translation,&#13; Fault_AddressSize,&#13; Fault_SyncExternal,&#13; Fault_SyncExternalOnWalk,&#13; Fault_SyncParity,&#13; Fault_SyncParityOnWalk,&#13; Fault_GPCFOnWalk,&#13; Fault_GPCFOnOutput,&#13; Fault_AsyncParity,&#13; Fault_AsyncExternal,&#13; Fault_Debug,&#13; Fault_TLBConflict,&#13; Fault_BranchTarget,&#13; Fault_HWUpdateAccessFlag,&#13; Fault_Lockdown,&#13; Fault_Exclusive,&#13; Fault_ICacheMaint}">Fault_GPCFOnWalk</a>;
            fault.paddress   = walkaddress.paddress;
            fault.gpcfs2walk = fault.secondstage;
            return (fault, bits(N) UNKNOWN);

    (memstatus, descriptor) = <a href="shared_pseudocode.html#impl-shared.PhysMemRead.3" title="function: (PhysMemRetStatus, bits(8*size)) PhysMemRead(AddressDescriptor desc, integer size,&#13; AccessDescriptor accdesc)">PhysMemRead</a>(walkaddress, N DIV 8, walkacc);
    if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(memstatus) then
        fault = <a href="shared_pseudocode.html#impl-shared.HandleExternalTTWAbort.6" title="function: FaultRecord HandleExternalTTWAbort(PhysMemRetStatus memretstatus, boolean iswrite,&#13; AddressDescriptor memaddrdesc,&#13; AccessDescriptor accdesc, integer size,&#13; FaultRecord input_fault)">HandleExternalTTWAbort</a>(memstatus, fault.write, walkaddress,
                                       walkacc, N DIV 8, fault);
        if <a href="shared_pseudocode.html#impl-shared.IsFault.1" title="function: boolean IsFault(AddressDescriptor addrdesc)">IsFault</a>(fault.statuscode) then
            return (fault, bits(N) UNKNOWN);

    if ee == '1' then
        descriptor = <a href="shared_pseudocode.html#impl-shared.BigEndianReverse.1" title="function: bits(width) BigEndianReverse (bits(width) value)">BigEndianReverse</a>(descriptor);

    return (fault, descriptor);</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.HasUnprivileged"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/HasUnprivileged</h3>
      <p class="pseudocode">// HasUnprivileged()
// =================
// Returns whether a translation regime serves EL0 as well as a higher EL

boolean <a id="impl-shared.HasUnprivileged.1"/>HasUnprivileged(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    return (regime IN {
        <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>,
        <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>,
        <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>
    });</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.IsAtomicRW"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/IsAtomicRW</h3>
      <p class="pseudocode">// IsAtomicRW()
// ============
// Is the access an atomic operation?

boolean <a id="impl-shared.IsAtomicRW.1"/>IsAtomicRW(<a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    return acctype IN {
                <a href="shared_pseudocode.html#AccType_ATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ATOMICRW</a>,
                <a href="shared_pseudocode.html#AccType_ORDEREDRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDRW</a>,
                <a href="shared_pseudocode.html#AccType_ORDEREDATOMICRW" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_ORDEREDATOMICRW</a>
           };</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.Regime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/Regime</h3>
      <p class="pseudocode">enumeration <a id="Regime"/>Regime {
    <a id="Regime_EL3"/>Regime_EL3,            // EL3
    <a id="Regime_EL30"/>Regime_EL30,           // EL3&amp;0 (PL1&amp;0 when EL3 is AArch32)
    <a id="Regime_EL2"/>Regime_EL2,            // EL2
    <a id="Regime_EL20"/>Regime_EL20,           // EL2&amp;0
    <a id="Regime_EL10"/>Regime_EL10            // EL1&amp;0
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.RegimeUsingAArch32"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/RegimeUsingAArch32</h3>
      <p class="pseudocode">// RegimeUsingAArch32()
// ====================
// Determine if the EL controlling the regime executes in AArch32 state

boolean <a id="impl-shared.RegimeUsingAArch32.1"/>RegimeUsingAArch32(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> return <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> return TRUE;
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> return FALSE;
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>  return <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>  return FALSE;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.S1TTWParams"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/S1TTWParams</h3>
      <p class="pseudocode">type <a id="S1TTWParams"/>S1TTWParams is (
// A64-VMSA exclusive parameters
    bit         ha,         // TCR_ELx.HA
    bit         hd,         // TCR_ELx.HD
    bit         tbi,        // TCR_ELx.TBI{x}
    bit         tbid,       // TCR_ELx.TBID{x}
    bit         nfd,        // TCR_EL1.NFDx or TCR_EL2.NFDx when HCR_EL2.E2H == '1'
    bit         e0pd,       // TCR_EL1.E0PDx or TCR_EL2.E0PDx when HCR_EL2.E2H == '1'
    bit         ds,         // TCR_ELx.DS
    bits(3)     ps,         // TCR_ELx.{I}PS
    bits(6)     txsz,       // TCR_ELx.TxSZ
    bit         epan,       // SCTLR_EL1.EPAN or SCTLR_EL2.EPAN when HCR_EL2.E2H == '1'
    bit         dct,        // HCR_EL2.DCT
    bit         nv1,        // HCR_EL2.NV1
    bit         cmow,       // SCTLR_EL1.CMOW or SCTLR_EL2.CMOW when HCR_EL2.E2H == '1'

// A32-VMSA exclusive parameters
    bits(3)     t0sz,       // TTBCR.T0SZ
    bits(3)     t1sz,       // TTBCR.T1SZ
    bit         uwxn,       // SCTLR.UWXN

// Parameters common to both A64-VMSA &amp; A32-VMSA (A64/A32)
    <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a>         tgx,        // TCR_ELx.TGx      / Always TGx_4KB
    bits(2)     irgn,       // TCR_ELx.IRGNx    / TTBCR.IRGNx or HTCR.IRGN0
    bits(2)     orgn,       // TCR_ELx.ORGNx    / TTBCR.ORGNx or HTCR.ORGN0
    bits(2)     sh,         // TCR_ELx.SHx      / TTBCR.SHx or HTCR.SH0
    bit         hpd,        // TCR_ELx.HPD{x}   / TTBCR2.HPDx or HTCR.HPD
    bit         ee,         // SCTLR_ELx.EE     / SCTLR.EE or HSCTLR.EE
    bit         wxn,        // SCTLR_ELx.WXN    / SCTLR.WXN or HSCTLR.WXN
    bit         ntlsmd,     // SCTLR_ELx.nTLSMD / SCTLR.nTLSMD or HSCTLR.nTLSMD
    bit         dc,         // HCR_EL2.DC       / HCR.DC
    bit         sif,        // SCR_EL3.SIF      / SCR.SIF
    <a href="shared_pseudocode.html#MAIRType" title="type MAIRType">MAIRType</a>    mair        // MAIR_ELx         / MAIR1:MAIR0 or HMAIR1:HMAIR0
)</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.S2TTWParams"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/S2TTWParams</h3>
      <p class="pseudocode">type <a id="S2TTWParams"/>S2TTWParams is (
// A64-VMSA exclusive parameters
    bit         ha,     // VTCR_EL2.HA
    bit         hd,     // VTCR_EL2.HD
    bit         sl2,    // V{S}TCR_EL2.SL2
    bit         ds,     // VTCR_EL2.DS
    bit         sw,     // VSTCR_EL2.SW
    bit         nsw,    // VTCR_EL2.NSW
    bit         sa,     // VSTCR_EL2.SA
    bit         nsa,    // VTCR_EL2.NSA
    bits(3)     ps,     // VTCR_EL2.PS
    bits(6)     txsz,   // V{S}TCR_EL2.T0SZ
    bit         fwb,    // HCR_EL2.PTW
    bit         cmow,   // HCRX_EL2.CMOW

// A32-VMSA exclusive parameters
    bit         s,      // VTCR.S
    bits(4)     t0sz,   // VTCR.T0SZ

// Parameters common to both A64-VMSA &amp; A32-VMSA if implemented (A64/A32)
    <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a>         tgx,    // V{S}TCR_EL2.TG0  / Always TGx_4KB
    bits(2)     sl0,    // V{S}TCR_EL2.SL0  / VTCR.SL0
    bits(2)     irgn,   // VTCR_EL2.IRGN0   / VTCR.IRGN0
    bits(2)     orgn,   // VTCR_EL2.ORGN0   / VTCR.ORGN0
    bits(2)     sh,     // VTCR_EL2.SH0     / VTCR.SH0
    bit         ee,     // SCTLR_EL2.EE     / HSCTLR.EE
    bit         ptw,    // HCR_EL2.PTW      / HCR.PTW
    bit         vm      // HCR_EL2.VM       / HCR.VM
)</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.SDFType"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/SDFType</h3>
      <p class="pseudocode">enumeration <a id="SDFType"/>SDFType {
    <a id="SDFType_Table"/>SDFType_Table,
    <a id="SDFType_Invalid"/>SDFType_Invalid,
    <a id="SDFType_Supersection"/>SDFType_Supersection,
    <a id="SDFType_Section"/>SDFType_Section,
    <a id="SDFType_LargePage"/>SDFType_LargePage,
    <a id="SDFType_SmallPage"/>SDFType_SmallPage
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.SecurityStateForRegime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/SecurityStateForRegime</h3>
      <p class="pseudocode">// SecurityStateForRegime()
// ========================
// Return the Security State of the given translation regime

SecurityState <a id="impl-shared.SecurityStateForRegime.1"/>SecurityStateForRegime(<a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a> regime)
    case regime of
        when <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>     return <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>);
        when <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>    return <a href="shared_pseudocode.html#SS_Secure" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SS_Secure</a>; // A32 EL3 is always Secure
        when <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>     return <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        when <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>    return <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>);
        when <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>    return <a href="shared_pseudocode.html#impl-aarch64.SecurityStateAtEL.1" title="function: SecurityState SecurityStateAtEL(bits(2) EL)">SecurityStateAtEL</a>(<a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a>);</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.StageOA"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/StageOA</h3>
      <p class="pseudocode">// StageOA()
// =========
// Given the final walk state (a page or block descriptor), map the untranslated
// input address bits to the output address

FullAddress <a id="impl-shared.StageOA.3"/>StageOA(bits(64) ia, <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a> walkstate)
    // Output Address
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a> oa;

    tsize = <a href="shared_pseudocode.html#impl-shared.TranslationSize.2" title="function: integer TranslationSize(TGx tgx, integer level)">TranslationSize</a>(tgx, walkstate.level);
    if walkstate.contiguous == '1' then
        csize = <a href="shared_pseudocode.html#impl-shared.ContiguousSize.2" title="function: integer ContiguousSize(TGx tgx, integer level)">ContiguousSize</a>(tgx, walkstate.level);
    else
        csize = 0;

    ia_msb = tsize + csize;
    oa.paspace = walkstate.baseaddress.paspace;
    oa.address = walkstate.baseaddress.address&lt;51:ia_msb&gt;:ia&lt;ia_msb-1:0&gt;;

    return oa;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TGx"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TGx</h3>
      <p class="pseudocode">enumeration <a id="TGx"/>TGx {
    <a id="TGx_4KB"/>TGx_4KB,
    <a id="TGx_16KB"/>TGx_16KB,
    <a id="TGx_64KB"/>TGx_64KB
};</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TGxGranuleBits"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TGxGranuleBits</h3>
      <p class="pseudocode">// TGxGranuleBits()
// ================
// Retrieve the address size, in bits, of a granule

integer <a id="impl-shared.TGxGranuleBits.1"/>TGxGranuleBits(<a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx)
    case tgx of
        when <a href="shared_pseudocode.html#TGx_4KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_4KB</a>  return 12;
        when <a href="shared_pseudocode.html#TGx_16KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_16KB</a> return 14;
        when <a href="shared_pseudocode.html#TGx_64KB" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx_64KB</a> return 16;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TLBContext"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TLBContext</h3>
      <p class="pseudocode">type <a id="TLBContext"/>TLBContext is (
    <a href="shared_pseudocode.html#SecurityState" title="enumeration SecurityState {&#13; SS_NonSecure,&#13; SS_Root,&#13; SS_Realm,&#13; SS_Secure&#13; }">SecurityState</a> ss,
    <a href="shared_pseudocode.html#Regime" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime</a>        regime,
    bits(16)      vmid,
    bits(16)      asid,
    bit           nG,
    <a href="shared_pseudocode.html#PASpace" title="enumeration PASpace {&#13; PAS_NonSecure,&#13; PAS_Secure,&#13; PAS_Root,&#13; PAS_Realm&#13; }">PASpace</a>       ipaspace, // Used in stage 2 lookups &amp; invalidations only
    boolean       includes_s1,
    boolean       includes_s2,
    boolean       includes_gpt,
    bits(64)      ia,       // Input Address
    <a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a>           tg,
    bit           cnp,
    bit           xs        // XS attribute (FEAT_XS)
)</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TLBRecord"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TLBRecord</h3>
      <p class="pseudocode">type <a id="TLBRecord"/>TLBRecord is (
    <a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a>  context,
    <a href="shared_pseudocode.html#TTWState" title="type TTWState is ( boolean istable, integer level, FullAddress baseaddress, bit contiguous, bit nG, bit guardedpage, SDFType sdftype, bits(4) domain, MemoryAttributes memattrs, Permissions permissions )">TTWState</a>    walkstate,
    integer     blocksize,    // Number of bits directly mapped from IA to OA
    integer     contigsize,   // Number of entries log 2 marking a contiguous output range
    bits(64)    s1descriptor, // Stage 1 leaf descriptor in memory (valid if the TLB caches stage 1)
    bits(64)    s2descriptor  // Stage 2 leaf descriptor in memory (valid if the TLB caches stage 2)
)</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TTWState"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TTWState</h3>
      <p class="pseudocode">type <a id="TTWState"/>TTWState is (
    boolean             istable,
    integer             level,
    <a href="shared_pseudocode.html#FullAddress" title="type FullAddress is ( PASpace paspace, bits(52) address )">FullAddress</a>         baseaddress,
    bit                 contiguous,
    bit                 nG,
    bit                 guardedpage,
    <a href="shared_pseudocode.html#SDFType" title="enumeration SDFType {&#13; SDFType_Table,&#13; SDFType_Invalid,&#13; SDFType_Supersection,&#13; SDFType_Section,&#13; SDFType_LargePage,&#13; SDFType_SmallPage&#13; }">SDFType</a>             sdftype, // AArch32 Short-descriptor format walk only
    bits(4)             domain,  // AArch32 Short-descriptor format walk only
    <a href="shared_pseudocode.html#MemoryAttributes" title="type MemoryAttributes is ( MemType memtype, DeviceType device, MemAttrHints inner, MemAttrHints outer, Shareability shareability, boolean tagged, bit xs )">MemoryAttributes</a>    memattrs,
    <a href="shared_pseudocode.html#Permissions" title="type Permissions is ( bits(2) ap_table, bit xn_table, bit pxn_table, bit uxn_table, bits(3) ap, bit xn, bit uxn, bit pxn, bits(2) s2ap, bit s2xnx, bit s2xn )">Permissions</a>         permissions
)</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TranslationRegime"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TranslationRegime</h3>
      <p class="pseudocode">// TranslationRegime()
// ===================
// Select the translation regime given the target EL and PE state

Regime <a id="impl-shared.TranslationRegime.2"/>TranslationRegime(bits(2) el, <a href="shared_pseudocode.html#AccType" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType</a> acctype)
    if el == <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> then
        return if <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a> else <a href="shared_pseudocode.html#Regime_EL3" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL3</a>;
    elsif el == <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> then
        return if <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> else <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
    elsif el == <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> then
        if acctype == <a href="shared_pseudocode.html#AccType_NV2REGISTER" title="enumeration AccType {AccType_NORMAL, AccType_VEC,&#13; AccType_STREAM, AccType_VECSTREAM,&#13; AccType_UNPRIVSTREAM, AccType_A32LSMD, AccType_ATOMIC, AccType_ATOMICRW,&#13; AccType_ORDERED, AccType_ORDEREDRW,&#13; AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_ATOMICLS64, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_TTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_TRBE,  AccType_DC, AccType_IC, AccType_DCZVA, AccType_ATPAN, AccType_AT}">AccType_NV2REGISTER</a> then
            assert <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();
            return if <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a>) then <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a> else <a href="shared_pseudocode.html#Regime_EL2" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL2</a>;
        else
            return <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    elsif el == <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> then
        if <a href="shared_pseudocode.html#impl-shared.IsSecure.0" title="function: boolean IsSecure()">IsSecure</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ELUsingAArch32.1" title="function: boolean ELUsingAArch32(bits(2) el)">ELUsingAArch32</a>(<a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a>) then
            return <a href="shared_pseudocode.html#Regime_EL30" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL30</a>;
        elsif <a href="shared_pseudocode.html#impl-shared.ELIsInHost.1" title="function: boolean ELIsInHost(bits(2) el)">ELIsInHost</a>(<a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>) then
            return <a href="shared_pseudocode.html#Regime_EL20" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL20</a>;
        else
            return <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a>;
    else
        <a href="shared_pseudocode.html#impl-shared.Unreachable.0" title="function: Unreachable()">Unreachable</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.TranslationSize"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/TranslationSize</h3>
      <p class="pseudocode">// TranslationSize()
// =================
// Compute the number of bits directly mapped from the input address
// to the output address

integer <a id="impl-shared.TranslationSize.2"/>TranslationSize(<a href="shared_pseudocode.html#TGx" title="enumeration TGx {&#13; TGx_4KB,&#13; TGx_16KB,&#13; TGx_64KB&#13; }">TGx</a> tgx, integer level)
    granulebits = <a href="shared_pseudocode.html#impl-shared.TGxGranuleBits.1" title="function: integer TGxGranuleBits(TGx tgx)">TGxGranuleBits</a>(tgx);
    blockbits   = (<a href="shared_pseudocode.html#FINAL_LEVEL" title="constant integer FINAL_LEVEL = 3">FINAL_LEVEL</a> - level) * (granulebits - 3);

    return granulebits + blockbits;</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.UseASID"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/UseASID</h3>
      <p class="pseudocode">// UseASID()
// =========
// Determine whether the translation context for the access requires ASID or is a global entry

boolean <a id="impl-shared.UseASID.1"/>UseASID(<a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> access)
    return <a href="shared_pseudocode.html#impl-shared.HasUnprivileged.1" title="function: boolean HasUnprivileged(Regime regime)">HasUnprivileged</a>(access.regime);</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.UseVMID"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/UseVMID</h3>
      <p class="pseudocode">// UseVMID()
// =========
// Determine whether the translation context for the access requires VMID to match a TLB entry

boolean <a id="impl-shared.UseVMID.1"/>UseVMID(<a href="shared_pseudocode.html#TLBContext" title="type TLBContext is ( SecurityState ss, Regime regime, bits(16) vmid, bits(16) asid, bit nG, PASpace ipaspace, boolean includes_s1, boolean includes_s2, boolean includes_gpt, bits(64) ia, TGx tg, bit cnp, bit xs )">TLBContext</a> access)
    return access.regime == <a href="shared_pseudocode.html#Regime_EL10" title="enumeration Regime {&#13; Regime_EL3, Regime_EL30, Regime_EL2, Regime_EL20, Regime_EL10 }">Regime_EL10</a> &amp;&amp; <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>();</p>
    </div>
    <div class="ps"><a id="shared.translation.vmsa.VARange"/><h3 class="pseudocode">
            Library pseudocode for shared/translation/vmsa/VARange</h3>
      <p class="pseudocode">enumeration <a id="VARange"/>VARange {
    <a id="VARange_LOWER"/>VARange_LOWER,
    <a id="VARange_UPPER"/>VARange_UPPER
};</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v33.11seprel, AdvSIMD v29.05, pseudocode v2021-09_rel, sve v2021-09_rc3d
      ; Build timestamp: 2021-10-06T11:41
    </p><p class="copyconf">
      Copyright © 2010-2021 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
